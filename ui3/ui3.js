/* eslint eqeqeq: 0, no-extra-parens: 0, semi: 0, no-redeclare: 0, no-empty: 0, valid-jsdoc: 0 */
/// <reference path="ui3-local-overrides.js" />
/// <reference path="libs-src/jquery-1.12.4.js" />
/// <reference path="libs-ui3.js" />
/// This web interface is licensed under the GNU LGPL Version 3
"use strict";
var developerMode_internal = false;
try
{
	if (typeof Object.defineProperty == "function")
	{
		Object.defineProperty(window, "developerMode",
			{
				get: function () { return developerMode_internal; },
				set: function (value)
				{
					developerMode_internal = value;
					if (value)
						$("body").addClass("developerMode");
					else
						$("body").removeClass("developerMode");
				}
			});
	}
}
catch (ex)
{
	console.error(ex);
}
window.developerMode = false;
function developerLog()
{
	if (!developerMode) return;
	var args = ["[dev]"];
	for (var i = 0; i < arguments.length; i++)
		args.push(arguments[i]);
	console.log.apply(this, args);
}
function developerTrace()
{
	if (!developerMode) return;
	var args = ["[dev]"];
	for (var i = 0; i < arguments.length; i++)
		args.push(arguments[i]);
	console.trace.apply(this, args);
}
function developerError()
{
	if (!developerMode) return;
	var args = ["[dev]"];
	for (var i = 0; i < arguments.length; i++)
		args.push(arguments[i]);
	console.error.apply(this, args);
}
var isReloadingUi3 = false;
var appPath = GetAppPath();
if (navigator.cookieEnabled)
{
	NavRemoveUrlParams("session");
}
/**
 * Uniquely identifies each UI3 instance (randomly generated during page loading; not persisted outside of memory).
 * This is sent to /time/ APIs as the argument "opaque" so BI can tell UI3 instances apart when they share the same session.
 * Otherwise the instances interfere with each other's timeline playback state.
 */
var ui3InstanceId = getRandomAlphanumericStr(16);

if ('serviceWorker' in navigator && typeof navigator.serviceWorker === "object" && typeof navigator.serviceWorker.register === "function")
{
	window.addEventListener('load', function ()
	{
		navigator.serviceWorker.register('ui3serviceworker.js?v=' + combined_version + local_bi_session_arg)
			.then(function (registration)
			{
				console.log('UI3 Service Worker registration successful with scope: ', registration.scope);
			})
			.catch(function (err)
			{
				console.log('UI3 Service Worker registration failed: ', err);
			});
	});
}

// Remove bitwarden extension overlay that is frequently getting shown in the upper left corner of UI3 for no reason (probably because it sees the login form despite it being invisible).
try
{
	var observer = new MutationObserver(function (mutations)
	{
		try
		{
			if (loginModal)
				return;
			//console.log("Bitwarden browser extension pattern detector running.");
			for (var i = 0; i < mutations.length; i++)
			{
				var mutation = mutations[i];
				for (var j = 0; j < mutation.addedNodes.length; j++)
				{
					var node = mutation.addedNodes[j];
					if (node.nodeType === 1 && node.nodeName !== "DIV" && node.hasAttribute('style') && node.getAttribute('style').includes('box-shadow: initial !important'))
					{
						console.log("Bitwarden browser extension pattern detector removed node:", node.nodeName);
						node.remove();
					}
				}
			}
		}
		catch (ex) { }
	});

	// Start observing document.body for added elements
	observer.observe(document.body, { childList: true });
}
catch (ex) { }

//
///////////////////////////////////////////////////////////////
// Host Redirection, Proxy Handling ///////////////////////////
///////////////////////////////////////////////////////////////
var currentServer =
{
	remoteBaseURL: GetAppPath()
	, remoteServerName: ""
	, remoteServerUser: ""
	, remoteServerPass: ""
	, isLoggingOut: false
	, isUsingRemoteServer: false
	, GetAPISessionArg: function (prefix, forceAddArg)
	{
		if (currentServer.isUsingRemoteServer || !navigator.cookieEnabled || forceAddArg)
			return prefix + "session=" + sessionManager.GetAPISession();
		return "";
	}
	, GetLocalSessionArg: function (prefix, forceAddArg)
	{
		if (!navigator.cookieEnabled || forceAddArg)
		{
			return prefix + "session=" + local_bi_session;
		}
		return "";
	}
	, SetRemoteServer: function (serverName, baseUrl, user, pass)
	{
		if (!currentServer.ValidateRemoteServerNameSimpleRules(serverName))
		{
			toaster.Error("Unable to validate remote server name. Connecting to local server instead.", 10000);
			serverName = "";
		}
		if (serverName == "")
		{
			currentServer.remoteBaseURL = GetAppPath();
			currentServer.remoteServerName = "";
			currentServer.remoteServerUser = "";
			currentServer.remoteServerPass = "";
			currentServer.isUsingRemoteServer = false;
		}
		else
		{
			currentServer.remoteBaseURL = baseUrl;
			currentServer.remoteServerName = serverName;
			currentServer.remoteServerUser = user;
			currentServer.remoteServerPass = pass;
			currentServer.isUsingRemoteServer = true;
		}
	}
	, ValidateRemoteServerNameSimpleRules: function (val)
	{
		if (val.length == 0)
			return false;
		if (val.length > 16)
			return false;
		for (var i = 0; i < val.length; i++)
		{
			var c = val.charAt(i);
			if ((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9") && c != " ")
				return false;
		}
		return true;
	}
};
///////////////////////////////////////////////////////////////
// Feature Detect /////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var _browser_is_ie = -1;
function BrowserIsIE()
{
	if (_browser_is_ie === -1)
		_browser_is_ie = /MSIE \d|Trident.*rv:/.test(navigator.userAgent) ? 1 : 0;
	return _browser_is_ie == 1;
}
var _browser_is_edge_legacy = -1;
function BrowserIsEdgeLegacy()
{
	if (_browser_is_edge_legacy === -1)
	{
		var edgeVersion = BrowserEdgeVersion();
		if (edgeVersion && parseInt(edgeVersion) < 20)
			_browser_is_edge_legacy = 1;
		else
			_browser_is_edge_legacy = 0;
	}
	return _browser_is_edge_legacy === 1;
}
function BrowserEdgeVersion()
{
	var m = window.navigator.userAgent.match(/ Edge\/([0-9.,]+)/);
	if (!m)
		m = window.navigator.userAgent.match(/ Edg\/([0-9.,]+)/);
	if (m)
		return m[1];
	return null;
}
var _browser_is_firefox = -1;
function BrowserIsFirefox()
{
	if (_browser_is_firefox === -1)
		_browser_is_firefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1 ? 1 : 0;
	return _browser_is_firefox === 1;
}
var any_h264_playback_supported = false;
var streaming_supported = false; // fetch and readablestream
var h264_js_player_supported = false; // JS H.264 player
var audio_playback_supported = false;
var web_workers_supported = false;
var export_blob_supported = false;
var exporting_clips_to_avi_supported = false;
var html5HistorySupported = false;
var html5HistoryPushEnabled = false;
var fetch_supported = false;
var readable_stream_supported = false;
var webgl_supported = false;
var web_audio_supported = false;
var web_audio_buffer_source_supported = false;
var web_audio_buffer_copyToChannel_supported = false;
var web_audio_requires_user_input = false;
var fullscreen_supported = false;
var browser_is_ios = false;
var browser_is_android = false;
var pnacl_player_supported = false; // pNaCl H.264 player
var mse_mp4_h264_supported = false; // HTML5 H.264 player
var mse_mp4_aac_supported = false;
var webcodecs_h264_player_supported = false; // WebCodecs h264 player
var vibrate_supported = false;
var web_audio_autoplay_disabled = false;
var cookies_accessible = false;
var fetch_streams_cant_close_bug = false;
var flac_supported = false;
var speech_synthesis_supported = false;
var gamepad_api_supported = false;
function DoUIFeatureDetection()
{
	try
	{
		requestAnimationFramePolyFill();
		if (!isCanvasSupported())
			MissingRequiredFeature("HTML5 Canvas"); // Excludes IE 8
		else if (!window.Uint8Array && !window.VBArray)
			MissingRequiredFeature("Uint8Array or VBArray", "One of these is required for the Jpeg video player since UI3-197.");
		else
		{
			// All critical tests pass
			// Non-critical tests can run here and store their results in global vars.
			cookies_accessible = testCookieFunctionality();
			browser_is_ios = BrowserIsIOS();
			browser_is_android = BrowserIsAndroid();
			web_workers_supported = typeof Worker !== "undefined";
			export_blob_supported = detectIfCanExportBlob();
			fetch_supported = typeof fetch == "function";
			if (fetch_supported && BrowserIsEdgeLegacy())
			{
				var edgeVersion = BrowserEdgeVersion();
				if (edgeVersion && parseInt(edgeVersion) >= 17 && parseInt(edgeVersion) < 19)
					fetch_streams_cant_close_bug = true;
			}
			readable_stream_supported = typeof ReadableStream === "function";
			webgl_supported = detectWebGLContext();

			streaming_supported = fetch_supported && readable_stream_supported;
			h264_js_player_supported = streaming_supported && web_workers_supported;
			pnacl_player_supported = streaming_supported && detectIfPnaclSupported();
			var mse_support = detectMSESupport();
			mse_mp4_h264_supported = streaming_supported && (mse_support & 1) > 0;
			mse_mp4_aac_supported = streaming_supported && (mse_support & 2) > 0; // Not yet used
			var webcodecs_support = detectWebCodecsVideoDecoderSupport();
			webcodecs_h264_player_supported = streaming_supported && webcodecs_support.h264;
			any_h264_playback_supported = streaming_supported && (h264_js_player_supported || mse_mp4_h264_supported || pnacl_player_supported || webcodecs_h264_player_supported);

			detectAudioSupport();
			vibrate_supported = detectVibrateSupport();
			fullscreen_supported = ((document.documentElement.requestFullscreen || document.documentElement.msRequestFullscreen || document.documentElement.mozRequestFullScreen || document.documentElement.webkitRequestFullscreen) && (document.exitFullscreen || document.msExitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen)) ? true : false;
			audio_playback_supported = any_h264_playback_supported && web_audio_supported && web_audio_buffer_source_supported && web_audio_buffer_copyToChannel_supported;
			exporting_clips_to_avi_supported = any_h264_playback_supported && export_blob_supported;
			html5HistorySupported = isHtml5HistorySupported();
			html5HistoryPushEnabled = shouldHtml5HistoryPushBeEnabled();
			flac_supported = isFlacSupported();
			speech_synthesis_supported = isSpeechSupported();
			gamepad_api_supported = typeof navigator.getGamepads === "function";

			$(function ()
			{
				var ul_root = $('<ul></ul>');
				if (!streaming_supported)
				{
					var ul = $('<ul></ul>');
					if (!fetch_supported)
						ul.append('<li>Fetch API</li>');
					if (!readable_stream_supported)
						ul.append('<li>ReadableStream</li>');
					ul_root.append($('<li>Data Streaming requires these unsupported features:</li>').append(ul));
				}
				if (!h264_js_player_supported)
				{
					var ul = $('<ul></ul>');
					if (!streaming_supported)
						ul.append('<li>Data Streaming</li>');
					if (!web_workers_supported)
						ul.append('<li>Web Workers</li>');
					ul_root.append($('<li>The JavaScript H.264 Player requires these unsupported features:</li>').append(ul));
				}
				if (!mse_mp4_h264_supported)
				{
					var ul = $('<ul></ul>');
					if (!streaming_supported)
						ul.append('<li>Data Streaming</li>');
					if (!((mse_support & 1) > 0))
						ul.append('<li>Media Source Extensions, H.264 codec, MP4 format</li>');
					ul_root.append($('<li>The HTML5 H.264 Player requires these unsupported features:</li>').append(ul));
				}
				if (!webcodecs_h264_player_supported)
				{
					var ul = $('<ul></ul>');
					if (!streaming_supported)
						ul.append('<li>Data Streaming</li>');
					if (webcodecs_support.videoFrame && !webcodecs_support.decoder && !isSecureContext)
						ul.append('<li>WebCodecs: VideoDecoder requires secure context (HTTPS).</li>');
					else
					{
						if (!webcodecs_support.decoder)
							ul.append('<li>WebCodecs: Video Decoder</li>');
						else if (!webcodecs_support.h264)
							ul.append('<li>WebCodecs: H.264 Codec</li>');
					}
					ul_root.append($('<li>The WebCodecs H.264 Player requires these unsupported features:</li>').append(ul));
				}
				if (!any_h264_playback_supported)
					ul_root.append($('<li>No H.264 Player is available.</li>'));
				if (!audio_playback_supported)
				{
					var ul = $('<ul></ul>');
					if (!streaming_supported)
						ul.append('<li>Data Streaming</li>');
					if (!any_h264_playback_supported)
						ul.append('<li>Any H.264 Player</li>');
					if (!web_audio_supported)
						ul.append('<li>Web Audio API</li>');
					if (!web_audio_buffer_source_supported)
						ul.append('<li>AudioBufferSourceNode</li>');
					if (!web_audio_buffer_copyToChannel_supported)
						ul.append('<li>AudioBuffer.copyToChannel</li>');
					ul_root.append($('<li>The audio player requires these unsupported features:</li>').append(ul));
				}
				if (!isLocalStorageEnabled())
				{
					ul_root.append('<li>Local Storage is disabled or unavailable in your browser. Settings will not be saved between sessions.</li>');
				}
				if (!navigator.cookieEnabled)
				{
					ul_root.append('<li>Cookies are disabled in this browser. The browser cache will be less effective, making UI3 load at sub-optimal speed.</li>');
				}
				if (!fullscreen_supported)
				{
					ul_root.append('<li>Fullscreen mode is not supported.</li>');
				}
				if (!html5HistoryPushEnabled)
				{
					ul_root.append('<li>The back button will not close the current clip or camera, like it does on most other platforms.</li>');
				}
				if (!exporting_clips_to_avi_supported)
				{
					ul_root.append('<li>Exporting clips to AVI in-browser is not supported.</li>');
				}
				if (fetch_streams_cant_close_bug)
				{
					ul_root.append('<li>This browser has a compatibility issue which makes H.264 streams not close properly, leading to stability problems.  H.264 playback is disabled by default, but may be re-enabled in UI Settings -&gt; Video Player.</li>');
				}
				if (!gamepad_api_supported)
				{
					ul_root.append('<li>Gamepads/Joysticks are not supported.</li>');
				}
				if (ul_root.children().length > 0)
				{
					var $opt = $('#optionalFeaturesNotSupported');
					$opt.append(ul_root);
					$opt.show();
				}
				var $videoPlayers = $("<ul></ul>");
				$videoPlayers.append("<li>Jpeg</li>");
				if (mse_mp4_h264_supported)
					$videoPlayers.append("<li>H.264 via HTML5</li>");
				if (pnacl_player_supported)
					$videoPlayers.append("<li>H.264 via NaCl</li>");
				if (h264_js_player_supported)
					$videoPlayers.append("<li>H.264 via JavaScript</li>");
				if (webcodecs_h264_player_supported)
					$videoPlayers.append("<li>H.264 via WebCodecs</li>");
				$('#videoPlayersSupported').append($videoPlayers);
			});
			return;
		}
		// A critical test failed
		location.href = currentServer.remoteBaseURL + "jpegpull.htm" + currentServer.GetLocalSessionArg("?");
	}
	catch (ex)
	{
		alert("Unknown error during feature detection. This web browser is likely incompatible.\n" + ex);
		try
		{
			console.log(ex);
		}
		catch (ex2)
		{
		}
	}
}
function MissingRequiredFeature(featureName, description)
{
	alert("This web interface requires a feature that is unavailable or disabled in your web browser.\n\nMissing feature: " + featureName + (description ? ". " + description : "") + "\n\nYou will be redirected to a simpler web interface.");
}
function isCanvasSupported()
{
	var elem = document.createElement('canvas');
	return !!(elem.getContext && elem.getContext('2d'));
}
function testCookieFunctionality()
{
	try
	{
		if (!navigator.cookieEnabled)
			return false;
		var session = $.cookie("session");
		if (session)
			return true;
		$.cookie("session", "test", { path: "/" });
		session = $.cookie("session")
		$.cookie("session", "", { path: "/" });
		return session === "test";
	} catch (e) { }
	return false;
}
function isFlacSupported()
{
	try
	{
		var testEl = document.createElement("video");
		return testEl.canPlayType("audio/flac");
	}
	catch (e) { return false; }
}
function isLocalStorageEnabled()
{
	try // May throw exception if local storage is disabled by browser settings!
	{
		var key = "local_storage_test_item";
		localStorage.setItem(key, key);
		localStorage.removeItem(key);
		return true;
	} catch (e)
	{
		return false;
	}
}
function isHtml5HistorySupported()
{
	try
	{
		if (window.history && typeof window.history.state == "object" && typeof window.history.pushState == "function" && typeof window.history.replaceState == "function")
			return true;
		return false;
	} catch (e)
	{
		return false;
	}
}
function shouldHtml5HistoryPushBeEnabled()
{
	try
	{
		if (BrowserIsIOSChrome())
			return false; // Chrome on iOS has too many history bugs.
		if (BrowserIsAndroid())
			return false; // If the back button is overridden on Android, it can't be used to close the browser while UI3 is the first item in history.
		if (isHtml5HistorySupported())
			return true;
	} catch (e) { }
	return false;
}
function requestAnimationFramePolyFill()
{
	try
	{
		if (typeof requestAnimationFrame != "function")
			window.requestAnimationFrame = function (callback) { setTimeout(callback, 33); };
		return true;
	}
	catch (e)
	{
		return false;
	}
}
function detectWebGLContext()
{
	var canvas = document.createElement("canvas");
	var gl = canvas.getContext("webgl2")
		|| canvas.getContext("webgl")
		|| canvas.getContext("experimental-webgl");
	return gl && gl instanceof WebGLRenderingContext;
}
function detectIfCanExportBlob()
{
	try
	{
		return typeof window.URL !== "undefined" && typeof window.URL.revokeObjectURL === "function" && typeof Blob !== "undefined";
	}
	catch (ex)
	{
	}
	return false;
}
function detectIfPnaclSupported()
{
	try
	{
		var reportsFeature = navigator.mimeTypes['application/x-pnacl'] !== undefined;
		if (reportsFeature)
		{
			if (BrowserEdgeVersion()) // Chromium-based Edge falsely reports supporting pnacl.
				return false;
			return true;
		}
	}
	catch (ex) { }
	return false;
}
function detectMSESupport()
{
	try
	{
		if (window.MediaSource)
		{
			if (MediaSource.isTypeSupported("video/mp4; codecs=\"avc1.640033\""))
				return 1;
		}
	}
	catch (ex) { }
	return 0;
}
function detectWebCodecsVideoDecoderSupport()
{
	var result = { videoFrame: false, decoder: false, h264: false };
	try
	{
		var videoDecoder = null;
		if ('VideoFrame' in window)
			result.videoFrame = true;
		if ('VideoDecoder' in window)
		{
			try
			{
				var videoDecoder = new VideoDecoder({ output: function (frame) { }, error: function (error) { } });
				result.decoder = true;
				try
				{
					videoDecoder.configure({ codec: "avc1.640029" });
					result.h264 = true;
				}
				catch (ex) { }
				finally { videoDecoder.reset(); }
			}
			catch (ex) { }
			finally { videoDecoder.close(); }
		}
	}
	catch (ex) { }
	return result;
}
function detectAudioSupport()
{
	try
	{
		// Web Audio (camera sound)
		var AudioContext = window.AudioContext || window.webkitAudioContext;
		if (AudioContext)
		{
			var context = new AudioContext();
			try
			{
				if (typeof context.createGain === "function")
				{
					web_audio_supported = true;
					web_audio_autoplay_disabled = context.state === "suspended";

					if (typeof context.createBuffer === "function" && typeof context.createBufferSource === "function")
					{
						var buffer = context.createBuffer(1, 1, 22050);
						if (buffer)
						{
							web_audio_buffer_source_supported = true;
							if (typeof buffer.copyFromChannel === "function" && typeof buffer.copyToChannel === "function")
								web_audio_buffer_copyToChannel_supported = true;
						}
					}
				}
			}
			finally
			{
				context.close();
			}
		}
	}
	catch (ex) { }
}
function detectVibrateSupport()
{
	try
	{
		return typeof window.navigator.vibrate === "function";
	}
	catch (ex) { }
	return false;
}
function isSpeechSupported()
{
	try
	{
		return !!speechSynthesis;
	}
	catch (ex)
	{
		return false;
	}
}

DoUIFeatureDetection();
///////////////////////////////////////////////////////////////
// Globals (most of them) /////////////////////////////////////
///////////////////////////////////////////////////////////////
var toaster = new Toaster();
var ajaxHistoryManager;
var loadingHelper = new LoadingHelper();
var touchEvents = new TouchEventHelper();
var ui3CamSettings = null;
var clipboardHelper;
var uiSizeHelper = null;
var uiSettingsPanel = null;
var pcmPlayer = null;
var diskUsageGUI = null;
var serverControl = null;
var cameraListDialog = null;
var exportListDialog = null;
var clipProperties = null;
var clipDownloadDialog = null;
var statusAreaApi = null;
var volumeSlider = null;
var dropdownBoxes = null;
var leftBarBools = null;
var cornerStatusIcons = null;
var serverTimeLimiter = null;
var liveVideoPausing = null;
var genericQualityHelper = null;
var streamingProfileUI = null;
var relativePTZ = null;
var ptzButtons = null;
var gamepadPtzController = null;
var playbackHeader = null;
var exportControls = null;
var clipExportPanel = null;
var exportAPIStatusDialog = null;
var seekBar = null;
var playbackControls = null;
var clipTimeline = null;
var hotkeys = null;
var dateFilter = null;
var clipFilterSearch = null;
var hlsPlayer = null;
var fullScreenModeController = null;
var maximizedModeController = null;
var canvasContextMenu = null;
var calendarContextMenu = null;
var openAlertListButtonContextMenu = null;
var clipListContextMenu = null;
var togglableContextMenus = null;
var cameraConfig = null;
var keepScreenAlive = null;
var videoPlayer = null;
var imageRenderer = null;
var cameraNameLabels = null;
var sessionManager = null;
var mediaSessionController = null;
var pictureInPictureController = null;
var statusLoader = null;
var cameraListLoader = null;
var clipLoader = null;
var clipThumbnailVideoPreview = null;
var nerdStats = null;
var sessionTimeout = null;
var clipOverlayCfg = null;
var groupCfg = null;
var programmaticSoundPlayer = null;
var sidebarResizeBar = null;
var mqttClient = null;

var currentPrimaryTab = "";

var togglableUIFeatures =
	[
		// The uniqueId is also used in the name of a setting which remembers the enabled state.
		// If you add a new togglabe UI feature here, also add the corresponding default setting value.
		// [selector, uniqueId, displayName, onToggle, extraMenuButtons, shouldDisableToggler, labels]
		["#volumeBar", "volumeBar", "Volume Controls", function (enabled)
		{
			volumeSlider.setEnabled(enabled);
			if (enabled)
				$("#volumeBar").removeClass("disabled")
			else
				$("#volumeBar").addClass("disabled")
		}, null, null]
		, ["#profileStatusBox", "profileStatus", "Profile Status Controls", function (enabled) { statusLoader.SetProfileButtonsEnabled(enabled); }, null, null]
		, ["#stoplightBtn", "stopLight", "Stoplight/Shield Controls", function (enabled) { statusLoader.SetStoplightButtonEnabled(enabled); }, null, null]
		, ["#globalScheduleBox", "globalSchedule", "Schedule Controls", function (enabled) { dropdownBoxes.setEnabled("schedule", enabled); }, null, null]
		// The PTZ Controls hot area specifically does not include the main button pad because a context menu on that pad would break touchscreen usability
		, [".ptzpreset", "ptzControls", "PTZ Controls", function (enabled) { ptzButtons.setEnabled(enabled); }
			, [{
				getName: function (ele) { return "Goto Preset " + ele.getAttribute("presetnum") + htmlEncode(ptzButtons.GetPresetDescription(ele.getAttribute("presetnum"), true)); }
				, action: function (ele) { ptzButtons.PTZ_goto_preset(ele.presetnum); }
				, shouldDisable: function () { return !ptzButtons.isEnabledNow(); }
			}
				, {
				getName: function (ele) { return "Set Preset " + ele.getAttribute("presetnum"); }
				, action: function (ele) { ptzButtons.PresetSet(ele.getAttribute("presetnum")); }
				, shouldDisable: function () { return !ptzButtons.isEnabledNow(); }
			}]
			, function () { return !videoPlayer.Loading().image.ptz; }
		]
		, ["#playbackHeader", "clipNameLabel", "Clip Name", function (enabled)
		{
			if (enabled)
				$("#clipNameHeading").show();
			else
				$("#clipNameHeading").hide();
		}, null, null, ["Show", "Hide", "Toggle"]]
	];

///////////////////////////////////////////////////////////////
// Notes that require BI changes //////////////////////////////
///////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
// High priority notes ////////////////////////////////////////
///////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
// Low priority notes /////////////////////////////////////////
///////////////////////////////////////////////////////////////

// Clock drift and timezone differences were last tested 2022-03-12 and 2022-02-25.
// KNOWN: Around May 11, 2018 with BI 4.7.4.1, Blue Iris began imposing Streaming 0's frame size and quality settings on jpeg frames, and I wasn't able to talk the developer out of it.  UI3 works around this by always requesting jpeg snapshots with explicit dimensions and quality.
// CONSIDER: Add "Remote Control" menu based on that which is available in iOS and Android apps.
// KNOWN: Sometimes the clip list scrolls down when you're trying to work with it, probably related to automatic refreshing addings items at the top.
// KNOWN: Black frame shown when pausing HTML5 player before first frame is rendered. This is caused by destroying the jmuxer instance before the frame has rendered. Skipping or delaying the destroy causes camera-changing weirdness, so this is the lesser nuisance.
// CONSIDER: Expandable clip list. ("Show more clips")
// KNOWN: Jpeg snapshots of dynamic groups often are missing some labels because BI returned the frame before drawing them.
// KNOWN: navigator.mediaSession doesn't work properly. Timeline playback has never been tested with it.

///////////////////////////////////////////////////////////////
// Settings ///////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var CameraLabelTextValues = {
	Name: "Name",
	ShortName: "Short Name",
	Both: "Name (Short Name)"
}
var CameraLabelPositionValues = {
	Above: "Above",
	Top: "Top",
	Bottom: "Bottom",
	Below: "Below"
}
var H264PlayerOptions = {
	Automatic: "Automatic",
	JavaScript: "JavaScript",
	HTML5: "HTML5",
	NaCl_HWVA_Auto: "NaCl (Auto hw accel)",
	NaCl_HWVA_No: "NaCl (No hw accel)",
	NaCl_HWVA_Yes: "NaCl (Only hw accel)",
	WebCodecs: "WebCodecs"
}
function GetH264PlayerOptions()
{
	var arr = new Array();
	arr.push(H264PlayerOptions.Automatic);
	if (webcodecs_h264_player_supported)
		arr.push(H264PlayerOptions.WebCodecs);
	if (mse_mp4_h264_supported)
		arr.push(H264PlayerOptions.HTML5);
	if (pnacl_player_supported)
	{
		arr.push(H264PlayerOptions.NaCl_HWVA_Auto);
		arr.push(H264PlayerOptions.NaCl_HWVA_No);
		arr.push(H264PlayerOptions.NaCl_HWVA_Yes);
	}
	if (h264_js_player_supported)
		arr.push(H264PlayerOptions.JavaScript);
	return arr;
}
function GetDefaultH264PlayerOption()
{
	if (BrowserIsEdgeLegacy())
		return H264PlayerOptions.JavaScript;
	return GetH264PlayerOptions()[0];
}
function GetSpeechVoiceOptions()
{
	var opt = [];
	if (speech_synthesis_supported)
	{
		try
		{
			var voices = speechSynthesis.getVoices();
			for (var i = 0; i < voices.length; i++)
				opt.push(voices[i].name);
		}
		catch (ex)
		{
			opt.push("Not Supported");
		}
	}
	return opt;
}
function GetAudioCodecOptions()
{
	return ["\u03BC-law", "FLAC"];
}
var HTML5DelayCompensationOptions = {
	None: "None",
	Weak: "Weak",
	Normal: "Normal",
	Strong: "Strong"
}
function GetStatusAreaBarOptions()
{
	var arr = new Array();
	if (statusAreaApi)
	{
		var registrations = statusAreaApi.getStatusBarRegistrations();
		for (var i = 0; i < registrations.length; i++)
			arr.push(registrations[i].uniqueName);
	}
	return arr;
}
var settings = null;
var settingsCategoryList = ["General Settings", "Video Player", "Video Player (Advanced)", "Timeline", "UI Status Sounds", "Top Bar", "Side Bar", "Status Area", "Clips / Alerts", "Clip / Alert Icons", "Event-Triggered Icons", "Event-Triggered Sounds", "PTZ", "Hotkeys", "UI3 Camera Labels", "Digital Zoom", "MQTT Remote Control", "Extra"]; // Create corresponding "ui3_cps_uiSettings_category_" default when adding a category here.
var defaultSettings =
	[
		{
			key: "ui3_defaultTab"
			, value: "live"
		}
		, {
			key: "ui3_defaultCameraGroupId"
			, value: "index"
		}
		, {
			key: "ui3_audioVolume"
			, value: 0
		}
		, {
			key: "ui3_audioMute"
			, value: "1"
		}
		, {
			key: "ui3_streamingQuality"
			, value: "1080p VBR^"
		}
		, {
			key: "ui3_playback_reverse"
			, value: "0"
		}
		, {
			key: "ui3_playback_speed"
			, value: "1"
		}
		, {
			key: "ui3_playback_autoplay"
			, value: "0"
		}
		, {
			key: "ui3_playback_loop"
			, value: "0"
		}
		, {
			key: "ui3_current_dbView"
			, value: "all"
		}
		, {
			key: "ui3_cliplist_larger_thumbnails"
			, value: "0"
		}
		, {
			key: "ui3_cliplist_mouseover_thumbnails"
			, value: "1"
		}
		, {
			key: "ui3_clip_export_format"
			, value: 1
		}
		, {
			key: "ui3_clip_export_profile"
			, value: 0
		}
		, {
			key: "ui3_clip_export_substream"
			, value: "0"
		}
		, {
			key: "ui3_clip_export_withAudio"
			, value: "1"
		}
		, {
			key: "ui3_clip_export_reencode"
			, value: "0"
		}
		, {
			key: "ui3_clip_export_overlay"
			, value: "0"
		}
		, {
			key: "ui3_clip_export_timelapse"
			, value: "0"
		}
		, {
			key: "ui3_clip_export_timelapseMultiplier"
			, value: 10
		}
		, {
			key: "ui3_clip_export_timelapseFps"
			, value: 30
		}
		, {
			key: "ui3_portraitSidebarSize"
			, value: 0.5
		}
		, {
			key: "bi_rememberMe"
			, value: "0"
		}
		, {
			key: "bi_username"
			, value: ""
		}
		, {
			key: "bi_password"
			, value: ""
		}
		, {
			key: "bi_lastunload"
			, value: 0
		}
		, {
			key: "ui3_webcasting_disabled_dontShowAgain"
			, value: "0"
		}
		, {
			key: "ui3_feature_enabled_volumeBar" // ui3_feature_enabled keys are tied to unique IDs in togglableUIFeatures
			, value: "1"
		}
		, {
			key: "ui3_feature_enabled_profileStatus"
			, value: "1"
		}
		, {
			key: "ui3_feature_enabled_stopLight"
			, value: "0"
		}
		, {
			key: "ui3_feature_enabled_globalSchedule"
			, value: "1"
		}
		, {
			key: "ui3_feature_enabled_ptzControls"
			, value: "1"
		}
		, {
			key: "ui3_feature_enabled_clipNameLabel"
			, value: "1"
		}
		, {
			key: "ui3_collapsible_ptz"
			, value: "1"
		}
		, {
			key: "ui3_collapsible_profileStatus"
			, value: "1"
		}
		, {
			key: "ui3_collapsible_schedule"
			, value: "1"
		}
		, {
			key: "ui3_collapsible_currentGroup"
			, value: "1"
		}
		, {
			key: "ui3_collapsible_streamingQuality"
			, value: "1"
		}
		, {
			key: "ui3_collapsible_serverStatus"
			, value: "1"
		}
		, {
			key: "ui3_collapsible_filterRecordings"
			, value: "1"
		}
		, {
			key: "ui3_cps_info_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_gs_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_mt_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_jp_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_mro_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_mgmt_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_General_Settings_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_Video_Player_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_Video_Player__Advanced__visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_Timeline_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_UI_Status_Sounds_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_Top_Bar_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_Side_Bar_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_Status_Area_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_Clips___Alerts_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_Clip___Alert_Icons_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_Event_Triggered_Icons_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_Event_Triggered_Sounds_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_PTZ_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_Hotkeys_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_UI3_Camera_Labels_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_Digital_Zoom_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_MQTT_Remote_Control_visible"
			, value: "1"
		}
		, {
			key: "ui3_cps_uiSettings_category_Extra_visible"
			, value: "1"
		}
		, {
			key: "ui3_disableIEWarning"
			, value: "0"
		}
		, {
			key: "ui3_maxGOP"
			, value: 1000
		}
		, {
			key: "ui3_didAdd8kProfiles"
			, value: "0" // 8K streaming profiles are added dynamically to UI3 only when a camera or group is found with a dimension above 3840px (which is uncommon as of 2022). This flag gets set afterward to disable the relevant code.
		}
		, {
			key: "ui3_clipOverlayCfg"
			, value: ""
		}
		, {
			key: "ui3_groupCfg"
			, value: ""
		}
		, {
			key: "ui3_streamingProfileArray"
			, value: "[]"
			, category: "Streaming Profiles" // This category isn't shown in UI Settings, but has special-case logic in ui3-local-overrides.js export.
		}
		, {
			key: "ui3_timelineZoomScaler"
			, value: 13
		}
		, {
			key: "ui3_cam_settings_map" // Stores a JSON-serialized map of camera settings keyed by camera ID (normalized to lower case). Accessed via Camera Properties.
			, value: "{}"
		}
		, {
			key: "ui3_timeout"
			, value: 10
			, inputType: "number"
			, minValue: 0
			, maxValue: 525600
			, label: 'Idle Timeout<div class="settingDesc">The UI will close itself after this many minutes of inactivity. (0 to disable)<br>Can be set with URL parameter <span class="icode">&amp;timeout=0</span></div>'
			, category: "General Settings"
		}
		, {
			key: "ui3_preferred_ui_scale"
			, value: "Auto"
			, inputType: "select"
			, options: ["Auto", "Large", "Medium", "Small", "Smaller"]
			, label: "Preferred UI Scale"
			, onChange: OnChange_ui3_preferred_ui_scale
			, category: "General Settings"
		}
		, {
			key: "ui3_portrait_layout"
			, value: "Auto"
			, inputType: "select"
			, options: ["Auto", "Yes", "No"]
			, label: "Portrait Layout"
			, onChange: OnChange_ui3_portrait_layout
			, category: "General Settings"
		}
		, {
			key: "ui3_color_theme"
			, value: "Auto"
			, inputType: "select"
			, options: ["Auto", "Blue Iris 6", "Blue Iris 6 Black", "Blue Iris 5", "Blue Iris 5 Black", "Legacy UI3"]
			, label: "Color Theme"
			, onChange: OnChange_ui3_color_theme
			, category: "General Settings"
		}
		, {
			key: "ui3_time24hour"
			, value: localeUses24HourTime() ? "1" : "0"
			, inputType: "checkbox"
			, label: '24-Hour Time'
			, onChange: OnChange_ui3_time24hour
			, category: "General Settings"
		}
		, {
			key: "ui3_edge_fetch_bug_h264_enable"
			, value: "0"
			, inputType: "checkbox"
			, label: '<span style="color:#FF0000;font-weight:bold">Enable H.264 Player</span><div class="settingDesc">This browser has known compatiblity issues. <a href="javascript:UIHelp.LearnMore(\'Edge Fetch Bug\')">(learn more)</a></div>'
			, onChange: OnChange_ui3_edge_fetch_bug_h264_enable
			, preconditionFunc: Precondition_ui3_edge_fetch_bug_h264_enable
			, category: "Video Player"
		}
		, {
			key: "ui3_h264_choice4"
			, value: GetDefaultH264PlayerOption()
			, inputType: "select"
			, options: GetH264PlayerOptions()
			, label: 'H.264 Player <a href="javascript:UIHelp.LearnMore(\'H.264 Player Options\')">(learn more)</a>'
			, onChange: OnChange_ui3_h264_choice
			, preconditionFunc: Precondition_ui3_h264_choice
			, category: "Video Player"
		}
		, {
			key: "ui3_h264_choice_requires_restart"
			, value: ""
			, inputType: "comment"
			, comment: '<div style="text-align: center"><a href="javascript:ReloadInterface()">Click to apply H.264 Player change</a></div>'
			, preconditionFunc: Precondition_ui3_h264_choice_requires_restart
			, category: "Video Player"
		}
		, {
			key: "ui3_comment_current_h264_player"
			, value: ""
			, inputType: "comment"
			, comment: GenerateCurrentH264PlayerComment
			, preconditionFunc: Precondition_ui3_h264_choice
			, category: "Video Player"
		}
		, {
			key: "ui3_streamingProfileBitRateMax"
			, value: -1
			, inputType: "number"
			, minValue: -1
			, maxValue: 100000
			, label: 'Maximum H.264 Kbps<div class="settingDesc">(disabled if less than 10)</div>'
			, hint: "Useful for slow connections. Audio streams are not affected by this setting. Limit 100000 Kbps."
			, onChange: OnChange_ui3_streamingProfileBitRateMax
			, preconditionFunc: Precondition_ui3_streamingProfileBitRateMax
			, category: "Video Player"
		}
		, {
			key: "ui3_doubleClick_behavior"
			, value: "Recordings"
			, inputType: "select"
			, options: ["None", "Live View", "Recordings", "Both"]
			, label: 'Double-Click to Fullscreen<div class="settingDesc"><a href="javascript:UIHelp.LearnMore(\'Double-Click to Fullscreen\')">(learn more)</a></div>'
			, category: "Video Player"
		}
		, {
			key: "ui3_pause_when_hidden"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Pause when tab is inactive'
			, hint: 'When set to "Yes", video playback will pause when the tab is inactive.\nSelect "No" to allow audio and event-triggered sounds to play while the browser tab is inactive.\nRecommended: "Yes"'
			, category: "Video Player"
		}
		, {
			key: "ui3_web_audio_autoplay_warning"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Warn at startup if audio playback requires user input'
			, hint: 'When set to "Yes", a full-page overlay will appear if camera audio playback requires user input. Otherwise, the audio icon will simply turn red.'
			, category: "Video Player"
		}
		, {
			key: "ui3_show_picture_in_picture_button"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Picture-in-Picture Button'
			, hint: 'Requires a supported browser and only works with the HTML5 player.' // Do not include "H.264 player" text, for filtering reasons
			, onChange: OnChange_ui3_show_picture_in_picture_button
			, category: "Video Player"
		}
		, {
			key: "ui3_prioritizeTriggered"
			, value: "0"
			, inputType: "checkbox"
			, label: '<svg class="icon noflip clipicon prioritizeTriggeredButton"><use xlink:href="#svg_auto_maximize"></use></svg> Auto-Maximize Enabled'
			, onChange: OnChange_ui3_prioritizeTriggered
			, onCreate: OnChange_ui3_prioritizeTriggered
			, category: "Video Player"
		}
		, {
			key: "ui3_prioritizeTriggered_triggerMode"
			, value: "Alert"
			, inputType: "select"
			, options: ["Alert", "Trigger", "Motion"]
			, label: '<svg class="icon noflip clipicon prioritizeTriggeredButton"><use xlink:href="#svg_auto_maximize"></use></svg> Auto-Maximize upon...'
			, hint: '"Motion" uses Blue Iris\'s built-in motion detection.\n\n"Trigger" works with any method of trigger (such as ONVIF or audio), but may not respond as quickly. Trigger happens before AI verification.\n\n"Alert" waits for the camera to begin alerting, which happens after AI verification (if configured).'
			, category: "Video Player"
		}
		, {
			key: "ui3_dynamicGroupLayout"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Dynamic Group Layout<div class="settingDesc"><a href="javascript:UIHelp.LearnMore(\'Dynamic Group Layout\')">(learn more)</a></div>'
			, onChange: OnChange_ui3_dynamicGroupLayout
			, category: "Video Player"
		}
		, {
			key: "ui3_maxDynamicGroupImageMegapixels"
			, value: 2.1
			, minValue: 0.1
			, maxValue: 32
			, step: 0.1
			, inputType: "range"
			, unitLabel: " megapixels"
			, label: 'Dynamic Group Max Resolution<div class="settingDesc">(can strongly affect server CPU usage)</div>'
			, changeOnStep: false
			, onChange: OnChange_ui3_maxDynamicGroupImageMegapixels
			, category: "Video Player"
		}
		, {
			key: "ui3_comment_h264_acceptable_delay"
			, value: ""
			, inputType: "comment"
			, comment: '<svg class="icon noflip" style="fill: rgb(255,128,0); width: 2em; height: 2em; float: right; margin-left: 10px;"><use xlink:href="#svg_mio_clock"></use></svg> An orange clock icon is shown when video delay exceeds warning thresholds:'
			, preconditionFunc: Precondition_ui3_h264_choice
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_h264_net_delay_threshold"
			, value: 2.5
			, minValue: 0.05
			, maxValue: 30
			, step: 0.050
			, inputType: "range"
			, unitLabel: " sec"
			, label: 'Source/Network Delay Warning Threshold'
			, changeOnStep: true
			, hint: 'See "Stats for nerds" to monitor video delays.'
			, preconditionFunc: Precondition_ui3_h264_net_delay_threshold
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_h264_html5_delay_threshold"
			, value: 6.5
			, minValue: 0.05
			, maxValue: 30
			, step: 0.050
			, inputType: "range"
			, unitLabel: " sec"
			, label: 'Player Delay Warning Threshold'
			, changeOnStep: true
			, hint: 'See "Stats for nerds" to monitor video delays.  The HTML5 H.264 player inherently has more delay than other H.264 players, so its acceptable delay setting is stored separately.'
			, preconditionFunc: Precondition_ui3_h264_html5_delay_threshold
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_h264_delay_threshold"
			, value: 3
			, minValue: 0.05
			, maxValue: 30
			, step: 0.050
			, inputType: "range"
			, unitLabel: " sec"
			, label: 'Player Delay Threshold'
			, changeOnStep: true
			, hint: 'See "Stats for nerds" to monitor video delays.'
			, preconditionFunc: Precondition_ui3_h264_delay_threshold
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_h264_reset_at_delay"
			, value: 60
			, minValue: 1
			, maxValue: 180
			, step: 1
			, inputType: "range"
			, unitLabel: " sec"
			, label: 'Restart stream if delay exceeds'
			, changeOnStep: true
			, hint: 'The stream will restart if total delay (Source/Network Delay + Player Delay) are above this limit.  See "Stats for nerds" to monitor video delays.'
			, preconditionFunc: Precondition_ui3_h264_choice
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_html5_delay_compensation"
			, value: HTML5DelayCompensationOptions.Normal
			, inputType: "select"
			, options: [HTML5DelayCompensationOptions.None, HTML5DelayCompensationOptions.Weak, HTML5DelayCompensationOptions.Normal, HTML5DelayCompensationOptions.Strong]
			, label: 'HTML5 Video Delay Compensation <div class="settingDesc"><a href="javascript:UIHelp.LearnMore(\'HTML5 Video Delay Compensation\')">(learn more)</a></div>'
			, preconditionFunc: Precondition_ui3_html5_delay_compensation
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_download_snapshot_method"
			, value: "Server"
			, inputType: "select"
			, options: ["Server", "Local (JPEG)", "Local (PNG)"]
			, label: 'Source of snapshot downloads<div class="settingDesc"><a href="javascript:UIHelp.LearnMore(\'Local Snapshots\')">(learn more)</a></div>'
			, onChange: OnChange_ui3_download_snapshot_method
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_comment_download_snapshot_local"
			, value: ""
			, inputType: "comment"
			, comment: GenerateLocalSnapshotsComment
			, preconditionFunc: Precondition_ui3_download_snapshot_local
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_download_snapshot_server_quality"
			, value: 85
			, minValue: 1
			, maxValue: 100
			, step: 1
			, unitLabel: "%"
			, inputType: "range"
			, label: 'Server-sourced Snapshot Jpeg Quality'
			, hint: 'Default: 85%'
			, changeOnStep: false
			, preconditionFunc: Precondition_ui3_download_snapshot_server
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_audio_codec"
			, value: flac_supported ? "FLAC" : GetAudioCodecOptions()[0]
			, inputType: "select"
			, options: GetAudioCodecOptions()
			, label: 'Audio Codec' + (!flac_supported ? '<div class="settingDesc">(FLAC unavailable in this browser)</div>' : '')
			, onChange: OnChange_ui3_audio_codec
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_audio_buffer_ms"
			, value: 700
			, minValue: 0
			, maxValue: 5000
			, inputType: "number"
			, label: 'Audio Buffer Size Milliseconds<div class="settingDesc">(max audio delay)</div>'
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_jpegSupersampling"
			, value: 1
			, minValue: 0.01
			, maxValue: 2
			, step: 0.01
			, inputType: "range"
			, label: 'Jpeg Video Supersampling Factor'
			, changeOnStep: true
			, hint: "(Default: 1)\n\nJpeg video frames loaded by UI3 will have their dimensions scaled by this amount.\n\nLow values save bandwidth, while high values improve quality slightly."
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_video_loading_overlay"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Darken Video While Loading'
			, onChange: OnChange_ui3_video_loading_overlay
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_video_loading_animation"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Spinner Animation While Loading'
			, onChange: OnChange_ui3_video_loading_animation
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_allow_touch_swipe_gestures"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Touchscreen Swipe Gestures<div class="settingDesc">(swipe left and right to switch cameras)</div>'
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_allow_mouse_swipe_gestures"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Mouse Swipe Gestures<div class="settingDesc">(swipe left and right to switch cameras)</div>'
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_touch_gestures_reverse"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Reverse Swipe Gestures'
			, hint: 'By default, swiping left goes to the next camera and swiping right goes to the previous camera.'
			, category: "Video Player (Advanced)"
		}
		, {
			key: "ui3_playback_skipDeadAir"
			, value: 0
			, inputType: "threeState"
			, label: 'Skip dead-air during playback'
			, onChange: OnChange_ui3_playback_skipDeadAir
			, category: "Timeline"
		}
		, {
			key: "ui3_timeline_starfield"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Starfield Background<div class="settingDesc">A little visual flair outside the timeline boundaries.</div>'
			, category: "Timeline"
		}
		, {
			key: "ui3_timeline_alertBarColor"
			, value: "#8E3510"
			, inputType: "color"
			, label: 'Alert Bar Color'
			, category: "Timeline"
		}
		, {
			key: "ui3_timeline_alertTrackMarkers"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Alert Track Markers<div class="settingDesc">Marks timeline color bars wherever they were alerted.</div>'
			, category: "Timeline"
		}
		, {
			key: "ui3_timeline_currentZoomScaleComment"
			, value: ""
			, inputType: "comment"
			, comment: function () { return 'Current Zoom Scale: <span id="timelineCurrentZoomScaleComment">' + (clipTimeline && clipTimeline.getZoomScaler() ? clipTimeline.getZoomScaler().toFixed(1) : "[timeline not loaded!]") + '</span>'; }
			, category: "Timeline"
		}
		, {
			key: "ui3_timeline_minZoomScaler"
			, value: 7
			, minValue: 6
			, maxValue: 8
			, step: 0.5
			, inputType: "range"
			, label: 'Minimum Zoom Scale'
			, changeOnStep: true
			, onChange: OnChange_ui3_timeline_minZoomScaler
			, category: "Timeline"
		}
		, {
			key: "ui3_timeline_alertThumbnailsAppearAtZoomLevel"
			, value: 8
			, minValue: 6
			, maxValue: 30 // Matches maxZoomScaler in ClipTimeline
			, step: 0.5
			, inputType: "range"
			, label: 'Alert Thumbnails Appear At Zoom Scale'
			, changeOnStep: true
			, onChange: OnChange_ui3_timeline_alertThumbnailsAppearAtZoomLevel
			, category: "Timeline"
		}
		, {
			key: "ui3_timeline_alertThumbnailsAppearForGroups"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Alert Thumbnails Appear for Groups'
			, onChange: OnChange_ui3_timeline_alertThumbnailsAppearForGroups
			, category: "Timeline"
		}
		, {
			key: "ui3_timeline_drawHoveredAlertOnTop"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Highlight Hovered Thumbnail<div class="settingDesc">When mousing over an alert thumbnail, it will be drawn on top with a white border.</div>'
			, category: "Timeline"
		}
		, {
			key: "ui3_timeline_drawHoveredAlertOnly"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Draw Only Hovered Thumbnail<div class="settingDesc">Only draw the thumbnail currently being moused over.</div>'
			, category: "Timeline"
		}
		, {
			key: "ui3_timeline_alertThumbnailClickLoadsAlertStartTime"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Alert Thumb Click Handling<div class="settingDesc">Clicking an alert thumbnail will seek to the alert\'s start time.  Results may be inaccurate when zoomed far out.</div>'
			, hint: 'UI3 does not have extremely precise timeline data available, so this function works best when zoomed far in.'
			, category: "Timeline"
		}
		, {
			key: "ui3_uiStatusSounds"
			, value: "0"
			, inputType: "checkbox"
			, label: 'UI Status Sounds<div class="settingDesc">Sound is emitted when certain important events occur. <a href="javascript:UIHelp.LearnMore(\'UI Status Sounds\')">(learn more)</a></div>'
			, onChange: OnChange_ui3_uiStatusSounds
			, category: "UI Status Sounds"
		}
		, {
			key: "ui3_uiStatusSpeech"
			, value: "0"
			, inputType: "checkbox"
			, label: 'UI Status Speech<div class="settingDesc">Requires compatible browser. <a href="javascript:TestSpeech()">Click to test.</a></div>'
			, onChange: OnChange_ui3_uiStatusSpeech
			, preconditionFunc: Precondition_ui3_speechAvailable
			, category: "UI Status Sounds"
		}
		, {
			key: "ui3_speechVoice"
			, value: ""
			, inputType: "select"
			, options: []
			, getOptions: GetSpeechVoiceOptions
			, label: 'Speech Voice'
			, onChange: OnChange_ui3_speechVoice
			, preconditionFunc: Precondition_ui3_speechAvailable
			, category: "UI Status Sounds"
		}
		, {
			key: "ui3_topbar_save_snapshot_btn_show"
			, value: "1"
			, inputType: "checkbox"
			, label: "Save Snapshot Button"
			, onChange: OnChange_ui3_topbar_save_snapshot_btn_show
			, category: "Top Bar"
		}
		, {
			key: "ui3_topbar_allclips_shortcut_show"
			, value: "1"
			, inputType: "checkbox"
			, label: "Shortcut to All Clips"
			, onChange: OnChange_ui3_topbar_allclips_shortcut_show
			, category: "Top Bar"
		}
		, {
			key: "ui3_topbar_alerts_shortcut_show"
			, value: "1"
			, inputType: "checkbox"
			, label: "Shortcut to Alerts"
			, onChange: OnChange_ui3_topbar_alerts_shortcut_show
			, category: "Top Bar"
		}
		, {
			key: "ui3_topbar_alerts_canceled_shortcut_show"
			, value: "0"
			, inputType: "checkbox"
			, label: "Shortcut to Cancelled Alerts"
			, onChange: OnChange_ui3_topbar_alerts_canceled_shortcut_show
			, category: "Top Bar"
		}
		, {
			key: "ui3_topbar_alerts_confirmed_shortcut_show"
			, value: "0"
			, inputType: "checkbox"
			, label: "Shortcut to Confirmed Alerts"
			, onChange: OnChange_ui3_topbar_alerts_confirmed_shortcut_show
			, category: "Top Bar"
		}
		, {
			key: "ui3_topbar_alerts_shortcut_counter"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Show New Alerts Counter<div class="settingDesc">(requires Shortcut to Alerts)</div>'
			, onChange: OnChange_ui3_topbar_alerts_shortcut_counter
			, category: "Top Bar"
		}
		, {
			key: "ui3_topbar_warnings_counter"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Show New Warnings Counter<div class="settingDesc">(appears on Main Menu &amp; System Log)</div>'
			, onChange: OnChange_ui3_topbar_warnings_counter
			, category: "Top Bar"
		}
		, {
			key: "ui3_show_update_available_notice"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Update Available Notice<div class="settingDesc">(icon overlaid on Main Menu when a Blue Iris update is available. Requires administrator privilege)</div>'
			, hint: 'UI3 cannot independently check for updates.  UI3 learns of update availability from Blue Iris during UI3 startup.'
			, onChange: OnChange_ui3_show_update_available_notice
			, category: "Top Bar"
		}
		, {
			key: "ui3_system_name_button_text_override"
			, value: ""
			, inputType: "text"
			, label: 'System Name Button Text Override<div class="settingDesc">(keep empty to use system name from BI settings)</div>'
			, onChange: setSystemNameButtonTextState
			, category: "Top Bar"
		}
		, {
			key: "ui3_system_name_button"
			, value: "About This UI"
			, inputType: "select"
			, options: []
			, getOptions: getSystemNameButtonOptions
			, label: 'System Name Button Action'
			, hint: 'This action occurs when you click the system name in the upper left.'
			, onChange: setSystemNameButtonState
			, category: "Top Bar"
		}
		, {
			key: "ui3_system_name_button_link"
			, value: ""
			, inputType: "text"
			, class: "column_reverse"
			, label: 'System Name Button Link<div class="settingDesc">example: "https://host/"</div>'
			, preconditionFunc: Precondition_ui3_system_name_button_link
			, category: "Top Bar"
		}
		, {
			key: "ui3_sidebar_visible_on_live"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Show Side Bar<div class="settingDesc">on Live View Tab</div>'
			, onChange: resized
			, category: "Side Bar"
		}
		, {
			key: "ui3_sidebar_visible_on_clips"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Show Side Bar<div class="settingDesc">on Clips tab</div>'
			, onChange: resized
			, category: "Side Bar"
		}
		, {
			key: "ui3_show_sidebar_hidden_button"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Show Icon when Side Bar Hidden<div class="settingDesc">(icon appears by System Name)</div>'
			, onChange: HandleSidebarVisibilityChange
			, category: "Side Bar"
		}
		, {
			key: "ui3_sideBarPosition"
			, value: "Left"
			, inputType: "select"
			, options: ["Left", "Right"]
			, label: "Side Bar Position"
			, onChange: OnChange_ui3_sideBarPosition
			, category: "Side Bar"
		}
		, {
			key: "ui3_status_area_show"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Show Status Area<div class="settingDesc">on Live View tab</div>'
			, onChange: resized
			, category: "Status Area" // Note all status area settings should contain the text "status area" in a filterable field.
		}
		, {
			key: "ui3_status_area_show_clips"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Show Status Area<div class="settingDesc">on Clips tab</div>'
			, onChange: resized
			, category: "Status Area"
		}
		, {
			key: "ui3_status_area_show_timeline"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Show Status Area<div class="settingDesc">on Timeline tab</div>'
			, onChange: resized
			, category: "Status Area"
		}
		, {
			key: "ui3_status_area_name"
			, value: "Server Status"
			, inputType: "select"
			, options: ["Server Status", "Status"]
			, label: 'Status Area Label'
			, hint: 'You can change the label shown in the status area.'
			, onChange: OnChange_ui3_status_area
			, category: "Status Area"
		}
		, {
			key: "ui3_status_area_bar_key_1"
			, value: "Server CPU"
			, inputType: "select"
			, options: []
			, getOptions: GetStatusAreaBarOptions
			, label: 'Status Bar 1'
			, hint: 'Choose what is shown in bar 1 of the Status Area'
			, onChange: OnChange_ui3_status_area
			, category: "Status Area"
		}
		, {
			key: "ui3_status_area_bar_key_2"
			, value: "Server Memory"
			, inputType: "select"
			, options: []
			, getOptions: GetStatusAreaBarOptions
			, label: 'Status Bar 2'
			, hint: 'Choose what is shown in bar 2 of the Status Area'
			, onChange: OnChange_ui3_status_area
			, category: "Status Area"
		}
		, {
			key: "ui3_status_area_bar_key_3"
			, value: "Server Disk"
			, inputType: "select"
			, options: []
			, getOptions: GetStatusAreaBarOptions
			, label: 'Status Bar 3'
			, hint: 'Choose what is shown in bar 3 of the Status Area'
			, onChange: OnChange_ui3_status_area
			, category: "Status Area"
		}
		, {
			key: "ui3_status_area_bar_key_4"
			, value: "Stream FPS"
			, inputType: "select"
			, options: []
			, getOptions: GetStatusAreaBarOptions
			, label: 'Status Bar 4'
			, hint: 'Choose what is shown in bar 4 of the Status Area'
			, onChange: OnChange_ui3_status_area
			, category: "Status Area"
		}
		, {
			key: "ui3_clipPreviewEnabled"
			, value: "1"
			, inputType: "checkbox"
			, label: "Clip Preview Animations"
			, hint: "When enabled, mousing over the alert/clip list shows a rapid animated preview.  Video streaming performance may suffer while the animation is active."
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_hires_jpeg_popups"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Use Hi-res JPEG for alert mouseover'
			, hint: "This only affects alerts that have Hi-res JPEG images saved by Blue Iris"
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_hires_jpeg_disables_preview_animation"
			, value: "1"
			, inputType: "checkbox"
			, label: 'No preview animation for alerts with Hi-res JPEG'
			, hint: 'The preview animation would prevent you from reading annotations from deepstack AI.'
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_clip_preview_num_frames"
			, value: 8
			, minValue: 2
			, maxValue: 100
			, inputType: "number"
			, label: 'Number of frames in clip preview'
			, hint: 'Default: 8'
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_clip_preview_speed"
			, value: 5
			, minValue: 1
			, maxValue: 60
			, step: 1
			, unitLabel: " fps"
			, inputType: "range"
			, label: 'Clip preview speed up to'
			, hint: 'Default: 5 fps'
			, changeOnStep: false
			, preconditionFunc: Precondition_ui3_download_snapshot_server
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_pc_next_prev_buttons"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Playback Controls: Next/Previous'
			, onChange: OnChange_ui3_pc_next_prev_buttons
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_pc_seek_buttons"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Playback Controls: Skip Buttons'
			, onChange: OnChange_ui3_pc_seek_buttons
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_pc_seek_1frame_buttons"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Playback Controls: Skip 1 Frame Buttons'
			, onChange: OnChange_ui3_pc_seek_1frame_buttons
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_pc_delete_button"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Playback Controls: Delete Button'
			, onChange: OnChange_ui3_pc_delete_button
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_extra_playback_controls_padding"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Playback Controls: Extra Padding'
			, onChange: OnChange_ui3_extra_playback_controls_padding
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_extra_playback_controls_timestamp"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Playback Controls: Real Timestamp<br>When Streaming H.264'
			, hint: 'Adds a real-world timestamp to the playback controls, available only when streaming .bvr recordings with an H.264 streaming method.'
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_extra_playback_controls_alwaysVisible"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Playback Controls: Always Visible'
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_clipDownloadOriginalName"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Preserve Original File Names<div class="settingDesc">when downloading clips</div>'
			, hint: 'Does not affect clip "exports"'
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_askForDelete"
			, value: "All"
			, inputType: "select"
			, options: ["All", // All is the original default, will ask to confirm any delete
				"Multiple", // Multiple will only ask to confirm when multiple items are to be deleted
				"None"] // Will not ask to confirm deletions
			, label: 'Confirm deletes for'
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_allow_clip_deletion"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Allow Clip Deletion'
			, onChange: OnChange_ui3_allow_clip_deletion
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_download_exports_automatically"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Download Exports Automatically'
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_seek_with_substream"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Seek with Sub Stream<div class="settingDesc">for better performance</div>'
			, hint: 'Only affects recordings that include main and sub streams'
			, keywords: "sub stream substream main stream mainstream"
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_playback_speed_mainStreamComment"
			, value: ""
			, inputType: "comment"
			, comment: function () { return 'Playback rates from <span id="playback_speed_mainStreamComment">' + (playbackControls ? playbackControls.GetMainStreamSpeedRangeComment() : "[playback controls not loaded!]") + '</span> use main stream.'; }
			, keywords: "sub stream substream main stream mainstream"
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_reverse_speed_substream_threshold"
			, value: function () { return GetClosestNumericValueFromArray(GetPlaybackSpeedSubStreamOptions(), "2"); }
			, inputType: "select"
			, options: []
			, getOptions: GetPlaybackSpeedSubStreamOptions
			, label: 'Prefer sub stream at reverse speed: '
			, onChange: OnChange_ui3_reverse_speed_substream_threshold
			, keywords: "sub stream substream main stream mainstream"
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_forward_speed_substream_threshold"
			, value: function () { return GetClosestNumericValueFromArray(GetPlaybackSpeedSubStreamOptions(), "4"); }
			, inputType: "select"
			, options: []
			, getOptions: GetPlaybackSpeedSubStreamOptions
			, label: 'Prefer sub stream at forward speed: '
			, onChange: OnChange_ui3_forward_speed_substream_threshold
			, keywords: "sub stream substream main stream mainstream"
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_openARecording"
			, value: "No"
			, inputType: "select"
			, options: ["No", "First", "Last"]
			, label: 'Automatically Open a Recording<div class="settingDesc">when loading Alerts or Clips tab</div>'
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_clip_navigation_direction"
			, value: "Oldest First"
			, inputType: "select"
			, options: ["Newest First", // "next clip" is older, further down the clip list.
				"Oldest First"] // "next clip" is newer, further up the clip list.
			, label: 'Clip Review Order/Direction'
			, hint: 'Choose "Oldest First" if you prefer to review clips from oldest to newest.  Affects autoplay direction and Next/Previous button logic.  May affect other aspects of clip navigation in the future.'
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_showClipListFilterSearch"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Show filter by "search" input'
			, hint: 'Hiding the search box will allow more vertical space for the clip list'
			, onChange: OnChange_ui3_showClipListFilterSearch
			, category: "Clips / Alerts"
		}
		, {
			key: "ui3_clipicon_trigger_motion"
			, value: "0"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip"><use xlink:href="#svg_mio_run"></use></svg> for motion-triggered alerts'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_trigger_audio"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip"><use xlink:href="#svg_mio_volumeUp"></use></svg> for audio-triggered alerts'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_trigger_external"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon"><use xlink:href="#svg_x5F_Alert1"></use></svg> for externally-triggered alerts'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_trigger_group"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip"><use xlink:href="#svg_mio_quilt"></use></svg> for group-triggered alerts'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_trigger_sentry"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip"><use xlink:href="#svg_mio_cbChecked"></use></svg> for AI-confirmed alerts'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_trigger_sentry_occupied"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip"><use xlink:href="#sentry_human"></use></svg> for AI-confirmed alerts that continue a previous alert'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_ai_person"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip icon-ai_person"><use xlink:href="#svg_mio_man"></use></svg> when AI detected a person'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_ai_vehicle"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip icon-ai_vehicle"><use xlink:href="#svg_mio_directions_car"></use></svg> when AI detected a vehicle'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_ai_wildlife"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip icon-ai_wildlife"><use xlink:href="#wildlife"></use></svg> when AI detected wildlife'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_alert_cancelled"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon"><use xlink:href="#svg_x5F_HoldProfile"></use></svg> for alerts that were cancelled'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_clip_audio"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip"><use xlink:href="#svg_mio_volumeUp"></use></svg> for clips with audio'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_clip_backingup"
			, value: "0"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip"><use xlink:href="#svg_mio_cloudUploading"></use></svg> for clips that are being backed up'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_clip_backup"
			, value: "0"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip"><use xlink:href="#svg_mio_cloudUploaded"></use></svg> for clips that have been backed up'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_protect"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip"><use xlink:href="#svg_mio_lock"></use></svg> for protected items'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_flag"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon"><use xlink:href="#svg_x5F_Flag"></use></svg> for flagged items'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_is_recording"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon"><use xlink:href="#svg_x5F_Stoplight"></use></svg> while the clip is still recording'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_nosignal"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip"><use xlink:href="#svg_x5F_Error"></use></svg> for alerts where the camera had no signal'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_clipicon_is_new"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon"><use xlink:href="#svg_x5F_Stoplight"></use></svg> for new alerts'
			, category: "Clip / Alert Icons"
		}
		, {
			key: "ui3_comment_eventTriggeredIcons_Heading"
			, value: ""
			, inputType: "comment"
			, comment: GenerateEventTriggeredIconsComment
			, category: "Event-Triggered Icons"
		}
		, {
			key: "ui3_icon_motion"
			, value: "0"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip" style="fill: rgba(120,205,255,1)"><use xlink:href="#svg_mio_run"></use></svg> on Motion Detected'
			, category: "Event-Triggered Icons"
		}
		, {
			key: "ui3_icon_trigger"
			, value: "0"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon" style="fill: rgba(255,64,64,1)"><use xlink:href="#svg_x5F_Alert1"></use></svg> on Camera Triggered'
			, category: "Event-Triggered Icons"
		}
		, {
			key: "ui3_icon_recording"
			, value: "0"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon" style="fill: rgba(255,0,0,1)"><use xlink:href="#svg_x5F_Stoplight"></use></svg> on Camera Recording'
			, hint: "Does not appear when viewing a group of cameras"
			, category: "Event-Triggered Icons"
		}
		, {
			key: "ui3_comment_camera_overlay_icons_Heading"
			, value: ""
			, inputType: "comment"
			, comment: "The following icons are shown <b>per-camera</b> and do not require an H.264 stream."
			, category: "Event-Triggered Icons"
		}
		, {
			key: "ui3_camera_overlay_icon_motion_trigger"
			, value: "0"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip" style="fill: rgba(255,0,0,1)"><use xlink:href="#svg_mio_run"></use></svg> on Motion Trigger'
			, onChange: OnChange_ui3_camera_overlay_icons
			, category: "Event-Triggered Icons"
		}
		, {
			key: "ui3_camera_overlay_icon_audio_trigger"
			, value: "0"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip" style="fill: rgba(255,0,0,1)"><use xlink:href="#svg_mio_volumeUp"></use></svg> on Audio Trigger'
			, onChange: OnChange_ui3_camera_overlay_icons
			, category: "Event-Triggered Icons"
		}
		, {
			key: "ui3_camera_overlay_icon_generic_trigger"
			, value: "0"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon" style="fill: rgba(255,0,0,1)"><use xlink:href="#svg_x5F_Alert1"></use></svg> on Other Trigger'
			, onChange: OnChange_ui3_camera_overlay_icons
			, category: "Event-Triggered Icons"
		}
		, {
			key: "ui3_camera_overlay_icon_webcasting_disabled"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip" style="fill: rgba(255,0,0,1)"><use xlink:href="#svg_x5F_HoldProfile"></use></svg> if Webcasting Disabled'
			, onChange: OnChange_ui3_camera_overlay_icons
			, category: "Event-Triggered Icons"
		}
		, {
			key: "ui3_camera_overlay_icon_paused"
			, value: "0"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon" style="fill: rgba(255,128,64,1)"><use xlink:href="#svg_x5F_Pause"></use></svg> if Paused'
			, hint: 'Icon shows if the Pause function is active (a "paused" camera behaves as if the Shield icon is red).'
			, onChange: OnChange_ui3_camera_overlay_icons
			, category: "Event-Triggered Icons"
		}
		, {
			key: "ui3_camera_overlay_icon_new_alerts"
			, value: "0"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon" style="fill: rgba(255,255,0,1)"><use xlink:href="#svg_x5F_Alert2"></use></svg> if Camera Has New Alerts<div class="settingDesc">(see camera properties for per-camera setting)</div>'
			, hint: 'Icon shows if the camera has alerts newer than you have seen.'
			, onChange: OnChange_ui3_camera_overlay_icons
			, category: "Event-Triggered Icons"
		}
		, {
			key: "ui3_icons_extraVisibility"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Extra Visibility For Icons'
			, onChange: OnChange_ui3_icons_extraVisibility
			, category: "Event-Triggered Icons"
		}
		, {
			key: "ui3_comment_eventTriggeredSounds_Heading"
			, value: ""
			, inputType: "comment"
			, comment: GenerateEventTriggeredSoundsComment
			, category: "Event-Triggered Sounds"
		}
		, {
			key: "ui3_sound_motion"
			, value: "None"
			, inputType: "select"
			, options: []
			, getOptions: getBISoundOptions
			, alwaysRefreshOptions: true
			, label: 'Motion Detected'
			, onChange: function () { biSoundPlayer.PlayEvent("motion"); }
			, category: "Event-Triggered Sounds"
		}
		, {
			key: "ui3_sound_trigger"
			, value: "None"
			, inputType: "select"
			, options: []
			, getOptions: getBISoundOptions
			, alwaysRefreshOptions: true
			, label: 'Camera Triggered<div class="settingDesc">(before AI-verification)</div>'
			, onChange: function () { biSoundPlayer.PlayEvent("trigger"); }
			, category: "Event-Triggered Sounds"
		}
		, {
			key: "ui3_sound_alert"
			, value: "None"
			, inputType: "select"
			, options: []
			, getOptions: getBISoundOptions
			, alwaysRefreshOptions: true
			, label: 'Camera Alerting'
			, hint: "Occurs only after AI-verification, if AI is configured."
			, onChange: function () { biSoundPlayer.PlayEvent("alert"); }
			, category: "Event-Triggered Sounds"
		}
		, {
			key: "ui3_eventSoundVolume"
			, value: 100
			, minValue: 0
			, maxValue: 100
			, step: 1
			, unitLabel: "%"
			, inputType: "range"
			, label: 'Sound Effect Volume'
			, onChange: function () { biSoundPlayer.AdjustVolume(); }
			, changeOnStep: true
			, category: "Event-Triggered Sounds"
		}
		, {
			key: "ui3_comment_ptz_section"
			, value: ""
			, inputType: "comment"
			, comment: '<div class="ptzSectionComment">(Pan, Tilt, Zoom)</div>'
			, category: "PTZ"
		}
		, {
			key: "ui3_ptzPresetShowCount"
			, value: "20"
			, inputType: "select"
			, options: ["0", "10", "20", "30", "40"]
			, label: 'PTZ Preset Count'
			, onChange: OnChange_ui3_ptzPresetShowCount
			, category: "PTZ"
		}
		, {
			key: "ui3_swap_ptz_focus_buttons"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Swap PTZ Focus Near/Far<div class="settingDesc">(affects graphical PTZ pad layout)</div>'
			, hint: 'If NO, the "Focus Near" icon will be on the left. If YES, the "Focus Near" icon will be on the right.'
			, onChange: OnChange_ui3_swap_ptz_focus_buttons
			, category: "PTZ"
		}
		, {
			key: "ui3_ptzHome"
			, value: "0"
			, inputType: "checkbox"
			, label: 'PTZ Home Button'
			, onChange: OnChange_ui3_ptzHome
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_ptz_enabled"
			, value: "1"
			, inputType: "checkbox"
			, label: '<svg class="icon clipicon noflip"><use xlink:href="#svg_mio_gamepad"></use></svg> Enable Gamepad Controls'
			, hint: 'Enables gamepads and joysticks to be used for PTZ control'
			, onChange: OnChange_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_comment_ptz_gamepad_display"
			, value: ""
			, inputType: "comment"
			, comment: function ()
			{
				return '<div class="gamepadTestHeading">Gamepad Test</div>'
					+ '<div title="The combined inputs of all connected gamepads are shown here.">'
					+ getSvgIconToEmbed("ui3gamepad", "ui3gamepad_preview", "icon noflip")
					+ '</div>'
					+ '<div id="ui3gamepadTestOutput"><div>No gamepad activity detected yet ...</div></div>';
			}
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_analog_deadzone"
			, value: 0.2
			, minValue: 0.01
			, maxValue: 0.99
			, step: 0.01
			, inputType: "range"
			, label: 'Analog Input Deadzone'
			, hint: '(PTZ) Increase the deadzone if your joystick(s) or analog buttons show activity while not being touched.'
			, changeOnStep: true
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_comment_ptz_gamepad_bindings"
			, value: ""
			, inputType: "comment"
			, comment: '<div class="gamepadBindingsComment">Gamepad Bindings</div>'
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_pan_left"
			, value: "axis 0 -"
			, gamepad_binding: true
			, label: "Pan Left"
			, hint: "PTZ Pan Left"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_pan_left2"
			, value: "button 14"
			, gamepad_binding: true
			, label: "Pan Left (extra binding)"
			, hint: "PTZ Pan Left"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_pan_right"
			, value: "axis 0 +"
			, gamepad_binding: true
			, label: "Pan Right"
			, hint: "PTZ Pan Right"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_pan_right2"
			, value: "button 15"
			, gamepad_binding: true
			, label: "Pan Right (extra binding)"
			, hint: "PTZ Pan Right"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_tilt_up"
			, value: "axis 1 -"
			, gamepad_binding: true
			, label: "Tilt Up"
			, hint: "PTZ Tilt Up"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_tilt_up2"
			, value: "button 12"
			, gamepad_binding: true
			, label: "Tilt Up (extra binding)"
			, hint: "PTZ Tilt Up"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_tilt_down"
			, value: "axis 1 +"
			, gamepad_binding: true
			, label: "Tilt Down"
			, hint: "PTZ Tilt Down"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_tilt_down2"
			, value: "button 13"
			, gamepad_binding: true
			, label: "Tilt Down (extra binding)"
			, hint: "PTZ Tilt Down"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_zoom_out"
			, value: "button 0"
			, gamepad_binding: true
			, label: "Zoom Out"
			, hint: "PTZ Zoom Out"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_zoom_out2"
			, value: "button 6"
			, gamepad_binding: true
			, label: "Zoom Out (extra binding)"
			, hint: "PTZ Zoom Out"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_zoom_in"
			, value: "button 3"
			, gamepad_binding: true
			, label: "Zoom In"
			, hint: "PTZ Zoom In"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_zoom_in2"
			, value: "button 7"
			, gamepad_binding: true
			, label: "Zoom In (extra binding)"
			, hint: "PTZ Zoom In"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_focus_near"
			, value: "button 2"
			, gamepad_binding: true
			, label: "Focus Near"
			, hint: "PTZ Focus Near"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_focus_near2"
			, value: "unbound"
			, gamepad_binding: true
			, label: "Focus Near (extra binding)"
			, hint: "PTZ Focus Near"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_focus_far"
			, value: "button 1"
			, gamepad_binding: true
			, label: "Focus Far"
			, hint: "PTZ Focus Far"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_focus_far2"
			, value: "unbound"
			, gamepad_binding: true
			, label: "Focus Far (extra binding)"
			, hint: "PTZ Focus Far"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_previous_camera"
			, value: "unbound"
			, gamepad_binding: true
			, label: "Previous Camera"
			, hint: "Load the previous camera"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_next_camera"
			, value: "unbound"
			, gamepad_binding: true
			, label: "Next Camera"
			, hint: "Load the next camera"
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_gamepad_binding_restart_camera"
			, value: "unbound"
			, gamepad_binding: true
			, label: "Restart Camera"
			, hint: "Restart the currently selected camera instance in Blue Iris.  If a single live camera is not selected, this will merely restart the video stream (behavior subject to change)."
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_experimental_joystick_api"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Experimental Joystick API<div class="settingDesc">(enables variable-speed PTZ control via compatible gamepad devices)</div>'
			, hint: 'Enables gamepads and joysticks to be used for PTZ control'
			, onChange: OnChange_ui3_gamepad_ptz_enabled
			, preconditionFunc: Precondition_ui3_gamepad_ptz_enabled
			, category: "PTZ"
		}
		, {
			key: "ui3_comment_ptz_hotkeys"
			, value: ""
			, inputType: "comment"
			, comment: 'PTZ keyboard binds are in the Hotkeys section below.'
			, category: "PTZ"
		}
		, {
			key: "ui3_hotkey_maximizeVideoArea"
			, value: "1|0|0|192" // 192: tilde (~`)
			, hotkey: true
			, label: "Maximize Video Area"
			, hint: 'Shows or hides the left and top control bars. This can be triggered on page load via the URL parameter: &maximize=1'
			, actionDown: BI_Hotkey_MaximizeVideoArea
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_togglefullscreen"
			, value: "0|0|0|192" // 192: tilde (~`)
			, hotkey: true
			, label: "Full Screen Mode"
			, hint: "Toggles Full Screen Mode and shows or hides the left and top control bars according to UI defaults."
			, actionDown: BI_Hotkey_FullScreen
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_tab_live"
			, value: "0|0|0|112" // 112: F1
			, hotkey: true
			, label: "Load Tab: Live View"
			, hint: "Opens the Live View tab"
			, actionDown: BI_Hotkey_Load_Tab_Live
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_tab_clips"
			, value: "0|0|0|113" // 113: F2
			, hotkey: true
			, label: "Load Tab: Clips"
			, hint: "Opens the Clips tab"
			, actionDown: BI_Hotkey_Load_Tab_Clips
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_tab_timeline"
			, value: "0|0|0|114" // 114: F3
			, hotkey: true
			, label: "Load Tab: Timeline"
			, hint: "Opens the Timeline tab"
			, actionDown: BI_Hotkey_Load_Tab_Timeline
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_cameraLabels"
			, value: "1|0|0|76" // 76: L
			, hotkey: true
			, label: "Toggle UI3 Camera Labels"
			, actionDown: BI_Hotkey_Toggle_Camera_Labels
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_downloadframe"
			, value: "1|0|0|83" // 83: S
			, hotkey: true
			, label: "Download Frame"
			, actionDown: BI_Hotkey_DownloadFrame
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_toggleMute"
			, value: "1|0|0|77" // 77: M
			, hotkey: true
			, label: "Toggle Camera Mute"
			, actionDown: BI_Hotkey_ToggleMute
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_nextCamera"
			, value: "0|0|0|190" // 190: . (period)
			, hotkey: true
			, label: "Next Camera"
			, hint: "Manually cycles to the next camera when a camera is maximized."
			, actionDown: BI_Hotkey_NextCamera
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_prevCamera"
			, value: "0|0|0|188" // 188: , (comma)
			, hotkey: true
			, label: "Previous Camera"
			, hint: "Manually cycles to the previous camera when a camera is maximized."
			, actionDown: BI_Hotkey_PreviousCamera
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_nextGroup"
			, value: "1|0|1|190" // 190: CTRL + SHIFT + . (period)
			, hotkey: true
			, label: "Next Group"
			, hint: "Manually loads your next group or cycle stream."
			, actionDown: BI_Hotkey_NextGroup
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_prevGroup"
			, value: "1|0|1|188" // 188: CTRL + SHIFT + , (comma)
			, hotkey: true
			, label: "Previous Group"
			, hint: "Manually loads your previous group or cycle stream."
			, actionDown: BI_Hotkey_PreviousGroup
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_playpause"
			, value: "0|0|0|32" // 32: space
			, hotkey: true
			, label: "Play/Pause"
			, hint: "Plays or pauses the current recording."
			, actionDown: BI_Hotkey_PlayPause
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_delete"
			, value: "0|0|0|46" // 46: delete
			, hotkey: true
			, label: "Delete"
			, hint: "Deletes the current recording."
			, actionDown: BI_Hotkey_Delete
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_toggleReverse"
			, value: "0|0|0|8" // 8: backspace
			, hotkey: true
			, label: "Reverse Playback"
			, hint: "Toggles between Forward and Reverse playback."
			, actionDown: BI_Hotkey_ToggleReverse
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_newerClip"
			, value: "0|0|0|38" // 38: up arrow
			, hotkey: true
			, label: "Navigate Up One Clip"
			, hint: "Load the next clip, higher up in the list."
			, actionDown: BI_Hotkey_NextClip
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_olderClip"
			, value: "0|0|0|40" // 40: down arrow
			, hotkey: true
			, label: "Navigate Down One Clip"
			, hint: "Load the previous clip, lower down in the list."
			, actionDown: BI_Hotkey_PreviousClip
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_skipAhead"
			, value: "0|0|0|39" // 39: right arrow
			, hotkey: true
			, label: "Skip Ahead"
			, hint: "Skips ahead in the current recording by a configurable number of seconds."
			, actionDown: BI_Hotkey_SkipAhead
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_skipBack"
			, value: "0|0|0|37" // 37: left arrow
			, hotkey: true
			, label: "Skip Back"
			, hint: "Skips back in the current recording by a configurable number of seconds."
			, actionDown: BI_Hotkey_SkipBack
			, category: "Hotkeys"
		}
		, {
			key: "ui3_skipAmount"
			, value: 10
			, inputType: "number"
			, minValue: 0
			, maxValue: 9999
			, label: "Skip Time (seconds)"
			, hint: "[0.01-9999] (default: 10) \r\nNumber of seconds to skip forward and back when using hotkeys to skip."
			, onChange: OnChange_ui3_skipAmount
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_skipAhead1Frame"
			, value: "0|0|0|190" // 190: . (period)
			, hotkey: true
			, label: "Skip Ahead 1 Frame"
			, hint: "Skips ahead in the current recording by approximately one frame."
			, actionDown: BI_Hotkey_SkipAhead1Frame
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_skipBack1Frame"
			, value: "0|0|0|188" // 188: , (comma)
			, hotkey: true
			, label: "Skip Back 1 Frame"
			, hint: "Skips back in the current recording by approximately one frame."
			, actionDown: BI_Hotkey_SkipBack1Frame
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_playback_faster"
			, value: "0|0|0|221" // 221: ]
			, hotkey: true
			, label: "Playback Faster"
			, hint: "Increases clip playback speed"
			, actionDown: BI_Hotkey_PlaybackFaster
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_playback_slower"
			, value: "0|0|0|219" // 219: [
			, hotkey: true
			, label: "Playback Slower"
			, hint: "Decreases clip playback speed"
			, actionDown: BI_Hotkey_PlaybackSlower
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_close_clip"
			, value: "0|0|0|27" // 27: escape
			, hotkey: true
			, label: "Close Clip"
			, hint: "Closes the current clip."
			, actionDown: BI_Hotkey_CloseClip
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_close_camera"
			, value: "0|0|0|27" // 27: escape
			, hotkey: true
			, label: "Close Camera"
			, hint: "Closes the current live camera and returns to the group view."
			, actionDown: BI_Hotkey_CloseCamera
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_digitalZoomIn"
			, value: "0|0|1|187" // 187: =
			, hotkey: true
			, label: "Digital Zoom In"
			, hint: "This has the same function as rolling a mouse wheel one notch."
			, actionDown: BI_Hotkey_DigitalZoomIn
			, allowRepeatKey: true
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_digitalZoomOut"
			, value: "0|0|1|189" // : 189: -
			, hotkey: true
			, label: "Digital Zoom Out"
			, hint: "This has the same function as rolling a mouse wheel one notch."
			, actionDown: BI_Hotkey_DigitalZoomOut
			, allowRepeatKey: true
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_digitalPanUp"
			, value: "0|0|1|38" // 38: up arrow
			, hotkey: true
			, label: "Digital Pan Up"
			, hint: "If zoomed in with digital zoom, pans up."
			, actionDown: BI_Hotkey_DigitalPanUp
			, actionUp: BI_Hotkey_DigitalPanUp_Up
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_digitalPanDown"
			, value: "0|0|1|40" // 40: down arrow
			, hotkey: true
			, label: "Digital Pan Down"
			, hint: "If zoomed in with digital zoom, pans down."
			, actionDown: BI_Hotkey_DigitalPanDown
			, actionUp: BI_Hotkey_DigitalPanDown_Up
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_digitalPanLeft"
			, value: "0|0|1|37" // 37: left arrow
			, hotkey: true
			, label: "Digital Pan Left"
			, hint: "If zoomed in with digital zoom, pans left."
			, actionDown: BI_Hotkey_DigitalPanLeft
			, actionUp: BI_Hotkey_DigitalPanLeft_Up
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_digitalPanRight"
			, value: "0|0|1|39" // 39: right arrow
			, hotkey: true
			, label: "Digital Pan Right"
			, hint: "If zoomed in with digital zoom, pans right."
			, actionDown: BI_Hotkey_DigitalPanRight
			, actionUp: BI_Hotkey_DigitalPanRight_Up
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzUp"
			, value: "0|0|0|38" // 38: up arrow
			, hotkey: true
			, label: "PTZ Up"
			, hint: "If the current live camera is PTZ, moves the camera up."
			, actionDown: BI_Hotkey_PtzUp
			, actionUp: BI_Hotkey_PtzUp_Up
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzDown"
			, value: "0|0|0|40" // 40: down arrow
			, hotkey: true
			, label: "PTZ Down"
			, hint: "If the current live camera is PTZ, moves the camera down."
			, actionDown: BI_Hotkey_PtzDown
			, actionUp: BI_Hotkey_PtzDown_Up
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzLeft"
			, value: "0|0|0|37" // 37: left arrow
			, hotkey: true
			, label: "PTZ Left"
			, hint: "If the current live camera is PTZ, moves the camera left."
			, actionDown: BI_Hotkey_PtzLeft
			, actionUp: BI_Hotkey_PtzLeft_Up
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzRight"
			, value: "0|0|0|39" // 39: right arrow
			, hotkey: true
			, label: "PTZ Right"
			, hint: "If the current live camera is PTZ, moves the camera right."
			, actionDown: BI_Hotkey_PtzRight
			, actionUp: BI_Hotkey_PtzRight_Up
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzIn"
			, value: "0|0|0|187" // 187: =
			, hotkey: true
			, label: "PTZ Zoom In"
			, hint: "If the current live camera is PTZ, zooms the camera in."
			, actionDown: BI_Hotkey_PtzIn
			, actionUp: BI_Hotkey_PtzIn_Up
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzOut"
			, value: "0|0|0|189" // 189: -
			, hotkey: true
			, label: "PTZ Zoom Out"
			, hint: "If the current live camera is PTZ, zooms the camera out."
			, actionDown: BI_Hotkey_PtzOut
			, actionUp: BI_Hotkey_PtzOut_Up
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzFocusNear"
			, value: "0|0|0|219" // 219: [
			, hotkey: true
			, label: "PTZ Focus Near"
			, hint: "If the current live camera is PTZ, focuses the camera closer."
			, actionDown: BI_Hotkey_PtzFocusNear
			, actionUp: BI_Hotkey_PtzFocusNear_Up
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzFocusFar"
			, value: "0|0|0|221" // 221: ]
			, hotkey: true
			, label: "PTZ Focus Far"
			, hint: "If the current live camera is PTZ, focuses the camera further away."
			, actionDown: BI_Hotkey_PtzFocusFar
			, actionUp: BI_Hotkey_PtzFocusFar_Up
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset1"
			, value: "0|0|0|49" // 49: 1
			, hotkey: true
			, label: "Load Preset 1"
			, hint: "If the current live camera is PTZ, loads preset 1."
			, actionDown: function () { BI_Hotkey_PtzPreset(1); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset2"
			, value: "0|0|0|50" // 50: 2
			, hotkey: true
			, label: "Load Preset 2"
			, hint: "If the current live camera is PTZ, loads preset 2."
			, actionDown: function () { BI_Hotkey_PtzPreset(2); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset3"
			, value: "0|0|0|51" // 51: 3
			, hotkey: true
			, label: "Load Preset 3"
			, hint: "If the current live camera is PTZ, loads preset 3."
			, actionDown: function () { BI_Hotkey_PtzPreset(3); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset4"
			, value: "0|0|0|52" // 52: 4
			, hotkey: true
			, label: "Load Preset 4"
			, hint: "If the current live camera is PTZ, loads preset 4."
			, actionDown: function () { BI_Hotkey_PtzPreset(4); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset5"
			, value: "0|0|0|53" // 53: 5
			, hotkey: true
			, label: "Load Preset 5"
			, hint: "If the current live camera is PTZ, loads preset 5."
			, actionDown: function () { BI_Hotkey_PtzPreset(5); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset6"
			, value: "0|0|0|54" // 54: 6
			, hotkey: true
			, label: "Load Preset 6"
			, hint: "If the current live camera is PTZ, loads preset 6."
			, actionDown: function () { BI_Hotkey_PtzPreset(6); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset7"
			, value: "0|0|0|55" // 55: 7
			, hotkey: true
			, label: "Load Preset 7"
			, hint: "If the current live camera is PTZ, loads preset 7."
			, actionDown: function () { BI_Hotkey_PtzPreset(7); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset8"
			, value: "0|0|0|56" // 56: 8
			, hotkey: true
			, label: "Load Preset 8"
			, hint: "If the current live camera is PTZ, loads preset 8."
			, actionDown: function () { BI_Hotkey_PtzPreset(8); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset9"
			, value: "0|0|0|57" // 57: 9
			, hotkey: true
			, label: "Load Preset 9"
			, hint: "If the current live camera is PTZ, loads preset 9."
			, actionDown: function () { BI_Hotkey_PtzPreset(9); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset10"
			, value: "0|0|0|48" // 48: 0
			, hotkey: true
			, label: "Load Preset 10"
			, hint: "If the current live camera is PTZ, loads preset 10."
			, actionDown: function () { BI_Hotkey_PtzPreset(10); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset11"
			, value: "1|0|0|49" // 49: 1
			, hotkey: true
			, label: "Load Preset 11"
			, hint: "If the current live camera is PTZ, loads preset 11."
			, actionDown: function () { BI_Hotkey_PtzPreset(11); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset12"
			, value: "1|0|0|50" // 50: 2
			, hotkey: true
			, label: "Load Preset 12"
			, hint: "If the current live camera is PTZ, loads preset 12."
			, actionDown: function () { BI_Hotkey_PtzPreset(12); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset13"
			, value: "1|0|0|51" // 51: 3
			, hotkey: true
			, label: "Load Preset 13"
			, hint: "If the current live camera is PTZ, loads preset 13."
			, actionDown: function () { BI_Hotkey_PtzPreset(13); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset14"
			, value: "1|0|0|52" // 52: 4
			, hotkey: true
			, label: "Load Preset 14"
			, hint: "If the current live camera is PTZ, loads preset 14."
			, actionDown: function () { BI_Hotkey_PtzPreset(14); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset15"
			, value: "1|0|0|53" // 53: 5
			, hotkey: true
			, label: "Load Preset 15"
			, hint: "If the current live camera is PTZ, loads preset 15."
			, actionDown: function () { BI_Hotkey_PtzPreset(15); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset16"
			, value: "1|0|0|54" // 54: 6
			, hotkey: true
			, label: "Load Preset 16"
			, hint: "If the current live camera is PTZ, loads preset 16."
			, actionDown: function () { BI_Hotkey_PtzPreset(16); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset17"
			, value: "1|0|0|55" // 55: 7
			, hotkey: true
			, label: "Load Preset 17"
			, hint: "If the current live camera is PTZ, loads preset 17."
			, actionDown: function () { BI_Hotkey_PtzPreset(17); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset18"
			, value: "1|0|0|56" // 56: 8
			, hotkey: true
			, label: "Load Preset 18"
			, hint: "If the current live camera is PTZ, loads preset 18."
			, actionDown: function () { BI_Hotkey_PtzPreset(18); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset19"
			, value: "1|0|0|57" // 57: 9
			, hotkey: true
			, label: "Load Preset 19"
			, hint: "If the current live camera is PTZ, loads preset 19."
			, actionDown: function () { BI_Hotkey_PtzPreset(19); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset20"
			, value: "1|0|0|48" // 48: 0
			, hotkey: true
			, label: "Load Preset 20"
			, hint: "If the current live camera is PTZ, loads preset 20."
			, actionDown: function () { BI_Hotkey_PtzPreset(20); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset21"
			, value: "0|0|1|49" // 49: 1
			, hotkey: true
			, label: "Load Preset 21"
			, hint: "If the current live camera is PTZ, loads preset 1."
			, actionDown: function () { BI_Hotkey_PtzPreset(21); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset22"
			, value: "0|0|1|50" // 50: 2
			, hotkey: true
			, label: "Load Preset 22"
			, hint: "If the current live camera is PTZ, loads preset 22."
			, actionDown: function () { BI_Hotkey_PtzPreset(22); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset23"
			, value: "0|0|1|51" // 51: 3
			, hotkey: true
			, label: "Load Preset 23"
			, hint: "If the current live camera is PTZ, loads preset 23."
			, actionDown: function () { BI_Hotkey_PtzPreset(23); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset24"
			, value: "0|0|1|52" // 52: 4
			, hotkey: true
			, label: "Load Preset 24"
			, hint: "If the current live camera is PTZ, loads preset 24."
			, actionDown: function () { BI_Hotkey_PtzPreset(24); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset25"
			, value: "0|0|1|53" // 53: 5
			, hotkey: true
			, label: "Load Preset 25"
			, hint: "If the current live camera is PTZ, loads preset 25."
			, actionDown: function () { BI_Hotkey_PtzPreset(25); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset26"
			, value: "0|0|1|54" // 54: 6
			, hotkey: true
			, label: "Load Preset 26"
			, hint: "If the current live camera is PTZ, loads preset 26."
			, actionDown: function () { BI_Hotkey_PtzPreset(26); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset27"
			, value: "0|0|1|55" // 55: 7
			, hotkey: true
			, label: "Load Preset 27"
			, hint: "If the current live camera is PTZ, loads preset 27."
			, actionDown: function () { BI_Hotkey_PtzPreset(27); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset28"
			, value: "0|0|1|56" // 56: 8
			, hotkey: true
			, label: "Load Preset 28"
			, hint: "If the current live camera is PTZ, loads preset 28."
			, actionDown: function () { BI_Hotkey_PtzPreset(28); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset29"
			, value: "0|0|1|57" // 57: 9
			, hotkey: true
			, label: "Load Preset 29"
			, hint: "If the current live camera is PTZ, loads preset 29."
			, actionDown: function () { BI_Hotkey_PtzPreset(29); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset30"
			, value: "0|0|1|48" // 48: 0
			, hotkey: true
			, label: "Load Preset 30"
			, hint: "If the current live camera is PTZ, loads preset 30."
			, actionDown: function () { BI_Hotkey_PtzPreset(30); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset31"
			, value: "1|0|1|49" // 49: 1
			, hotkey: true
			, label: "Load Preset 31"
			, hint: "If the current live camera is PTZ, loads preset 31."
			, actionDown: function () { BI_Hotkey_PtzPreset(31); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset32"
			, value: "1|0|1|50" // 50: 2
			, hotkey: true
			, label: "Load Preset 32"
			, hint: "If the current live camera is PTZ, loads preset 32."
			, actionDown: function () { BI_Hotkey_PtzPreset(32); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset33"
			, value: "1|0|1|51" // 51: 3
			, hotkey: true
			, label: "Load Preset 33"
			, hint: "If the current live camera is PTZ, loads preset 33."
			, actionDown: function () { BI_Hotkey_PtzPreset(33); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset34"
			, value: "1|0|1|52" // 52: 4
			, hotkey: true
			, label: "Load Preset 34"
			, hint: "If the current live camera is PTZ, loads preset 34."
			, actionDown: function () { BI_Hotkey_PtzPreset(34); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset35"
			, value: "1|0|1|53" // 53: 5
			, hotkey: true
			, label: "Load Preset 35"
			, hint: "If the current live camera is PTZ, loads preset 35."
			, actionDown: function () { BI_Hotkey_PtzPreset(35); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset36"
			, value: "1|0|1|54" // 54: 6
			, hotkey: true
			, label: "Load Preset 36"
			, hint: "If the current live camera is PTZ, loads preset 36."
			, actionDown: function () { BI_Hotkey_PtzPreset(36); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset37"
			, value: "1|0|1|55" // 55: 7
			, hotkey: true
			, label: "Load Preset 37"
			, hint: "If the current live camera is PTZ, loads preset 37."
			, actionDown: function () { BI_Hotkey_PtzPreset(37); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset38"
			, value: "1|0|1|56" // 56: 8
			, hotkey: true
			, label: "Load Preset 38"
			, hint: "If the current live camera is PTZ, loads preset 38."
			, actionDown: function () { BI_Hotkey_PtzPreset(38); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset39"
			, value: "1|0|1|57" // 57: 9
			, hotkey: true
			, label: "Load Preset 39"
			, hint: "If the current live camera is PTZ, loads preset 39."
			, actionDown: function () { BI_Hotkey_PtzPreset(39); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_hotkey_ptzPreset40"
			, value: "1|0|1|48" // 48: 0
			, hotkey: true
			, label: "Load Preset 40"
			, hint: "If the current live camera is PTZ, loads preset 40."
			, actionDown: function () { BI_Hotkey_PtzPreset(40); }
			, category: "Hotkeys"
		}
		, {
			key: "ui3_cameraLabels_enabled"
			, value: "0"
			, inputType: "checkbox"
			, label: 'UI3 Camera Labels Enabled<div class="settingDesc"><br>Blue Iris provides its own camera name labels since version 5.5, so UI3\'s clientside labels are no longer recommended.<br><br>Toggle Blue Iris\'s labels using Blue Iris\'s "Edit Layout" functionality (See Blue Iris Help > Cameras > Camera Groups), or toggle the camera names via UI3 by right clicking a group video feed and choosing "Group Settings".</div>'
			, onChange: onui3_cameraLabelsChanged
			, category: "UI3 Camera Labels"
		}
		, {
			key: "ui3_cameraLabels_multiCameras"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Label multi-camera streams'
			, onChange: onui3_cameraLabelsChanged
			, category: "UI3 Camera Labels"
		}
		, {
			key: "ui3_cameraLabels_singleCameras"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Label single-camera streams'
			, onChange: onui3_cameraLabelsChanged
			, category: "UI3 Camera Labels"
		}
		, {
			key: "ui3_cameraLabels_text"
			, value: CameraLabelTextValues.Name
			, inputType: "select"
			, options: [CameraLabelTextValues.Name, CameraLabelTextValues.ShortName, CameraLabelTextValues.Both]
			, label: "Label Text"
			, onChange: onui3_cameraLabelsChanged
			, category: "UI3 Camera Labels"
		}
		, {
			key: "ui3_cameraLabels_position"
			, value: CameraLabelPositionValues.Top
			, inputType: "select"
			, options: [CameraLabelPositionValues.Above, CameraLabelPositionValues.Top, CameraLabelPositionValues.Bottom, CameraLabelPositionValues.Below]
			, label: "Label Position"
			, onChange: onui3_cameraLabelsChanged
			, category: "UI3 Camera Labels"
		}
		, {
			key: "ui3_cameraLabels_fontSize"
			, value: 10
			, inputType: "number"
			, minValue: 0
			, maxValue: 128
			, label: "Font Size"
			, onChange: onui3_cameraLabelsChanged
			, category: "UI3 Camera Labels"
		}
		, {
			key: "ui3_cameraLabels_minimumFontSize"
			, value: BI_GetDevicePixelRatio() > 1 ? 6 : 8
			, inputType: "number"
			, minValue: 0
			, maxValue: 128
			, label: "Min Font Size"
			, hint: "When a group view is rendered smaller than native resolution, font size is scaled down no smaller than this."
			, onChange: onui3_cameraLabelsChanged
			, category: "UI3 Camera Labels"
		}
		, {
			key: "ui3_cameraLabels_backgroundColor"
			, value: "#000000"
			, inputType: "color"
			, label: 'Background Color'
			, onChange: onui3_cameraLabelsChanged
			, category: "UI3 Camera Labels"
		}
		, {
			key: "ui3_cameraLabels_textColor"
			, value: "#FFFFFF"
			, inputType: "color"
			, label: 'Text Color'
			, onChange: onui3_cameraLabelsChanged
			, category: "UI3 Camera Labels"
		}
		, {
			key: "ui3_cameraLabels_cameraColor"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Use Camera Color<div class="settingDesc">(ignore colors set above)</div>'
			, onChange: onui3_cameraLabelsChanged
			, category: "UI3 Camera Labels"
		}
		, {
			key: "ui3_cameraLabels_backgroundOpacity"
			, value: 100
			, minValue: 0
			, maxValue: 100
			, step: 1
			, unitLabel: "%"
			, inputType: "range"
			, label: 'Background Opacity'
			, onChange: onui3_cameraLabelsChanged
			, changeOnStep: true
			, category: "UI3 Camera Labels"
		}
		, {
			key: "ui3_cameraLabels_textOpacity"
			, value: 100
			, minValue: 0
			, maxValue: 100
			, step: 1
			, unitLabel: "%"
			, inputType: "range"
			, label: 'Text Opacity'
			, onChange: onui3_cameraLabelsChanged
			, changeOnStep: true
			, category: "UI3 Camera Labels"
		}
		, {
			key: "ui3_wheelAdjustableSpeed"
			, value: 400
			, minValue: 20
			, maxValue: 2000
			, step: 1
			, inputType: "range"
			, label: 'Digital Zoom Speed'
			, changeOnStep: true
			, category: "Digital Zoom"
		}
		, {
			key: "ui3_wheelZoomReverse"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Reverse Mouse Wheel Zoom'
			, hint: "By default, UI3 follows the de-facto standard for mouse wheel zoom, where up zooms in."
			, category: "Digital Zoom"
		}
		, {
			key: "ui3_alwaysAllow1xVideoZoom"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Always Allow 1x Zoom<div class="settingDesc">(if "yes", small cameras can be rendered smaller than the viewport)</div>'
			, category: "Digital Zoom"
		}
		, {
			key: "ui3_browserZoomEnabled"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Browser Native Zoom<div class="settingDesc">(enabling this will disable ui3\'s video player touchscreen pinch and swipe handling)</div>'
			, onChange: OnChange_ui3_browserZoomEnabled
			, category: "Digital Zoom"
		}
		, {
			key: "ui3_comment_mqtt_learnmore"
			, value: ""
			, inputType: "comment"
			, comment: function () { return '<div style="text-align: center;"><a href="ui3/help/help.html' + currentServer.GetLocalSessionArg("?") + '#mqtt">Help Link: MQTT Remote Control</a></div>'; }
			, category: "MQTT Remote Control"
		}
		, {
			key: "ui3_mqttBrokerUrl"
			, value: ""
			, inputType: "text"
			, class: "column_reverse"
			, label: 'WebSocket URL to connect to MQTT broker<div class="settingDesc">(example: <code>ws://homeassistant.local:1884/</code>)</div>'
			, category: "MQTT Remote Control"
		}
		, {
			key: "ui3_mqttUser"
			, value: ""
			, inputType: "text"
			, label: 'MQTT User Name'
			, category: "MQTT Remote Control"
		}
		, {
			key: "ui3_mqttPass"
			, value: ""
			, inputType: "password"
			, label: 'MQTT Password'
			, category: "MQTT Remote Control"
		}
		, {
			key: "ui3_mqttInstanceId"
			, value: GetRandomMqttInstanceId
			, maxValue: 12
			, inputType: "text"
			, label: 'Instance ID<div class="settingDesc">(Uniquely identifies this UI3)</div>'
			, category: "MQTT Remote Control"
		}
		, {
			key: "ui3_mqttClientEnabled"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Enable MQTT Client<div class="settingDesc">(toggle to reconnect with new settings)</div>'
			, onChange: OnChange_ui3_mqttClientEnabled
			, category: "MQTT Remote Control"
		}
		, {
			key: "ui3_mqttStatusToasts"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Connection Status Messages'
			, hint: 'Disabling connection status messages does not suppress error messages related to the MQTT connection.'
			, category: "MQTT Remote Control"
		}
		, {
			key: "ui3_comment_mqtt_advanced"
			, value: ""
			, inputType: "comment"
			, comment: function ()
			{
				return 'The following are <b>advanced configuration</b> options, recommended only for MQTT experts. Please read the <a href="ui3/help/help.html'
					+ currentServer.GetLocalSessionArg("?") + '#mqtt">help file</a> to better-understand the function of each advanced option.</div>';
			}
			, category: "MQTT Remote Control"
		}
		, {
			key: "ui3_mqttSubscribeEnabled"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Subscribe to Topics'
			, hint: "Disabling this will disable inbound state synchronization with the MQTT broker. MQTT-triggered audio commands will not work."
			, category: "MQTT Remote Control"
		}
		, {
			key: "ui3_mqttSubscribeQOS"
			, value: 0
			, inputType: "number"
			, minValue: 0
			, maxValue: 2
			, label: 'Subscribe QOS'
			, hint: "The MQTT QOS value (0,1,2) that is sent when subscribing to topics."
			, category: "MQTT Remote Control"
		}
		, {
			key: "ui3_mqttPublishEnabled"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Publish to /state/ Topics'
			, hint: "Disabling this will disable outbound state synchronization with the MQTT broker."
			, category: "MQTT Remote Control"
		}
		, {
			key: "ui3_mqttPublishQOS"
			, value: 0
			, inputType: "number"
			, minValue: 0
			, maxValue: 2
			, label: 'Publish QOS'
			, hint: "The MQTT QOS value (0,1,2) that is sent when publishing to the /state/ topics."
			, category: "MQTT Remote Control"
		}
		, {
			key: "ui3_mqttPublishRetain"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Publish Retain'
			, hint: "If enabled, UI3 will set the Retain flag when publishing to the /state/ topics."
			, category: "MQTT Remote Control"
		}
		, {
			key: "ui3_mqttAudioEvents"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Audio/TTS Events'
			, hint: "If enabled, UI3 will subscribe to playaudio and playtts topics and may require user interaction to finish loading UI3."
			, category: "MQTT Remote Control"
		}
		, {
			key: "ui3_mqttToastEvents"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Toast Events'
			, hint: "If enabled, UI3 can be commanded to show toast messages via MQTT (see help file)."
			, category: "MQTT Remote Control"
		}
		, {
			key: "ui3_fullscreen_videoonly"
			, value: "1"
			, inputType: "checkbox"
			, label: 'Maximize Video in Full Screen Mode'
			, hint: 'If "yes", toggling Full Screen mode automatically toggles the video player\'s maximize state.'
			, onChange: OnChange_ui3_fullscreen_videoonly
			, category: "Extra"
		}
		, {
			key: "ui3_show_maximize_button"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Always Show Maximize Button<div class="settingDesc">by Full Screen button</div>'
			, hint: 'If "no", the Maximize button only appears while the video player is maximized, to allow you to un-maximize.'
			, onChange: OnChange_ui3_show_maximize_button
			, category: "Extra"
		}
		, {
			key: "ui3_is_maximized"
			, value: "0"
		}
		, {
			key: "ui3_ir_brightness_contrast"
			, value: "0"
			, inputType: "checkbox"
			, label: 'IR, Brightness, Contrast Controls<br><a href="javascript:UIHelp.LearnMore(\'IR Brightness Contrast\')">(learn more)</a>'
			, onChange: OnChange_ui3_ir_brightness_contrast
			, category: "Extra"
		}
		, {
			key: "ui3_show_cameras_in_group_dropdowns"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Show Cameras in Group Dropdowns'
			, hint: 'If enabled, the "Current Group" and "Filter by" dropdown lists will include individual cameras.'
			, onChange: OnChange_ui3_show_cameras_in_group_dropdowns
			, category: "Extra"
		}
		, {
			key: "ui3_show_session_success"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Show Session Status at Startup'
			, hint: 'If enabled, session status is shown in the lower-right corner when the UI loads.'
			, category: "Extra"
		}
		, {
			key: "ui3_bypass_single_camera_groups"
			, value: "0"
			, inputType: "checkbox"
			, label: 'Bypass Single-Camera Groups<div class="settingDesc">(enable this if you have trouble with PTZ controls; disable this if you want to configure a group with only one visible camera)</div>'
			, onChange: OnChange_ui3_bypass_single_camera_groups
			, category: "Extra"
		}
		, {
			key: "ui3_contextMenus_trigger"
			, value: "Right-Click"
			, options: ["Right-Click", "Long-Press", "Double-Click"]
			, inputType: "select"
			, label: 'Context Menu Trigger<br><a href="javascript:UIHelp.LearnMore(\'Context Menu Trigger\')">(learn more)</a>'
			, onChange: OnChange_ui3_contextMenus_trigger
			, category: "Extra"
		}
	];
var ui3CamSettingsDefaults = [
	{
		key: "overlay_icon_new_alerts"
		, value: "0"
		, inputType: "checkbox"
		, label: 'Overlay icon <svg class="icon clipicon" style="fill: rgba(255,255,0,1)"><use xlink:href="#svg_x5F_Alert2"></use></svg><div class="settingDesc">if Camera Has New Alerts</div>'
		, onChange: OnChange_ui3_camera_overlay_icons
	}
];
var obsoleteSettings = { ui3_openFirstRecording: true, ui3_contextMenus_longPress: true };

/**
 * Overrides a default setting. This method is intended to be called by the ui3_local_overrides.js file.
 */
function OverrideDefaultSetting(key, value, IncludeInOptionsWindow, AlwaysReload, Generation)
{
	if (obsoleteSettings[key])
		return;
	for (var i = 0; i < defaultSettings.length; i++)
		if (defaultSettings[i].key === key)
		{
			defaultSettings[i].value = value;
			defaultSettings[i].AlwaysReload = AlwaysReload;
			defaultSettings[i].Generation = Generation;
			defaultSettings[i].IncludeInOptionsWindow = IncludeInOptionsWindow;
			break;
		}
}
function LoadDefaultSettings()
{
	if (settings == null) // This null check allows local overrides to replace the settings object.
		settings = SetupStorageSniffing(GetLocalStorageWrapper());
	for (var i = 0; i < defaultSettings.length; i++)
	{
		if (settings.getItem(defaultSettings[i].key) == null
			|| defaultSettings[i].AlwaysReload
			|| IsNewGeneration(defaultSettings[i].key, defaultSettings[i].Generation))
		{
			if (typeof defaultSettings[i].value === 'function')
				settings.setItem(defaultSettings[i].key, defaultSettings[i].value());
			else
				settings.setItem(defaultSettings[i].key, defaultSettings[i].value);
		}
	}
}
function RevertSettingsToDefault()
{
	for (var i = 0; i < defaultSettings.length; i++)
		settings.setItem(defaultSettings[i].key, defaultSettings[i].value);
}
/**
 * Returns the localStorage object, or a dummy localStorage object if the localStorage object is not available.
 * This method should be used only when the wrapped localStorage object is not desired (e.g. when using settings that are persisted globally, not specific to a Blue Iris server).
 */
function GetLocalStorage()
{
	if (isLocalStorageEnabled())
		return localStorage;
	return GetDummyLocalStorage();
}
function IsNewGeneration(key, gen)
{
	if (typeof gen == "undefined" || gen == null)
		return false;

	gen = parseInt(gen);
	var currentGen = settings.getItem("ui3_gen_" + key);
	if (currentGen == null)
		currentGen = 0;
	else
		currentGen = parseInt(currentGen);

	var isNewGen = gen > currentGen;
	if (isNewGen)
		settings.setItem("ui3_gen_" + key, gen);
	return isNewGen;
}
/**
 * Returns the local storage object or a wrapper suitable for the current Blue Iris server. The result of this should be stored in the settings variable.
 */
function GetLocalStorageWrapper()
{
	if (isLocalStorageEnabled())
	{
		if (currentServer.isUsingRemoteServer)
		{
			if (typeof Object.defineProperty == "function")
				return GetRemoteServerLocalStorage();
			else
			{
				toaster.Error("Your browser is not compatible with Object.defineProperty which is necessary to use remote servers.", 10000);
				SetRemoteServer("");
				return GetLocalStorage();
			}
		}
		else
			return GetLocalStorage();
	}
	return GetDummyLocalStorage();
}
function GetRemoteServerLocalStorage()
{
	var serverNamePrefix = currentServer.remoteServerName.toLowerCase().replace(/ /g, '_') + "_";

	var myLocalStorage = GetLocalStorage();
	var wrappedStorage = new Object();
	wrappedStorage.getItem = function (key)
	{
		return myLocalStorage[serverNamePrefix + key];
	};
	wrappedStorage.setItem = function (key, value)
	{
		return (myLocalStorage[serverNamePrefix + key] = value);
	};
	AttachDefaultSettingsProperties(wrappedStorage);
	return wrappedStorage;
}
var localStorageDummy = null;
function GetDummyLocalStorage()
{
	if (localStorageDummy === null)
	{
		var dummy = new Object();
		dummy.getItem = function (key)
		{
			return dummy[key];
		};
		dummy.setItem = function (key, value)
		{
			return (dummy[key] = value);
		};
		localStorageDummy = dummy;
	}
	return localStorageDummy;
}
function SetupStorageSniffing(storageObj)
{
	if (typeof Object.defineProperty === "function")
	{
		var isInvokingChangedEvent = {};
		var storageWrapper = new Object();
		storageWrapper.getItem = function (key)
		{
			return storageObj.getItem(key);
		};
		storageWrapper.setItem = function (key, value)
		{
			if (isInvokingChangedEvent[key])
				storageObj.setItem(key, value);
			else
			{
				var oldValue = storageObj.getItem(key);
				storageObj.setItem(key, value);
				isInvokingChangedEvent[key] = true;
				BI_CustomEvent.Invoke("SettingChanged", { key: key, value: value, oldValue: oldValue });
				isInvokingChangedEvent[key] = false;
			}
		};
		AttachDefaultSettingsProperties(storageWrapper);
		return storageWrapper;
	}
	else
	{
		console.log('The custom event "SettingChanged" requires Object.defineProperty which is not available.');
		return storageObj;
	}
}
function AttachDefaultSettingsProperties(storageWrapper)
{
	if (typeof Object.defineProperty !== "function")
		return;
	for (var i = 0; i < defaultSettings.length; i++)
	{
		var tmp = function (key)
		{
			Object.defineProperty(storageWrapper, key,
				{
					get: function ()
					{
						return storageWrapper.getItem(key);
					},
					set: function (value)
					{
						return storageWrapper.setItem(key, value);
					}
				});
		}(defaultSettings[i].key);
	}
}
///////////////////////////////////////////////////////////////
// UI Loading /////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
/** This is set to true when the synchronous loading function has completed, but typically before async stuff has finished loading. */
var ui3_loading_ended = false;
// Load svg before document.ready, to give it a head-start.
$.ajax({
	url: "ui3/icons.svg?v=" + combined_version + local_bi_session_arg,
	dataType: "html",
	cache: true,
	success: function (data)
	{
		$("#svgContainer").html(data);
		loadingHelper.SetLoadedStatus("svg");

		BI_CustomEvent.Invoke("svgLoaded");
	},
	error: function (jqXHR, textStatus, errorThrown)
	{
		loadingHelper.SetErrorStatus("svg", 'Error trying to load icons.svg<br/>Response: ' + jqXHR.status + ' ' + jqXHR.statusText + '<br>Status: ' + textStatus + '<br>Error: ' + errorThrown, true);
	}
});
$(function ()
{
	BI_CustomEvent.Invoke("UI_Loading_Start");

	if (cacheBust)
		toaster.Info("Cache-busting is enabled");

	$DialogDefaults.theme = "dark";
	SimpleDialog.onErrorDefault = toaster.Error;

	if (location.protocol == "file:")
	{
		var fileSystemErrorMessage = "This interface must be loaded through the Blue Iris web server, and cannot function when loaded directly from your filesystem.";
		alert(fileSystemErrorMessage);
		toaster.Error(fileSystemErrorMessage, 60000);
		return;
	}

	if (!isLocalStorageEnabled())
	{
		toaster.Warning("Local Storage is disabled or unavailable in your browser. Settings will not be saved between sessions.", 10000);
	}

	$("#ui_version_label").text(ui_version);
	$("#bi_version_label").text(bi_version);

	LoadDefaultSettings();

	try
	{
		if (isLocalStorageEnabled())
		{
			if (typeof localStorage.ui3_recordings_flagged_only !== "undefined")
				delete localStorage.ui3_recordings_flagged_only;
			if (typeof localStorage.ui3_contextMenus_longPress !== "undefined")
			{
				if (localStorage.ui3_contextMenus_longPress === "1" && settings.ui3_contextMenus_trigger === "Right-Click")
					settings.ui3_contextMenus_trigger = "Long-Press"; // one-time transition
				delete localStorage.ui3_contextMenus_longPress;
			}
			if (typeof localStorage.ui3_openFirstRecording !== "undefined")
			{
				if (localStorage.ui3_openFirstRecording === "1")
					settings.ui3_openARecording = "First"; // one-time transition
				delete localStorage.ui3_openFirstRecording;
			}
			if (typeof localStorage.ui3_time24hour_migrated === "undefined")
			{
				if (localeUses24HourTime())
					settings.ui3_time24hour = "1";
				localStorage.ui3_time24hour_migrated = "1";
			}
			if (typeof localStorage.ui3_html5_migration === "undefined")
			{
				if (typeof localStorage.ui3_h264_choice2 !== "undefined")
				{
					// UI3-177 transitions Firefox users from JavaScript to the new FF default of HTML5.
					// For all other users, this one-time setting migration preserves their previous preference.
					var isFFwithJS = BrowserIsFirefox() && localStorage.ui3_h264_choice2 === H264PlayerOptions.JavaScript;
					if (!isFFwithJS)
						localStorage.ui3_h264_choice3 = localStorage.ui3_h264_choice2;
					delete localStorage.ui3_h264_choice2;
				}
				localStorage.ui3_html5_migration = "1";
			}
			if (typeof localStorage.ui3_h264_choice3 !== "undefined")
			{
				// UI3-189 sets a new default of Automatic, but transitions the old setting if it is not HTML5 or WebCodecs.
				if (localStorage.ui3_h264_choice3 !== H264PlayerOptions.HTML5 && localStorage.ui3_h264_choice3 !== H264PlayerOptions.WebCodecs)
					settings.ui3_h264_choice4 = localStorage.ui3_h264_choice3;
				delete localStorage.ui3_h264_choice3;
			}
			if (typeof localStorage.ui3_maxDynamicGroupImageDimension !== "undefined")
			{
				// UI3-280 specifies dynamic group max resolution as a megapixel count, no longer a rectangle dimension limit.
				var d = parseFloat(localStorage.ui3_maxDynamicGroupImageDimension);
				if (d && !isNaN(d))
				{
					console.log("Migrating Dynamic Group Max Resolution setting to new style (UI3-280).");
					settings.ui3_maxDynamicGroupImageMegapixels = Math.ceil(d * d / 100000) / 10; // Round up to nearest tenth.
				}
				delete localStorage.ui3_maxDynamicGroupImageDimension;
			}
		}
	}
	catch (e)
	{
		console.log("Error migrating settings", e);
	}

	if (fetch_streams_cant_close_bug && settings.ui3_edge_fetch_bug_h264_enable !== "1")
		any_h264_playback_supported = h264_js_player_supported = mse_mp4_h264_supported = pnacl_player_supported = webcodecs_h264_player_supported = false; // Affects Edge 17.x, 18.x, and possibly newer versions.

	HandlePreLoadUrlParameters();

	statusAreaApi = new StatusAreaApi();

	new Vue({ el: "#layoutleft" }); // Activates any nested vue components in #layoutleft. This INVALIDATES any previously created DOM element references within #layoutleft, so it needs to happen early.

	biSoundPlayer.TestUserInputRequirement();

	currentPrimaryTab = ValidateTabName(settings.ui3_defaultTab);

	setSystemNameButtonTextState();
	setSystemNameButtonState();

	relativePTZ = new RelativePTZ();

	ptzButtons = new PtzButtons();

	gamepadPtzController = new GamepadPtzController();

	if (!any_h264_playback_supported)
		loadingHelper.SetLoadedStatus("h264"); // We aren't going to load the player, so clear the loading step.

	$("#layoutleftLiveScrollable").CustomScroll(
		{
			changeMarginRightToScrollBarWidth: false
			, trackClass: 'layoutleft-track'
			, handleClass: 'layoutleft-track-handle'
		});
	$("#clipsbody").CustomScroll(
		{
			changeMarginRightToScrollBarWidth: false
			, trackClass: 'layoutleft-track'
			, handleClass: 'layoutleft-track-handle'
		});
	$("#layoutleftExportScrollable").CustomScroll(
		{
			changeMarginRightToScrollBarWidth: false
			, trackClass: 'layoutleft-track'
			, handleClass: 'layoutleft-track-handle'
		});
	$(".topbar_tab").click(function ()
	{
		var $ele = $(this);
		var tabName = $ele.attr("name");
		if (!developerMode && sessionManager && !sessionManager.HasPermission_Clips() && tabName !== "live")
		{
			console.log("Session does not have permission to use " + tabName + ". Switching to live tab.");
			$("#topbar_tab_live").click();
			return;
		}
		SetClipListShortcutIconState("#open_all_clips_btn", false);
		SetClipListShortcutIconState("#open_alerts_btn", false);
		SetClipListShortcutIconState("#open_alerts_canceled_btn", false);
		SetClipListShortcutIconState("#open_alerts_confirmed_btn", false);

		$(".topbar_tab").removeClass("selected");
		$ele.addClass("selected");

		currentPrimaryTab = settings.ui3_defaultTab = tabName;

		clipExportPanel.Abort();

		if (currentPrimaryTab == "live")
		{
			$("#layoutleftLive").show();
			$("#layoutleftRecordings").hide();
			$("#layoutbottomTimeline").hide();
			$("body").removeClass("tabTimeline");
			if (videoPlayer && videoPlayer.Loading().image.isTimeline())
				videoPlayer.goLive();
		}
		else if (currentPrimaryTab == "clips")
		{
			$("#layoutleftLive").hide();
			$("#layoutleftRecordings").show();
			$("#layoutbottomTimeline").hide();
			$("body").removeClass("tabTimeline");
			$("#recordingsFilterByHeading").text("Filter by:");
			if (videoPlayer && videoPlayer.Loading().image.isTimeline())
				videoPlayer.goLive();
		}
		else if (currentPrimaryTab == "timeline")
		{
			$("#layoutleftLive").hide();
			$("#layoutleftRecordings").hide();
			$("#layoutbottomTimeline").show();
			$("body").addClass("tabTimeline");
		}

		if (!skipLoadingAllVideoStreams && !skipLoadingFirstVideoStream && (settings.ui3_openARecording === "First" || settings.ui3_openARecording === "Last"))
			clipLoader.OpenARecordingAfterNextClipListLoad();

		BI_CustomEvent.Invoke("TabLoaded_" + currentPrimaryTab);

		resized();
		UpdateCurrentURL();
	});
	BI_CustomEvent.AddListener("TabLoaded_live", function () { videoPlayer.goLive(); });
	BI_CustomEvent.AddListener("TabLoaded_clips", function () { clipLoader.LoadClips(); });

	ui3CamSettings = new UI3CamSettings();

	clipboardHelper = new ClipboardHelper();

	uiSizeHelper = new UiSizeHelper();

	uiSettingsPanel = new UISettingsPanel();

	pcmPlayer = new PcmAudioPlayer();

	diskUsageGUI = new DiskUsageGUI();

	serverControl = new ServerControl();

	cameraListDialog = new CameraListDialog();

	exportListDialog = new ExportListDialog;

	clipProperties = new ClipProperties();

	clipDownloadDialog = new ClipDownloadDialog();

	volumeSlider = new VolumeSlider();
	pcmPlayer.SetAudioVolumeFromSettings();

	dropdownBoxes = new DropdownBoxes();

	leftBarBools = new LeftBarBooleans();

	cornerStatusIcons = new CornerStatusIcons();

	serverTimeLimiter = new ServerTimeLimiter();

	liveVideoPausing = new LiveVideoPausing();

	genericQualityHelper = new GenericQualityHelper();

	streamingProfileUI = new StreamingProfileUI();

	SetupCollapsibleTriggers();

	exportControls = new ExportControls();

	clipExportPanel = new ClipExportPanel();

	exportAPIStatusDialog = new ExportAPIStatusDialog();

	seekBar = new SeekBar();

	playbackHeader = new PlaybackHeader();

	playbackControls = new PlaybackControls();

	clipTimeline = new ClipTimeline();

	hotkeys = new BI_Hotkeys();

	dateFilter = new DateFilter("#dateRangeLabel");

	clipFilterSearch = new ClipFilterSearch();

	hlsPlayer = new HLSPlayer();

	fullScreenModeController = new FullScreenModeController();

	maximizedModeController = new MaximizedModeController();

	canvasContextMenu = new CanvasContextMenu();

	calendarContextMenu = new CalendarContextMenu();

	openAlertListButtonContextMenu = new OpenAlertListButtonContextMenu();

	clipListContextMenu = new ClipListContextMenu();

	cameraConfig = new CameraConfig();

	keepScreenAlive = new KeepScreenAlive();

	videoPlayer = new VideoPlayerController();
	videoPlayer.PreLoadPlayerModules();

	imageRenderer = new ImageRenderer();

	cameraNameLabels = new CameraNameLabels();

	statusLoader = new StatusLoader();

	sessionManager = new SessionManager();

	mediaSessionController = new MediaSessionController();

	pictureInPictureController = new PictureInPictureController();

	cameraListLoader = new CameraListLoader();

	clipLoader = new ClipLoader("#clipsbody");

	clipThumbnailVideoPreview = new ClipThumbnailVideoPreview_BruteForce();

	nerdStats = new UI3NerdStats();

	sessionTimeout = new SessionTimeout();

	clipOverlayCfg = new ClipOverlayCfg();

	groupCfg = new GroupCfg();

	programmaticSoundPlayer = new ProgrammaticSoundPlayer();

	sidebarResizeBar = new SidebarResizeBar();

	mqttClient = new MqttClient();

	togglableContextMenus = new Array();
	for (var i = 0; i < togglableUIFeatures.length; i++)
	{
		var item = togglableUIFeatures[i];
		if (item.length < 4)
			continue;
		if (item.length < 5)
			item.push(null);
		if (item.length < 6)
			item.push(null);
		if (item.length < 7)
			item.push(["Enable", "Disable", "Toggle"]);
		else if (item[6].length != 3)
			item[6] = ["Enable", "Disable", "Toggle"];

		togglableContextMenus.push(new ContextMenu_EnableDisableItem(item[0], item[1], item[2], item[3], item[4], item[5], item[6]));
	}

	OnChange_ui3_color_theme();
	OnChange_ui3_time24hour();
	OnChange_ui3_topbar_save_snapshot_btn_show();
	OnChange_ui3_topbar_allclips_shortcut_show();
	OnChange_ui3_topbar_alerts_shortcut_show();
	OnChange_ui3_topbar_alerts_confirmed_shortcut_show();
	OnChange_ui3_topbar_alerts_canceled_shortcut_show();
	OnChange_ui3_skipAmount();
	OnChange_ui3_pc_next_prev_buttons();
	OnChange_ui3_pc_seek_buttons();
	OnChange_ui3_pc_seek_1frame_buttons();
	OnChange_ui3_pc_delete_button();
	OnChange_ui3_extra_playback_controls_padding();
	OnChange_ui3_ir_brightness_contrast();
	OnChange_ui3_ptzHome();
	OnChange_ui3_video_loading_overlay();
	OnChange_ui3_video_loading_animation();
	OnChange_ui3_sideBarPosition();
	OnChange_ui3_browserZoomEnabled();
	OnChange_ui3_showClipListFilterSearch();

	// This makes it impossible to text-select or drag certain UI elements.
	makeUnselectable($("#layouttop, #layoutleft, #layoutdivider, #layoutbody"));

	sessionManager.Initialize();

	$(window).resize(resized);
	$('.topbar_tab[name="' + currentPrimaryTab + '"]').click(); // this calls resized()

	window.addEventListener("beforeunload", function ()
	{
		if (isReloadingUi3)
		{
			settings.bi_lastunload = 0;
			console.log('UI3 is reloading. Automatic login will not be suppressed.');
		}
		else if (tabVisibleStopwatch.Elapsed() < 2000)
		{
			settings.bi_lastunload = 0;
			console.log('UI3 is unloading after being active for less than 2 seconds. Automatic login will not be suppressed.');
		}
		else
		{
			settings.bi_lastunload = Date.now();
			console.log('UI3 is unloading after being active for more than 2 seconds. Automatic login will be suppressed for the next 5 seconds.');
		}
	});

	ui3_loading_ended = true;
	BI_CustomEvent.Invoke("UI_Loading_End");
});
function OnChange_ui3_dynamicGroupLayout()
{
	videoPlayer.ReopenStreamAtCurrentSeekPosition();
}
function ValidateTabName(tabName)
{
	if (tabName === "alerts")
	{
		settings.ui3_current_dbView = "alerts";
		return "clips";
	}
	if (tabName === "live" || tabName === "clips" || tabName === "timeline")
		return tabName;
	return "live";
}
function SetupCollapsibleTriggers()
{
	$(".collapsibleTrigger,.serverStatusLabel").each(function (idx, ele)
	{
		var $ele = $(ele);
		var collapsibleid = $ele.attr('collapsibleid');
		if (collapsibleid && collapsibleid.length > 0 && settings.getItem("ui3_collapsible_" + collapsibleid) != "1")
			$ele.next().hide();
		if ($ele.next().is(":visible"))
			$ele.removeClass("collapsed");
		else
			$ele.addClass("collapsed");
		$ele.click(function (e)
		{
			$ele.next().slideToggle({
				duration: 100
				, complete: function ()
				{
					var vis = $ele.next().is(":visible");
					if (vis)
						$ele.removeClass("collapsed");
					else
						$ele.addClass("collapsed");
					if (collapsibleid && collapsibleid.length > 0)
						settings.setItem("ui3_collapsible_" + collapsibleid, vis ? "1" : "0");
					if ($ele.hasClass("serverStatusLabel") || $ele.attr("id") == "recordingsFilterByHeading")
						resized();
				}
			});
		});
		if (!$ele.hasClass("serverStatusLabel"))
			$ele.prepend('<svg class="icon collapsibleTriggerIcon"><use xlink:href="#svg_x5F_PTZcardinalDown"></use></svg>');
	});
}
///////////////////////////////////////////////////////////////
// Reload Interface ///////////////////////////////////////////
///////////////////////////////////////////////////////////////
function ReloadInterface()
{
	isReloadingUi3 = true;
	location.reload();
}
///////////////////////////////////////////////////////////////
// Incoming URL Parameters ////////////////////////////////////
///////////////////////////////////////////////////////////////
var skipLoadingFirstVideoStream = false;
var skipLoadingAllVideoStreams = false;
var startupTimelineMs = null;
var startupPaused = false;
var startupClipFilterSearch = null;
var startupClipFilterBeginDate = null;
var startupClipFilterEndDate = null;
function HandlePreLoadUrlParameters()
{
	// Parameter "developerMode"
	var devModeParam = UrlParameters.Get("developerMode")
	if (devModeParam === "1")
		developerMode = true;
	else if (devModeParam === "0")
		developerMode = false;

	// Parameter "tab"
	var tab = UrlParameters.Get("tab", "t");
	if (tab !== '')
	{
		if (tab.toUpperCase() === "L")
			tab = "live";
		if (tab.toUpperCase() === "C")
			tab = "clips";
		if (tab.toUpperCase() === "T")
			tab = "timeline";
		settings.ui3_defaultTab = tab;
	}

	// Parameter "clipview"
	var clipview = UrlParameters.Get("clipview", "v");
	if (clipview !== '')
		settings.ui3_current_dbView = clipview;

	// Parameter "clipsearch"
	startupClipFilterSearch = UrlParameters.Get("clipsearch", "cs");

	// Parameters "datestart", "dateend"
	var dateStart = UrlParameters.Get("datestart", "ds");
	var dateEnd = UrlParameters.Get("dateend", "de");
	if (dateStart)
		startupClipFilterBeginDate = getDateFromDateArgument(dateStart);
	if (dateEnd)
		startupClipFilterEndDate = getDateFromDateArgument(dateEnd);

	// Parameter "group"
	var group = UrlParameters.Get("group", "g");
	if (group !== '')
	{
		settings.ui3_defaultCameraGroupId = group;
		BI_CustomEvent.AddListener("FinishedLoading", function ()
		{
			if (!mqttClient.preLoadVideoSpecified)
			{
				var camData = cameraListLoader.GetCameraWithId(group);
				if (camData != null && videoPlayer.Loading().image.id !== group)
					videoPlayer.SelectCameraGroup(group);
			}
		});
	}

	// Parameter "cam" is handled in the LoadCameraList method

	var maximize = UrlParameters.Get("maximize", "m");
	if (maximize === "1" || maximize.toLowerCase() === "true")
		settings.ui3_is_maximized = "1";
	else if (maximize === "0" || maximize.toLowerCase() === "false")
		settings.ui3_is_maximized = "0";

	// Parameter "rec", e.g. "12345" or "12345-5000"
	var recId = UrlParameters.Get("rec", "r");
	if (recId !== '')
	{
		// Get Offset
		var offset = 0;
		var idxHyphen = recId.lastIndexOf('-');
		if (idxHyphen > 0)
		{
			offset = parseInt(recId.substr(idxHyphen + 1));
			if (isNaN(offset))
				offset = 0;
			recId = recId.substr(0, idxHyphen);
		}
		recId = ltrim(recId, "@");
		if (!recId.startsWith("@"))
			recId = "@" + recId;
		settings.ui3_defaultTab = "clips";
		StartupClipOpener(recId, offset);
	}
	else
	{
		$("#loadingStartupClip").parent().hide();
		loadingHelper.SetLoadedStatus("startupClip");
	}

	// Parameter "timeline", value is a millisecond timestamp
	var timelineMsStr = UrlParameters.Get("timeline", "tl");
	if (timelineMsStr !== '')
	{
		var timelineMs = ParseTimelineStartStr(timelineMsStr);
		if (!isNaN(timelineMs))
		{
			settings.ui3_defaultTab = "timeline";
			skipLoadingAllVideoStreams = true;
			startupTimelineMs = timelineMs;
			developerLog('"timeline"/"tl" URL parameter received value: ' + timelineMs);
		}
		else
			console.log('"timeline"/"tl" URL parameter received invalid value: ' + UrlParameters.Get("timeline", "tl"));
	}
	else
	{
		$("#loadingStartupClip").parent().hide();
		loadingHelper.SetLoadedStatus("startupClip");
	}

	// Parameter "streamingprofile"
	var streamingprofile = UrlParameters.Get("streamingprofile", "p");
	if (streamingprofile !== '')
		settings.ui3_streamingQuality = streamingprofile;

	// Parameter "timeout"
	var timeoutParam = UrlParameters.Get("timeout", "to");
	if (timeoutParam !== '')
	{
		var timeoutInt = parseInt(timeoutParam);
		if (!isNaN(timeoutInt) && timeoutInt >= 0 && timeoutInt <= 525600)
			settings.ui3_timeout = timeoutInt;
		else
			console.log('"timeout"/"to" URL parameter received invalid value: ' + timeoutParam);
	}

	// Parameter "pause"
	var pauseParam = UrlParameters.Get("pause");
	if (pauseParam === "1" || maximize.toLowerCase() === "true")
		startupPaused = true;
}
function ParseTimelineStartStr(str)
{
	var timelineMs = parseInt(str);
	if (isNaN(timelineMs) || (timelineMs > 0 && timelineMs < 60000))
		timelineMs = Date.parse(str.toString().replace('_', ' '));
	return timelineMs;
}
function StartupClipOpener(recId, offset)
{
	function Initialize()
	{
		skipLoadingFirstVideoStream = true;
		BI_CustomEvent.AddListener("Login Success", onSessionReady);
	}
	function onSessionReady()
	{
		BI_CustomEvent.RemoveListener("Login Success", onSessionReady);
		clipStatsLoader.LoadClipStats(recId, null, false, function (stats)
		{
			if (!stats)
				toaster.Warning("The recording specified in the URL could not be opened.");
			else
			{
				if (offset && offset > 0)
				{
					if (offset > stats.msec || stats.msec - offset < 100)
						offset = 0;
					stats.offset = offset;
				}
			}
			loadingHelper.SetLoadedStatus("startupClip");

			if (!loadingHelper.DidLoadingFinish())
			{
				BI_CustomEvent.AddListener("FinishedLoading", function ()
				{
					OpenClipFromStats(stats);
				});
			}
			else
				OpenClipFromStats(stats);
		});
	}
	Initialize();
}
///////////////////////////////////////////////////////////////
// UI Resize //////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function resized()
{
	HandleSidebarVisibilityChange();

	var windowW = $(window).width();
	var windowH = $(window).height();
	var sideBarRight = settings.ui3_sideBarPosition === "Right";
	var portrait = uiSizeHelper.UsePortraitLayout(windowW, windowH);
	uiSizeHelper.SetPortraitLayout(portrait);

	// Adjust UI style presets based on window size
	uiSizeHelper.SetMostAppropriateSize(windowW, windowH);

	// Learn some sizes
	var layouttop = $("#layouttop");
	var layoutsidebar = $("#layoutleft");
	var layoutbody = $("#layoutbody");
	var layoutbottom = $("#layoutbottom");
	InitSavedBounds(layoutbody);
	InitSavedBounds(layoutbottom);
	var el_layoutbody = layoutbody.get(0);
	var el_layoutbottom = layoutbottom.get(0);
	var statusArea = $("#statusArea");
	var llrControls = $("#layoutLeftRecordingsControls");
	var camimg_loading_anim = $("#camimg_loading_anim,#camimg_false_loading_anim");
	var videoCenter_Icons = $("#camimg_playIcon,#camimg_pauseIcon");
	var videoCenter_Bg = $("#camimg_centerIconBackground");

	var topVis = layouttop.is(":visible");
	var sidebarVis = layoutsidebar.is(":visible");
	var statusAreaVis = statusArea.is(":visible");
	var botVis = layoutbottom.is(":visible");

	var topH = topVis ? layouttop.height() : 0;
	var botH = botVis ? layoutbottom.height() : 0;
	var sidebarH = sidebarVis ? (windowH - topH) : 0;
	var sidebarW = sidebarVis ? layoutsidebar.width() : 0;
	var statusH = statusAreaVis ? statusArea.outerHeight(true) : 0;
	// layouttop is sized with flexbox since UI3-269

	// Size layoutsidebar
	var sidebarT = topH;
	var $dragBar = $("#sidebarPortraitDragbar");
	var dragBarH = 0;
	if (settings.ui3_is_maximized !== "1")
	{
		if (currentPrimaryTab == "timeline")
		{
			if (portrait)
				sidebarH = statusH;
			else
				sidebarH = botH;
			sidebarT = windowH - sidebarH;
			$dragBar.hide();
		}
		else if (sidebarVis)
		{
			if (portrait)
			{
				sidebarH = Math.round(sidebarResizeBar.getSidebarSize() * (windowH - topH - botH));
				sidebarT = windowH - sidebarH;
				$dragBar.show();
				dragBarH = $dragBar.height();
			}
			else
				$dragBar.hide();
		}
	}
	layoutsidebar.css("top", sidebarT + "px");
	layoutsidebar.css("height", sidebarH + "px");

	if (currentPrimaryTab == "live")
	{
		$("#layoutleftLiveScrollableWrapper").css("height", sidebarH - statusH - dragBarH + "px");
		var $layoutleftLiveContent = $("#layoutleftLiveContent");
		var sidebarStuff = $layoutleftLiveContent.children();
		if (portrait)
		{
			$layoutleftLiveContent.css("column-width", uiSizeHelper.GetPreferredSidebarSize() + "px");
			sidebarStuff.css("width", uiSizeHelper.GetPreferredSidebarSize() + "px");
			sidebarStuff.css("margin", "0px auto");
		}
		else
		{
			$layoutleftLiveContent.css("column-width", "");
			sidebarStuff.css("width", "");
			sidebarStuff.css("margin", "");
		}
	}
	else if (currentPrimaryTab == "clips")
	{
		var llrControlsH = llrControls.outerHeight(true);
		if (portrait)
		{
			var topDateH = $("#clipListTopDate").outerHeight(true);
			$("#clipsbodyWrapper").css("height", (sidebarH - statusH - dragBarH - topDateH) + "px");
			$("#clipsbodyWrapper").css("top", topDateH + "px");
			uiSizeHelper.setDynCSS(".portrait .cliptile, .portrait .datetile { width: " + ((windowW / 2) - 30) + "px }\n"
				+ ".sizeMedium.portrait .cliptile, .sizeMedium.portrait .datetile { width: " + ((windowW / 2) - 15) + "px }\n"
				+ ".sizeSmall.portrait .cliptile, .sizeSmall.portrait .datetile { width: " + ((windowW / 2) - 14) + "px }");
		}
		else
		{
			$("#clipsbodyWrapper").css("height", sidebarH - statusH - dragBarH - llrControlsH + "px");
			$("#clipsbodyWrapper").css("top", "");
		}
		$("#layoutleftExportScrollableWrapper").css("height", sidebarH - statusH - dragBarH + "px");
	}

	var statusArea_margins = statusArea.outerWidth(true) - statusArea.width();
	statusArea.css("width", (sidebarW - statusArea_margins) + "px");

	// Size layoutbody
	var bodyL = (portrait || sideBarRight || currentPrimaryTab == "timeline") ? 0 : sidebarW;
	var bodyT = topH;
	var bodyW = windowW;
	var bodyH = windowH - topH - botH;
	if (portrait)
		bodyH -= sidebarH;
	else if (currentPrimaryTab != "timeline")
		bodyW -= sidebarW;
	layoutbody.css("top", bodyT + "px");
	layoutbody.css("left", bodyL + "px");
	layoutbody.css("width", bodyW + "px");
	layoutbody.css("height", bodyH + "px");
	el_layoutbody.savedBounds = { x: bodyL, y: bodyT, w: bodyW, h: bodyH };

	// Size camimg_loading_anim
	var camimg_loading_anim_Size = Clamp(Math.min(bodyW, bodyH), 10, 120);
	camimg_loading_anim.css("top", ((bodyH - camimg_loading_anim_Size) / 2) + "px");
	camimg_loading_anim.css("left", ((bodyW - camimg_loading_anim_Size) / 2) + "px");
	camimg_loading_anim.css("width", camimg_loading_anim_Size + "px");
	camimg_loading_anim.css("height", camimg_loading_anim_Size + "px");

	// Size videoCenter_Bg
	var videoCenter_Bg_Size = Clamp(Math.min(bodyW, bodyH), 10, 72);
	videoCenter_Bg.css("top", ((bodyH - videoCenter_Bg_Size) / 2) + "px");
	videoCenter_Bg.css("left", ((bodyW - videoCenter_Bg_Size) / 2) + "px");
	videoCenter_Bg.css("width", videoCenter_Bg_Size + "px");
	videoCenter_Bg.css("height", videoCenter_Bg_Size + "px");

	// Size videoCenter_Icons
	var videoCenter_Icon_Size = Clamp(Math.min(bodyW, bodyH), 10, 40);
	videoCenter_Icons.css("top", ((bodyH - videoCenter_Icon_Size) / 2) + "px");
	videoCenter_Icons.css("left", ((bodyW - videoCenter_Icon_Size) / 2) + "px");
	videoCenter_Icons.css("width", videoCenter_Icon_Size + "px");
	videoCenter_Icons.css("height", videoCenter_Icon_Size + "px");

	playbackControls.resized();

	playbackHeader.resized();

	// Size layoutbottom
	if (portrait)
	{
		layoutbottom.css("width", windowW + "px");
		el_layoutbottom.savedBounds.w = windowW;
		layoutbottom.css("left", "0px");
		el_layoutbottom.savedBounds.x = 0;
		layoutbottom.css("bottom", windowH - sidebarT + "px");
	}
	else
	{
		layoutbottom.css("width", windowW - sidebarW + "px");
		el_layoutbottom.savedBounds.w = windowW - sidebarW;
		if (sideBarRight)
		{
			layoutbottom.css("left", "0px");
			el_layoutbottom.savedBounds.x = 0;
		}
		else
		{
			layoutbottom.css("left", sidebarW + "px");
			el_layoutbottom.savedBounds.x = sidebarW;
		}
		layoutbottom.css("bottom", "0px");
	}
	el_layoutbottom.savedBounds.h = botH;
	el_layoutbottom.savedBounds.y = layoutbottom.offset().top;

	// Size misc items
	imageRenderer.ImgResized(false);

	dropdownBoxes.Resized();

	// Call other methods to notify that resizing is done
	clipLoader.resizeClipList();
	$.CustomScroll.callMeOnContainerResize();
	BI_CustomEvent.Invoke("afterResize");
}
function InitSavedBounds($el)
{
	var el = $el.get(0);
	if (el && !el.savedBounds)
	{
		var o = $el.offset();
		el.savedBounds = { w: $el.width(), h: $el.height(), x: o ? o.left : 0, y: o ? o.top : 0 };
	}
}
function UiSizeHelper()
{
	var self = this;
	var largeMinH = 1042; // 1075
	var mediumMinH = 786; // 815
	var largeMinW = 670;// 550 575 1160;
	var mediumMinW = 540;// 450 515 900;
	var smallMinW = 350;//680;
	var largeSidebarSize = 256;
	var mediumSidebarSize = 196;
	var smallSidebarSize = 146;
	var currentSize = "unset";
	var autoSize = true;

	this.setDynCSS = InjectStyleBlock(""); // For dynamic clip tile sizing

	this.SetMostAppropriateSize = function (availableWidth, availableHeight)
	{
		if (autoSize)
		{
			if (availableWidth < smallMinW)
				SetSize("smaller");
			else if (availableHeight < mediumMinH || availableWidth < mediumMinW)
				SetSize("small");
			else if (availableHeight < largeMinH || availableWidth < largeMinW)
				SetSize("medium");
			else
				SetSize("large");
		}
	}
	var SetSize = function (size)
	{
		if (currentSize == size)
			return;
		currentSize = size;
		var $roots = $('body');
		$roots.removeClass("sizeSmaller sizeSmall sizeMedium sizeLarge");
		if (size == "smaller")
			$roots.addClass("sizeSmall sizeSmaller");
		else if (size == "small")
			$roots.addClass("sizeSmall");
		else if (size == "medium")
			$roots.addClass("sizeMedium");
		else
			$roots.addClass("sizeLarge");
	}
	this.GetCurrentSize = function ()
	{
		return currentSize;
	}
	this.GetPreferredSidebarSize = function ()
	{
		if (currentSize === "smaller" || currentSize === "small")
			return smallSidebarSize;
		if (currentSize === "medium")
			return mediumSidebarSize;
		return largeSidebarSize;
	}
	this.SetUISizeByName = function (size)
	{
		if (size)
			size = size.toLowerCase();
		autoSize = size == "auto";
		if (!autoSize)
			SetSize(size);
		resized();
	}
	this.UsePortraitLayout = function (windowWidth, windowHeight)
	{
		if (settings.ui3_portrait_layout === "Yes")
			return true;
		else if (settings.ui3_portrait_layout === "No")
			return false;
		else
			return (windowWidth / windowHeight < (5 / 6) || (windowWidth < windowHeight && windowWidth < 440));
	}
	this.SetPortraitLayout = function (portrait)
	{
		var $roots = $('body');
		if (portrait)
		{
			$roots.addClass("portrait");
			$roots.removeClass("landscape");
		}
		else
		{
			$roots.removeClass("portrait");
			$roots.addClass("landscape");
		}
	}

	SetSize(settings.ui3_preferred_ui_scale);

	setTimeout(function () { self.SetUISizeByName(settings.ui3_preferred_ui_scale); }, 0);
}
function HandleSidebarVisibilityChange()
{
	var showSidebar = false;
	var showSidebarHiddenButton = false;
	var showStatusArea = false;

	if ((currentPrimaryTab === "live" && settings.ui3_sidebar_visible_on_live === "0")
		|| (currentPrimaryTab === "clips" && settings.ui3_sidebar_visible_on_clips === "0"))
	{
		showSidebar = false;
		if (settings.ui3_show_sidebar_hidden_button === "1")
			showSidebarHiddenButton = true;
		else
			showSidebarHiddenButton = false;
	}
	else
	{
		showSidebar = true;
		showSidebarHiddenButton = false;
	}

	if ((currentPrimaryTab === "live" && settings.ui3_status_area_show === "0")
		|| (currentPrimaryTab === "clips" && settings.ui3_status_area_show_clips === "0")
		|| (currentPrimaryTab === "timeline" && settings.ui3_status_area_show_timeline === "0"))
	{
		showStatusArea = false;
		if (currentPrimaryTab === "timeline")
			showSidebar = false;
	}
	else
	{
		showStatusArea = true;
		if (currentPrimaryTab === "timeline")
			showSidebar = true;
	}

	if (showSidebar)
		$('#layoutleft').removeClass('disabledBySetting');
	else
		$('#layoutleft').addClass('disabledBySetting');

	if (showSidebarHiddenButton)
		$("#sidebar_hidden_button").addClass('visible');
	else
		$("#sidebar_hidden_button").removeClass('visible');

	if (showStatusArea)
		$("#statusArea").removeClass('disabledBySetting');
	else
		$("#statusArea").addClass('disabledBySetting');
}
///////////////////////////////////////////////////////////////
// Portrait Layout Sidebar Resize Bar /////////////////////////
///////////////////////////////////////////////////////////////
function SidebarResizeBar()
{
	var self = this;
	var resizeState = { dragging: false, startY: 0, startSize: 0 };
	var layouttop = $("#layouttop");
	var layoutbottom = $("#layoutbottom");
	var layoutsidebar = $("#layoutleft");
	var statusArea = $("#statusArea");
	var $dragBar = $("#sidebarPortraitDragbar");
	var resizedThrottled = throttle(resized, 33.333);

	$(document).on('mouseup touchend', function (e)
	{
		mouseCoordFixer.fix(e);
		resizeState.dragging = false;
	});
	$(document).on("touchcancel", function (e)
	{
		if (resizeState.dragging)
		{
			resizeState.dragging = false;
			self.setSidebarSize(resizeState.startSize);
			resized();
		}
	});
	$(document).on('mousemove touchmove', function (e)
	{
		mouseCoordFixer.fix(e);

		if (resizeState.dragging)
		{
			var dy = (resizeState.startY - e.mouseY) / availableHeight();
			self.setSidebarSize(resizeState.startSize + dy);
			resizedThrottled();
		}
	});
	$dragBar.on("mousedown touchstart", function (e)
	{
		mouseCoordFixer.fix(e);
		if (e.which === 0 || e.which === 1)
		{
			resizeState.startY = e.mouseY;
			resizeState.startSize = clampSidebarSize(layoutsidebar.height() / availableHeight());
			resizeState.dragging = true;
		}
	});
	this.setSidebarSize = function (size)
	{
		settings.ui3_portraitSidebarSize = clampSidebarSize(size);
	}
	function availableHeight()
	{
		return $(window).height() - layouttop.height() - layoutbottom.height();
	}
	function clampSidebarSize(size)
	{
		var min = ($dragBar.height() + statusArea.height() + 30) / $(window).height();
		return Clamp(parseFloat(size), min, 0.9)
	}
	this.getSidebarSize = function (defaultSize)
	{
		return clampSidebarSize(settings.ui3_portraitSidebarSize);
	}
}
///////////////////////////////////////////////////////////////
// Status Area and Volume control /////////////////////////////
///////////////////////////////////////////////////////////////
/**
 * Manages the volume slider control.  Based on the old StatusBars class.
 */
function VolumeSlider()
{
	var self = this;

	var $ele = $("#volumeBarCtrl");
	var pb = $('<div></div>');
	$ele.append(pb);
	ProgressBar.initialize(pb);

	ProgressBar.addDragHandle(pb, function (newValue) { self.setPosition(newValue) });

	ProgressBar.addOnProgressChangedListener(pb, function (newVolume)
	{
		newVolume = Clamp(parseFloat(newVolume), 0, 1);
		if (!pcmPlayer.SuppressAudioVolumeSave())
		{
			settings.ui3_audioMute = "0";
			settings.ui3_audioVolume = newVolume;
		}
		pcmPlayer.SetVolume(newVolume);
	});

	$ele.find('.statusBarLabel').on('click', CameraAudioMuteToggle);

	this.setPosition = function (progressAmount)
	{
		ProgressBar.setProgress(pb, progressAmount);
	};
	this.setEnabled = function (enabled)
	{
		ProgressBar.setEnabled(pb, enabled);
	};
}
var ProgressBar =
{
	initialize: function ($ele)
	{
		if ($ele.children().length == 0)
		{
			var ele = $ele.get(0);
			ele.$progressBarInner = $('<div class="progressBarInner"></div>');
			$ele.append(ele.$progressBarInner);
			$ele.addClass("progressBarOuter");
			ele.defaultColor = ele.$progressBarInner.css("background-color");
		}
	}
	, setProgress: function ($ele, progressAmount)
	{
		var ele = $ele.get(0);
		progressAmount = Clamp(progressAmount, 0, 1);
		var changed = typeof ele.pbValue == "undefined" || ele.pbValue != progressAmount;
		ele.pbValue = progressAmount;
		if (changed)
			ele.$progressBarInner.css("width", (progressAmount * 100) + "%");
		if (typeof ele.moveDragHandleElements == "function")
			ele.moveDragHandleElements();
		if (changed && typeof ele.onProgressChanged == "function")
			ele.onProgressChanged(progressAmount);
	}
	, addDragHandle: function ($ele, onDrag)
	{
		$ele.addClass("withDragHandle");
		var ele = $ele.get(0);
		ele.$dragHandle = $('<div class="statusBarDragHandle"><div class="statusBarDragHandleInner"></div></div>');
		$ele.prepend(ele.$dragHandle);

		ele.onDragHandleDragged = function (mouseX)
		{
			var relX = mouseX - $ele.offset().left;
			var progressPercentage = Clamp(relX / $ele.width(), 0, 1);
			onDrag(progressPercentage);
		};
		ele.moveDragHandleElements = function ()
		{
			ele.$dragHandle.css("left", (ele.pbValue * $ele.width()) - (ele.$dragHandle.width() / 2) + "px");
		};
		ele.moveDragHandleElements();
		BI_CustomEvent.AddListener("afterResize", ele.moveDragHandleElements);

		// Set up input events
		$ele.on("mousedown touchstart", function (e)
		{
			mouseCoordFixer.fix(e);
			if (e.which != 3)
			{
				if ($ele.hasClass("disabled"))
					return;
				ele.isDragging = true;
				ele.onDragHandleDragged(e.mouseX);
			}
		});
		$(document).on("mouseup touchend touchcancel", function (e)
		{
			mouseCoordFixer.fix(e);
			ele.isDragging = false;
		});
		$(document).on("mousemove touchmove", function (e)
		{
			mouseCoordFixer.fix(e);
			if (ele.isDragging)
				ele.onDragHandleDragged(e.mouseX);
		});
	}
	, addOnProgressChangedListener: function ($ele, onProgressChanged)
	{
		$ele.get(0).onProgressChanged = onProgressChanged;
	}
	, setEnabled: function ($ele, enabled)
	{
		if (enabled)
			$ele.removeClass("disabled");
		else
			$ele.addClass("disabled");
	}
};
///////////////////////////////////////////////////////////////
// Status Area ////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function StatusAreaApi()
{
	var self = this;
	var tmpStoplightEnabled = true;
	var tmpStoplightSignal = -1;
	/** [statusAreaComponent] is set when the 'status-area' vue component is created, which is triggered later in the loading routine. */
	var statusAreaComponent = null;
	/** Merged with statusAreaComponent.reactiveStatusBarRegistry after the vue component is created. */
	var statusBarRegistry = {};

	/**
	 * Register a status bar that the user will be able to choose via UI Settings > Status Area.
	 * @param {String} uniqueName Unique name of the status bar, displayed in UI Settings and used when getting/setting values.
	 * @param {String} componentName Vue component name.  If not provided, a generic component will be used that requires the value to be a floating point percentage between 0.0 and 1.0.
	 * @param {Object} defaultValue An object that is a suitable default value for the status bar.
	 */
	this.setStatusBarRegistration = function (uniqueName, componentName, initialValue)
	{
		if (statusAreaComponent)
		{
			console.log("statusAreaApi.setStatusBarRegistration should be called only during the `StatusArea_Loading` event.");
			statusAreaComponent.setStatusBarRegistration(uniqueName, componentName, initialValue)
		}
		else
			statusBarRegistry[uniqueName] = { uniqueName: uniqueName, componentName: componentName, value: initialValue };
	}

	this.setStatusBarRegistration("Server CPU", "status-bar-cpu", 0.0);
	this.setStatusBarRegistration("Server Memory", "status-bar-mem", { bi: 0, memPhys: 1024, load: 0.0 });
	this.setStatusBarRegistration("Server Disk", "status-bar-disk", { fullness: 0.0, tooltip: "", error: false });
	this.setStatusBarRegistration("Server Uptime", "status-area-uptime", { uptime: "unknown" });
	this.setStatusBarRegistration("Stream FPS", "status-bar-fps", { fps: 0, maxFps: 10 });
	this.setStatusBarRegistration("Stream Bit Rate", "status-bar-stream-bit-rate", { video: 0, audio: 0 });
	this.setStatusBarRegistration("Stream Delay", "status-bar-stream-delay", { netDelay: 0, playerDelay: 0 });
	this.setStatusBarRegistration("Audio Buffer", "status-bar-audio-buffer", 0);

	this.getStatusBarRegistration = function (uniqueName)
	{
		return statusBarRegistry[uniqueName];
	}

	this.getStatusBarRegistrations = function ()
	{
		var arr = new Array();
		for (var key in statusBarRegistry)
			arr.push(statusBarRegistry[key]);
		return arr;
	}

	this.setValue = function (uniqueName, value)
	{
		var r = statusBarRegistry[uniqueName];
		if (r)
			r.value = value;
		else
			toaster.Error('statusAreaApi.setValue failed. Unrecognized status bar "' + uniqueName + '"');
	}

	this.getValue = function (uniqueName)
	{
		var r = statusBarRegistry[uniqueName];
		if (r)
			return r.value;
		else
		{
			toaster.Error('statusAreaApi.getValue failed. Unrecognized status bar "' + uniqueName + '"');
			return null;
		}
	}

	this.setStoplightEnabled = function (enabled)
	{
		tmpStoplightEnabled = enabled;
		if (statusAreaComponent)
			statusAreaComponent.setStoplightEnabled(enabled);
	}

	this.setStoplightSignal = function (signal)
	{
		tmpStoplightSignal = signal;
		if (statusAreaComponent)
			statusAreaComponent.setStoplightSignal(signal);
	}

	/**
	 * Returns the status-area vue component instance. Use with caution.
	 */
	this.getStatusAreaComponent = function ()
	{
		return statusAreaComponent;
	}

	this.loadUserSettings = function ()
	{
		if (statusAreaComponent)
			statusAreaComponent.loadUserSettings();
		else
			toaster.Error("StatusArea.loadUserSettings failed. statusAreaComponent has not been created yet.");
	}

	Vue.component('status-area', {
		template: ''
			+ '<div id="statusArea">'
			+ ' <stoplight-button :enabled="stoplightEnabled" :signal="stoplightSignal"></stoplight-button>'
			+ '	<div class="serverStatusLabel" collapsibleid="serverStatus" ref="serverStatusLabel">'
			+ '' + '{{panelName}}'
			+ '' + '<div class="serverStatusSmallIcon">'
			+ '			<component v-for="(b, index) in displayableStatusBars" :key="index" v-bind:is="b.componentName" :tiny="true" :value="b.value"></component>'
			+ '		</div>'
			+ '	</div>'
			+ '	<div class="statusBarsMain">'
			+ '		<component v-for="(b, index) in displayableStatusBars" :key="index" v-bind:is="b.componentName" :genericLabel="b.uniqueName" :value="b.value"></component>'
			+ '	</div>'
			+ '</div>',
		data: function ()
		{
			return {
				panelName: "Server Status",
				reactiveStatusBarRegistry: {},
				userChosenBarNames: [],
				stoplightEnabled: false,
				stoplightSignal: -1
			};
		},
		created: function ()
		{
			for (var key in statusBarRegistry)
			{
				var b = statusBarRegistry[key];
				this.setStatusBarRegistration(b.uniqueName, b.componentName, b.value);
			}
			statusBarRegistry = this.reactiveStatusBarRegistry;
			this.loadUserSettings();
			this.stoplightEnabled = tmpStoplightEnabled;
			this.stoplightSignal = tmpStoplightSignal;

			statusAreaComponent = this;
		},
		mounted: function ()
		{
			var optionStatusArea =
			{
				alias: "cmroot_statusarea", width: 200, items:
					[
						{
							text: 'Configure Status Area', icon: "#svg_x5F_Settings", alias: "configure",
							action: function () { uiSettingsPanel.open("Status Area"); }
						}
					]
				, clickType: GetPreferredContextMenuTrigger()
			};
			$(this.$refs.serverStatusLabel).contextmenu(optionStatusArea);
		},
		computed:
		{
			displayableStatusBars: function ()
			{
				var bars = [];
				if (this.reactiveStatusBarRegistry)
				{
					for (var i = 0; i < this.userChosenBarNames.length; i++)
					{
						var uniqueName = this.userChosenBarNames[i];
						var bar = null;
						if (uniqueName)
							bar = this.reactiveStatusBarRegistry[uniqueName];
						if (!bar)
							bar = this.reactiveStatusBarRegistry["Server CPU"];
						bars.push(bar);
					}
				}
				return bars;
			}
		},
		methods:
		{
			setValue: function (uniqueName, value)
			{
				var b = this.reactiveStatusBarRegistry[uniqueName]
				if (b)
					b.value = value;
				else
					toaster.Error('Attempted to set status bar value for unrecognized status bar "' + uniqueName + '"');
			},
			getValue: function (uniqueName)
			{
				var b = this.reactiveStatusBarRegistry[uniqueName];
				if (b)
					return b.value;
				toaster.Error('Attempted to get status bar value for unrecognized status bar "' + uniqueName + '"');
				return null;
			},
			setStatusBarRegistration: function (uniqueName, componentName, value)
			{
				if (!Vue.options.components[componentName])
				{
					console.log("statusAreaApi registration \"" + uniqueName + "\" has an invalid component name \"" + componentName + "\".  The \"status-bar-generic\" component will be substituted.");
					componentName = "status-bar-generic";
				}
				var b = this.reactiveStatusBarRegistry[uniqueName]
				if (b)
				{
					b.componentName = componentName;
					b.value = value;
				}
				else
					this.reactiveStatusBarRegistry[uniqueName] = Vue.observable({
						uniqueName: uniqueName,
						componentName: componentName,
						value: value
					});
			},
			loadUserSettings: function ()
			{
				this.panelName = settings.ui3_status_area_name;

				this.userChosenBarNames = [];
				for (var i = 1; i <= 4; i++)
				{
					var uniqueName = settings.getItem("ui3_status_area_bar_key_" + i);
					this.userChosenBarNames.push(uniqueName);
				}
			},
			setStoplightEnabled: function (enabled)
			{
				this.stoplightEnabled = enabled;
			},
			setStoplightSignal: function (signal)
			{
				this.stoplightSignal = signal;
			}
		}
	});

	Vue.component('status-bar', {
		template: ''
			+ '<div :class="{ statusBar: true, clickableStatusBar: clickable && !tiny, statusTiny: tiny, textOnly: textOnly }" :title="tooltipText" @click="onClick">'
			+ '<div class="statusBarLabel" v-if="!tiny">{{ label ? label : \'\' }}</div>'
			+ '<div :class="{ progressBarOuter: 1, zeroWidth: textOnly && !tiny }"><div class="progressBarInner" :style="myStyle"></div></div>'
			+ '<div class="statusBarAmount" v-if="!tiny">{{ textDisplayValue }}</div>'
			+ '</div>',
		props:
		{
			label: String,
			percent: Number,
			color: String,
			textValue: String,
			tooltipText: String,
			clickable: Boolean,
			tiny: Boolean,
			textOnly: {
				type: Boolean,
				default: false
			}
		},
		computed:
		{
			myStyle: function ()
			{
				var s = {};
				s.width = Clamp(this.percent * 100, 0, 100) + "%";
				if (this.color)
					s.backgroundColor = this.color;
				return s;
			},
			textDisplayValue: function ()
			{
				if (this.textValue)
				{
					if (this.textOnly)
						return this.textValue;
					else
						return this.textValue.substr(0, 4);
				}
				return "";
			}
		},
		methods:
		{
			onClick: function (e)
			{
				if (!this.tiny)
					this.$emit("click", e);
			}
		}
	});

	Vue.component('status-bar-generic', {
		template: ''
			+ '<status-bar :tiny="tiny" :label="genericLabel" :percent="value" :textValue="textValue"></status-bar>',
		props:
		{
			genericLabel: { type: String, default: "ERR" },
			value: Object,
			tiny: { type: Boolean, default: false }
		},
		computed:
		{
			label: function ()
			{
				if (!this.genericLabel)
					return "ERR";
				return this.genericLabel.toUpperCase();
			},
			textValue: function ()
			{
				return Math.round(this.value * 100) + "%";
			}
		}
	});

	Vue.component('status-bar-cpu', {
		template: ''
			+ '<status-bar :tiny="tiny" label="CPU" :percent="value" :color="color" :textValue="textValue" :tooltipText="tooltipText"></status-bar>',
		props:
		{
			value: { type: Number, default: 0.0 },
			tiny: { type: Boolean, default: false }
		},
		computed:
		{
			color: function ()
			{
				if (this.value < 0.7)
					return null;
				else if (this.value < 0.8)
					return "#CCCC00";
				else if (this.value < 0.87)
					return "#CCAA00";
				else if (this.value < 0.95)
					return "#CC3300";
				else
					return "#CC0000";
			},
			textValue: function ()
			{
				return Math.round(this.value * 100) + "%";
			},
			tooltipText: function ()
			{
				return "Total CPU usage on server: " + Math.round(this.value * 100) + "%";
			}
		}
	});

	Vue.component('status-bar-mem', {
		template: ''
			+ '<status-bar :tiny="tiny" label="MEM" :percent="value.load" :color="color" :textValue="textValue" :tooltipText="tooltipText"></status-bar>',
		props:
		{
			value: { type: Object, default: function () { return { bi: 0, memPhys: 1024, load: 0.0 }; } },
			tiny: { type: Boolean, default: false }
		},
		computed:
		{
			color: function ()
			{
				if (this.value.load < 0.95)
					return null;
				else
					return "#CCAA00";
			},
			textValue: function ()
			{
				return parseInt(this.value.load * 100) + "%";
			},
			tooltipText: function ()
			{
				var totalMemUsed = this.value.memPhys * this.value.load;
				var otherProcessesMemUsed = this.value.memPhys - this.value.bi;
				var memFree = this.value.memPhys - otherProcessesMemUsed;
				return "Server's Memory Usage: " + formatBytes(totalMemUsed, 2) + "/" + formatBytes(this.value.memPhys, 2) + " (" + parseInt(this.value.load * 100) + "%)"
					+ "\n\nBlue Iris: " + formatBytes(this.value.bi, 2)
					+ "\nOther Processes: " + formatBytes(otherProcessesMemUsed, 2)
					+ "\nFree: " + formatBytes(memFree, 2);
			}
		}
	});

	Vue.component('status-bar-disk', {
		template: ''
			+ '<status-bar :tiny="tiny" label="DISK" :percent="value.fullness" :textValue="textValue" :tooltipText="value.tooltip" :clickable="true" @click="onClick"></status-bar>',
		props:
		{
			value: { type: Object, default: function () { return { fullness: 0.0, tooltip: "", error: false }; } },
			tiny: { type: Boolean, default: false }
		},
		computed:
		{
			textValue: function ()
			{
				return this.value.error ? "ERR" : (parseInt(this.value.fullness * 100) + "%");
			}
		},
		methods:
		{
			onClick: function (e)
			{
				statusLoader.diskUsageClick();
			}
		}
	});

	Vue.component('status-area-uptime', {
		template: ''
			+ '<status-bar :tiny="tiny" :textOnly="true" label="UPTIME" :percent="1" :textValue="value.uptime" tooltipText="Server Uptime"></status-bar>',
		props:
		{
			value: { type: Object, default: function () { return { uptime: "unknown" }; } },
			tiny: { type: Boolean, default: false }
		}
	});

	Vue.component('status-bar-fps', {
		template: ''
			+ '<status-bar :tiny="tiny" label="FPS" :percent="percent" :color="color" :textValue="value.fps.toString()" tooltipText="Frame rate of video being played by UI3"></status-bar>',
		props:
		{
			value: { type: Object, default: function () { return { fps: 0, maxFps: 10 }; } },
			tiny: { type: Boolean, default: false }
		},
		computed:
		{
			percent: function ()
			{
				return Clamp(this.value.fps / this.value.maxFps, 0, 1);
			},
			color: function ()
			{
				if (this.percent > 0.5)
					return null;
				else if (this.percent > 0.25)
					return "#CCAA00";
				else if (this.percent > 0.1)
					return "#CC3300";
				else
					return "#CC0000";
			}
		}
	});

	Vue.component('status-bar-stream-delay', {
		template: ''
			+ '<status-bar :tiny="tiny" label="DLY" :percent="percent" :color="color" :textValue="totalDelayString" tooltipText="Total video streaming delay in milliseconds"></status-bar>',
		props:
		{
			value: { type: Object, default: function () { return { netDelay: 0, playerDelay: 0 }; } },
			tiny: { type: Boolean, default: false }
		},
		computed:
		{
			totalDelay: function ()
			{
				return this.value.netDelay + this.value.playerDelay;
			},
			totalDelayString: function ()
			{
				var ms = Math.round(this.totalDelay);
				if (ms > 99999)
					return "99+s";
				if (ms > 9999)
					return Math.round(ms / 1000) + "s";
				return ms.toString();
			},
			percent: function ()
			{
				return Clamp(this.totalDelay / 5000, 0, 1);
			},
			color: function ()
			{
				if (this.totalDelay < 1000)
					return null;
				else if (this.totalDelay < 2000)
					return "#CCAA00";
				else if (this.totalDelay < 3000)
					return "#CC8800";
				else if (this.totalDelay < 4000)
					return "#CC5500";
				else if (this.totalDelay < 5000)
					return "#CC3300";
				else
					return "#CC0000";
			}
		}
	});

	Vue.component('status-bar-audio-buffer', {
		template: ''
			+ '<status-bar :tiny="tiny" label="ABUF" :percent="percent" :color="color" :textValue="totalBufferString" tooltipText="Audio buffer contains this many milliseconds"></status-bar>',
		props:
		{
			value: { type: Number, default: 0 },
			tiny: { type: Boolean, default: false }
		},
		computed:
		{
			totalBufferString: function ()
			{
				var ms = Math.round(this.value);
				if (ms > 99999)
					return "99+s";
				if (ms > 9999)
					return Math.round(ms / 1000) + "s";
				return ms.toString();
			},
			percent: function ()
			{
				return Clamp(this.value / 1000, 0, 1);
			},
			color: function ()
			{
				if (this.value < 1000)
					return null;
				else
					return "#CCAA00";
			}
		}
	});

	function estimateMaxBitRate()
	{
		if (genericQualityHelper)
		{
			var p = genericQualityHelper.GetCurrentProfile();
			if (p.vcodec === "h264")
			{
				var overridesAllowed = sessionManager.DoesStreamAllowOverrides(p.stream);
				if (p.limitBitrate === 0 || (p.limitBitrate === 2 && !overridesAllowed))
				{
					var serversideStream = sessionManager.GetServersideStream(p.stream);
					if (serversideStream && serversideStream.control === "CBR")
						return serversideStream.kbps / 1000;
					else
						return 24.0;
				}
				else if (p.limitBitrate === 1)
					return 24.0;
				else if (p.limitBitrate === 2)
					return p.kbps / 1000;
			}
		}
		return 50.0;
	}

	Vue.component('status-bar-stream-bit-rate', {
		template: ''
			+ '<status-bar :tiny="tiny" label="MBPS" :percent="percent" :color="color" :textValue="textValue" tooltipText="Total video + audio bit rate"></status-bar>',
		props:
		{
			value: { type: Object, default: { video: 0, audio: 0 } },
			tiny: { type: Boolean, default: false }
		},
		computed:
		{
			totalKbps: function ()
			{
				return Math.round((this.value.video + this.value.audio) / 1000);
			},
			totalMbps: function ()
			{
				return this.totalKbps / 1000;
			},
			percent: function ()
			{
				return this.totalMbps / estimateMaxBitRate();
			},
			textValue: function ()
			{
				if (this.totalMbps < 1)
					return this.totalMbps.toFixed(3);
				else if (this.totalMbps < 10)
					return this.totalMbps.toFixed(2);
				else if (this.totalMbps < 100)
					return this.totalMbps.toFixed(1);
				else
					return Math.round(this.totalMbps);
			},
			color: function ()
			{
				return this.percent > 1 ? "#CCAA00" : undefined;
			}
		}
	});

	Vue.component('stoplight-button', {
		template: ''
			+ '	<div id="stoplightBtn" title="Control Blue Iris\'s Shield state with this button. Right-click to enable or disable button." @click="onClick" :class="{ disabled: !enabled }">'
			+ '		<div id="stoplightRed" :style="redStyle"><svg class="icon noflip"><use xlink:href="#svg_shield"></use></svg></div>'
			+ '		<div id="stoplightYellow" :style="yellowStyle"><svg class="icon noflip"><use xlink:href="#svg_shield"></use></svg></div>'
			+ '		<div id="stoplightGreen" :style="greenStyle"><svg class="icon noflip"><use xlink:href="#svg_shield"></use></svg></div>'
			+ '	</div>',
		data: function ()
		{
			return {
			};
		},
		props:
		{
			enabled: { type: Boolean, default: true },
			signal: { type: Number, default: -1 }
		},
		computed:
		{
			redStyle: function ()
			{
				var s = {};
				if (this.signal === 0)
					s.opacity = "1";
				return s;
			},
			yellowStyle: function ()
			{
				var s = {};
				if (this.signal === 2)
					s.opacity = "1";
				return s;
			},
			greenStyle: function ()
			{
				var s = {};
				if (this.signal === 1)
					s.opacity = "1";
				return s;
			}
		},
		methods:
		{
			onClick: function (e)
			{
				if (!this.enabled)
					return;
				var newSignal;
				if (this.signal !== 0)
					newSignal = 0;
				else
					newSignal = 2;
				statusLoader.SetStoplight(newSignal);
			}
		}
	});

	BI_CustomEvent.Invoke("StatusArea_Loading", self); // Addons should register their own status bars and components during this event.
}
///////////////////////////////////////////////////////////////
// Dropdown Boxes /////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function DropdownListDefinition(name, options)
{
	var self = this;
	this.name = name;
	this.timeClosed = 0;
	// Default Options
	this.items = [];
	this.onItemClick = null;
	this.getDefaultLabel = function () { return "..."; };
	// End options
	$.extend(this, options);
}
function DropdownListItem(options)
{
	var self = this;
	// Default Options
	this.text = "List Item";
	this.isHtml = !!options.isHtml;
	this.autoSetLabelText = true;
	// End options
	this.GetTooltip = function ()
	{
		if (typeof self.tooltip == "function")
			return self.tooltip(self);
		else if (self.tooltip)
			return self.tooltip;
		else
			return "";
	}
	$.extend(this, options);
}
function DropdownBoxes()
{
	var self = this;
	var handleElements = {};
	var $dropdownBoxes = $(".dropdownBox,#btn_main_menu,.dropdownTrigger,#changeGroupButton");
	var currentlyOpenList = null;
	var preventDDLClose = false;

	this.listDefs = {};
	this.listDefs["schedule"] = new DropdownListDefinition("schedule",
		{
			onItemClick: function (item)
			{
				var scheduleName = item.id;
				if (scheduleName != null)
				{
					self.setLabelText("schedule", "...");
					statusLoader.ChangeSchedule(scheduleName);
				}
			}
			, rebuildItems: function ()
			{
				this.items = [];
				if (statusLoader.IsGlobalScheduleEnabled())
				{
					var schedulesArray = sessionManager.GetSchedulesArray();
					if (schedulesArray)
					{
						if (schedulesArray.length == 0)
						{
							console.log("Schedules array is empty. Opening login dialog because login responses provide the schedule list");
							openLoginDialog();
							return;
						}
						for (var i = 0; i < schedulesArray.length; i++)
						{
							var scheduleName = schedulesArray[i];
							this.items.push(new DropdownListItem(
								{
									text: scheduleName
									, id: scheduleName
									, selected: scheduleName == statusLoader.GetCurrentlySelectedScheduleName()
								}));
						}
					}
				}
				else
					this.items.push(new DropdownListItem(
						{
							text: "The global schedule must first be configured in Blue Iris."
							, id: null
							, selected: false
							, autoSetLabelText: false
						}));
			}
		});
	this.listDefs["currentGroup"] = new DropdownListDefinition("currentGroup",
		{
			onItemClick: function (item)
			{
				if (item.isGroupOrCycle)
					videoPlayer.SelectCameraGroup(item.id);
				else
				{
					var camData = cameraListLoader.GetCameraWithId(item.id);
					if (camData)
						videoPlayer.LoadLiveCamera(camData, clipTimeline.getTimelineArgsForCameraSwitch());
					else
						videoPlayer.LoadHomeGroup();
				}
			}
			, rebuildItems: function (data)
			{
				this.items = [];
				for (var i = 0; i < data.length; i++)
				{
					var isGroupOrCycle = cameraListLoader.CameraIsGroupOrCycle(data[i]);
					if (isGroupOrCycle || (settings.ui3_show_cameras_in_group_dropdowns === "1" && data[i].isEnabled && data[i].webcast))
					{
						this.items.push(new DropdownListItem(
							{
								text: CleanUpGroupName(data[i].optionDisplay)
								, id: data[i].optionValue
								, isGroupOrCycle: isGroupOrCycle
							}));
					}
				}
			}
		});
	this.listDefs["streamingQuality"] = new DropdownListDefinition("streamingQuality",
		{
			items: [new DropdownListItem({ text: "Not Loaded!", uniqueId: "Not Loaded!" })]
			, onItemClick: function (item)
			{
				genericQualityHelper.QualityChoiceChanged(item.uniqueId);
			}
		});
	var mainMenuItems = [
		new DropdownListItem({ cmd: "ui_settings", text: "UI Settings", icon: "#svg_x5F_Settings", cssClass: "goldenLarger", tooltip: "User interface settings are stored in this browser and are not shared with other computers." })
		, new DropdownListItem({ cmd: "about_this_ui", text: "About This UI", icon: "#svg_x5F_About", cssClass: "goldenLarger" })
		, new DropdownListItem({ cmd: "streaming_profiles", text: "Streaming Profiles", icon: "#svg_mio_VideoFilter", cssClass: "goldenLarger" })
		, new DropdownListItem({ cmd: "copy_current_url", text: "Copy Current URL", icon: "#svg_mio_copy", cssClass: "goldenLarger" })
		, new DropdownListItem({ cmd: "system_log", text: "System Log", icon: "#svg_x5F_SystemLog", cssClass: "blueLarger", notificationCounter: function () { return Math.min(99999, statusLoader.getNotificationCounterValue("warnings")); } })
		, new DropdownListItem({ cmd: "user_list", text: "User List", icon: "#svg_x5F_User", cssClass: "blueLarger" })
		, new DropdownListItem({ cmd: "device_list", text: "Device List", icon: "#svg_mio_deviceInfo", cssClass: "blueLarger" })
		, new DropdownListItem({ cmd: "full_camera_list", text: "Full Camera List", icon: "#svg_x5F_FullCameraList", cssClass: "blueLarger" })
		, new DropdownListItem({ cmd: "export_list", text: "Convert/Export Queue", icon: "#svg_mio_launch", cssClass: "blueLarger" })
		, new DropdownListItem({ cmd: "disk_usage", text: "Disk Usage", icon: "#svg_x5F_Information", cssClass: "blueLarger" })
		, new DropdownListItem({ cmd: "server_control", text: "Server Control", icon: "#svg_x5F_SystemConfiguration", cssClass: "blueLarger", tooltip: "Control Blue Iris Server", updateAvailableFn: function () { return sessionManager.UpdateAvailable(); } })
		, new DropdownListItem({ cmd: "help", text: "Help", icon: "#svg_mio_help", cssClass: "goldenLarger" })
		, new DropdownListItem({ cmd: "logout", text: "Log Out", icon: "#svg_x5F_Logout", cssClass: "goldenLarger" })
	];
	if (BrowserIsIE())
		mainMenuItems.splice(0, 0, new DropdownListItem({ cmd: "using_ie", text: "Using Internet Explorer?", imgsrc: "ui3/horror.png", cssClass: "redLarger", tooltip: "Get a better web browser" }));
	this.listDefs["mainMenu"] = new DropdownListDefinition("mainMenu",
		{
			selectedIndex: -1
			, items: mainMenuItems
			, onItemClick: function (item)
			{
				switch (item.cmd)
				{
					case "using_ie":
						settings.ui3_disableIEWarning = "0";
						ShowIEWarning();
						break;
					case "ui_settings":
						uiSettingsPanel.open();
						break;
					case "about_this_ui":
						openAboutDialog();
						break;
					case "streaming_profiles":
						streamingProfileUI.open();
						break;
					case "copy_current_url":
						clipboardHelper.CopyText(UpdateCurrentURL());
						break;
					case "system_log":
						systemLog.open();
						break;
					case "user_list":
						userList.open();
						break;
					case "device_list":
						deviceList.open();
						break;
					case "server_control":
						serverControl.open();
						break;
					case "full_camera_list":
						cameraListDialog.open();
						break;
					case "export_list":
						exportListDialog.open();
						break;
					case "disk_usage":
						statusLoader.diskUsageClick();
						break;
					case "help":
						window.open("ui3/help/help.html" + currentServer.GetLocalSessionArg("?") + "#overview");
						break;
					case "logout":
						logout();
						break;
				}
			}
		});

	this.listDefs["ptzIR"] = new DropdownListDefinition("ptzIR",
		{
			items:
				[
					new DropdownListItem({ cmd: "off", text: "IR Off" })
					, new DropdownListItem({ cmd: "on", text: "IR On" })
					, new DropdownListItem({ cmd: "auto", text: "IR Auto" })
				]
			, onItemClick: function (item)
			{
				var loading = videoPlayer.Loading().image;
				if (loading.ptz && loading.isLive)
					switch (item.cmd)
					{
						case "off":
							ptzButtons.vue().enqueuePtzAction(loading.id, 34, undefined, function ()
							{
								ptzButtons.SetIRButtonState(0);
							});
							break;
						case "on":
							ptzButtons.vue().enqueuePtzAction(loading.id, 35, undefined, function ()
							{
								ptzButtons.SetIRButtonState(1);
							});
							break;
						case "auto":
							ptzButtons.vue().enqueuePtzAction(loading.id, 36, undefined, function ()
							{
								ptzButtons.SetIRButtonState(2);
							});
							break;
					}
			}
		});
	this.listDefs["ptzBrightness"] = new DropdownListDefinition("ptzBrightness",
		{
			items: GetNumberedDropdownListItems("Brightness", 0, 15)
			, onItemClick: function (item)
			{
				var loading = videoPlayer.Loading().image;
				if (loading.ptz && loading.isLive)
				{
					var newBrightness = Clamp(parseInt(item.cmd), 0, 15);
					ptzButtons.vue().enqueuePtzAction(loading.id, 11 + newBrightness, undefined, function ()
					{
						ptzButtons.SetBrightnessButtonState(newBrightness);
					});
				}
			}
		});
	this.listDefs["ptzContrast"] = new DropdownListDefinition("ptzContrast",
		{
			items: GetNumberedDropdownListItems("Contrast", 0, 6)
			, onItemClick: function (item)
			{
				var loading = videoPlayer.Loading().image;
				if (loading.ptz && loading.isLive)
				{
					var newContrast = Clamp(parseInt(item.cmd), 0, 6);
					ptzButtons.vue().enqueuePtzAction(loading.id, 27 + newContrast, undefined, function ()
					{
						ptzButtons.SetContrastButtonState(newContrast);
					});
				}
			}
		});
	function GetNumberedDropdownListItems(name, min, max)
	{
		var items = [];
		for (var i = min; i <= max; i++)
			items.push(new DropdownListItem({ cmd: i.toString(), text: name + " " + i }));
		return items;
	}
	this.listDefs["dbView"] = new DropdownListDefinition("dbView",
		{
			onItemClick: function (item)
			{
				if (item.id === "separator")
					return;

				settings.ui3_current_dbView = item.id;
				clipLoader.LoadClips();
			}
			, rebuildItems: function (data)
			{
				this.items = [];
				this.items.push(new DropdownListItem({ id: "all", text: "All clips", icon: "#svg_mio_storage", iconClass: "smallIcon" }));

				this.items.push(new DropdownListItem({ id: "separator" }));

				var alertsName = "Alerts";
				var alertsFolder = statusLoader ? statusLoader.GetFolder(2) : null;
				if (alertsFolder && alertsFolder.name)
					alertsName = alertsFolder.name;
				this.items.push(new DropdownListItem({ id: "alerts", text: alertsName, icon: "#svg_x5F_Alert1", iconClass: "smallIcon" }));

				AddDbViewFolder(this.items, "new", "New", 0, "#svg_mio_folder_special");
				AddDbViewFolder(this.items, "stored", "Stored", 1, "#svg_mio_folder");
				for (var i = 1; i <= 13; i++)
				{
					AddDbViewFolder(this.items, "aux" + i, "Aux " + i, i + 2, "#svg_mio_folder");
				}

				this.items.push(new DropdownListItem({ id: "separator" }));

				this.items.push(new DropdownListItem({ id: "flagged", text: "Flagged", icon: "#svg_x5F_Flag", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "new.clipboard", text: "Clipboard", icon: "#svg_mio_crop", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "cancelled", text: "Cancelled alerts", icon: "#svg_x5F_HoldProfile", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "confirmed", text: "Confirmed alerts", icon: "#svg_mio_cbChecked", iconClass: "smallIcon greenIcon" }));
				this.items.push(new DropdownListItem({ id: "people", text: "Person alerts", icon: "#svg_mio_man", iconClass: "smallIcon orangeIcon" }));
				this.items.push(new DropdownListItem({ id: "vehicles", text: "Vehicle alerts", icon: "#svg_mio_directions_car", iconClass: "smallIcon orangeIcon" }));
				this.items.push(new DropdownListItem({ id: "wildlife", text: "Wildlife alerts", icon: "#wildlife", iconClass: "smallIcon orangeIcon" }));
				this.items.push(new DropdownListItem({ id: "separator" }));

				this.items.push(new DropdownListItem({ id: "zonea", text: "Zone A alerts", icon: "#blank", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "zoneb", text: "Zone B alerts", icon: "#blank", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "zonec", text: "Zone C alerts", icon: "#blank", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "zoned", text: "Zone D alerts", icon: "#blank", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "zonee", text: "Zone E alerts", icon: "#blank", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "zonef", text: "Zone F alerts", icon: "#blank", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "zoneg", text: "Zone G alerts", icon: "#blank", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "zoneh", text: "Hotspot alerts", icon: "#blank", iconClass: "smallIcon" }));

				this.items.push(new DropdownListItem({ id: "separator" }));

				this.items.push(new DropdownListItem({ id: "dio", text: "DIO alerts", icon: "#blank", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "onvif", text: "ONVIF alerts", icon: "#blank", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "audio", text: "Audio alerts", icon: "#blank", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "external", text: "External alerts", icon: "#blank", iconClass: "smallIcon" }));

				this.items.push(new DropdownListItem({ id: "separator" }));

				this.items.push(new DropdownListItem({ id: "memos", text: "Memos", icon: "#blank", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "protected", text: "Protected", icon: "#svg_mio_lock", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "archive", text: "FTP backup queue", icon: "#svg_mio_cloudUploading", iconClass: "smallIcon" }));
				this.items.push(new DropdownListItem({ id: "export", text: "Convert/Export queue", icon: "#svg_mio_launch", iconClass: "smallIcon" }));

				var didSet = false;
				for (var i = 0; i < this.items.length && !didSet; i++)
				{
					if (this.items[i].id === settings.ui3_current_dbView)
					{
						self.setLabelText("dbView", this.items[i].text, false, this.items[i]);
						didSet = true;
					}
				}
				if (!didSet)
				{
					var notFound = settings.ui3_current_dbView;
					settings.ui3_current_dbView = this.items[0].id;
					self.setLabelText("dbView", this.items[0].text, false, this.items[0]);
					console.log('Clip List db view not found: "' + notFound + '". Falling back to "' + settings.ui3_current_dbView + '"');
					clipLoader.LoadClips();
				}
			}
		});

	function AddDbViewFolder(items, id, defaultName, folderIndex, icon)
	{
		var folder = statusLoader ? statusLoader.GetFolder(folderIndex) : null;
		if (!folder)
		{
			if (!statusLoader || !statusLoader.getLastResponse())
				folder = { name: defaultName }; // Status hasn't loaded yet.  Fall back to default folder name.
			else
				return;
		}
		var name = folder.name;
		if (!name)
			name = defaultName;
		items.push(new DropdownListItem({ id: id, text: name, icon: icon, iconClass: "smallIcon" }));
	}

	this.listDefs["profile"] = new DropdownListDefinition("profile",
		{
			onItemClick: function (item)
			{
				statusLoader.LoadProfile(parseInt(item.id.substr("profile".length)));
			}
			, rebuildItems: function (data)
			{
				this.items = [];
				for (var i = 0; i < 8; i++)
					this.items.push(new DropdownListItem({ id: "profile" + i, text: statusLoader.getProfileDropdownHtml(i), isHtml: true }));
			}
		});

	// This event can be utilized to modify the listDefs collection before it is processed.
	BI_CustomEvent.Invoke("DropdownBoxes_Initializing", this);

	$dropdownBoxes.each(function (idx, ele)
	{
		var $ele = $(ele);
		var name = $ele.attr("name");
		var listDef = self.listDefs[name];
		if (listDef == null)
		{
			toaster.Warning("Unknown dropdown box name: " + htmlEncode(name));
			return;
		}
		ele.extendLeft = $ele.attr("extendLeft") == "1";
		ele.extendUp = $ele.attr("extendUp") == "1";
		if ($ele.hasClass('dropdownBox'))
		{
			ele.$label = $('<div class="dropdownLabel"></div>');
			ele.$label.text(listDef.getDefaultLabel());
			ele.$arrow = $('<div class="dropdownArrow"><svg class="icon"><use xlink:href="#svg_x5F_DownArrow"></use></svg></div>');
			$ele.append(ele.$label);
			$ele.append(ele.$arrow);
		}
		else if ($ele.hasClass('dropdownTrigger'))
		{
			ele.$label = $ele.find('div.invisibleLabel');
		}
		else
		{
			ele.$label = $();
			ele.$arrow = $();
		}
		$ele.on('click', function ()
		{
			if ($ele.hasClass("disabled"))
				return;
			LoadDropdownList(name, $ele);
		});
		if (!handleElements[name])
			handleElements[name] = [];
		handleElements[name].push(ele);
	});
	this.setLabelText = function (name, labelText, isHtml, item)
	{
		var handleEles = handleElements[name];
		if (handleEles)
			for (var i = 0; i < handleEles.length; i++)
			{
				var ele = handleEles[i];
				if (ele)
				{
					if (isHtml)
						ele.$label.html(labelText);
					else
						ele.$label.text(labelText);
					if (item && item.icon)
					{
						var iconClass = item.iconClass ? (" " + item.iconClass) : "";
						ele.$label.prepend('<div class="mainMenuIcon' + iconClass + '"><svg class="icon' + (item.icon.indexOf('_x5F_') == -1 ? " noflip" : "") + '"><use xlink:href="' + item.icon + '"></use></svg></div>');
					}
				}
			}
	};
	this.getLabelText = function (name, isHtml)
	{
		var handleEles = handleElements[name];
		if (handleEles)
			for (var i = 0; i < handleEles.length; i++)
			{
				var ele = handleEles[i];
				if (ele)
				{
					if (isHtml)
						return ele.$label.html();
					else
						return ele.$label.text();
				}
			}
		return "";
	}
	this.setEnabled = function (name, enabled)
	{
		var handleEles = handleElements[name];
		if (handleEles)
			for (var i = 0; i < handleEles.length; i++)
			{
				var ele = handleEles[i];
				if (ele)
				{
					if (enabled)
						$(ele).removeClass("disabled");
					else
						$(ele).addClass("disabled");
				}
			}
	}
	var LoadDropdownList = function (name, $ele)
	{
		var listDef = self.listDefs[name];
		if (listDef == null)
			return;
		if (new Date().getTime() - 33 <= listDef.timeClosed)
			return;

		var $ddl = listDef.$currentListEle = $('<div class="dropdown_list"></div>');
		$ddl.on("mouseup", function ()
		{
			return false;
		});

		var selectedText = self.getLabelText(name);
		for (var i = 0; i < listDef.items.length; i++)
			AddDropdownListItem($ddl, listDef, i, selectedText);
		if (listDef.items.length == 0)
			$ddl.append("<div>This list is empty!</div>");

		$("body").append($ddl);

		if ($ele.length > 0)
			$ddl.css('min-width', $ele.innerWidth() + "px");

		if (name == "mainMenu")
		{
			$ddl.css("min-width", ($ddl.width() + 1) + "px"); // Workaround for "Server Control" wrapping bug
			if (BrowserIsIE())
				$ddl.css("height", ($ddl.height() + 3) + "px"); // Workaround for IE bug that adds unnecessary scroll bars
		}

		var windowH = $(window).height();
		var windowW = $(window).width();
		var width = $ddl.outerWidth();
		var height = $ddl.outerHeight();
		var offset = $ele.offset();
		var top = (offset.top + $ele.outerHeight());
		var left = offset.left;
		if ($ele.get(0).extendLeft)
		{
			left = (left + $ele.outerWidth()) - width;
			if ((BrowserIsIE() || BrowserIsEdgeLegacy()) && height > windowH)
				left -= 20; // Workaround for Edge/IE bug that renders scroll bar offscreen
		}
		if ($ele.get(0).extendUp)
			top = offset.top - height;

		// Adjust box position so the box doesn't extend off the bottom, top, right, left, in that order.
		if (top + height > windowH)
			top = windowH - height;
		if (top < 0)
			top = 0;
		if (left + width > windowW)
			left = windowW - width;
		if (left < 0)
			left = 0;

		$ddl.css("top", top + "px");
		$ddl.css("left", left + "px");

		closeDropdownLists();
		currentlyOpenList = listDef;
		preventDDLClose = true;
		setTimeout(allowDDLClose, 0);
		self.Resized();

		var $selectedItem = $ddl.children('.selected');
		if ($selectedItem.length > 0)
		{
			// Determine ideal scroll position
			var eleCenter = $selectedItem.position().top + $selectedItem.outerHeight(true) / 2;
			var visibleHeight = $ddl.innerHeight();
			var idealScrollTop = eleCenter - (visibleHeight / 2);
			if (idealScrollTop > 0)
				$ddl.scrollTop(idealScrollTop);
		}
	}
	var AddDropdownListItem = function ($ddl, listDef, i, selectedText)
	{
		var item = listDef.items[i];
		var $item = $("<div></div>");
		if (item.id === "separator")
			$item.addClass("separator");
		else if (item.isHtml)
			$item.html(item.text);
		else
			$item.text(item.text);
		if (selectedText == item.text)
			$item.addClass("selected");
		if (item.cssClass)
			$item.addClass(item.cssClass);
		if (typeof item.notificationCounter === "function")
		{
			var notificationCounterValue = item.notificationCounter();
			if (notificationCounterValue)
			{
				$item.css("position", "relative");
				var $nc = $('<div class="notificationCounter">' + htmlEncode(notificationCounterValue) + '</div>');
				$item.append($nc);
				$nc.show();
			}
		}
		if (typeof item.updateAvailableFn === "function")
		{
			var updateAvailableValue = item.updateAvailableFn();
			if (updateAvailableValue)
			{
				$item.css("position", "relative");
				var $upd = $('<div class="updateAvailable full" title="A Blue Iris update is available!"></div>');
				$item.append($upd);
			}
		}
		$item.click(function ()
		{
			if (listDef.items[i].id === "separator")
				return;

			if (listDef.items[i].autoSetLabelText)
				self.setLabelText(listDef.name, item.text, item.isHtml, item);
			listDef.selectedIndex = i;
			listDef.onItemClick && listDef.onItemClick(listDef.items[i]); // run if not null
			closeDropdownLists();
		});
		var iconClass = item.iconClass ? (" " + item.iconClass) : "";
		if (item.icon)
		{
			$item.prepend('<div class="mainMenuIcon' + iconClass + '"><svg class="icon' + (item.icon.indexOf('_x5F_') == -1 ? " noflip" : "") + '"><use xlink:href="' + item.icon + '"></use></svg></div>');
		}
		else if (item.imgsrc)
			$item.prepend('<div class="mainMenuIcon' + iconClass + '"><img src="' + item.imgsrc + '" alt="" /></div>');
		var tooltip = item.GetTooltip();
		if (tooltip)
			$item.attr('title', tooltip);
		$ddl.append($item);
	}
	$(document).mouseup(function (e)
	{
		if (!preventDDLClose)
			closeDropdownLists();
	});
	//$(document).mouseleave(function (e)
	//{
	//	if (!preventDDLClose)
	//		closeDropdownLists();
	//});
	var closeDropdownLists = function ()
	{
		if (currentlyOpenList != null)
		{
			currentlyOpenList.$currentListEle.remove();
			currentlyOpenList.$currentListEle = null;
			currentlyOpenList.timeClosed = new Date().getTime();
			currentlyOpenList = null;
		}
	}
	/** This exists to prevent a glitch where dropdown lists close immediately in Edge when using a touchscreen, giving the appearance that the dropdown lists never even open. */
	var allowDDLClose = function ()
	{
		preventDDLClose = false;
	}
	this.Resized = function ()
	{
		var windowH = $(window).height();
		$(".dropdown_list").each(function (idx, ele)
		{
			var $ele = $(ele);
			$ele.css("max-height", (windowH - $ele.offset().top - 2) + "px");
		});
	}

	// Initialize dbView dropdown list.
	this.listDefs["dbView"].rebuildItems();
}
function GetTooltipForStreamQuality(index)
{
	var arr = sessionManager.GetStreamsArray();
	if (index > -1 && index < arr.length)
		return arr[index].str + (arr[index].overrides ? "" : " OVERRIDES NOT ALLOWED");
	return "";
}
///////////////////////////////////////////////////////////////
// Notification Counters //////////////////////////////////////
///////////////////////////////////////////////////////////////
var notificationCounters = new (function ()
{
	var self = this;

	this.setCounter = function (selector, value)
	{
		var $ele = $(selector);
		if (value)
		{
			$ele.text(value);
			$ele.show();
		}
		else
			$ele.hide();
	}
})();
///////////////////////////////////////////////////////////////
// System Name Button /////////////////////////////////////////
///////////////////////////////////////////////////////////////
var systemNameButton;
function getSystemNameButtonOptions()
{
	var mmItems = dropdownBoxes.listDefs["mainMenu"].items;
	var opts = new Array();
	for (var i = 0; i < mmItems.length; i++)
		opts.push(mmItems[i].text);
	opts.push("Toggle Side Bar");
	opts.push("Follow a Link");
	opts.push("Do Nothing");
	return opts;
}
function systemNameButtonClick()
{
	var mmItems = dropdownBoxes.listDefs["mainMenu"].items;
	for (var i = 0; i < mmItems.length; i++)
		if (settings.ui3_system_name_button == mmItems[i].text)
		{
			dropdownBoxes.listDefs["mainMenu"].onItemClick(mmItems[i]);
			return;
		}
	if (settings.ui3_system_name_button === "Toggle Side Bar")
	{
		if (currentPrimaryTab === "live")
		{
			settings.ui3_sidebar_visible_on_live = settings.ui3_sidebar_visible_on_live === "1" ? "0" : "1";
			resized();
		}
		else if (currentPrimaryTab === "clips")
		{
			settings.ui3_sidebar_visible_on_clips = settings.ui3_sidebar_visible_on_clips === "1" ? "0" : "1";
			resized();
		}
		return;
	}
	else if (settings.ui3_system_name_button === "Follow a Link")
	{
		location.href = settings.ui3_system_name_button_link;
		return;
	}
}
function setSystemNameButtonState()
{
	if (settings.ui3_system_name_button == "Do Nothing")
		$("#systemnamewrapper").removeClass("hot");
	else
		$("#systemnamewrapper").addClass("hot");
	if (uiSettingsPanel)
		uiSettingsPanel.Refresh();
}
function setSystemNameButtonTextState()
{
	if (settings.ui3_system_name_button_text_override)
		$("#systemname").text(settings.ui3_system_name_button_text_override);
	else if (sessionManager && sessionManager.sysName)
		$("#systemname").text(sessionManager.sysName);
}
function SidebarHiddenButtonClick(e)
{
	e.stopPropagation();
	uiSettingsPanel.open('Side Bar');
}
function Precondition_ui3_system_name_button_link()
{
	return settings.ui3_system_name_button === "Follow a Link";
}
///////////////////////////////////////////////////////////////
// Left Bar Boolean Options ///////////////////////////////////
///////////////////////////////////////////////////////////////
function LeftBarBooleans()
{
	//var $items = $('#layoutleft .leftBarBool');
	//$items.each(function (idx, ele)
	//{
	//	var $ele = $(ele);
	//	var name = $ele.attr("name");
	//	switch (name)
	//	{
	//		case "flaggedOnly":
	//			{
	//				var $cb = $('<input type="checkbox" />');
	//				if (settings.ui3_recordings_flagged_only == "1")
	//					$cb.prop('checked', 'checked');
	//				$cb.on('change', function ()
	//				{
	//					settings.ui3_recordings_flagged_only = $cb.is(':checked') ? "1" : "0";
	//					clipLoader.LoadClips();
	//				});
	//				var $label = $('<label></label>');
	//				$label.append('<div class="smallFlagIcon"><svg class="icon"><use xlink:href="#svg_x5F_Flag"></use></svg></div>');
	//				$label.append($cb);
	//				$label.append($ele.html());
	//				$ele.empty();
	//				$ele.append($label);
	//			}
	//			break;
	//	}
	//});
}
///////////////////////////////////////////////////////////////
// PTZ Pad Buttons ////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var currentPtzPresetShowCount = -1;
function GetPtzPresetShowCount()
{
	if (currentPtzPresetShowCount < 0)
	{
		var count = settings.ui3_ptzPresetShowCount;
		if (count === "0") currentPtzPresetShowCount = 0;
		else if (count === "10") currentPtzPresetShowCount = 10;
		else if (count === "30") currentPtzPresetShowCount = 30;
		else if (count === "40") currentPtzPresetShowCount = 40;
		else currentPtzPresetShowCount = 20;
	}
	return currentPtzPresetShowCount;
}
function PtzButtons()
{
	var self = this;

	var panelBgColor = "panel-bg-color";
	var ptzpadColor = "ptzpad-color";
	var ptzpadDisabledColor = "ptzpad-disabled-color";
	var textHoverColor = "text-hover-color";
	var textActiveColor = "text-active-color";
	var allColors = panelBgColor + " " + ptzpadColor + " " + ptzpadDisabledColor + " " + textHoverColor + " " + textActiveColor;
	var setColor = function ($ele, colorClass)
	{
		$ele.removeClass(allColors);
		$ele.addClass(colorClass);
	};

	var ptzControlsEnabled = false;
	var $hoveredEle = null;
	var $activeEle = null;

	var ptzActionPending = false;
	var currentPtzData = null;

	var count = GetPtzPresetShowCount();
	if (count < 40)
		$("#ptzPresetsContent .ptzPresets40").remove();
	else
		$("#ptzPresetsContent .ptzPresets40").show()
	if (count < 30)
		$("#ptzPresetsContent .ptzPresets30").remove();
	else
		$("#ptzPresetsContent .ptzPresets30").show()
	if (count < 20)
		$("#ptzPresetsContent .ptzPresets20").remove();
	if (count < 10)
		$("#ptzPresetsContent .ptzPresets10").remove();

	var $ptzGraphicWrapper = $("#ptzGraphicWrapper");
	var $ptzGraphics = $("#ptzGraphicWrapper div.ptzGraphic");
	var $ptzBackgroundGraphics = $("#ptzGraphicWrapper div.ptzBackground");
	var $ptzGraphicContainers = $("#ptzGraphicWrapper .ptzGraphicContainer");
	var $ptzPresets = $("#ptzPresetsContent .ptzpreset");
	var $ptzButtons = $("#ptzButtonsMain");
	var $ptzControlsContainers = $("#ptzPresetsContent,#ptzButtonsMain");
	var $ptzExtraDropdowns = $("#ptzIrBrightnessContrast .dropdownTrigger");
	var $ptzHome = $("#ptzHome");
	var $irButtonText = $("#irButtonText");
	var $irButtonLabel = $("#irButtonLabel");
	var $brightnessButtonLabel = $("#brightnessButtonLabel");
	var $contrastButtonLabel = $("#contrastButtonLabel");
	var $ptzRelativeToggle = $("#ptzRelativeToggle");

	var hitPolys = {};
	hitPolys["PTZzoomIn"] = [[64, 64], [82, 82], [91, 77], [99, 77], [106, 81], [126, 64], [116, 58], [105, 53], [86, 53], [74, 58]];
	hitPolys["PTZzoomOut"] = [[64, 126], [82, 108], [91, 113], [99, 113], [106, 109], [126, 126], [116, 132], [105, 137], [86, 137], [74, 132]];
	hitPolys["PTZfocusLarge"] = [[64, 64], [82, 82], [77, 91], [77, 99], [81, 106], [64, 126], [58, 116], [53, 105], [53, 86], [58, 74]];
	hitPolys["PTZfocusSmall"] = [[126, 64], [108, 82], [113, 91], [113, 99], [109, 106], [126, 126], [132, 116], [137, 105], [137, 86], [132, 74]];
	hitPolys["PTZstop"] = [[82, 82], [91, 77], [99, 77], [108, 82], [113, 91], [113, 99], [108, 108], [99, 113], [91, 113], [82, 108], [77, 99], [77, 91]];
	hitPolys["PTZcardinalUp"] = [[52, 9], [74, 58], [86, 53], [105, 53], [116, 58], [138, 9], [96, 0]];
	hitPolys["PTZcardinalRight"] = [[181, 52], [132, 74], [138, 86], [138, 105], [132, 116], [181, 138], [190, 96]];
	hitPolys["PTZcardinalDown"] = [[52, 181], [74, 132], [86, 138], [105, 138], [116, 132], [138, 181], [96, 190]];
	hitPolys["PTZcardinalLeft"] = [[9, 52], [58, 74], [53, 86], [53, 105], [58, 116], [9, 138], [0, 96]];
	hitPolys["PTZordinalNE"] = [[138, 9], [116, 58], [124, 63], [127, 66], [132, 74], [181, 52], [171, 19]];
	hitPolys["PTZordinalNW"] = [[52, 9], [74, 58], [66, 63], [63, 66], [58, 74], [9, 52], [19, 19]];
	hitPolys["PTZordinalSW"] = [[52, 181], [74, 132], [66, 127], [63, 124], [58, 116], [9, 138], [19, 171]];
	hitPolys["PTZordinalSE"] = [[138, 181], [116, 132], [124, 127], [127, 124], [132, 116], [181, 138], [171, 171]];

	if (settings.ui3_swap_ptz_focus_buttons === "1")
	{
		var tmp = hitPolys["PTZfocusLarge"];
		hitPolys["PTZfocusLarge"] = hitPolys["PTZfocusSmall"];
		hitPolys["PTZfocusSmall"] = tmp;
	}

	var ptzCmds = {};
	ptzCmds["PTZhome"] = 4;
	ptzCmds["PTZzoomIn"] = 5;
	ptzCmds["PTZzoomOut"] = 6;
	ptzCmds["PTZfocusLarge"] = -1;
	ptzCmds["PTZfocusSmall"] = -2;
	ptzCmds["PTZstop"] = 64;
	ptzCmds["PTZcardinalUp"] = 2;
	ptzCmds["PTZcardinalRight"] = 1;
	ptzCmds["PTZcardinalDown"] = 3;
	ptzCmds["PTZcardinalLeft"] = 0;
	ptzCmds["PTZordinalNE"] = 60;
	ptzCmds["PTZordinalNW"] = 59;
	ptzCmds["PTZordinalSW"] = 61;
	ptzCmds["PTZordinalSE"] = 62;

	var ptzTitles = {};
	ptzTitles["PTZhome"] = "Home";
	ptzTitles["PTZzoomIn"] = "Zoom In";
	ptzTitles["PTZzoomOut"] = "Zoom Out";
	ptzTitles["PTZfocusLarge"] = "Focus Near";
	ptzTitles["PTZfocusSmall"] = "Focus Far";
	ptzTitles["PTZstop"] = "Stop";
	ptzTitles["PTZcardinalUp"] = "Up";
	ptzTitles["PTZcardinalRight"] = "Right";
	ptzTitles["PTZcardinalDown"] = "Down";
	ptzTitles["PTZcardinalLeft"] = "Left";
	ptzTitles["PTZordinalNE"] = "Up Right";
	ptzTitles["PTZordinalNW"] = "Up Left";
	ptzTitles["PTZordinalSW"] = "Down Left";
	ptzTitles["PTZordinalSE"] = "Down Right";

	var ptzStateKeys = {}; // Map of svgid to array of input state property names that should cause the svg to light up when active.
	ptzStateKeys["PTZhome"] = [];
	ptzStateKeys["PTZzoomIn"] = ["zin"];
	ptzStateKeys["PTZzoomOut"] = ["zout"];
	ptzStateKeys["PTZfocusLarge"] = ["fnear"];
	ptzStateKeys["PTZfocusSmall"] = ["ffar"];
	ptzStateKeys["PTZstop"] = [];
	ptzStateKeys["PTZcardinalUp"] = ["up"];
	ptzStateKeys["PTZcardinalRight"] = ["right"];
	ptzStateKeys["PTZcardinalDown"] = ["down"];
	ptzStateKeys["PTZcardinalLeft"] = ["left"];
	ptzStateKeys["PTZordinalNE"] = ["up", "right"];
	ptzStateKeys["PTZordinalNW"] = ["up", "left"];
	ptzStateKeys["PTZordinalSW"] = ["down", "left"];
	ptzStateKeys["PTZordinalSE"] = ["down", "right"];

	var allPtzSvgIds = [];
	var ptzSvgIds = {};
	for (var key in ptzCmds)
	{
		if (ptzCmds.hasOwnProperty(key))
		{
			allPtzSvgIds.push(key);
			ptzSvgIds[ptzCmds[key]] = key;
		}
	}

	/**
	 * Returns the map of svgid to PTZ command number for PTZ button mappings.
	 */
	this.GetPtzCmds = function ()
	{
		return ptzCmds;
	}
	/**
	 * Returns the map of PTZ command number to svgid.
	 */
	this.GetPtzSvgIds = function ()
	{
		return ptzSvgIds;
	}
	/**
	 * Returns the map of svgid to tooltip text for PTZ button mappings.
	 */
	this.GetPtzTooltips = function ()
	{
		return ptzTitles;
	}

	$ptzGraphicContainers.each(function (idx, ele)
	{
		ele.graphicObjects = {};
	});

	// Layout PTZ buttons //
	$ptzGraphics.each(function (idx, ele)
	{
		var $ele = $(ele);
		ele.svgid = PtzFocusSwapSvgId($ele.attr('svgid'));
		var layoutParts = $ele.attr('layoutR').split(' ');
		ele.layout = {
			x: parseFloat(layoutParts[0])
			, y: parseFloat(layoutParts[1])
			, w: parseFloat(layoutParts[2])
			, h: parseFloat(layoutParts[3])
		};

		$ele.css("left", ele.layout.x + "px");
		$ele.css("top", ele.layout.y + "px");
		$ele.css("width", ele.layout.w + "px");
		$ele.css("height", ele.layout.h + "px");

		var classes = "icon";
		if (settings.ui3_swap_ptz_focus_buttons !== "1" && (ele.svgid === "PTZfocusLarge" || ele.svgid === "PTZfocusSmall"))
			classes += " invertv";
		$ele.append('<svg class="' + classes + '"><use xlink:href="#svg_x5F_' + ele.svgid + '"></use></svg>');
		ele.defaultColor = $ele.hasClass("ptzBackground") ? ptzpadColor : panelBgColor;
		setColor($ele, ele.defaultColor);
		ele.parentNode.graphicObjects[ele.svgid] = ele;
	});

	function PtzFocusSwapSvgId(svgid)
	{
		if (settings.ui3_swap_ptz_focus_buttons === "1")
		{
			if (svgid === "PTZfocusSmall")
				return "PTZfocusLarge";
			if (svgid === "PTZfocusLarge")
				return "PTZfocusSmall";
		}
		return svgid;
	}

	BI_CustomEvent.AddListener("afterResize", function ()
	{
		var o = $ptzGraphicWrapper.offset();
		$ptzGraphicWrapper.get(0).savedBounds = { x: o ? o.left : 0, y: o ? o.top : 0, w: $ptzGraphicWrapper.width(), h: $ptzGraphicWrapper.height() };
	});
	// PTZ button input events //

	// onHoverEnter called whenever a mouse pointer begins hovering over any button.
	var onHoverEnter = function (btn)
	{
		$ptzButtons.attr("title", ptzTitles[btn.svgid]);
		$hoveredEle = $(btn);
		self.vue().guiButtonBeingHovered = btn;
	}
	// onHoverLeave called whenever a mouse pointer leaves any button or a mouse up event is triggered
	var onHoverLeave = function ()
	{
		if ($hoveredEle != null)
		{
			$ptzButtons.removeAttr("title");
			self.vue().guiButtonBeingHovered = null;
			$hoveredEle = null;
		}
		if ($activeEle != null)
		{
			var stateKeys = ptzStateKeys[$activeEle.get(0).svgid];
			for (var i = 0; i < stateKeys.length; i++)
			{
				var key = stateKeys[i];
				self.vue().guiButtonState[key] = 0;
			}
			$activeEle = null;
		}
	}
	var onButtonMouseDown = function (btn)
	{
		var stateKeys = ptzStateKeys[btn.svgid];
		if (stateKeys.length)
		{
			for (var i = 0; i < stateKeys.length; i++)
			{
				var key = stateKeys[i];
				self.vue().guiButtonState[key] = 1;
			}
		}
		else
		{
			// This button has no reactive state assignment; therefore it must be triggered the old-fashioned way.
			self.vue().enqueuePtzAction(videoPlayer.Loading().image.id, ptzCmds[btn.svgid]);
		}
		$activeEle = $(btn);
	}
	var onPointerMove = function (e)
	{
		if (pointInsideElement($ptzGraphicWrapper, e.mouseX, e.mouseY))
		{
			// Hovering near buttons, maybe over one
			if ($activeEle == null && !touchEvents.isTouchEvent(e))
			{
				var offset = $ptzGraphicWrapper.offset();
				var x = e.mouseX - offset.left;
				var y = e.mouseY - offset.top;
				var btn = GetHoveredPTZButton(x, y);
				if (btn == null)
				{
					// Not hovering on any buttons
					onHoverLeave();
				}
				else if ($hoveredEle == null || $hoveredEle.get(0).svgid != btn.svgid)
				{
					onHoverLeave();
					onHoverEnter(btn);
				}
			}
		}
		else
		{
			// Not hovering on any buttons
			onHoverLeave();
		}
	}
	// Hide long-press square that appears when using ptz controls on Windows touchscreen devices.  Unfortunately, it can only be hidden in IE and Edge.
	$ptzGraphicWrapper.get(0).addEventListener("MSHoldVisual", function (e) { e.preventDefault(); }, false);
	$ptzGraphicWrapper.on('mousedown touchstart', function (e)
	{
		if (!ptzControlsEnabled)
			return;
		mouseCoordFixer.fix(e);
		if (touchEvents.Gate(e))
			return;
		if (e.which != 3)
		{
			var offset = $ptzGraphicWrapper.offset();
			var x = e.mouseX - offset.left;
			var y = e.mouseY - offset.top;
			var btn = GetHoveredPTZButton(x, y);
			if (btn != null)
			{
				onHoverLeave();
				onButtonMouseDown(btn);
				$.hideAllContextMenus();
				return stopDefault(e);
			}
		}
		onPointerMove(e);
	});
	$(document).on('mouseup mouseleave touchend touchcancel', function (e)
	{
		if (!ptzControlsEnabled)
			return;
		mouseCoordFixer.fix(e);
		if (touchEvents.Gate(e))
			return;
		onHoverLeave();
		onPointerMove(e);
	});
	$(document).on('mousemove touchmove', function (e)
	{
		if (!ptzControlsEnabled)
			return;
		mouseCoordFixer.fix(e);
		if (touchEvents.Gate(e))
			return;
		onPointerMove(e);
	});
	$ptzHome.on('click', function ()
	{
		self.vue().enqueuePtzAction(videoPlayer.Loading().image.id, ptzCmds["PTZhome"]);
	});
	var GetHoveredPTZButton = function (x, y)
	{
		var sizeMultiplier = $ptzGraphicWrapper.width() / 190;
		var point = [x / sizeMultiplier, y / sizeMultiplier];
		var buttonId = FindPolyForPoint(point);
		if (buttonId != null)
			return GetPTZButtonEle(buttonId);
		return null;
	}
	var GetPTZButtonEle = function (svgId)
	{
		var visibleGraphicContainer = GetVisibleGraphicContainer();
		return visibleGraphicContainer ? visibleGraphicContainer.graphicObjects[svgId] : null;
	}
	var FindPolyForPoint = function (point)
	{
		var keys = Object.keys(hitPolys);
		for (var i = 0; i < keys.length; i++)
		{
			if (pointInPolygon(point, hitPolys[keys[i]]))
				return keys[i];
		}
		return null;
	}
	var GetVisibleGraphicContainer = function ()
	{
		return $ptzGraphicContainers.filter(':visible').get(0);
	}

	// PTZ Control display state //
	this.UpdatePtzControlDisplayState = function (loadThumbsOverride)
	{
		var featureEnabled = GetUi3FeatureEnabled("ptzControls");
		LoadPtzPresetThumbs(loadThumbsOverride);
		if (videoPlayer.Loading().image.ptz)
			ptzControlsEnabled = featureEnabled;
		else
		{
			onHoverLeave();
			ptzControlsEnabled = false;
		}
		if (ptzControlsEnabled)
		{
			$ptzControlsContainers.removeAttr("title");
			$ptzPresets.removeClass("disabled");
			$ptzButtons.removeClass("disabled");
			$ptzExtraDropdowns.removeClass("disabled");
			$ptzHome.removeClass("disabled");
			setColor($ptzBackgroundGraphics, $ptzBackgroundGraphics.get(0).defaultColor);
		}
		else
		{
			$ptzControlsContainers.attr("title", featureEnabled ? "PTZ not available for current camera" : "PTZ disabled by user preference");
			$ptzPresets.addClass("disabled");
			$ptzButtons.addClass("disabled");
			$ptzExtraDropdowns.addClass("disabled");
			$ptzHome.addClass("disabled");
			setColor($ptzBackgroundGraphics, ptzpadDisabledColor);
		}
		self.vue().resetGuiButtonState();
		var currentCam = cameraListLoader.GetCameraWithId(videoPlayer.Loading().image.id);
		if (videoPlayer.Loading().image.isLive && currentCam && currentCam.ptzdirect && ptzControlsEnabled)
		{
			$ptzRelativeToggle.removeClass("disabled");
			$ptzRelativeToggle.removeAttr("disabled");
			$ptzRelativeToggle.attr('title', "Clicking this button will toggle 3D Positioning mode, where you can click or drag within a PTZ camera's view to move/zoom the camera.\n\nTo use 3D Positioning without this button activated, use the middle mouse button or hold the CTRL key.");
		}
		else
		{
			$ptzRelativeToggle.addClass("disabled");
			$ptzRelativeToggle.attr("disabled", "disabled");
			$ptzRelativeToggle.attr('title', "3D Positioning is not available from the current camera.\n\nAs of Blue Iris 5.5.6.19, the only PTZ protocol that fully supports 3D positioning is \"Dahua New V4\".");
		}
	}
	this.isEnabledNow = function ()
	{
		return ptzControlsEnabled;
	}
	this.setEnabled = function (enabled)
	{
		self.UpdatePtzControlDisplayState(true);
	}
	this.PresetSet = function (presetNumStr)
	{
		if (!ptzControlsEnabled)
			return;
		if (!videoPlayer.Loading().image.ptz)
			return;
		if (!sessionManager.HasPermission_PtzPresetSet())
		{
			openLoginDialog(function () { self.PresetSet(presetNumStr); });
			return;
		}
		var presetNum = parseInt(presetNumStr);
		var $descInput = $('<input type="text" />');
		$descInput.val(self.GetPresetDescription(presetNum));
		var $question = $('<div style="margin:7px 3px 20px 3px;text-align:center;">Enter a description:<br><br></div>');
		$question.append($descInput);
		AskYesNo($question, function ()
		{
			PTZ_set_preset(presetNum, $descInput.val());
		}, null, toaster.Error, "Set Preset " + presetNum, "Cancel", videoPlayer.Loading().cam.optionDisplay);
	}
	// Enable preset buttons //
	$ptzPresets.each(function (idx, ele)
	{
		var $ele = $(ele);
		ele.presetnum = parseInt($ele.attr("presetnum"));
		$ele.text(ele.presetnum);
		$ele.click(function (e)
		{
			bigThumbHelper.Hide();
			self.PTZ_goto_preset(ele.presetnum);
		});
		if (settings.ui3_contextMenus_trigger !== "Long-Press")
			$ele.longpress(function (e) { self.PresetSet($ele.attr("presetnum")); });
		$ele.on("mouseenter touchstart", function (e)
		{
			if (!ptzControlsEnabled)
				return;

			// Show big preset thumbnail
			var imgData = ptzPresetThumbLoader.GetImgData(videoPlayer.Loading().image.id, ele.presetnum);
			var imgUrl = null;
			var imgW = 0;
			var imgH = 0;
			if (imgData && !imgData.error)
			{
				if (imgData.loaded)
					imgUrl = imgData.imgEle;
				else
					imgUrl = imgData.src;
				imgW = imgData.w;
				imgH = imgData.h;
			}
			bigThumbHelper.Show($ele, $ele.parent(), self.GetPresetDescription(ele.presetnum), imgUrl, imgW, imgH);
		});
		$ele.on("mouseleave touchend touchcancel", function (e)
		{
			bigThumbHelper.Hide();
		});
	});
	$(document).on('touchend touchcancel', function (e)
	{
		bigThumbHelper.Hide();
	});
	// Presets //
	var LoadPtzPresetThumbs = function ()
	{
		var loading = videoPlayer.Loading().image;
		if (loading.ptz && GetUi3FeatureEnabled("ptzControls"))
		{
			ptzPresetThumbLoader.NotifyPtzCameraSelected(loading.id);
			LoadPTZPresetDescriptions(loading.id);
		}
		else
		{
			$ptzPresets.each(function (idx, ele)
			{
				$(ele).text(ele.presetnum);
			});
		}
	}
	this.PTZ_goto_preset = function (presetNumber)
	{
		if (!ptzControlsEnabled)
			return;
		if (!videoPlayer.Loading().image.ptz)
		{
			toaster.Error("Current camera is not PTZ");
			return;
		}
		self.vue().enqueuePtzAction(videoPlayer.Loading().image.id, 100 + parseInt(presetNumber));
	}
	this.PTZ_relative = function (x, y, z, onSuccess, onFail, camData)
	{
		if (!camData)
			camData = videoPlayer.Loading().cam;
		if (!camData.ptz)
		{
			toaster.Error("Current camera is not PTZ");
			return;
		}
		x = Clamp(x, 0, 1);
		y = Clamp(y, 0, 1);
		z = Clamp(z, -1, 1);
		self.vue().enqueuePtzAction(camData.optionValue, 4, { xperc: x, yperc: y, zperc: z }, onSuccess, onFail);
	}
	var PTZ_set_preset = function (presetNumber, description)
	{
		if (!ptzControlsEnabled)
			return;
		if (!videoPlayer.Loading().image.ptz)
		{
			toaster.Error("Current camera is not PTZ");
			return;
		}
		var cameraId = videoPlayer.Loading().image.id;
		if (description == null || description == "")
			description = "Preset " + presetNumber;
		var args = { cmd: "ptz", camera: cameraId, button: (100 + presetNumber), description: description };
		ExecJSON(args, function (response)
		{
			if (response && typeof response.result != "undefined" && response.result == "success")
			{
				RememberPresetDescription(cameraId, presetNumber, description);
				toaster.Success("Preset " + presetNumber + " set successfully.");
				UpdatePresetImage(cameraId, presetNumber);
			}
		}, function ()
		{
			toaster.Error("Unable to save preset");
		});
	}
	var UpdatePresetImage = function (cameraId, presetNumber)
	{
		if (currentServer.isLoggingOut)
			return;

		// Wait a moment in case Blue Iris needs time to save the updated preset image.
		setTimeout(function () { ptzPresetThumbLoader.ReloadPresetImage(cameraId, presetNumber); }, 250);
		setTimeout(function () { ptzPresetThumbLoader.ReloadPresetImage(cameraId, presetNumber); }, 1100);
		setTimeout(function () { ptzPresetThumbLoader.ReloadPresetImage(cameraId, presetNumber); }, 3600);
	}
	var LoadPTZPresetDescriptions = function (cameraId)
	{
		if (currentPtzData && currentPtzData.cameraId == cameraId)
			return;
		ExecJSON({ cmd: "ptz", camera: cameraId }, function (response)
		{
			if (response.result === "fail")
				toaster.ErrorResponse(response);
			else
			{
				if (videoPlayer.Loading().image.id == cameraId)
				{
					/*
						brightness:-1
						contrast:0
						irmode:0
						powermode:-1
						presetnum:15
						presets:[""]
						talksamplerate:8000
					*/
					currentPtzData = response.data;
					if (currentPtzData)
					{
						currentPtzData.presetMap = {};
						if (currentPtzData.presets)
						{
							for (var i = 0; i < currentPtzData.presets.length; i++)
							{
								var objType = typeof currentPtzData.presets[i];
								if (objType === "string")
									currentPtzData.presetMap[i + 1] = MakePresetObj(i + 1, currentPtzData.presets[i]);
								else if (objType === "object")
									currentPtzData.presetMap[parseInt(currentPtzData.presets[i].num)] = currentPtzData.presets[i];
							}
						}
						currentPtzData.cameraId = cameraId;
						self.SetIRButtonState();
						self.SetBrightnessButtonState();
						self.SetContrastButtonState();
					}
				}
			}
		}, function ()
		{
			if (videoPlayer.Loading().image.id == cameraId)
				toaster.Warning("Unable to load PTZ metadata for camera: " + cameraId);
		});
	}
	var MakePresetObj = function (presetNum, description)
	{
		return { num: presetNum, desc: description };
	}
	this.GetPresetDescription = function (presetNum, asAnnotation)
	{
		presetNum = parseInt(presetNum);
		if (presetNum < 0 || presetNum > GetPtzPresetShowCount())
			return asAnnotation ? "" : ("Preset " + presetNum);
		var desc = null;
		if (currentPtzData && currentPtzData.cameraId == videoPlayer.Loading().image.id)
		{
			var obj = currentPtzData.presetMap[presetNum];
			if (obj)
				desc = obj.desc;
		}
		if (desc === null || desc === "" || desc === "(undefined)")
			desc = "Preset " + presetNum;
		if (asAnnotation)
		{
			if (desc.match(/^Preset [0-9]+$/i) == null)
				desc = ' (' + desc + ')';
			else
				desc = '';
		}
		return desc;
	}
	var RememberPresetDescription = function (cameraId, presetNum, description)
	{
		presetNum = parseInt(presetNum);
		if (presetNum < 0 || presetNum > GetPtzPresetShowCount())
			return;
		if (currentPtzData && currentPtzData.cameraId == cameraId)
		{
			currentPtzData.presetMap[presetNum] = MakePresetObj(presetNum, description);
		}
	}
	// PTZ Actions //
	/**
	 * Performs a safe PTZ action (one that will not leave things in a moving state regardless of whether it succeeds or fails).
	 * The function provides no automatic retry in case of failure; use the onSuccess and onFail callback methods to handle the result either way.
	 */
	var PTZ_async_noguarantee = function (cameraId, ptzCmd, extraArgs, onSuccess, onFail)
	{
		if (ptzActionPending)
			throw new Error("PTZ_async_noguarantee called while another call was active.");
		var args = { cmd: "ptz", camera: cameraId, button: parseInt(ptzCmd) };
		if (extraArgs)
			args = $.extend(args, extraArgs);
		ptzActionPending = true;
		ExecJSON(args, function (response)
		{
			ptzActionPending = false;
			try
			{
				if (response && response.result === "success")
				{
					if (typeof onSuccess === "function")
						onSuccess();
				}
				else
				{
					if (typeof onFail !== "function")
						onFail = function (messageHtml) { toaster.Error("PTZ command failed. " + messageHtml); }

					if (!response)
						onFail("No response body.");
					else if (response.result && response.result === "fail")
					{
						if (response.status)
							onFail("Status: " + htmlEncode(response.status));
						else if (response.data && response.data.reason)
							onFail("Reason: " + htmlEncode(response.data.reason));
						else
							onFail("No failure reason was given.");
					}
					else
						onFail("Unexpected response: " + htmlEncode(JSON.stringify(response)));
				}
			}
			finally
			{
				self.vue().ptzChangeRespond();
			}
		}, function (jqXHR, textStatus, errorThrown)
		{
			ptzActionPending = false;
			try
			{
				if (typeof onFail !== "function")
					onFail = function (messageHtml) { toaster.Error("PTZ command failed. " + messageHtml); }
				onFail(jqXHR.ErrorMessageHtml);
			}
			finally
			{
				self.vue().ptzChangeRespond();
			}
		});
	}
	/**
	 * Performs an unsafe PTZ action (one that starts or stops a persistent PTZ movement state, and therefore must be carefully handled).
	 * This function retries automatically until the command receives a "success" response.
	 */
	var PTZ_unsafe_async_guarantee = function (cameraId, ptzCmd, isStop, extraArgs)
	{
		if (ptzActionPending)
			throw new Error("PTZ_unsafe_async_guarantee called while another call was active.");
		var args = { cmd: "ptz", camera: cameraId, button: parseInt(ptzCmd), updown: isStop ? 0 : 1 };
		if (extraArgs)
			args = $.extend(args, extraArgs);
		ptzActionPending = true;
		ExecJSON(args, function (response)
		{
			ptzActionPending = false;
			self.vue().ptzChangeRespond();
		}, function ()
		{
			setTimeout(function ()
			{
				PTZ_unsafe_async_guarantee(cameraId, ptzCmd, isStop, extraArgs);
			}, 100);
		});
	}
	/**
	 * Performs an unsafe PTZ action (one that starts or stops a persistent PTZ movement state, and therefore must be carefully handled).
	 * The command is performed synchronously (pauses page execution) and should only be used if the page is exiting and you need to stop a PTZ motor.
	 * This function retries automatically until the command receives a "success" response.
	 */
	var PTZ_unsafe_sync_guarantee = function (cameraId, ptzCmd, isStop, extraArgs)
	{
		if (ptzActionPending)
			throw new Error("PTZ_unsafe_sync_guarantee called while another call was active.");
		var args = { cmd: "ptz", camera: cameraId, button: parseInt(ptzCmd), updown: isStop ? 0 : 1 };
		if (extraArgs)
			args = $.extend(args, extraArgs);
		ptzActionPending = true;
		ExecJSON(args, function (response)
		{
			ptzActionPending = false;
		}, function ()
		{
			PTZ_unsafe_sync_guarantee(cameraId, ptzCmd, isStop, extraArgs);
		}, true);
	}
	this.Get$PtzPresets = function ()
	{
		return $ptzPresets;
	}
	this.SetIRButtonState = function (irmode)
	{
		if (typeof irmode != "undefined")
			currentPtzData.irmode = irmode;

		if (currentPtzData.irmode == 1)
		{
			$irButtonText.text("*").parent().addClass("yellow");
			$irButtonLabel.text("IR On");
		}
		else if (currentPtzData.irmode == 2)
		{
			$irButtonText.text("A").parent().removeClass("yellow");
			$irButtonLabel.text("IR Auto");
		}
		else // if (currentPtzData.irmode == 0)
		{
			$irButtonText.text("").parent().removeClass("yellow");
			$irButtonLabel.text("IR Off");
		}
	}
	this.SetBrightnessButtonState = function (brightness)
	{
		if (typeof brightness != "undefined")
			currentPtzData.brightness = brightness;
		$brightnessButtonLabel.text("Brightness " + currentPtzData.brightness);
	}
	this.SetContrastButtonState = function (contrast)
	{
		if (typeof contrast != "undefined")
			currentPtzData.contrast = contrast;
		$contrastButtonLabel.text("Contrast " + currentPtzData.contrast);
	}
	// ptzButtonsVue is a vue component that uses reactivity to handle the PTZ button state.
	var ptzButtonsVue = null;
	ptzButtonsVue = new Vue({
		template: '<div id="ptzButtonsVue"></div>',
		data: function ()
		{
			return {
				hotkeyState: CreateBIPtzState(),
				guiButtonState: CreateBIPtzState(),
				joystickState: CreateBIPtzState(),
				oneTimeActionQueue: new Queue(),
				allPtzStates: [],
				unsafe_currentPtzCmd: null, // The button number which is currently activating or activated via the "unsafe"/"updown" method.  This will be "number" type or null.
				unsafe_currentPtzCamId: "", // The camera ID upon which the unsafe_currentPtzCmd was applied. (if not falsy)
				pageExiting: false,
				guiButtonBeingHovered: null,
				currentCamIsPtz: false
			};
		},
		created: function ()
		{
			this.allPtzStates.push(this.hotkeyState);
			this.allPtzStates.push(this.guiButtonState);
			this.allPtzStates.push(this.joystickState);
			ptzButtonsVue = this;
			BI_CustomEvent.AddListener("OpenVideo", function (loading)
			{
				ptzButtonsVue.currentCamIsPtz = loading.ptz;
			});
			BI_CustomEvent.AddListener("VisibilityChanged", this.onVisibilityChanged);
			BI_CustomEvent.AddListener("FinishedLoading", this.ptzChangeRespond);
			window.addEventListener("beforeunload", this.stopUnsafeActionsBeforeUnload);
			window.addEventListener('blur', this.onBrowserLostFocus);
		},
		mounted: function ()
		{
		},
		computed:
		{
			mergedState: function ()
			{
				// Merge the hotkeyState, guiButtonState, joystickState
				var state = CreateBIPtzState();
				var jsExp = settings.ui3_experimental_joystick_api === "1";
				for (var key in state)
				{
					if (Object.prototype.hasOwnProperty.call(state, key))
					{
						if (jsExp)
							state[key] = Math.max(this.hotkeyState[key], this.guiButtonState[key]);
						else
							state[key] = Math.max(this.hotkeyState[key], this.guiButtonState[key], this.joystickState[key]);
					}
				}
				return state;
			},
			guiButtonColors: function ()
			{
				// Derive GUI button colors from hover state and PTZ hotkey/button/joystick/etc state.
				// There are 3 possible colors for each button:
				// default color (button-specific) if not active and not hovered
				// hover color if hovered
				// active color if active
				var hoveredSvgId = this.guiButtonBeingHovered ? this.guiButtonBeingHovered.svgid : null;
				var colors = {};
				for (var i = 0; i < allPtzSvgIds.length; i++)
				{
					var svgId = allPtzSvgIds[i];
					colors[svgId] = null;
					if (hoveredSvgId === svgId)
						colors[svgId] = textHoverColor;
					if (shouldSvgBeActive(svgId))
						colors[svgId] = textActiveColor;
				}
				return colors;
			},
			ptzButtonId: function ()
			{
				var s = this.mergedState;
				var btnId = null;
				if (s.zout)
					btnId = ptzCmds["PTZzoomOut"];
				else if (s.zin)
					btnId = ptzCmds["PTZzoomIn"];
				else if (s.ffar)
					btnId = ptzCmds["PTZfocusSmall"];
				else if (s.fnear)
					btnId = ptzCmds["PTZfocusLarge"];
				else if (s.up)
				{
					if (s.left)
						btnId = ptzCmds["PTZordinalNW"];
					else if (s.right)
						btnId = ptzCmds["PTZordinalNE"];
					else
						btnId = ptzCmds["PTZcardinalUp"];
				}
				else if (s.down)
				{
					if (s.left)
						btnId = ptzCmds["PTZordinalSW"];
					else if (s.right)
						btnId = ptzCmds["PTZordinalSE"];
					else
						btnId = ptzCmds["PTZcardinalDown"];
				}
				else if (s.left)
					btnId = ptzCmds["PTZcardinalLeft"];
				else if (s.right)
					btnId = ptzCmds["PTZcardinalRight"];
				return btnId;
			},
			/**
			 * True if a PTZ motor is believed to be active according to the current state of this object.
			 */
			isMotorRunning: function ()
			{
				return !!(typeof this.unsafe_currentPtzCmd === "number" && this.unsafe_currentPtzCamId);
			},
			previousCamera_pressed: function ()
			{
				return this.joystickState.previousCamera;
			},
			nextCamera_pressed: function ()
			{
				return this.joystickState.nextCamera;
			},
			restartCamera_pressed: function ()
			{
				return this.joystickState.restartCamera;
			}
		},
		methods:
		{
			/**
			 * This method gets called any time the current PTZ state needs to be inspected and handled.
			 */
			ptzChangeRespond: function ()
			{
				if (!loadingHelper.DidLoadingFinish())
					return;
				if (ptzActionPending)
					return;

				var ptzCmd = this.ptzButtonId;
				var loading = videoPlayer.Loading();
				var ptzAvailable = loading.image.ptz && loading.image.isLive;
				if (!ptzAvailable)
				{
					ptzCmd = null; // This will cause any previously-active command to be stopped.
					this.oneTimeActionQueue.clear();
				}
				if (this.pageExiting)
					ptzCmd = null;
				if (this.oneTimeActionQueue.getLength())
					ptzCmd = null; // Stop the currently-active command so we can empty the one-time action queue.

				this.applySvgButtonColors();

				if (typeof ptzCmd !== "number")
				{
					// Based on available inputs, no PTZ action should be active at this time
					if (this.isMotorRunning)
					{
						if (developerMode)
							console.log("Stopping active PTZ action.", ptzSvgIds[this.unsafe_currentPtzCmd]);
						// A PTZ action is currently active, so stop it.
						PTZ_unsafe_async_guarantee(this.unsafe_currentPtzCamId, this.unsafe_currentPtzCmd, true, { stop: true });
						this.unsafe_currentPtzCmd = null;
						this.unsafe_currentPtzCamId = "";
					}
					else if (ptzAvailable)
					{
						var ota = this.oneTimeActionQueue.dequeue();
						if (ota)
							PTZ_async_noguarantee(ota.cameraId, ota.buttonNumber, ota.extraArgs, ota.onSuccess, ota.onFail);
					}
				}
				else if (this.isMotorRunning)
				{
					// A PTZ action is currently active.
					if (ptzCmd === this.unsafe_currentPtzCmd && loading.image.id === this.unsafe_currentPtzCamId)
					{
						// The active PTZ action is the one we want active.  Do not stop it.
					}
					else
					{
						if (developerMode)
							console.log("Stopping active PTZ action to begin another.", ptzSvgIds[this.unsafe_currentPtzCmd]);
						// Stop the active action.
						PTZ_unsafe_async_guarantee(this.unsafe_currentPtzCamId, this.unsafe_currentPtzCmd, true, { stop: true });
						this.unsafe_currentPtzCmd = null;
						this.unsafe_currentPtzCamId = "";
					}
				}
				else if (loading.image.ptz && loading.image.isLive)
				{
					if (developerMode)
						console.log("Starting PTZ action.", ptzSvgIds[ptzCmd]);
					// Start a PTZ action.
					PTZ_unsafe_async_guarantee(loading.image.id, ptzCmd, false);
					this.unsafe_currentPtzCmd = ptzCmd;
					this.unsafe_currentPtzCamId = loading.image.id;
				}
			},
			stopUnsafeActionsBeforeUnload: function (event)
			{
				if (this.isMotorRunning)
				{
					// Cancel the event as stated by the standard.
					event.preventDefault();
					// Chrome requires returnValue to be set.
					event.returnValue = 'Preventing close so a PTZ stop command can be sent'; // This message is not shown to user as of Chrome 129, but maybe in the future or in other browsers?
					// As of Chrome 129, the browser will freeze the page while it asks if the user wants to stay on the page (via modal dialog).
					// The remainder of this function is allowed to execute, and the PTZ stop command does get sent before the modal dialog is closed sent before the user has time to click anything.
					// While the modal dialog is open, the video stream will build up delay.
					// Queue a video stream reload for the next animation frame so that it reloads when the user closes the modal dialog and rendering is allowed to resume.
					this.resetAllButtonState();
					this.ptzChangeRespond();
					SimpleDialog.Text("Window close was prevented so UI3 could send a stop command to an active PTZ motor.\n\nPlease try again.");
					requestAnimationFrame(function () { videoPlayer.ReopenStreamAtCurrentSeekPosition(); });
				}
				else
					ptzButtonsVue.pageExiting = true;
			},
			onVisibilityChanged: function (visibleNow)
			{
				if (!visibleNow && this.isMotorRunning)
				{
					console.log("Stopping PTZ motor due to page no longer being visible");
					this.resetAllButtonState();
					this.ptzChangeRespond();
				}
			},
			onBrowserLostFocus: function (event)
			{
				if (this.isMotorRunning)
				{
					console.log("Stopping PTZ motor due to the browser losing focus");
					this.resetAllButtonState();
					this.ptzChangeRespond();
				}
			},
			/**
			 * Returns true if the given SVG ID from the PTZ pad should be displayed in its "active" style due to currently known inputs.
			 */
			shouldSvgBeActive: function (svgId)
			{
				var stateKeys = ptzStateKeys[svgId];
				var allPtzStates = this.allPtzStates;
				var anyOk = false;
				for (var i = 0; i < stateKeys.length; i++)
				{
					var key = stateKeys[i];
					var isOk = false;
					for (var j = 0; j < allPtzStates.length; j++)
					{
						var state = allPtzStates[j];
						if (state[key] > 0)
						{
							isOk = true;
							break;
						}
					}
					if (!isOk)
						return false;
					anyOk = true;
				}
				return anyOk;
			},
			applySvgButtonColors: function ()
			{
				var visibleGraphicContainer = GetVisibleGraphicContainer();
				if (!visibleGraphicContainer)
					return;

				var hoveredSvgId = this.guiButtonBeingHovered ? this.guiButtonBeingHovered.svgid : null;
				for (var i = 0; i < allPtzSvgIds.length; i++)
				{
					var svgId = allPtzSvgIds[i];
					var ele = visibleGraphicContainer.graphicObjects[svgId];
					if (!ele)
						continue;
					var desiredColor = ele.defaultColor;
					if (hoveredSvgId === svgId)
						desiredColor = textHoverColor;
					if (this.shouldSvgBeActive(svgId))
						desiredColor = textActiveColor;
					var $ele = $(ele);
					if ($ele.hasClass(desiredColor))
						continue;
					setColor($ele, desiredColor);
				}
			},
			resetGuiButtonState: function ()
			{
				for (var key in this.guiButtonState)
				{
					if (this.guiButtonState.hasOwnProperty(key))
					{
						this.guiButtonState[key] = 0;
					}
				}
				this.applySvgButtonColors();
			},
			resetAllButtonState: function ()
			{
				for (var i = 0; i < this.allPtzStates.length; i++)
				{
					var state = this.allPtzStates[i];
					for (var key in state)
					{
						if (state.hasOwnProperty(key))
						{
							state[key] = 0;
						}
					}
				}
				this.applySvgButtonColors();
			},
			/**
			 * Enqueues a PTZ action to occur safely and as soon as possible.  If there is an active PTZ action (e.g. panning motor), that action will be temporarily stopped so this queued action can execute safely without throwing Blue Iris's camera instance into a bad state.
			 * @param {String} cameraId Camera short name (ID)
			 * @param {Number} buttonNumber PTZ command button number
			 * @param {Object} extraArgs Extra arguments to the ptz command.  Use with care.
			 * @param {Function} onSuccess Callback to be called upon success.
			 * @param {Function} onFail Callback to be called upon failure.
			 */
			enqueuePtzAction: function (cameraId, buttonNumber, extraArgs, onSuccess, onFail)
			{
				var ota = { cameraId: cameraId, buttonNumber: buttonNumber, extraArgs: extraArgs, onSuccess: onSuccess, onFail: onFail };
				this.oneTimeActionQueue.enqueue(ota);
				this.ptzChangeRespond();
			}
		},
		watch:
		{
			//mergedState: {
			//	deep: true,
			//	handler: function (newValue, oldValue)
			//	{
			//		console.log("hotkeyState", this.hotkeyState);
			//		console.log("merged state", this.mergedState);
			//		console.log("ptzButtonId", this.ptzButtonId);
			//	}
			//},
			ptzButtonId: function (newBtnId, oldBtnId)
			{
				this.ptzChangeRespond();
			},
			guiButtonBeingHovered: function (newBtn, oldBtn)
			{
				this.applySvgButtonColors();
			},
			currentCamIsPtz: function ()
			{
				this.ptzChangeRespond();
			},
			previousCamera_pressed: function ()
			{
				if (this.previousCamera_pressed)
					BI_Hotkey_PreviousCamera();
			},
			nextCamera_pressed: function ()
			{
				if (this.nextCamera_pressed)
					BI_Hotkey_NextCamera();
			},
			restartCamera_pressed: function ()
			{
				if (this.restartCamera_pressed)
				{
					var img = videoPlayer.Loading().image;
					if (img.isLive && cameraListLoader.CameraIsAlone(videoPlayer.Loading().cam))
						ResetCamera(img.id);
					else
						videoPlayer.ReopenStreamAtCurrentSeekPosition();
				}
			}
		}
	});
	/**
	 * Gets the Vue component that handles sending PTZ movement commands to Blue Iris in reaction to user inputs.
	 */
	this.vue = function ()
	{
		return ptzButtonsVue;
	}
}
///////////////////////////////////////////////////////////////
// Relative PTZ GUI ///////////////////////////////////////////
///////////////////////////////////////////////////////////////
function RelativePTZ()
{
	var self = this;
	var initialized = false;
	var enabled3dPositioning = false;
	var pos3dX = 0;
	var pos3dY = 0;
	var pos3dDragging = false;
	var box = $("#relativeptzbox");
	var $camimg_wrapper = $("#camimg_wrapper");
	var currentCam = undefined;

	function Initialize()
	{
		if (initialized)
			return;
		initialized = true;

		BindEvents($camimg_wrapper.get(0), 'mousedown touchstart', ImageArea_MouseDown);
		BindEvents(document, 'mousemove touchmove', MouseMove);
		BindEvents(document, 'mouseleave', function (e)
		{
			mouseCoordFixer.fix(e);
			EndPos3dDragging(e.mouseX, e.mouseY);
		});
		BindEvents(document, 'mouseup touchend', function (e)
		{
			mouseCoordFixer.fix(e);
			EndPos3dDragging(e.mouseX, e.mouseY);
		});
		BindEvents(document, 'touchcancel', function (e)
		{
			mouseCoordFixer.fix(e);
			pos3dDragging = false;
			hideRelPtzBox();
		});
	}
	function EndPos3dDragging(mx, my)
	{
		if (pos3dDragging)
		{
			pos3dDragging = false;
			hideRelPtzBox();

			var boxSpec = { x: pos3dX, y: pos3dY, w: mx - pos3dX, h: my - pos3dY };

			var w = mx - pos3dX;
			var h = my - pos3dY;

			if (Math.abs(w) < 10 && Math.abs(h) < 10)
				w = h = 0;

			var imgFrameOffset = $camimg_wrapper.offset();
			var zoomFactor = imageRenderer.zoomHandler.GetZoomFactor();
			var imgFrameW = $camimg_wrapper.width() * zoomFactor;
			var imgFrameH = $camimg_wrapper.height() * zoomFactor;
			var loaded = videoPlayer.Loaded();
			if (!iEquals(loaded.cam.optionValue, currentCam.optionValue))
			{
				// [loaded.cam] is a group view where the user has middle-clicked on ptz camera [currentCam].
				// Adjust the calculations to be relative to the camera's frame.
				var cams = cameraListLoader.GetGroupCams(loaded.cam.optionValue);
				var rects = cameraListLoader.GetGroupRects(loaded.cam.optionValue);
				for (var i = 0; i < cams.length; i++)
				{
					if (iEquals(cams[i], currentCam.optionValue))
					{
						// This code is mostly copied from CameraNameLabels
						var rect = rects[i];
						var nativeRes = cameraListLoader.isDynamicLayoutEnabled(loaded.image.id)
							? loaded.image.getActualRect()
							: loaded.image.getFullRect();
						var scaleX = imageRenderer.GetPreviousImageDrawInfo().w / nativeRes.w;
						var scaleY = imageRenderer.GetPreviousImageDrawInfo().h / nativeRes.h;
						var adjX = rect[0] * scaleX;
						var adjY = rect[1] * scaleY;
						var adjW = (rect[2] - rect[0]) * scaleX;
						var adjH = (rect[3] - rect[1]) * scaleY;

						imgFrameOffset.top += adjY;
						imgFrameOffset.left += adjX;
						imgFrameW = adjW;
						imgFrameH = adjH;
						break;
					}
				}
			}
			var z = Math.max(Math.abs(w / imgFrameW), Math.abs(h / imgFrameH));
			if (w < 0)
				z *= -1;
			var xperc = ((pos3dX - imgFrameOffset.left) + (w / 2)) / imgFrameW;
			var yperc = ((pos3dY - imgFrameOffset.top) + (h / 2)) / imgFrameH;

			ptzButtons.PTZ_relative(xperc, yperc, z, function () { self.flashRelPtzBox(boxSpec.x, boxSpec.y, boxSpec.w, boxSpec.h); }, undefined, currentCam);
		}
	}
	function Precon_3dPos(e)
	{
		if (!videoPlayer.Loading().image.isLive)
			return false;

		if ((e.which === 2 || enabled3dPositioning || (e.getModifierState && e.getModifierState("Control"))))
		{
			mouseCoordFixer.fix(e); // <- Doing this at the wrong time creates havoc when doing two-finger zooming on touchscreens.
			currentCam = cameraListLoader.GetCameraWithId(videoPlayer.Loading().image.id);
			videoPlayer.DoThingIfImgClickEligible(e, function (camData)
			{
				currentCam = camData;
			});

			return !!(currentCam && currentCam.ptz && currentCam.ptzdirect);
		}
		return false;
	}
	function ImageArea_MouseDown(e)
	{
		if (pos3dDragging)
		{
			pos3dDragging = false;
			hideRelPtzBox();
			return;
		}
		if (Precon_3dPos(e))
		{
			videoPlayer.suppressMouseHelper(true);
			pos3dX = e.mouseX;
			pos3dY = e.mouseY;
			pos3dDragging = true;
			e.preventDefault();
			e.stopPropagation();
		}
	}
	function ImageArea_MouseLeave(e)
	{
		mouseCoordFixer.fix(e);
		var ofst = $camimg_wrapper.offset();
		var zoomFactor = imageRenderer.zoomHandler.GetZoomFactor();
		var imgFrameW = $camimg_wrapper.width() * zoomFactor;
		var imgFrameH = $camimg_wrapper.height() * zoomFactor;
		if (e.mouseX < ofst.left || e.mouseY < ofst.top || e.mouseX >= ofst.left + imgFrameW || e.mouseY >= ofst.top + imgFrameH)
		{
			EndPos3dDragging(e.mouseX, e.mouseY);
		}
	}
	function MouseMove(e)
	{
		mouseCoordFixer.fix(e);
		if (pos3dDragging)
			showRelPtzBox(pos3dX, pos3dY, e.mouseX - pos3dX, e.mouseY - pos3dY);
	}
	function showRelPtzBox(x, y, w, h)
	{
		if (developerMode)
		{
			var imgFrameOffset = $camimg_wrapper.offset();
			var zoomFactor = imageRenderer.zoomHandler.GetZoomFactor();
			var imgFrameW = $camimg_wrapper.width() * zoomFactor;
			var imgFrameH = $camimg_wrapper.height() * zoomFactor;
			var z = Math.max(Math.abs(w / imgFrameW), Math.abs(h / imgFrameH));
			if (w < 0)
				z *= -1;
			var xperc = ((pos3dX - imgFrameOffset.left) + (w / 2)) / imgFrameW;
			var yperc = ((pos3dY - imgFrameOffset.top) + (h / 2)) / imgFrameH;

			box.html('<div class="relativePtzDebugText">'
				+ 'X: ' + xperc.toFixed(3)
				+ ', Y: ' + yperc.toFixed(3)
				+ ', Z: ' + z.toFixed(3)
				+ ', imgFrameW: ' + imgFrameW.toFixed(3)
				+ ', imgFrameH: ' + imgFrameH.toFixed(3)
				+ '</div > ');
		}
		else
			box.html('');

		var blueBox = false;
		if (w < 0)
		{
			x += w;
			w *= -1;
			blueBox = true;
		}
		if (h < 0)
		{
			y += h;
			h *= -1;
		}
		box.css("border-color", blueBox ? "Blue" : "Red");
		box.css("left", (x - 3) + "px");
		box.css("top", (y - 3) + "px");
		box.css("width", (w) + "px");
		box.css("height", (h) + "px");

		box.stop(true, true);
		box.show();
	}
	function hideRelPtzBox()
	{
		box.stop(true, true);
		box.hide();
	}
	this.flashRelPtzBox = function (x, y, w, h)
	{
		if (box.is(':visible'))
			return;
		showRelPtzBox(x, y, w, h);
		box.fadeOut(1000);
	}
	this.enable3dPositioning = function ()
	{
		if (!enabled3dPositioning)
			self.toggle3dPositioning();
	}
	this.disable3dPositioning = function ()
	{
		if (enabled3dPositioning)
			self.toggle3dPositioning();
	}
	this.toggle3dPositioning = function ()
	{
		enabled3dPositioning = !enabled3dPositioning;
		self.setToggleButtonState();
	}
	this.setToggleButtonState = function (forceTurnedOn)
	{
		if (enabled3dPositioning || forceTurnedOn)
			$("#ptzRelativeToggle").addClass("turnedon");
		else
			$("#ptzRelativeToggle").removeClass("turnedon");
	}

	Initialize();
}
///////////////////////////////////////////////////////////////
// PtzPresetThumbLoader ///////////////////////////////////////
///////////////////////////////////////////////////////////////
var ptzPresetThumbLoader = new (function ()
{
	var self = this;
	// A two-level cache.  The first level is a map of camera names.  The second level is a map of preset numbers to image elements.
	var cache = {};
	var asyncThumbLoader = null;

	var Initialize = function ()
	{
		if (asyncThumbLoader)
			return;
		asyncThumbLoader = new AsyncPresetThumbnailDownloader(thumbLoaded, thumbError);
	}
	/** Call this when a PTZ camera is selected so the thumbnails can begin loading (unless they are already cached). */
	this.NotifyPtzCameraSelected = function (cameraId)
	{
		if (!CameraIsEligible(cameraId))
			return;

		var camCache = cache[cameraId];
		if (!camCache)
		{
			camCache = cache[cameraId] = {}; // Note: cache and camCache are maps, not arrays.
			var count = GetPtzPresetShowCount();
			for (var i = 1; i <= count; i++)
			{
				var $img = $('<img src="" alt="' + i + '" class="presetThumb" />');
				$img.hide();
				var img = camCache[i] = $img[0];
				// Unfortunately, we can't allow the browser cache to be used for these, or the cached images become stale when updated and reloading the page doesn't fix it.
				img.imgData = {
					src: self.UrlForPreset(cameraId, i, true),
					w: 0,
					h: 0,
					imgEle: img
				};
				asyncThumbLoader.VisiblePath(img, img.imgData.src);
			}
		}
		ptzButtons.Get$PtzPresets().each(function (idx, ele)
		{
			var $ele = $(ele).empty();
			var img = camCache[ele.presetnum];
			if (img.imgData.w == 0)
				$ele.append('<span>' + ele.presetnum + '</span>')
			$ele.append(img);
		});
	}
	/** Force-reloads a preset image from the server. */
	this.ReloadPresetImage = function (cameraId, presetNumber)
	{
		if (currentServer.isLoggingOut)
			return false;

		if (presetNumber < 1 || presetNumber > GetPtzPresetShowCount())
			return;
		var camCache = cache[cameraId];
		if (camCache)
		{
			var img = camCache[presetNumber];
			img.imgData.src = self.UrlForPreset(cameraId, presetNumber, true);
			asyncThumbLoader.VisiblePath(img, img.imgData.src);
		}
		else
			self.NotifyPtzCameraSelected(cameraId); // This case shouldn't happen.
	}
	this.GetImgData = function (cameraId, presetNumber)
	{
		if (presetNumber >= 1 && presetNumber <= GetPtzPresetShowCount())
		{
			var camCache = cache[cameraId];
			if (camCache)
				return camCache[presetNumber].imgData;
		}
		return null;
	}
	var thumbLoaded = function (img)
	{
		if (img.complete && typeof img.naturalWidth != "undefined" && img.naturalWidth > 0)
		{
			img.imgData.error = false;
			img.imgData.w = img.naturalWidth
			img.imgData.h = img.naturalHeight;
			img.imgData.loaded = true;
			var $img = $(img);
			$img.prev('span').remove();
			$img.show();
			try
			{
				var remainder = img.getBoundingClientRect().height % 1;
				if (remainder != 0)
					$thumb.css("padding-bottom", (1 - remainder) + "px");
			}
			catch (ex) { }
		}
		else
			img.imgData.error = true;
	}
	var thumbError = function (img)
	{
		img.imgData.error = true;
	}
	this.UrlForPreset = function (cameraId, presetNumber, overrideCache)
	{
		if (presetNumber < 1 || presetNumber > GetPtzPresetShowCount())
			return "";
		var sessionArg = currentServer.GetAPISessionArg("?");
		var cacheArg = overrideCache ? ((sessionArg ? "&" : "?") + "cache=" + Date.now()) : "";
		return currentServer.remoteBaseURL + "image/" + cameraId + "/preset_" + presetNumber + ".jpg" + sessionArg + cacheArg;
	}
	var CameraIsEligible = function (cameraId)
	{
		if (currentServer.isLoggingOut)
			return false;
		var loading = videoPlayer.Loading().image;
		if (cameraId != loading.id)
			return false;
		if (!loading.ptz)
			return false;
		if (!GetUi3FeatureEnabled("ptzControls"))
			return false;
		Initialize();
		return true;
	}
})();
///////////////////////////////////////////////////////////////
// Gamepad PTZ ////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function GamepadPtzController()
{
	var self = this;
	var states = new FasterObjectMap();
	var startedLoop = false;
	// Button ID constants
	var UP = 12;
	var DOWN = 13;
	var LEFT = 14;
	var RIGHT = 15;
	var A = 0;
	var B = 1;
	var X = 2;
	var Y = 3;
	var gamepadPreviewStyle = InjectStyleBlock("");
	var existingGamepadStyle = "";
	var existingGamepadTestOutputHtml = "";

	BI_CustomEvent.AddListener("UI_Settings_Refreshed", function ()
	{
		existingGamepadTestOutputHtml = "";
	});

	function Initialize()
	{
		if (gamepad_api_supported)
		{
			window.addEventListener("gamepadconnected", gamepadConnected);
			window.addEventListener("gamepaddisconnected", gamepadDisconnected);
			console.log("Gamepad API initialized.");
			//var arr = navigator.getGamepads();
			//if (arr)
			//	for (var i = 0; i < arr.length; i++)
			//		addGamepad(arr[i]);
		}
	}

	function gamepadConnected(e)
	{
		addGamepad(e.gamepad);

		if (!startedLoop)
		{
			requestAnimationFrame(gamepadLoop);
			startedLoop = true;
		}
	}

	function gamepadDisconnected(e)
	{
		delete states[e.gamepad.index];
		console.log(
			"Gamepad disconnected from index %d: %s",
			e.gamepad.index,
			e.gamepad.id
		);
	}

	function addGamepad(gamepad)
	{
		if (gamepad)
		{
			states[gamepad.index] = new UI3GamepadState();

			console.log(
				"Gamepad connected at index %d: %s. %d buttons, %d axes.",
				gamepad.index,
				gamepad.id,
				gamepad.buttons.length,
				gamepad.axes.length
			);
		}
	}

	//function removeGamepad(gamepad)
	//{
	//	if (gamepad)
	//	{
	//		for (var i = 0; i < wrappers.length; i++)
	//			if (wrappers[i] === gamepad)
	//				wrappers.splice(i, 1);
	//	}
	//}

	function gamepadLoop()
	{
		var arr = navigator.getGamepads();
		for (var i = 0; i < arr.length; i++)
		{
			try
			{
				var gamepad = arr[i];
				if (gamepad)
				{
					var state = states[gamepad.index];
					if (!state)
					{
						states[gamepad.index] = state = new UI3GamepadState();
						console.log("Gamepad at index " + gamepad.index + " was discovered during loop iteration.");
					}
					state.handleInputs(gamepad);
				}
			}
			catch (ex)
			{
				toaster.Error(ex);
			}
		}
		try
		{
			if (settings.ui3_gamepad_ptz_enabled === "1")
			{
				if (uiSettingsPanel.isOpen())
				{
					UpdateGamepadPreview(arr);
					ClearJoystickInputStates();
				}
				else 
				{
					var state = ptzButtons.vue().joystickState;
					state.zout = Math.max(ReadBinding(settings.ui3_gamepad_binding_zoom_out), ReadBinding(settings.ui3_gamepad_binding_zoom_out2));
					state.zin = Math.max(ReadBinding(settings.ui3_gamepad_binding_zoom_in), ReadBinding(settings.ui3_gamepad_binding_zoom_in2));
					state.fnear = Math.max(ReadBinding(settings.ui3_gamepad_binding_focus_near), ReadBinding(settings.ui3_gamepad_binding_focus_near2));
					state.ffar = Math.max(ReadBinding(settings.ui3_gamepad_binding_focus_far), ReadBinding(settings.ui3_gamepad_binding_focus_far2));
					state.up = Math.max(ReadBinding(settings.ui3_gamepad_binding_tilt_up), ReadBinding(settings.ui3_gamepad_binding_tilt_up2));
					state.down = Math.max(ReadBinding(settings.ui3_gamepad_binding_tilt_down), ReadBinding(settings.ui3_gamepad_binding_tilt_down2));
					state.left = Math.max(ReadBinding(settings.ui3_gamepad_binding_pan_left), ReadBinding(settings.ui3_gamepad_binding_pan_left2));
					state.right = Math.max(ReadBinding(settings.ui3_gamepad_binding_pan_right), ReadBinding(settings.ui3_gamepad_binding_pan_right2));
					state.previousCamera = !!ReadBinding(settings.ui3_gamepad_binding_previous_camera);
					state.nextCamera = !!ReadBinding(settings.ui3_gamepad_binding_next_camera);
					state.restartCamera = !!ReadBinding(settings.ui3_gamepad_binding_restart_camera);

					if (settings.ui3_experimental_joystick_api === "1")
					{
						var X = 0;
						if (state.left >= state.right)
							X = -state.left;
						else
							X = state.right;
						var Y = 0;
						if (state.up >= state.down)
							Y = -state.up;
						else
							Y = state.down;
						PTZ_Joystick_Input(X, Y, state.zin, state.zout);
						ptzButtons.vue().applySvgButtonColors();
					}
				}
			}
		}
		catch (ex)
		{
			toaster.Error(ex);
		}
		requestAnimationFrame(gamepadLoop);
	}
	function ClearJoystickInputStates()
	{
		var state = ptzButtons.vue().joystickState;
		state.zout = 0;
		state.zin = 0;
		state.ffar = 0;
		state.fnear = 0;
		state.up = 0;
		state.down = 0;
		state.left = 0;
		state.right = 0;
		state.previousCamera = false;
		state.nextCamera = false;
		state.restartCamera = false;

		if (settings.ui3_experimental_joystick_api === "1")
		{
			PTZ_Joystick_Input(0, 0, 0, 0);
			ptzButtons.vue().applySvgButtonColors();
		}
	}
	function ReadBinding(binding)
	{
		if (typeof binding !== "string")
			return 0;
		if (binding.indexOf("button ") === 0)
		{
			var buttonIndex = parseInt(binding.substr("button ".length));
			if (!isNaN(buttonIndex))
			{
				return firstNonFalsy(GetAnalogButtonValue(buttonIndex), 0);
			}
		}
		else if (binding.indexOf("axis ") === 0)
		{
			var axisIndex = parseInt(binding.substr("axis ".length));
			if (!isNaN(axisIndex))
			{
				var v = firstNonFalsy(GetAxisValue(axisIndex), 0);
				if (v)
				{
					var negative = binding.indexOf("-") > 0;
					if (negative && v < 0)
						return -v;
					else if (!negative && v > 0)
						return v;
				}
				return 0;
			}
		}
		return 0;
	}
	function IsButtonPressed(buttonIndex)
	{
		for (var key in states)
		{
			var state = states[key];
			if (state.IsButtonPressed(buttonIndex))
				return true;
		}
	}
	/**
	 * Gets the current value of the specified analog button.  Across all connected controllers, the controller with the largest absolute value of the button position is the one whose value is returned.  May return undefined if no connected controller reports having a value for this button.
	 * @param {Number} buttonIndex Button index (0-based)
	 */
	function GetAnalogButtonValue(buttonIndex)
	{
		var best = undefined;
		var bestAbs = 0;
		for (var key in states)
		{
			var state = states[key];
			var value = state.GetAnalogButtonValue(buttonIndex);
			var absValue = Math.abs(value);
			if (absValue > bestAbs)
			{
				bestAbs = absValue;
				best = value;
			}
		}
		return best;
	}
	function IsSimpleAnalogDirectionHeld(direction)
	{
		var limit = 0.5;
		var nlimit = limit * -1;
		if (direction === LEFT)
			return GetAxisValue(0) <= nlimit;
		else if (direction === RIGHT)
			return GetAxisValue(0) >= limit;
		else if (direction === UP)
			return GetAxisValue(1) <= nlimit;
		else if (direction === DOWN)
			return GetAxisValue(1) >= limit;
		return false;
	}
	/**
	 * Gets the current value of the specified axis.  Across all connected controllers, the controller with the largest absolute value of the axis position is the one whose value is returned.  May return undefined if no connected controller reports having a value for this axis.
	 * @param {Number} axisIndex Axis index (0-based)
	 */
	function GetAxisValue(axisIndex)
	{
		var best = undefined;
		var bestAbs = 0;
		for (var key in states)
		{
			var state = states[key];
			var value = state.GetAxisValue(axisIndex);
			var absValue = Math.abs(value);
			if (absValue > bestAbs)
			{
				bestAbs = absValue;
				best = value;
			}
		}
		return best;
	}
	function UpdateGamepadPreview(gamepads)
	{
		var htmlParts = [];
		var buttons = [];
		var styleParts = [];

		for (var i = 0; i < gamepads.length; i++)
		{
			try
			{
				var gamepad = gamepads[i];
				if (gamepad)
					htmlParts.push("<div>Gamepad " + (i + 1) + ": " + gamepad.id + "</div>");
			}
			catch (ex)
			{
				toaster.Error(ex);
			}
		}

		// Read axis inputs
		var a0 = firstNonFalsy(GetAxisValue(0), 0);
		var a1 = firstNonFalsy(GetAxisValue(1), 0);
		var a2 = firstNonFalsy(GetAxisValue(2), 0);
		var a3 = firstNonFalsy(GetAxisValue(3), 0);
		if (a0 || a1)
		{
			if (a0)
			{
				if (a0 < 0)
					buttons.push("axis 0 -");
				else
					buttons.push("axis 0 +");
			}
			if (a1)
			{
				if (a1 < 0)
					buttons.push("axis 1 -");
				else
					buttons.push("axis 1 +");
			}
			styleParts.push("#ui3gamepad_preview .b10 { fill: #888888 !important; transform: translate(" + (a0 * 20) + "px, " + (a1 * 20) + "px); }");
		}
		if (a2 || a3)
		{
			if (a2)
			{
				if (a2 < 0)
					buttons.push("axis 2 -");
				else
					buttons.push("axis 2 +");
			}
			if (a3)
			{
				if (a3 < 0)
					buttons.push("axis 3 -");
				else
					buttons.push("axis 3 +");
			}
			styleParts.push("#ui3gamepad_preview .b11 { fill: #888888 !important; transform: translate(" + (a2 * 20) + "px, " + (a3 * 20) + "px); }");
		}

		// Read button inputs
		for (var b = 0; b < 16; b++)
		{
			var v = GetAnalogButtonValue(b);
			if (v > 0)
			{
				buttons.push(b);
				var color = "hsl(0deg, 0%, " + (30 + (v * 70)) + "%)";
				styleParts.push("#ui3gamepad_preview .b" + b + " { fill: " + color + " !important; }");
			}
		}

		htmlParts.push("<div>Buttons: " + buttons.join(", ") + "</div>");

		var gamepadStyle = styleParts.join('\n');
		if (gamepadStyle !== existingGamepadStyle)
		{
			existingGamepadStyle = gamepadStyle;
			gamepadPreviewStyle(gamepadStyle);
		}

		var newGamepadTestOutputHtml = htmlParts.join("\n");
		if (newGamepadTestOutputHtml !== existingGamepadTestOutputHtml)
		{
			var ele = document.getElementById("ui3gamepadTestOutput");
			if (ele)
			{
				existingGamepadTestOutputHtml = newGamepadTestOutputHtml;
				ele.innerHTML = newGamepadTestOutputHtml;
			}
		}
	}
	Initialize();
}
function GetGamepadAnalogDeadzone()
{
	return Clamp(parseFloat(settings.ui3_gamepad_analog_deadzone), 0.01, 0.99);
}
function UI3GamepadState()
{
	var self = this;
	var lastButtons = [];
	var lastAxes = [];
	var deadzone = GetGamepadAnalogDeadzone();

	this.handleInputs = function (gamepad)
	{
		deadzone = GetGamepadAnalogDeadzone();
		for (var i = 0; i < gamepad.axes.length; i++)
		{
			var axis = gamepad.axes[i];
			axis = NormalizeAnalog(axis);

			var lastAxis;
			if (lastAxes.length > i)
				lastAxis = lastAxes[i];
			else
				lastAxes.push(lastAxis = 0);
			lastAxes[i] = axis;

			if (axis !== 0 && lastAxis === 0)
				BI_CustomEvent.Invoke("GamepadAction", { key: "axis " + i + " " + (axis < 0 ? "-" : "+"), value: axis });
		}
		for (var i = 0; i < gamepad.buttons.length; i++)
		{
			var button = gamepad.buttons[i];
			button = { pressed: button.pressed, value: NormalizeAnalog(button.value) };

			var lastButton;
			if (lastButtons.length > i)
				lastButton = lastButtons[i];
			else
				lastButtons.push(lastButton = { pressed: false, value: 0 });
			lastButtons[i] = button;

			if (button.pressed && !lastButton.pressed)
				BI_CustomEvent.Invoke("GamepadAction", { key: "button " + i, value: button.value });
		}
	}
	function NormalizeAnalog(value)
	{
		if (Math.abs(value) < deadzone)
			return 0;
		var negative = value < 0;
		value = Math.abs(value);
		var normalized = (value - deadzone) / (1 - deadzone);
		return negative ? -normalized : normalized;
	}

	this.IsButtonPressed = function (buttonIndex)
	{
		var state = lastButtons[buttonIndex];
		if (state)
			return state.pressed;
		return false;
	};
	this.GetAxisValue = function (axisIndex)
	{
		if (axisIndex >= 0 && axisIndex < lastAxes.length)
			return lastAxes[axisIndex];
		return undefined;
	};
	this.GetAnalogButtonValue = function (buttonIndex)
	{
		var state = lastButtons[buttonIndex];
		if (state)
			return state.value;
		return false;
	};
}
function TranslateJoystickInputsIntoBitmask(axisX, axisY, axisZoomIn, axisZoomOut)
{
	function axisValueToSpeed(a)
	{
		var scaledUp = Clamp(Math.round(Math.abs(a) * 15), 1, 15);
		scaledUp = ~~scaledUp; // cast to int
		return scaledUp & 15; // 15 is 0b1111;
	}
	var dbg = "";// "axisX " + axisX + ", axisY " + axisY;
	var bitmask = 0;
	if (axisZoomIn > 0)
	{
		bitmask |= (1 << 13);
		bitmask |= axisValueToSpeed(axisZoomIn) << 4;
		dbg += " zoom in " + axisValueToSpeed(axisZoomIn);
	}
	else if (axisZoomOut > 0)
	{
		bitmask |= (1 << 14);
		bitmask |= axisValueToSpeed(axisZoomOut) << 4;
		dbg += " zoom out " + axisValueToSpeed(axisZoomOut);
	}
	if (bitmask === 0)
	{
		if (axisY < 0)
		{
			bitmask |= (1 << 11); // tilt up
			bitmask |= axisValueToSpeed(axisY);
			dbg += " up " + axisValueToSpeed(axisY);
		}
		else if (axisY > 0)
		{
			bitmask |= (1 << 12); // tilt down
			bitmask |= axisValueToSpeed(axisY);
			dbg += " down " + axisValueToSpeed(axisY);
		}

		if (axisX < 0)
		{
			bitmask |= (1 << 10); // pan left
			bitmask |= axisValueToSpeed(axisX) << 4;
			dbg += " left " + axisValueToSpeed(axisX);
		}
		else if (axisX > 0)
		{
			bitmask |= (1 << 9); // pan right
			bitmask |= axisValueToSpeed(axisX) << 4;
			dbg += " right " + axisValueToSpeed(axisX);
		}
	}
	if (joystickDebug)
		console.log(dbg);

	//bitmask = reverseBits(bitmask);
	//// Endian Swap //
	//var lsb = bitmask & 0b11111111;
	//var msb = bitmask & 0b1111111100000000;
	//bitmask = (lsb << 8) | (msb >> 8);
	///////////////////

	if (bitmask === 0)
	{
		if (joystickDebugToast)
		{
			joystickDebugToast.remove();
			joystickDebugToast = null;
		}
	}
	else if (!joystickDebugToast)
		joystickDebugToast = toaster.Info('<div id="joystickDebugToast" style="white-space:pre-wrap"></div>', 99999999, false, null, 99999999);
	$("#joystickDebugToast").text("Joystick: " + bitmask + "\n"
		+ "Binary: " + dec2bin(bitmask).padLeft(16, "0") + "\n"
		+ "English: " + dbg);
	return bitmask;
}
var joystickDebug = false;
var lastJoystickValue = null;
var isSendingJoystickCommand = false;
var joystickDebugToast = null;
function reverseBits(num)
{
	var reversed = num.toString(2);
	var padding = "0";
	reversed = padding.repeat(16 - reversed.length) + reversed;
	return parseInt(reversed.split('').reverse().join(''), 2);
}
function PTZ_Joystick_Input(axisX, axisY, axisZoomIn, axisZoomOut)
{
	if (isSendingJoystickCommand)
		return;
	var loading = videoPlayer.Loading();
	if (loading.image.ptz && loading.image.isLive)
	{
		var jsVal = TranslateJoystickInputsIntoBitmask(axisX, axisY, axisZoomIn, axisZoomOut);
		if (jsVal != lastJoystickValue)
		{
			var args = { cmd: "ptz", camera: loading.image.id, joystick: jsVal };
			console.log("Sending PTZ joystick # " + dec2bin(jsVal).padLeft(16, "0"));
			isSendingJoystickCommand = true;
			ExecJSON(args, function (response)
			{
				isSendingJoystickCommand = false;
				lastJoystickValue = jsVal;
			}, function ()
			{
				isSendingJoystickCommand = false;
			});
		}
	}
}

///////////////////////////////////////////////////////////////
// Timeline ///////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var timelineDeveloperMode = false;
/**
	A value that is added to the zoomScaler when requesting timeline data, to affect precision.
	+2 for 0.25x precision
	+1 for 0.5x precision
	-1 for 2x precision
	-2 for 4x precision
 */
var timelineDataZoomMultiplier = 0;
var timelineAlertImgSrc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAMAAADNlS1EAAABd1BMVEVHcEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
	+ "FAQAAAAAAAAAAAAADAAAAAAAAAAAAAAAUAwA1DQAZBAANAgAKAQAMAQAAAAAAAAAAAAAJAQBmIQAqCQBVGgD/XwD8XgD9XgBhHwD7XQD6XQD4XADRTACPMgB7KgBpIgDSTAD+XwAAAADO"
	+ "SwBiHwDuWAD2WwA5DwC9RABbHQDNSwBPGAD+XgDxWQD0WwCvPgDjVAD1WwCZNQDZTwBEEwAyDABvJQAuCwDpVgB+KwCXNQBXGwDRTQB1JwD3XABwJQB4KABtJABoIgDWTgBBEgDhUwDTT"
	+ "QCyQABzJgDtWADkVAAhBgDgUwDeUgDdUQBdHQDaUACbNgDLSgAgBQDXTwBRGABxJgAOAgDMSgDJSQBaHADGSADERwD5XABVGgBUGgDsVwBsIwBrIwBmIQCkOgBjIACeOAA8EADKSQDbUA"
	+ "BcHQCdNwDARQCQMgDqVwCjOgC/RQB9KgCZkaUQAAAAIHRSTlMAId69+SfYBsM8QvnwOdz5twWa/f7++fn5Y77k2P7+/ou/Tl8AAAEdSURBVBjTXdHVcsMwEAVQyZHsxA6VuVUMcZiTclN"
	+ "mZmZm5o+vrJkkcu/jmZXu7CwA5UiyUDdeK2LARXI568Njwzak1hieGEUOaDPfzEa0KMgSb8rkZnq3gRukhqa3Ymvb3KBlQzuqvrxeqbEsMqCS1RXUDDmbm1dJbC/T0oSlsiWXAoT0heJI"
	+ "cMgYSsy0KDXS1a8t7PsE0Q8BdKC3hGWks3vkIPv+20HLsJjL66QU1fj6Zvj5mpoKlDT4U2DYfjgb6kn0Bpl9FKztoV8Uve6awcgitcuLa+R00XaIsafaHT9KEWKcXzFjqfJ4jx8MYpyeV"
	+ "QzQj59Nop/keKOHuL3R8xpvdAHlKW0+2oy+zryY93ajmMze/TOAW9s0hbM/fBwr4p3w8DUAAAAASUVORK5CYII=";
var timelineFlagImgSrc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAYCAYAAAARfGZ1AAACCElEQVRIx8XUPWgUQRTA8f/M7oYLG+40RxQTkRiQCIJa5EjUJmoh"
	+ "FiKIhSBELETBSqwESyvBQiutAgmBIILFgaZQUCQgBjniokSMCmdUkBjMfeV2d3bG5oSAnNzmFnztDL+Z98ETQA64JJBpkBhUFXgEHJF0ZDWBIUYIbGFQJeCuDVwcsi6cG3AOWhjDh/CFX"
	+ "9Djm7aJ3OFhZyydkpk4NtooFsKn0Rs9ZWyHbHrQOWrtdU+iTUS9VBMFPe5kRb/c556iy+qJha+q73xSLzXwywaMxEYKq5GWWJeihUC2DPu6glfLMx898IBJCbFK2jSUCfBqeWbDe19CVm"
	+ "4Bb2USsDaKJX+eOX9qddl4N4GHgEoE/xkWeV67XftoZiaB+8AagEzi15/9WTw9vQDcAX78OWsbF0LSJbewmd09wMB6s30cyc7UCEPO2e3AdWB/YjhAp5Vh2B0Th6wrB4BrQF9iOEDG7mX"
	+ "EPW/tkaePNx7olq0k3lp5BFudQUY7r7o7xOgZ4ITd7HKEwjclbN0RK4Nup49+K5ctqmfHmuH1op4rzZRvWA6peKOJ5qv2ysBiM7xQZWmiEE24bGw/LAOv/8Ib0gqQB3Q7TZb/6GLbGy2x"
	+ "UfwfuNjAVLcWtiYgNGtoo4iMQuEnh0eUF9+Fj6tBpeIqE/A+elIHqkngAugFLgO7GqP3CpgGvrWL/wa9grsEBYmdaQAAAABJRU5ErkJggg==";
var timelinePersonImgSrc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAYCAYAAADKx8xXAAABx0lEQVQ4y8XUO2sUYRTG8d9eMopxAxEllyUma0QJAZt0lvaChQ"
	+ "oWYh2s/ASpbERb/QwWaa28xVKwSIwYEBcJbkwwMUbdxZ3s7ljM7GYviRAQfOAwL5zzf58z73tm2FOASygi6opikgvsowKeoTqTE90cE10bFY31iVBNcoVmcbbLMX91VHB7mqlBqnVerHF"
	+ "/UbBckW93bIIpyKW4MsHFYYJ0nLg8zuImyx8620snu0ygsEtQrVOP9gp2G4SNvY6arhmcxkPcqpGPajK5PjJp1io8WeXxRzZr+nEOK1jPYAizQxmTd6Zkb5wl3086Ffc/0s/MKYKGzNIP"
	+ "w5jEy9bhXC9IzU4zcix54TZdOMFEjrWy4Pm3uN10M3lmgJNHeyHIphk/TmGg83Bai/2gVj4VRw94WP1HcCeMR+wg/dxlp7oP+LTEwhfKtV5ovcJ8kYWNTjBE6dW28NG7uKhdjYg3m9x7y"
	+ "0Y9rkWYThZ3USrXOue0fV6/x9BrzKHUckyeByoV18wlcHiYU+0w+Df32Iji6FY96h3HDvBzmffb8Z01P+Cvv1neotK1Yba9/2Ko8GBJsLjF4JHYffUX858Obvlvv8ZmrOB8E/gDEteiey"
	+ "c1xP8AAAAASUVORK5CYII=";
var timelineWildlifeImgSrc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAYCAMAAADJYP15AAAA1VBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
	+ "AAAAAAAAAAAMAgAAAAAAAAAAAAAAAAAAAAAUAwAlCAAAAAAAAAAAAAAAAAAvDgAxDgAAAAAAAAAAAAAAAAAAAAD/XwD8XgD0WgDxWQDHSQHuWADrVwDkVADXTwCrPgCcNwCELgD3XADmV"
	+ "QDMSwDESAC8RAC0QQCkOgB5KgBwJgBKFgBAEgDfUwHiUwDbUQDPTQCnPACXNQCQMwC+RgG9RQGNMQFcHwG1QgCvPwBkIQBaHQBOGADS5e0IAAAAH3RSTlMARAescya2sUksJPTkx4kyHB"
	+ "YQ88i8qJaSd3VoYFI8iuR3UQAAASFJREFUKM9Vz9dywjAQQFFRQg8Q0uuVbDA2pveanvz/J2UlB0LOi2evZ1aScgqZTCatVAkoqIN0mTfqSj0Qc/qXz4iHpJS6Z/E/b/qSG1U6XDQOO/J"
	+ "Yj5dY+X2uQRiMEUvTg7qL2bssA63NBPpa64jsbTa5FG2ZV+DJp484UUUGXyxlboGRzwuzAUWVIpoykrkNvuyaMxlRUzg9bToQGfMMc6goYtOVsvvkV9N4oFhp3cXajuGcqRzQkbyWvTsg"
	+ "cKfSlDGWPJffW1hosXbZRzKRF8BQW2bKzGtNyKsC1thox4fkOeopAx9SEz24uj5RIsfmUN2rXE2Dp4+MSCX5Wx8L9xnfXsIPWl277F1yspswfMWaDdtNKLpcKmNVbnI4VWk/Uuw3cWXVV"
	+ "n8AAAAASUVORK5CYII=";
var timelineVehicleImgSrc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAYCAYAAADpnJ2CAAADHklEQVRIx93Vy29VVRQG8N++9/S0tAVLKNa2iFwiNSQaiIQakwZaH"
	+ "wP/AzVEHDAwDnSs0RiNkUQHxolxgASMkUQZ+pj5JDFWiTFEpS1U24CiwAXSR9rb3nscnF1B0sclztjJyTk556z17e9b316Lm32FZb6l6I73G1kVnI33ugFT9OLlCHoj6yxewuBioGEZsP"
	+ "0NQe+2VmlTsT6kmSo/TarMZQbx3GKgYSmw1qD3+Xukj2yksYisDi1rfDrOaydUJpcAvR6whAPo27dJ+uIOKlW++pO52vJgaYHdXTQUeOU47/6ugmPYh9+WqtsDGC2lsk8GZJcfk72xXRb"
	+ "5rXi9vj2P+XhAVkplGI05/zVe8TopX8XWPSXFR+/kzBRvnWBspr4azs5yfwc9bZybYvCSFvTgJM6hGq6VclXQ9/gd0id72Hkrxy8wfPnGLNpzCzvWM/g3h4c5MqYynV2VNol1XIUNT22R"
	+ "Pns3tzUzW2VrGzvXE0IdpgnUakzO5+a5r4ONraxJpW8Oux2rUUiQYO3qINnVSXcrP5c5cip3594eNq9ZoUXE/fx6hQ9GcuM8EeN2d3LglMaJmhJGCjFVsRhoTsgyhq9wcISjo3kd6zgRa"
	+ "lku/6ERPhxlfCp/35KQ5BiNCwwDmlCApMBAF+/35zvdtm5Fcrn7Av1dvNefP9/bHkuRsw9RSUlELqFxIXF7Ew9153+FUL9h1jXx4CJxIcdpQ5JEZo0FCpdnuThDW5ozhal5pufrA2xOcg"
	+ "nJG8WVSn6FqwxDgiqmyjXVd37hx4s8E52a4YfzHB6imq0s6d4ednXm7C7M5Gf4+/OUazkGqgmm8R1GPi9rz0j3bKFjVb7LM5McGlPJlhk5SIt0P7xBOpfRgPIs3/7F15dUMBIxphcYDuM"
	+ "F7P+mrPfgSelAFxPzHB2VRbCnl+qJKFV5+6PTNhWC0JLw5R8cy8EGY+7hiPWfXtqHLzC2tmC8ORjDED6LxgpLzNRS/GeoOeSxGIu5+q7tpYuNp824K7p3NrKasIKkcVCvXnB8jB2KDbyy"
	+ "3AAuLBxS1GJgrc6T8X9ib5L1D6qOEQx3D47yAAAAAElFTkSuQmCC";
function TimelineDataLoader(callbackStartedLoading, callbackGotData, callbackError)
{
	/** The most recent timeline parameters defining the timeline view we require. */
	var parameters = { camera: null, left: 0, right: 0, zoomScaler: 0 };
	/** Specifications of the current timeline dataset. */
	var loadedState = { camera: null, left: 0, right: 0, zoomScaler: 0, loadedAt: -99999 };
	/** True if a loading operation is currently active. */
	var isRunning = false;
	var lastFailure = -999999;
	var refreshTimelineInterval = setInterval(Update, 1001);
	/** Call to request that new Timeline data be requested if necessary.  Optionally takes a new visible range argument. */
	this.NewParameters = function (left, right, zoomScaler, camera)
	{
		parameters.camera = camera;
		parameters.left = left;
		parameters.right = right;
		parameters.zoomScaler = zoomScaler;
		Update();
	}
	function Update()
	{
		if (documentIsHidden() || currentPrimaryTab !== "timeline")
			return;
		if (isRunning || parameters.camera === null)
			return;

		var reqParams = JSON.parse(JSON.stringify(parameters));

		// Expand left and right borders.  We need to expand by AT LEAST as much as the safety buffer.
		var safetyMs = GetSafetyBufferMs();
		var expandBy = safetyMs * 2;
		reqParams.left -= expandBy;
		reqParams.right += expandBy;

		var live = GetUtcNow();
		if (reqParams.left >= live)
			return;
		if (reqParams.right > live)
			reqParams.right = live;
		if (reqParams.left < 1)
			reqParams.left = 1;
		if (reqParams.right < 128000)
			reqParams.right = 128000;

		if (!RequiresUpdatedView())
			return;

		isRunning = true;
		callbackStartedLoading();
		var requestTime = performance.now();
		GetTimelineData(reqParams.left, reqParams.right, reqParams.zoomScaler, reqParams.camera)
			.then(function (response)
			{
				if (response.result !== "success")
					return Promise.reject(htmlEncode('Server response did not indicate "success" result: ' + JSON.stringify(response)));
				else
				{
					if (timelineDeveloperMode)
						console.log('<<< Received timeline data in ' + (performance.now() - requestTime).toFixed() + ' ms <<<');
					loadedState = reqParams;
					callbackGotData(response.data);
				}
			})
			.catch(function (err)
			{
				lastFailure = performance.now();
				var errHtml;
				if (typeof err === "string")
					errHtml = err;
				else
					errHtml = htmlEncode("An unexpected error occurred loading timeline data: " + err);
				callbackError(errHtml);
			})
			.finally(function ()
			{
				isRunning = false;
				Update();
			});
	}

	/**
	 * Returns true if the current timeline parameters warrant downloading a new timeline view.
	 */
	function RequiresUpdatedView()
	{
		if (performance.now() - lastFailure < 1000)
			return false; // Throttle retry after failure by at least 1 second.

		if (parameters.camera === null)
			return false; // We don't require data yet.

		if (loadedState.camera === null)
			return true; // We haven't loaded data yet.

		if (parameters.camera !== loadedState.camera)
			return true; // We need data for a different camera or group.

		if (Math.abs(parameters.zoomScaler - loadedState.zoomScaler) > 0.25)
			return true; // We need data at a significantly different zoom scale.

		// Boundary checks
		var safetyMs = GetSafetyBufferMs();

		// Left boundary check
		var loadToLeft = Math.max(parameters.left - safetyMs, 1);
		if (loadToLeft < loadedState.left)
			return true; // New data required to satisfy left boundary requirements.

		// Right boundary check
		var loadToRight = Math.max(parameters.right + safetyMs, 128000);
		if (loadToRight > loadedState.right)
		{
			// New data is required to satisfy right boundary requirements.
			// But it is possible that the [live] timestamp falls within our proposed right boundary, in which case it is impossible to load all the data we want.
			var live = GetUtcNow(); // Current clock time.
			if (live >= loadToRight)
				return true; // [live] timestamp does not affect decision. Get new data.

			// [live] timestamp falls within the desired time span.  We still need new data, but for throttling purposes we should only request new data if the current dataset is missing a significant amount of time before [live].

			var msecpp = Math.pow(2, parameters.zoomScaler); // Milliseconds per pixel at the current zoom scale.
			var significantMs = Math.max(msecpp * 5, 10000); // "Significant" is here defined to be the greater of [5px] or [10s].
			if (loadedState.right < live - significantMs)
				return true;
		}
		return false;
	}

	function GetSafetyBufferMs()
	{
		var msecpp = Math.pow(2, parameters.zoomScaler); // Milliseconds per pixel at the current zoom scale.
		var viewportWidthMs = parameters.right - parameters.left;
		var safetyMs = Math.max(200 * msecpp, viewportWidthMs * 0.25); // Try to always have this much data loaded offscreen when possible. Larger of [200px] or [25% of viewport width].
		return safetyMs;
	}

	/**
	 * Returns a promise that resolves with timeline data that has been converted to the format UI3 wants.
	 * @param {Number} left leftmost millisecond since epoch
	 * @param {Number} right rightmost millisecond since epoch
	 * @param {Number} zoomScaler Zoom scaler
	 * @param {String} camera Camera short name or group name
	 */
	function GetTimelineData(left, right, zoomScaler, camera)
	{
		zoomScaler += timelineDataZoomMultiplier;
		var msecpp = Math.round(Math.pow(2, zoomScaler));
		var args = { cmd: "timeline", startdate: Math.floor(left / 1000), enddate: Math.ceil(right / 1000), msecpp: msecpp, camera: camera };
		return ExecJSONPromise(args).then(function (response)
		{
			var processed = { colors: [], alerts: [], clips: [] };
			// A "track" is an index in the colors array. Also specifies draw order.
			// Processed Format:
			//  colors: ["#FF0000:"]
			//  alerts: [{ time: 1000, len: 1000, isFlag: false, tracks: bitmask }] 
			//  clips: [{ time: 1000, len: 1000, track: 3 }]
			if (response.data)
			{
				var timeOffset = args.startdate * 1000;
				if (response.data.colors)
				{
					for (var i = 0; i < response.data.colors.length; i++)
						processed.colors.push("#" + BlueIrisColorToCssColor(response.data.colors[i]));
				}
				if (response.data.alerts)
				{
					for (var i = 0; i < response.data.alerts.length; i++)
					{
						var a = response.data.alerts[i];
						processed.alerts.push({
							time: timeOffset + (a.x1 * msecpp),
							len: (a.x2 - a.x1) * msecpp,
							isFlag: NumberHasFlags(a.type, BIDBFLAG.FLAGGED),
							isPerson: NumberHasFlags(a.type, BIDBFLAG.AI_PERSON),
							isVehicle: NumberHasFlags(a.type, BIDBFLAG.AI_VEHICLE),
							isWildlife: NumberHasFlags(a.type, BIDBFLAG.AI_WILDLIFE),
							tracks: a.tracks,
							recId: a.record ? GetRecIdFromPath(a.record) : undefined
						});
					}
				}
				if (response.data.clips)
				{
					for (var i = 0; i < response.data.clips.length; i++)
					{
						var c = response.data.clips[i];
						processed.clips.push({
							time: timeOffset + (c.x1 * msecpp),
							len: (c.x2 - c.x1) * msecpp,
							track: c.track
						});
					}
				}
			}
			response.data = processed;
			return response;
		});
	}
}
function ClipTimeline()
{
	var self = this;
	var timeline;
	var initialized = false;
	var didRunFinishInit = false;
	var alertImg = new TimelineRasterIcon(timelineAlertImgSrc);
	var flagImg = new TimelineRasterIcon(timelineFlagImgSrc);
	var personImg = new TimelineRasterIcon(timelinePersonImgSrc);
	var vehicleImg = new TimelineRasterIcon(timelineVehicleImgSrc);
	var wildlifeImg = new TimelineRasterIcon(timelineWildlifeImgSrc);
	var $tl_root = $();
	var timelineDataLoader = null;
	var minZoomScaler = function () { return Clamp(parseFloat(settings.ui3_timeline_minZoomScaler), 4, 8); }; // default was 8, changed to 7 when alert thumbnails were implemented.
	var maxZoomScaler = 30; // Has a copy declared in UI Settings ^^
	var minSavedZoomScaler = 6;
	var maxSavedZoomScaler = 19;
	var canvasData = null;
	/** Number of milliseconds prior to the "live" time that the timeline should not allow to be selected. */
	this.keepOutTime = 15000; // Blue Iris updates db info every 10s I think, so the absolute minimum age of video should be 10s.
	var averageCanvasDrawTime = new RollingAverage(30);
	var averageCanvasCpuUsage = new RollingAverage(30);
	var canvasDrawFps = new FPSCounter1();
	var drawRoundedRectangles = true;
	var timelineStarfieldOffset = 0;
	var lastTimelineDrawCurrentTime = -1;
	var timelineThumbnailLoader;
	var alertThumbVpad = 4;

	var starfield = null;

	this.Initialize = function ()
	{
		if (initialized)
			return;
		initialized = true;

		BI_CustomEvent.AddListener("CameraListLoaded", finishInit);
		finishInit();
	}
	var finishInit = function ()
	{
		if (didRunFinishInit || !cameraListLoader || !cameraListLoader.GetLastResponse())
			return;
		didRunFinishInit = true;
		BI_CustomEvent.RemoveListener("CameraListLoaded", finishInit);
		Vue.component('clip-timeline', {
			template: ''
				+ '<div class="clipTimeline" ref="tl_root" :class="clipTimelineClasses">'
				+ ' <clip-timeline-legend :width="timelineWidth" :zoomFactor="zoomFactor" :left="left" :right="right" :currentTime="currentTime" :showSelectedTime="showSelectedTime" />'
				+ ' <div class="timelineMain" :style="{ width: timelineWidth + \'px\' }">'
				+ '		<canvas ref="clipTimelineCanvas" class="clipTimelineCanvas" :style="timelineCanvasStyle" />'
				+ '		<div class="timelineError" v-if="errorHtml" v-html="errorHtml"></div>'
				+ '	</div>'
				+ '	<div class="timelineButtonBar">'
				+ '		<div class="timelineButton icon timelineGoLive" title="Go Live" @click="btnGoLive" :style="goLiveStyle">'
				+ '			<svg class="icon noflip"><use xlink:href="#svg_mio_clock"></use></svg>'
				+ '		</div>'
				+ '		<div class="timelineButton icon" title="Zoom In" @click="btnZoom(-1)">'
				+ '			<svg class="icon noflip"><use xlink:href="#svg_mio_zoom_in_crop"></use></svg>'
				+ '		</div>'
				+ '		<div class="timelineButton icon" title="Zoom Out" @click="btnZoom(1)">'
				+ '			<svg class="icon noflip"><use xlink:href="#svg_mio_zoom_out_crop"></use></svg>'
				+ '		</div>'
				+ '	</div>'
				+ '	<div class="timelineCenterBar" :style="CenterBarStyle"></div>'
				+ '</div>',
			data: function ()
			{
				return {
					errorHtml: "",
					/** Number that increases linearly to control zoom */
					zoomScaler: Clamp(parseInt(settings.ui3_timelineZoomScaler), minSavedZoomScaler, maxSavedZoomScaler),
					pinchZoomState: { startingZoomScaler: 0 },
					/** Width of the timeline canvas area in pixels. */
					timelineWidth: 0,
					/** Height of the timeline canvas area in pixels. */
					timelineHeight: 0,
					/** Width of the timeline internal buffer in pixels. Affected by device pixel ratio. */
					timelineInternalWidth: 0,
					/** Height of the timeline internal buffer in pixels. Affected by device pixel ratio. */
					timelineInternalHeight: 0,
					/** Unbounded millisecond timestamp that the user wants to set the timeline to. For a bounds-clamped value, see currentTime property. */
					lastSetTime: GetUtcNow(),
					/** Number that can be incremented to force the component to recompute the currentTime property. */
					recomputeCurrentTime: 0,
					dragState: { isMouseDown: false, isDragging: false, startX: 0, lastClickAt: -9999, doubleClickTime: 400 },
					mouseHoverX: -10000,
					wheelPanState: { isActive: false, timeout: null },
					/** Helps maintain a decent timeline frame rate while nothing is interacting with the timeline. */
					canvasRedrawState: { interval: null, lastRedraw: 0 },
					/** Helps throttle canvas drawing to once per frame */
					canvasThrottle: { didDrawAlreadyThisFrame: false, queuedDraw: false },
					hammerTime: null,
					accumulatedZoomDelta: 0,
					isHovered: true,
					/** True if the current video stream is live and is playing. */
					isLive: false,
					seekPreviewFrameTime: -1,
					seekPreviewLoading: false,
					/** True if the timeline is currently responsible for the video player being paused. */
					timelineDidPauseVideo: false
				};
			},
			created: function ()
			{
				timeline = this;
				timelineDataLoader = new TimelineDataLoader(this.callbackStartedLoading, this.callbackGotData, this.callbackError);
				loadingHelper.SetLoadedStatus("timeline");
				if (startupTimelineMs !== null)
				{
					if (startupTimelineMs < 0)
						startupTimelineMs = GetUtcNow() + startupTimelineMs;
					skipLoadingAllVideoStreams = false;
					developerLog("Timeline component created. Starting playback at " + startupTimelineMs);
					this.assignLastSetTime(startupTimelineMs);
					this.userDidSetTime();
				}
			},
			mounted: function ()
			{
				$tl_root = $(timeline.$refs.tl_root);
				timeline.hammertime = new Hammer(timeline.$refs.tl_root);
				timeline.hammertime.get('pinch').set({ enable: true });
				timeline.hammertime.get('pinch').recognizeWith(timeline.hammertime.get('pan')); // Allow pinch to resume if one finger lifts and touches again.
				timeline.hammertime.on('pinchstart', timeline.onPinchStart);
				timeline.hammertime.on('pinchmove', timeline.onPinchMove);
				BindEventsPassive(timeline.$refs.tl_root, "mousedown", timeline.mouseDown);
				BindEventsPassive(timeline.$refs.tl_root, "touchstart", timeline.mouseDown);
				BindEventsPassive(document, "touchmove mousemove", timeline.mouseMove);
				BindEventsPassive(document, "touchend mouseup ", timeline.mouseUp);
				BindEventsPassive(document, "touchcancel", timeline.touchCancel);
				BindEventsPassive(timeline.$refs.tl_root, "mouseleave", timeline.mouseLeave);
				BindEvents(timeline.$refs.tl_root, "wheel", timeline.mouseWheel);
				BI_CustomEvent.AddListener("afterResize", this.AfterResize);
				BI_CustomEvent.AddListener("OpenVideo", this.onOpenVideo);
				BI_CustomEvent.AddListener("Playback_Play", this.onVideoPlay);
				BI_CustomEvent.AddListener("Playback_Pause", this.onVideoPause);
				BI_CustomEvent.AddListener("TabLoaded_timeline", this.drawCanvas);
				BI_CustomEvent.AddListener("ImageRendered", this.FrameRendered);
				this.AfterResize();
				this.onOpenVideo();
				this.canvasRedrawState.interval = setInterval(this.canvasRedraw, 66);
				timelineThumbnailLoader = new AsyncOffscreenThumbnailDownloader(function () { timeline.drawCanvas() });
			},
			beforeDestroy: function ()
			{
				clearInterval(this.canvasRedrawState.interval);
				timeline.hammertime.off('pinchstart pinchmove');
				timeline.hammertime.get('pinch').set({ enable: false });
				BI_CustomEvent.RemoveListener("afterResize", timeline.AfterResize);
				BI_CustomEvent.RemoveListener("OpenVideo", this.onOpenVideo);
				BI_CustomEvent.RemoveListener("Playback_Play", this.onVideoPlay);
				BI_CustomEvent.RemoveListener("Playback_Pause", this.onVideoPause);
				BI_CustomEvent.RemoveListener("TabLoaded_timeline", this.drawCanvas);
				BI_CustomEvent.RemoveListener("ImageRendered", this.FrameRendered);
				timeline.$refs.tl_root.removeEventListener("touchstart", timeline.mouseDown);
				timeline.$refs.tl_root.removeEventListener("mousedown", timeline.mouseDown);
				document.removeEventListener("touchmove", timeline.mouseMove);
				document.removeEventListener("mousemove", timeline.mouseMove);
				document.removeEventListener("touchend", timeline.mouseUp);
				document.removeEventListener("mouseup", timeline.mouseUp);
				document.removeEventListener("touchcancel", timeline.touchCancel);
				timeline.$refs.tl_root.removeEventListener("mouseleave", timeline.mouseLeave);
				timeline.$refs.tl_root.removeEventListener("wheel", timeline.mouseWheel);
				timelineThumbnailLoader.Stop();
				timeline = undefined;
			},
			methods:
			{
				newTimelineParameters: function ()
				{
					timelineDataLoader.NewParameters(this.visibleRange.left, this.visibleRange.right, this.zoomScaler, videoPlayer.Loading().cam.optionValue);
				},
				/**
				 * Called when data begins loading for the current timeline view.
				 */
				callbackStartedLoading: function ()
				{
				},
				/**
				 * Called when data is received for the current timeline view.
				 * @param {Object} data Data from the server.
				 */
				callbackGotData: function (data)
				{
					this.errorHtml = "";

					if (typeof data === "undefined")
						return; // (unconfirmed with live API) This may happen if you request a future date, or perhaps any date with no data.

					canvasData = data;
					this.drawCanvas();
				},
				/**
				 * Called when an error occurs when loading data for the current timeline view.
				 * @param {String} errHtml HTML error message.
				 */
				callbackError: function (errHtml)
				{
					timeline.errorHtml = errHtml;
					console.error(htmlDecode(errHtml));
				},
				AfterResize: function ()
				{
					if (this.$refs.tl_root)
					{
						var o = $tl_root.offset();
						this.$refs.tl_root.savedBounds = {
							x: o ? o.left : 0,
							y: o ? o.top : 0,
							w: this.$refs.tl_root.offsetWidth - 36,// -36 for the button bar on the right side.  Subtracted here so the panning handler doesn't activate in the right margin area.
							h: this.$refs.tl_root.offsetHeight
						};
						var dpr = BI_GetDevicePixelRatio();
						this.timelineInternalWidth = Math.ceil(Math.max(0, this.$refs.tl_root.savedBounds.w) * dpr);
						this.timelineInternalHeight = Math.ceil(Math.max(0, this.$refs.tl_root.savedBounds.h - 16) * dpr); // -16 for the top bar containing labels
						this.timelineWidth = this.timelineInternalWidth / dpr;
						this.timelineHeight = this.timelineInternalHeight / dpr;
					}
				},
				mouseDown: function (e)
				{
					mouseCoordFixer.fix(e);
					if (touchEvents.Gate(e))
						return;
					if (touchEvents.isMultiTouch(e))
					{
						this.mouseUp(e);
						return;
					}
					if (e.button === 2)
						return;
					timeline.mouseHoverX = e.mouseX;
					if (pointInsideElement($tl_root, e.mouseX, e.mouseY))
					{
						timeline.dragState.startX = e.mouseX;
						timeline.dragState.isMouseDown = true;
						timeline.dragState.isDragging = false;
						timeline.timelineDidPauseVideo = !videoPlayer.Playback_IsPaused();
					}
				},
				mouseMove: function (e)
				{
					mouseCoordFixer.fix(e);
					if (touchEvents.Gate(e))
						return;
					timeline.mouseHoverX = e.mouseX;
					if (timeline.dragState.isMouseDown)
					{
						var delta = (e.mouseX - timeline.dragState.startX);
						if (Math.abs(delta) > 3)
							timeline.dragState.isDragging = true;
						if (timeline.dragState.isDragging)
						{
							timeline.dragState.startX = e.mouseX;
							var time = timeline.lastSetTime + delta * -timeline.zoomFactor;
							timeline.lastSetTime = time;
						}
						this.finishWheelPan();
					}
					this.isHovered = !touchEvents.isTouchEvent(e) && pointInsideElement($tl_root, e.mouseX, e.mouseY);
				},
				mouseUp: function (e)
				{
					mouseCoordFixer.fix(e);
					if (touchEvents.Gate(e))
						return;
					timeline.mouseHoverX = e.mouseX;
					if (timeline.dragState.isMouseDown)
					{
						var isMultiTouch = touchEvents.isMultiTouch(e);
						if (!isMultiTouch)
							timeline.mouseMove(e);
						if (timeline.dragState.isDragging || isMultiTouch)
							timeline.userDidSetTime();
						else
						{
							var now = performance.now();
							if (now - timeline.dragState.lastClickAt > timeline.dragState.doubleClickTime)
							{
								timeline.dragState.lastClickAt = now;
								var time = timeline.left + pointToElementRelative($tl_root, e.mouseX, 0).x * timeline.zoomFactor;
								if (this.shouldShowAlertThumbnails && settings.ui3_timeline_alertThumbnailClickLoadsAlertStartTime === "1")
								{
									var recId = this.getAlertThumbnailRecIdAtTime(time);
									if (recId)
									{
										var alertStartTime = this.getStartTimeOfRecId(recId);
										if (alertStartTime)
											time = alertStartTime;
									}
								}
								timeline.assignLastSetTime(time);
								timeline.userDidSetTime();
							}
						}
						// Order of setting timelineDidPauseVideo is important. userDidSetTime reads it and expects it to be unmodified
						timeline.timelineDidPauseVideo = timeline.dragState.isMouseDown = timeline.dragState.isDragging = false;
					}
					this.isHovered = !touchEvents.isTouchEvent(e) && pointInsideElement($tl_root, e.mouseX, e.mouseY);
				},
				touchCancel: function (e)
				{
					mouseCoordFixer.fix(e);
					if (touchEvents.Gate(e))
						return;
					if (timeline.dragState.isMouseDown)
						timeline.timelineDidPauseVideo = timeline.dragState.isMouseDown = timeline.dragState.isDragging = false;
				},
				mouseLeave: function (e)
				{
					this.isHovered = false;
				},
				mouseWheel: function (e)
				{
					e.preventDefault();
					e = normalizeWheelEvent(e);
					if (e.pixelX !== 0)
					{
						var dx = e.pixelX;
						if (settings.ui3_wheelZoomReverse === "1")
							dx *= -1;

						if (!this.wheelPanState.isActive && dx !== 0)
							this.wheelPanState.isActive = true;
						if (this.wheelPanState.isActive)
						{
							this.lastSetTime += dx * -this.zoomFactor;
							clearTimeout(this.wheelPanState.timeout);
							this.wheelPanState.timeout = setTimeout(this.finishWheelPan, 200);
						}
					}
					if (e.spinY !== 0)
					{
						var dy = e.spinY / 2;
						if (settings.ui3_wheelZoomReverse === "1")
							dy *= -1;
						this.accumulatedZoomDelta += dy;
						this.acceptZoom(null);
						this.finishWheelPan();
					}
				},
				finishWheelPan: function ()
				{
					clearTimeout(this.wheelPanState.timeout);
					if (this.wheelPanState.isActive)
					{
						this.wheelPanState.isActive = false;
						timeline.userDidSetTime();
					}
				},
				onPinchStart: function (e)
				{
					timeline.pinchZoomState.startingZoomScaler = timeline.zoomScaler;
				},
				onPinchMove: function (e)
				{
					var szf = Math.pow(2, timeline.pinchZoomState.startingZoomScaler);
					var speedExponent = 2;
					var zoomSpeed = Clamp(parseFloat(settings.ui3_wheelAdjustableSpeed), 20, 2000);
					zoomSpeed /= 400;
					speedExponent *= zoomSpeed;
					var zf = szf / Math.max(0.001, Math.pow(e.scale, speedExponent));
					var zs = Math.log2(zf);
					timeline.acceptZoom(zs);
				},
				acceptZoom: function (newZoomScaler)
				{
					if (newZoomScaler)
						timeline.setZoom_Internal(newZoomScaler);
					if (timeline.accumulatedZoomDelta !== 0)
					{
						var zoomSpeed = Clamp(parseFloat(settings.ui3_wheelAdjustableSpeed), 20, 2000);
						zoomSpeed /= 400;
						var dz = timeline.accumulatedZoomDelta * zoomSpeed;
						newZoomScaler = timeline.zoomScaler + dz;
						timeline.accumulatedZoomDelta = 0;
						timeline.setZoom_Internal(newZoomScaler);
					}
				},
				setZoom_Internal: function (zoom)
				{
					this.zoomScaler = Clamp(zoom, minZoomScaler(), maxZoomScaler);
					$("#timelineCurrentZoomScaleComment").text(this.zoomScaler);
					settings.ui3_timelineZoomScaler = Clamp(this.zoomScaler, minSavedZoomScaler, maxSavedZoomScaler);
				},
				assignLastSetTime: function (time)
				{
					developerLog("timeline.assignLastSetTime(" + time + ")");
					if (time < 1)
						time = 1;
					else
					{
						var serverTime = GetUtcNow();
						if (time > serverTime - self.keepOutTime)
							time = serverTime;
					}
					this.lastSetTime = time;
				},
				drawCanvas: function ()
				{
					if (this.canvasThrottle.didDrawAlreadyThisFrame)
					{
						this.canvasThrottle.queuedDraw = true;
						return;
					}
					else
					{
						this.canvasThrottle.queuedDraw = false;
						this.canvasThrottle.didDrawAlreadyThisFrame = true;
						requestAnimationFrame(this.nextCanvasDrawFrame);
					}
					var canvas = this.$refs.clipTimelineCanvas;
					if (!canvas || currentPrimaryTab !== "timeline")
						return;

					var perfStart = performance.now();
					var bet = new BasicEventTimer();
					bet.start("Draw Background");
					var ctx = canvas.getContext("2d");

					var dpr = BI_GetDevicePixelRatio();
					var zoomFactor = this.zoomFactor / dpr;
					var left = this.left;
					var right = this.right;
					var now = GetUtcNow();
					var showStarfield = settings.ui3_timeline_starfield === "1";

					if (lastTimelineDrawCurrentTime > -1)
						timelineStarfieldOffset += (this.currentTime - lastTimelineDrawCurrentTime) / zoomFactor;
					lastTimelineDrawCurrentTime = this.currentTime;

					if (!showStarfield)
					{
						ctx.fillStyle = "#000000";
						ctx.fillRect(0, 0, canvas.width, canvas.height);
					}
					else
					{
						if (!starfield)
							starfield = new StarfieldGenerator(80, 0.003, "bp2008");
						starfield.draw(ctx, 0, 0, canvas.width, canvas.height, timelineStarfieldOffset);
					}


					bet.stop();

					if (canvasData)
					{
						if (showStarfield)
						{
							// Draw partially-transparent black overlay behind loadable timeline area.
							var overlayLeft = Math.max(0, -left / zoomFactor);
							var overlayWidth = Math.min(canvas.width, (now - (self.keepOutTime * 0.8) - left) / zoomFactor);
							var stepsFromMaxZoomout = maxZoomScaler - this.zoomScaler;
							var blackBackgroundOpacity = Clamp(stepsFromMaxZoomout / 10, 0, 0.8) + 0.2;
							ctx.fillStyle = "rgba(0,0,0," + blackBackgroundOpacity + ")";
							ctx.fillRect(overlayLeft, 0, overlayWidth, canvas.height);
						}

						var alertIconSpace = 12 * dpr;
						var clipDrawRegionHeight = canvas.height - alertIconSpace;
						var timelineColorbarHeight = clipDrawRegionHeight / canvasData.colors.length;

						bet.start("Draw clip and alert color bars");
						// Draw clip rectangles
						for (var n = 0; n < canvasData.clips.length; n++)
						{
							var clip = canvasData.clips[n];
							var x = (clip.time - left) / zoomFactor;
							var w = clip.len / zoomFactor;
							if (x < canvas.width && x + w > 0)
							{
								var y1 = Math.round(clip.track * timelineColorbarHeight);
								var y2 = Math.round((clip.track + 1) * timelineColorbarHeight);

								ctx.fillStyle = canvasData.colors[clip.track];
								if (drawRoundedRectangles)
									roundRect(ctx, x, alertIconSpace + y1, w, y2 - y1);
								else
									ctx.fillRect(x, alertIconSpace + y1, w, y2 - y1);
							}
						}

						// Draw alert rectangles
						ctx.fillStyle = ValidateHexColor(settings.ui3_timeline_alertBarColor, "#8E3510");
						var y = Math.round(alertIconSpace * 0.125);
						var h = alertIconSpace - y - y;
						for (var n = 0; n < canvasData.alerts.length; n++)
						{
							var alert = canvasData.alerts[n];
							var x = (alert.time - left) / zoomFactor;
							var w = alert.len / zoomFactor;
							if (x < canvas.width && x + w > 0)
							{
								if (drawRoundedRectangles)
									roundRect(ctx, x, y, w, h);
								else
									ctx.fillRect(x, y, w, h);
							}
						}
						var hoveredAlert = null;
						var hoveredAlertOnTop = settings.ui3_timeline_drawHoveredAlertOnTop === "1";
						if (this.shouldShowAlertThumbnails)
						{
							// I tried drawing the images with opacity (ctx.globalAlpha) at futher-out zoom levels, but it is too messy looking.
							bet.start("Draw alert thumbnails");

							var hoveredAlertOnly = settings.ui3_timeline_drawHoveredAlertOnly === "1";
							var hoveredAlertThumbnailRecId = this.hoveredAlertThumbnailRecId;

							var y = alertIconSpace + alertThumbVpad;
							var h = (canvasData.colors.length * timelineColorbarHeight) - alertThumbVpad - alertThumbVpad;

							doWithTempShadowSettings(ctx, -5 * dpr, 0, 'rgba(0,0,0,0.67)', 10 * dpr, function ()
							{
								for (var n = 0; n < canvasData.alerts.length; n++)
								{
									var alert = canvasData.alerts[n];
									if (alert && alert.recId)
									{
										if ((hoveredAlertOnTop || hoveredAlertOnly) && alert.recId === hoveredAlertThumbnailRecId)
											hoveredAlert = alert; // This alert gets drawn later
										else
										{
											drawAlertThumbnail(alert, y, h, left, zoomFactor, dpr, canvas, ctx, false, !hoveredAlertOnly);
										}
									}
								}
							});
							bet.stop();
						}

						bet.start("Draw alert track markers and icons");
						if (settings.ui3_timeline_alertTrackMarkers === "1")
						{
							// Draw alert track markers
							for (var n = 0; n < canvasData.alerts.length; n++)
							{
								var alert = canvasData.alerts[n];
								var x = (alert.time - left) / zoomFactor;
								if (x < canvas.width && x >= 0)
								{
									for (var track = 0; track <= canvasData.colors.length; track++)
									{
										if ((alert.tracks & (1 << track)) > 0)
										{
											var y1 = Math.round(track * timelineColorbarHeight);
											var y2 = Math.round((track + 1) * timelineColorbarHeight);
											ctx.fillRect(x, alertIconSpace + y1, 1 * dpr, y2 - y1);
										}
									}
								}
							}
						}

						// Draw alert icons
						for (var n = 0; n < canvasData.alerts.length; n++)
						{
							var a = canvasData.alerts[n];
							var img = alertImg;
							if (a.isFlag)
								img = flagImg;
							else if (a.isPerson)
								img = personImg;
							else if (a.isVehicle)
								img = vehicleImg;
							else if (a.isWildlife)
								img = wildlifeImg;
							img.draw(ctx, canvas.width, dpr, ((a.time - left) / zoomFactor), 0);
						}
						bet.stop();

						if (hoveredAlert)
						{
							bet.start("Draw hovered alert thumbnail");
							drawAlertThumbnail(hoveredAlert, y, h, left, zoomFactor, dpr, canvas, ctx, hoveredAlertOnTop, true);
							bet.stop();
						}
					}

					if (left < 0 && right > 0)
					{
						// Left boundary is visible.
						ctx.fillStyle = "rgba(138,95,62,1)";
						ctx.fillRect((-left / zoomFactor) - (2 * dpr), 0, 2 * dpr, canvas.height);
					}
					if (now > left && now - self.keepOutTime <= right)
					{
						bet.start("Draw 'live' time indicator");
						var x = (now - left - self.keepOutTime) / zoomFactor;
						var y = 0;
						var w = self.keepOutTime / zoomFactor;
						var h = canvas.height;
						var grd = ctx.createLinearGradient(x, y, x + w, y);
						grd.addColorStop(0, "rgba(123,133,180,0.0)");
						grd.addColorStop(0.2, "rgba(123,133,180,0.3)");
						grd.addColorStop(0.8, "rgba(70,130,255,0.8)");
						grd.addColorStop(0.9, "rgba(100,255,255,0.9)");
						grd.addColorStop(1, "rgba(255,255,255,1)");
						ctx.fillStyle = grd;
						ctx.fillRect(x, y, w, h);
						if (zoomFactor > 1200)
						{
							// We're zoomed out far enough that 15s is getting really small.  Draw a 2px line so the live point remains easily visible.
							ctx.fillStyle = "rgba(100,255,255,1)";
							ctx.fillRect(x + w - 1 * dpr, y, 2 * dpr, h);
						}
						bet.stop();
					}

					// Draw a gradient if we've panned beyond a boundary.
					var outOfBoundsTime = this.lastSetTime;
					var currentTime = this.currentTime;
					var futureTimePx = (outOfBoundsTime - currentTime) / zoomFactor;
					if (futureTimePx > 0)
					{
						bet.start("Draw future overscroll gradient");
						var x = (canvas.width - futureTimePx);
						var y = 0;
						var w = futureTimePx;
						var h = canvas.height;
						var grd = ctx.createLinearGradient(x, y, x + w, y);
						grd.addColorStop(0, "rgba(0,0,0,0)");
						grd.addColorStop(1, "rgba(62,95,138,1)");
						ctx.fillStyle = grd;
						ctx.fillRect(x, y, w, h);
						bet.stop();
					}
					var pastTimePx = -outOfBoundsTime / zoomFactor;
					if (pastTimePx > 0)
					{
						bet.start("Draw past overscroll gradient");
						var x = 0;
						var y = 0;
						var w = pastTimePx;
						var h = canvas.height;
						var grd = ctx.createLinearGradient(x, y, x + w, y);
						grd.addColorStop(0, "rgba(138,95,62,1)");
						grd.addColorStop(1, "rgba(0,0,0,0)");
						ctx.fillStyle = grd;
						ctx.fillRect(x, y, w, h);
						bet.stop();
					}
					var perfEnd = performance.now();

					// Decide whether to render curved corners next time.
					var renderTime = perfEnd - perfStart;
					averageCanvasDrawTime.Add(renderTime);
					var fps = canvasDrawFps.getFPS(renderTime);
					var averageRenderTime = averageCanvasDrawTime.Get();
					var cpuUsage = (averageRenderTime * fps) / 1000;
					averageCanvasCpuUsage.Add(cpuUsage);
					var averageCpuUsage = averageCanvasCpuUsage.Get();
					if (drawRoundedRectangles && averageCpuUsage > 0.2)
						drawRoundedRectangles = false;
					else if (!drawRoundedRectangles && fps >= 30 && averageCpuUsage < 0.05)
						drawRoundedRectangles = true;
					if (timelineDeveloperMode)
						bet.log("Canvas Render: " + renderTime.toFixed(1) + " ms (avg " + averageRenderTime.toFixed(1) + "ms).\nFPS: " + fps.toFixed(0) + ". CPU: " + (cpuUsage * 100).toFixed(1) + "% (avg " + (averageCpuUsage * 100).toFixed(1) + "%)");

					this.canvasRedrawState.lastRedraw = perfStart;
				},
				nextCanvasDrawFrame: function ()
				{
					this.canvasThrottle.didDrawAlreadyThisFrame = false;
					if (this.canvasThrottle.queuedDraw)
						this.drawCanvas();
				},
				canvasRedraw: function ()
				{
					var now = performance.now();
					if (now > this.canvasRedrawState.lastRedraw + 50)
					{
						var live = GetUtcNow();
						if (this.left < live && this.right > live - self.keepOutTime)
							this.recomputeCurrentTime++;
					}
				},
				FrameRendered: function (data)
				{
					if (typeof data.utc !== "number" || this.dragState.isMouseDown || this.timelineIsBeingPanned || (data.isSeekPreview && !data.isTimelineJump))
						return;

					if (videoPlayer.Loaded().image.isTimeline())
					{
						var serverTime = GetUtcNow();
						if (data.utc > serverTime - self.keepOutTime)
						{
							console.log("Timeline video frame (" + GetDateStr(new Date(data.utc), true) + ") rendered after the start of the keep-out zone (" + GetDateStr(new Date(serverTime - self.keepOutTime), true) + "). Going to live view.");
							videoPlayer.goLive();
						}
					}
					this.lastSetTime = data.utc;

					if (this.timelineDidPauseVideo && !videoPlayer.Playback_IsPaused())
						videoPlayer.Playback_Pause();
				},
				btnGoLive: function ()
				{
					videoPlayer.goLive();
				},
				btnZoom: function (direction)
				{
					this.acceptZoom(this.zoomScaler + (direction > 0 ? 1 : -1));
				},
				onOpenVideo: function ()
				{
					this.isLive = videoPlayer.Loading().image.isLive;
					this.newTimelineParameters();
				},
				onVideoPlay: function ()
				{
					this.isLive = videoPlayer.Loading().image.isLive;
				},
				onVideoPause: function ()
				{
					this.isLive = false;
				},
				userDidSetTime: function ()
				{
					this.assignLastSetTime(this.lastSetTime);
					videoPlayer.LoadLiveCamera(videoPlayer.Loading().cam, this.getCurrentTimelineArgs());
				},
				getCurrentTimelineArgs: function ()
				{
					return { timelineMs: this.currentTime, startPaused: videoPlayer.Playback_IsPaused() && !this.timelineDidPauseVideo };
				},
				updateSeekPreview: function ()
				{
					timelineSync.run(this, function ()
					{
						if (!this.timelineIsBeingPanned || this.seekPreviewLoading)
						{
							timelineSync.unlock();
							return;
						}

						var requestMs = clipTimeline.BoundsCheckTimelineMs(this.currentTime);
						if (!requestMs || this.seekPreviewFrameTime === requestMs)
						{
							timelineSync.unlock();
							return;
						}

						this.downloadSeekPreview(requestMs);
					});
				},
				/** Call to download and render a seek preview frame. You must already have obtained a timelineSync lock. The request will be aborted if a fetch video stream is currently pending. */
				downloadSeekPreview: function (requestMs, jumpArg)
				{
					if (safeFetch.IsActive())
					{
						timelineSync.unlock();
						return;
					}
					if (!jumpArg)
						jumpArg = "";
					var loadingImg = videoPlayer.Loading().image;
					var qualityArgs = genericQualityHelper.getSeekPreviewQualityArgs(loadingImg);
					var groupArgs = groupCfg.GetUrlArgs(loadingImg);
					var overlayArgs = clipOverlayCfg.GetUrlArgs("*ui3_timeline_pseudocam");
					var seekImgUrl = currentServer.remoteBaseURL + "time/" + loadingImg.path + '?jpeg&speed=0&pos=' + Math.floor(requestMs) + jumpArg + currentServer.GetAPISessionArg("&", true) + '&opaque=' + ui3InstanceId + qualityArgs + groupArgs + overlayArgs;
					var uniqueId = loadingImg.uniqueId;
					var startTime = performance.now();
					this.seekPreviewLoading = true;
					videoPlayer.Loading().image.isLive = false;
					videoPlayer.Loading().image.timelineStart = Math.floor(requestMs);

					videoOverlayHelper.ShowLoadingOverlay(true, true);
					DownloadToDataUri(seekImgUrl)
						.then(function (result)
						{
							if (videoPlayer.Loading().image.uniqueId !== uniqueId)
								return;
							var frameUtc = parseInt(result.headers["x-utc"]);
							jpegPreviewModule.RenderDataURI(startTime, uniqueId, result.dataUri, frameUtc, result.headers, !!jumpArg);
						})
						.catch(function (err)
						{
							if (videoPlayer.Loading().image.uniqueId !== uniqueId)
								return;
							videoOverlayHelper.HideLoadingOverlay();
						})
						.finally(function ()
						{
							timeline.seekPreviewFrameTime = requestMs;
							timeline.seekPreviewLoading = false;
							timelineSync.unlock();
						});
				},
				getAlertThumbnailRecIdAtTime: function (time)
				{
					var canvas = this.$refs.clipTimelineCanvas;
					if (!canvas || !canvasData || !this.shouldShowAlertThumbnails)
						return null;
					var dpr = BI_GetDevicePixelRatio();
					var alertIconSpace = 12 * dpr;
					var clipDrawRegionHeight = canvas.height - alertIconSpace;
					var timelineColorbarHeight = clipDrawRegionHeight / canvasData.colors.length;
					var h = (canvasData.colors.length * timelineColorbarHeight) - alertThumbVpad - alertThumbVpad;
					var closestHoveredRecId = null;
					for (var n = canvasData.alerts.length - 1; n >= 0; n--)
					{
						var alert = canvasData.alerts[n];
						if (alert.recId && time >= alert.time)
						{
							var img = timelineThumbnailLoader.GetImg(alert.recId);
							if (img && img.loadedSuccessfully)
							{
								var wPx = (img.naturalWidth / img.naturalHeight) * h;
								var wMs = wPx * timeline.zoomFactor;
								if (time <= alert.time + wMs)
									return alert.recId;
							}
							else if (time <= alert.time + 100)
								closestHoveredRecId = alert.recId;
						}
					}
					return closestHoveredRecId;
				},
				getStartTimeOfRecId: function (recId)
				{
					for (var n = 0; n < canvasData.alerts.length; n++)
					{
						var alert = canvasData.alerts[n];
						if (alert.recId === recId)
							return alert.time;
					}
					return null;
				}
			},
			computed:
			{
				/** Number of milliseconds per pixel. */
				zoomFactor: function ()
				{
					return Math.pow(2, this.zoomScaler);
				},
				/** Number of milliseconds across the visible area of the timeline. */
				visibleMilliseconds: function ()
				{
					return this.timelineWidth * this.zoomFactor;
				},
				/** Timestamp of the left edge */
				left: function ()
				{
					return this.currentTime - (this.visibleMilliseconds / 2);
				},
				/** Timestamp of the right edge */
				right: function ()
				{
					return this.currentTime + (this.visibleMilliseconds / 2);
				},
				/** Timestamps of the left and right edges of the timeline */
				visibleRange: function ()
				{
					return {
						left: this.left,
						right: this.right,
					};
				},
				CenterBarCenterX: function ()
				{
					return this.timelineWidth / 2;
				},
				CenterBarStyle: function ()
				{
					return {
						left: (this.CenterBarCenterX - 1) + 'px'
					};
				},
				/** Currently highlighted time */
				currentTime: function ()
				{
					if (this.recomputeCurrentTime) { } // Reactively update currentTime when recomputeCurrentTime value changes

					var time = this.lastSetTime;
					if (time < 1)
						time = 1;
					var serverTime = GetUtcNow();
					if (time > serverTime)
						time = serverTime;
					return time;
				},
				clipTimelineClasses: function ()
				{
					if (this.dragState.isDragging)
						return "grabbingcursor";
					else
						return "grabcursor";
				},
				showSelectedTime: function ()
				{
					return this.dragState.isDragging || this.isHovered;
				},
				timelineInternalSize: function ()
				{
					return { w: this.timelineInternalWidth, h: this.timelineInternalHeight };
				},
				timelineCanvasStyle: function ()
				{
					return { width: this.timelineWidth + "px", height: this.timelineHeight + "px" };
				},
				goLiveStyle: function ()
				{
					return { color: this.isLive ? '#71E068' : '' };
				},
				timelineIsBeingPanned: function ()
				{
					return this.dragState.isDragging || this.wheelPanState.isActive || this.seekPreviewLoading;
				},
				shouldShowAlertThumbnails: function ()
				{
					if (this.zoomScaler <= parseFloat(settings.ui3_timeline_alertThumbnailsAppearAtZoomLevel))
					{
						var l = videoPlayer.Loading().image;
						var isSingleCamera = !l.cams || l.cams.length === 1;
						if (isSingleCamera || settings.ui3_timeline_alertThumbnailsAppearForGroups === "1")
							return true;
					}
					return false;
				},
				hoveredAlertThumbnailRecId: function ()
				{
					if ((this.dragState.isMouseDown || this.isHovered) && this.shouldShowAlertThumbnails && this.mouseHoverX && (settings.ui3_timeline_drawHoveredAlertOnTop === "1" || settings.ui3_timeline_drawHoveredAlertOnly === "1"))
					{
						var hoverTime = this.left + pointToElementRelative($tl_root, this.mouseHoverX, 0).x * this.zoomFactor;
						return this.getAlertThumbnailRecIdAtTime(hoverTime);
					}
					return undefined;
				}
			},
			watch:
			{
				zoomFactor: function ()
				{
					this.newTimelineParameters();
				},
				visibleRange: function ()
				{
					this.newTimelineParameters();
					this.drawCanvas();
				},
				timelineInternalSize: function ()
				{
					var canvas = this.$refs.clipTimelineCanvas;
					if (!canvas)
						return;
					canvas.width = this.timelineInternalWidth;
					canvas.height = this.timelineInternalHeight;
					this.drawCanvas();
				},
				seekPreviewFrameTime: function ()
				{
					this.updateSeekPreview();
				},
				currentTime: function ()
				{
					this.updateSeekPreview();
				},
				timelineDidPauseVideo: function (newValue, oldValue)
				{
					if (newValue && !videoPlayer.Playback_IsPaused())
						videoPlayer.Playback_Pause();
					else if (oldValue && !newValue && videoPlayer.Playback_IsPaused())
						videoPlayer.Playback_Play();
				},
				hoveredAlertThumbnailRecId: function ()
				{
					this.drawCanvas();
				}
			}
		});

		Vue.component('clip-timeline-legend', {
			template: ''
				+ '<div class="timelineLegendBar" :style="{ width: width + \'px\' }">'
				+ '	<div class="timelineLegend">'
				+ '		<div class="timelineLabel" v-for="tag in tags" :key="tag.time" :style="tag.style" :class="{ timelineLabelMinor: tag.minor }">{{tag.label}}</div>'
				+ '	</div>'
				+ '	<div class="timelineCurrentTimeWrapper" v-show="showSelectedTime"><div class="timelineCurrentTime">{{currentTimeStr}}</div></div>'
				+ '</div>',
			data: function ()
			{
				return {
				};
			},
			props:
			{
				/** Width of timeline in pixels */
				width: Number,
				/** Number of milliseconds per pixel. */
				zoomFactor: Number,
				/** Timestamp of the left edge */
				left: Number,
				/** Timestamp of the right edge */
				right: Number,
				/** Timestamp of the center (current time) */
				currentTime: Number,
				/** If true, the date should be shown in the selected time label */
				showSelectedTime: Boolean
			},
			created: function ()
			{
			},
			mounted: function ()
			{
			},
			beforeDestroy: function ()
			{
			},
			methods:
			{
				/** Returns an array of visible times with precision smaller than 1 day. */
				generateTickMarks: function ()
				{
					/** The number of hours we must skip between tags in order to fit 45px tags together tightly */
					var hourPrecisionAvailable = (this.zoomFactor * 45 / 1000 / 60 / 60);
					var hourInterval = Clamp(Math.ceil(hourPrecisionAvailable), 1, 4);
					if (hourInterval === 4)
						hourInterval = 12;
					var minutePrecisionAvailable = (this.zoomFactor * 100 / 1000 / 60);
					var minuteInterval;
					if (minutePrecisionAvailable <= 1)
						minuteInterval = 1;
					else if (minutePrecisionAvailable <= 5)
						minuteInterval = 5;
					else if (minutePrecisionAvailable <= 10)
						minuteInterval = 10;
					else if (minutePrecisionAvailable <= 15)
						minuteInterval = 15;
					else if (minutePrecisionAvailable <= 30)
						minuteInterval = 30;
					else
						minuteInterval = 0;
					var left = GetServerDate(new Date(this.left)).getTime();
					var right = GetServerDate(new Date(this.right)).getTime();
					var times = [];
					var date = new Date(left);
					date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
					while (date.getTime() < right)
					{
						if (date.getTime() > left)
						{
							if (date.getHours() > 0 || date.getMinutes() > 0)
							{
								var tag = { time: date.getTime(), minor: true };
								tag.label = GetHourStr(date, minuteInterval > 0);
								tag.style = {
									left: ((tag.time - left) / this.zoomFactor) + 'px'
								};
								times.push(tag);
							}
						}
						if (minuteInterval > 0)
							date.setMinutes(date.getMinutes() + minuteInterval);
						else
							date.setHours(date.getHours() + hourInterval);
					}
					return times;
				}
			},
			computed:
			{
				tags: function ()
				{
					var timingTickMarksCutoff = 350000;
					var dayWeekCutoff = 1122000;
					var weekMonthCutoff = 4544278;
					var monthYearCutoff = 50000000;
					var left = GetServerDate(new Date(this.left)).getTime();
					var right = GetServerDate(new Date(this.right)).getTime();
					var tags = [];
					var date = GetServerDate(new Date(left));
					if (this.zoomFactor < dayWeekCutoff)
					{
						// Show full days
						date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
					}
					else if (this.zoomFactor < weekMonthCutoff)
					{
						// Show full weeks
						date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
						while (date.getDay() != 1)
							date.setDate(date.getDate() - 1);
					}
					else if (this.zoomFactor < monthYearCutoff)
					{
						// Show full months
						date = new Date(date.getFullYear(), date.getMonth(), 1);
					}
					else
					{
						// Show full years
						date = new Date(date.getFullYear(), 0, 1);
					}
					var isFirst = true;
					while (date.getTime() < right)
					{
						var tag = { time: date.getTime() };
						if (this.zoomFactor < dayWeekCutoff)
						{
							// Show full days
							tag.label = GetDateDisplayStrShort(date, this.zoomFactor < 800000);
							date.setDate(date.getDate() + 1);
						}
						else if (this.zoomFactor < weekMonthCutoff)
						{
							// Show full weeks
							tag.label = GetWeekDisplayStr(date);
							date.setDate(date.getDate() + 7);
						}
						else if (this.zoomFactor < monthYearCutoff)
						{
							// Show full months
							tag.label = GetMonthDisplayStr(date, this.zoomFactor < 26106019);
							date.setMonth(date.getMonth() + 1);
						}
						else
						{
							// Show full years
							tag.label = date.getFullYear().toString();
							date.setFullYear(date.getFullYear() + 1);
						}

						tag.style = {
							left: ((tag.time - left) / this.zoomFactor) + 'px'
						};
						if (isFirst)
							tag.style.left = '-1px';
						tags.push(tag);

						isFirst = false;
					}
					if (this.zoomFactor < timingTickMarksCutoff)
					{
						var tickMarks = this.generateTickMarks();
						for (var i = 0; i < tickMarks.length; i++)
							tags.push(tickMarks[i]);
					}
					return tags;
				},
				currentTimeStr: function ()
				{
					var date = GetServerDate(new Date(this.currentTime));
					return GetShortDateOrToday(date) + '\n' + GetTimeStr(date);
				}
			},
			watch:
			{
			}
		});

		// The [timeline] field will contain a reference to the component, set by the component after its creation.
		new Vue({ el: "#layoutbottomTimeline" });

		var optionTimeline =
		{
			alias: "cmroot_timeline", width: 200, items:
				[
					ThreeStateMenuItem.Create("timeline_skipDeadAir", "Skip dead-air", function ()
					{
						switch (this.data.alias)
						{
							case "timeline_skipDeadAir_nopreference":
								settings.ui3_playback_skipDeadAir = "0";
								videoPlayer.RefreshVideoStream();
								break;
							case "timeline_skipDeadAir_off":
								settings.ui3_playback_skipDeadAir = "1";
								videoPlayer.RefreshVideoStream();
								break;
							case "timeline_skipDeadAir_on":
								settings.ui3_playback_skipDeadAir = "2";
								videoPlayer.RefreshVideoStream();
								break;
						}
					}),
					{
						text: '<span id="timeline_starfield_menuitem">Starfield Background</span>', iconClass: "noflip", icon: "#svg_mio_cbUnchecked", alias: "boringTimelineMode",
						tooltip: 'The starfield background adds a little visual flair outside the timeline boundaries and when zoomed out a long way.',
						action: function () { settings.ui3_timeline_starfield = settings.ui3_timeline_starfield === "1" ? "0" : "1"; }
					}
				]
			, onContextMenu: function ()
			{
				var $boringMode = $("#timeline_starfield_menuitem");
				$boringMode.parent().prev().find("use").attr("xlink:href", settings.ui3_timeline_starfield === "1" ? "#svg_mio_cbChecked" : "#svg_mio_cbUnchecked");

				ThreeStateMenuItem.Refresh("timeline_skipDeadAir", parseInt(settings.ui3_playback_skipDeadAir));
				return true;
			}
			, clickType: GetPreferredContextMenuTrigger()
		};
		$("#layoutbottomTimeline").contextmenu(optionTimeline);

		resized();
	}
	function doWithTempShadowSettings(ctx, x, y, c, b, fn)
	{
		var saved = { x: ctx.shadowOffsetX, y: ctx.shadowOffsetY, c: ctx.shadowColor, b: ctx.shadowBlur }
		try
		{
			ctx.shadowOffsetX = x;
			ctx.shadowOffsetY = y;
			ctx.shadowColor = c;
			ctx.shadowBlur = b;
			fn();
		}
		finally
		{
			ctx.shadowOffsetX = saved.x;
			ctx.shadowOffsetY = saved.y;
			ctx.shadowColor = saved.c;
			ctx.shadowBlur = saved.b;
		}
	}
	function drawAlertThumbnail(alert, y, h, left, zoomFactor, dpr, canvas, ctx, highlight, actuallyDrawImage)
	{
		var x = ((alert.time - left) / zoomFactor) + (1 * dpr);
		var w = 100;
		var img = timelineThumbnailLoader.GetImg(alert.recId);
		if (img && img.loadedSuccessfully)
			w = (img.naturalWidth / img.naturalHeight) * h;
		if (x < canvas.width && x >= -w)
		{
			if (img && img.loadedSuccessfully)
			{
				if (actuallyDrawImage)
				{
					if (highlight)
					{
						doWithTempShadowSettings(ctx, -5 * dpr, 0, 'rgba(0,0,0,0.67)', 10 * dpr, function ()
						{
							ctx.drawImage(img, x, y, w, h);
						});

						var lineWidth = 4 * dpr;
						var o = lineWidth / 2; // Line offset should be half the width.
						ctx.beginPath();
						ctx.lineWidth = lineWidth;
						ctx.strokeStyle = "rgba(255,255,255,1)";
						ctx.rect(x - o, y - o, w + o + o, h + o + o);
						ctx.stroke();
					}
					else
						ctx.drawImage(img, x, y, w, h);
				}
			}
			else
				timelineThumbnailLoader.Visible(alert.recId);
		}
		else
			timelineThumbnailLoader.Invisible(alert.recId);
	}
	this.getVue = function ()
	{
		return timeline;
	}
	this.setZoomScaler = function (zoomScaler)
	{
		if (timeline)
			timeline.acceptZoom(zoomScaler);
	}
	this.getZoomScaler = function ()
	{
		if (timeline)
			return timeline.zoomScaler;
		else
			return undefined;
	}
	this.redrawCanvas = function ()
	{
		if (timeline)
			timeline.drawCanvas();
	}
	this.pointInsideTimeline = function (x, y)
	{
		return $tl_root.length && pointInsideElement($tl_root, x, y);
	}
	/** Returns true if the timeline is currently responsible for pausing the video player. */
	this.timelineDidPauseVideo = function ()
	{
		return timeline && timeline.timelineDidPauseVideo;
	}
	this.BoundsCheckTimelineMs = function (timelineMs)
	{
		if (typeof timelineMs === "number")
		{
			if (timelineMs < 1)
				timelineMs = 1;
			var offset = GetUtcNow() - timelineMs;
			if (offset < self.keepOutTime)
				return undefined;
			else
				return timelineMs;
		}
		return undefined;
	}
	this.getCurrentTime = function ()
	{
		if (timeline)
			return timeline.currentTime;
		else
			return GetUtcNow();
	}
	/**
	 * Returns the largest possible timestamp the timeline control will allow, to the millisecond.
	 */
	this.getNewestAllowableTime = function ()
	{
		return GetUtcNow() - self.keepOutTime;
	}
	this.loadNewestAllowableTime = function ()
	{
		var args = self.getTimelineArgsForCameraSwitch(true);
		args.timelineMs = self.getNewestAllowableTime();
		videoPlayer.LoadLiveCamera(videoPlayer.Loading().cam, args);
	}
	/**
	 * Selects the given timestamp on the timeline.
	 * @param {Number} timestampMs Milliseconds since unix epoch.
	 */
	this.seekTo = function (timestampMs)
	{
		if (timeline)
		{
			if (typeof timestampMs === "string" || (timestampMs > 0 && timestampMs < 60000))
				timestampMs = ParseTimelineStartStr(timestampMs.toString());
			if (timestampMs < 0)
				timestampMs = GetUtcNow() + timestampMs;
			timeline.assignLastSetTime(timestampMs);
			timeline.userDidSetTime();
		}
	}
	/**
	 * Returns a timelineArgs object that will persist the current timeline playback position if sent to videoPlayer.LoadLiveCamera.
	 * @param alsoWhileLive {Boolean} If false, and the current video is live, then null is returned instead of a timelineArgs object.
	 */
	this.getTimelineArgsForCameraSwitch = function (alsoWhileLive)
	{
		if (timeline && (videoPlayer.Loading().image.isTimeline() || (currentPrimaryTab === "timeline" && !videoPlayer.Loading().image.isLive) || alsoWhileLive))
			return timeline.getCurrentTimelineArgs();
		return null;
	}
	/**
	 * Efficiently draws a rounded-corner rectangle on a canvas 2d context.
	 * It is a very trivial rounded corner algorithm with an emphasis on speed and matching Blue Iris's visual style.
	 */
	function roundRect(ctx, x, y, w, h)
	{
		var lhc = 1, rhc = 1; // Horizontal cutout
		if (w < 2)
			rhc = 0;
		if (w < 3)
			lhc = 0;
		var vc = 1; // Vertical cutout
		if (h < 3)
		{
			if (h < 2)
				vc = 0;
			else
				vc = h / 3;
		}
		// Draw top
		ctx.fillRect(x + lhc, y, w - lhc - rhc, vc);
		// Draw middle
		ctx.fillRect(x, y + vc, w, h - vc - vc);
		// Draw bottom
		ctx.fillRect(x + lhc, (y + h) - vc, w - lhc - rhc, vc);
	}
	self.Initialize();
}
var timelineSync = new (function ()
{
	var queue = new Queue();
	var locked = false;
	/**
	 * Helps guarantee synchronous timeline access by only allowing one thing at a time to access timeline video in Blue Iris.
	 * This function queues the passed-in function to run as soon as possible. 
	 * The internal state is set to "locked" just before the passed function is called.
	 * The passed function must call [unlock] when it is done accessing timeline video from Blue Iris.
	 * @param {Function} fn Function to run.
	 */
	this.run = function (thisArg, fn)
	{
		queue.enqueue({ thisArg: thisArg, fn: fn });
		processQueue();
	}
	/** Returns true if the current state is "locked". */
	this.islocked = function ()
	{
		return locked;
	}
	/** Call this to just set the current state to "locked". You must call [unlock] later. */
	this.lock = function ()
	{
		locked = true;
	}
	/** Call this when you are done accessing timeline video and it is safe to run another function from the queue. */
	this.unlock = function ()
	{
		locked = false;
		processQueue();
	}
	function processQueue()
	{
		if (locked)
			return;
		var item = queue.dequeue();
		if (!item)
			return;
		// Doing this asynchronously helps avoid a stack overflow in some cases when dragging the timeline back and forth rapidly and releasing it.
		setTimeout(function () { processItem(item); }, 0);
	}
	function processItem(item)
	{
		locked = true;
		try
		{
			item.fn.apply(item.thisArg);
		}
		catch (ex)
		{
			toaster.Error(ex);
			locked = false;
		}
	}
})();
function StarfieldGenerator(blockSize, density, seedStr)
{
	// There are some very minor (cosmetic) continuity issues when the starfield expands, caused by the offsetX argument.
	// We could mitigate that by separating horizontal and vertical block sizes and using a much larger horizontal block size so that expansion happens less often.
	blockSize = Math.max(40, blockSize);
	density = Clamp(density, 0.00001, 0.5);
	var hues = [0, 60, 240];
	var stars = [];
	var blocksWide = 0;
	var blocksHigh = 0;
	var starsPerBlock = Math.round(blockSize * blockSize * density);

	var lastDrawnBackBufferSize = "";
	var backBuffer = document.createElement('canvas');

	var r = new SeededRandom(seedStr);
	function randInt(min, maxPlusOne)
	{
		return min + Math.floor(r.rand() * (maxPlusOne - min));
	}
	function addRow()
	{
		for (var i = 0; i < blocksWide; i++)
			generateBlock(i, blocksHigh);
		blocksHigh++;
	}
	function addColumn()
	{
		for (var i = 0; i < blocksHigh; i++)
			generateBlock(blocksWide, i);
		blocksWide++;
	}
	function generateBlock(x, y)
	{
		var xOffset = x * blockSize;
		var yOffset = y * blockSize;
		for (var i = 0; i < starsPerBlock; i++)
		{
			stars.push({
				x: xOffset + r.rand() * blockSize,
				y: yOffset + r.rand() * blockSize,
				m: r.rand() * 1.2,
				hue: hues[randInt(0, hues.length)],
				sat: randInt(0, 31),
				lig: randInt(20, 60)
			});
		}
	}

	function DrawBackBufferIfNecessary()
	{
		var dpr = BI_GetDevicePixelRatio();
		var requiredBackBufferSize = blocksWide + "x" + blocksHigh + "@" + dpr;
		if (lastDrawnBackBufferSize !== requiredBackBufferSize)
		{
			lastDrawnBackBufferSize = requiredBackBufferSize;
			backBuffer.width = blockSize * blocksWide * dpr;
			backBuffer.height = blockSize * blocksHigh * dpr;

			var bb = backBuffer.getContext("2d");
			bb.fillStyle = "#000000";
			bb.fillRect(0, 0, backBuffer.width, backBuffer.height);
			for (var i = 0; i < stars.length; i++)
			{
				var star = stars[i];
				bb.beginPath();
				bb.arc(star.x * dpr, star.y * dpr, star.m * dpr, 0, 360);
				bb.fillStyle = "hsl(" + star.hue + ", " + star.sat + "%, " + star.lig + "%)";
				bb.fill();
			}
		}
	}

	this.draw = function (ctx, dx, dy, dw, dh, offsetX)
	{
		var dpr = BI_GetDevicePixelRatio();
		while (dh / dpr > blocksHigh * blockSize)
			addRow();
		while (dw / dpr > blocksWide * blockSize)
			addColumn();
		DrawBackBufferIfNecessary();
		offsetX = ui3Modulus(offsetX, backBuffer.width);
		var sx = offsetX;
		var sy = 0;
		var sw = Math.min(dw, backBuffer.width - sx);
		var sh = dh;
		var firstDrawW = sw;
		if (sw > 0)
			ctx.drawImage(backBuffer, sx, sy, sw, sh, dx, dy, firstDrawW, dh);
		var rem = dw - firstDrawW;
		if (rem)
		{
			sx = 0;
			sw = rem;
			if (sw > 0)
				ctx.drawImage(backBuffer, sx, sy, sw, sh, dx + firstDrawW, dy, rem, dh);
		}
		//ctx.fillStyle = "rgba(138,95,62,1)";
		//ctx.fillRect(dx + firstDrawW, dy, 1, dh);
	};
}
function TimelineRasterIcon(src, onLoad)
{
	var img = new Image();
	var loadedOk = false;
	var myW;
	var myH;
	var lastDpr = null;
	var scale;
	var w;
	var h;
	var xOffset;
	var yOffset;
	img.onload = function ()
	{
		myW = img.naturalWidth;
		myH = img.naturalHeight;
		loadedOk = !!(myW && myH);
		if (loadedOk)
		{
			if (typeof onLoad === "function")
				onLoad();
		}
	};
	img.src = src;

	var calcScaleValues = function (dpr)
	{
		if (dpr !== lastDpr)
		{
			lastDpr = dpr;
			scale = (myH / 12) / dpr;
			w = myW / scale;
			h = myH / scale;
			xOffset = w / 2;
			yOffset = 0 * dpr;
		}
	}
	/**
	 * Draws the image on the canvas at the specified location.
	 * @param {Number} ctx Device pixel ratio
	 * @param {Number} canvasWidth Width of the canvas element for culling purposes.
	 * @param {Number} dpr Device pixel ratio
	 * @param {Number} x Image will be drawn with center at this X-coordinate.
	 * @param {Number} y Image will be drawn with top at this Y-coordinate.
	 */
	this.draw = function (ctx, canvasWidth, dpr, x, y)
	{
		if (loadedOk)
		{
			calcScaleValues(dpr);

			x -= xOffset;
			y += yOffset;
			if (x < canvasWidth && x + w > 0)
				ctx.drawImage(img, x, y, w, h);
		}
	}
}
///////////////////////////////////////////////////////////////
// Zebra Date Picker //////////////////////////////////////////
///////////////////////////////////////////////////////////////
function DateFilter(dateRangeLabelSelector)
{
	var self = this;
	this.BeginDate = 0;
	this.EndDate = 0;
	var suppressDatePickerCallbacks = false;
	var $dateRangeLabel = $(dateRangeLabelSelector);
	var $datePickerDialog = $("#datePickerDialog");
	var dp1 = new DatePicker("datePicker1Container", 1, self);
	var dp2 = new DatePicker("datePicker2Container", 2, self);
	var timeClosed = 0;
	var mayClose = true;
	var isVisible = false;

	$("#dateRange").add($datePickerDialog).on('mousedown mouseup touchstart touchend touchcancel', function (e)
	{
		if (e.currentTarget.id == "dateRange" && e.button == 2)
			return; // Right click here doesn't prevent close.
		mayClose = false;
		setTimeout(function () { mayClose = true; }, 0);
	});
	$(document).on('mousedown mouseup touchstart touchend touchcancel', function (e)
	{
		if (mayClose && isVisible)
			self.CloseDatePicker();
	});

	this.OpenDatePicker = function (ele)
	{
		if (isVisible)
			self.CloseDatePicker();
		else if (performance.now() - 33 > timeClosed)
		{
			var $ele = $(ele);
			var offset = $ele.offset();
			var wW = $(window).width();
			var minW = 195; // 192 plus some wiggle room
			if (settings.ui3_sideBarPosition === "Right")
			{
				var right = wW - offset.left;
				if (wW - right < minW)
					right = wW - minW;
				$datePickerDialog.css("left", "");
				$datePickerDialog.css("right", right + "px");
			}
			else
			{
				var left = offset.left + $ele.outerWidth(true);
				if (wW - left < minW)
					left = wW - minW;
				$datePickerDialog.css("left", left + "px");
				$datePickerDialog.css("right", "");
			}
			$datePickerDialog.css("top", offset.top + "px");
			$datePickerDialog.show();
			dp1.Update([]);
			dp2.Update([]);
			ClipCalendarLoadData(function (dates)
			{
				dp1.Update(dates);
				dp2.Update(dates);
			}
				, function (errorHtml)
				{
					toaster.Warning(errorHtml);
				});
			isVisible = true;
		}
	};
	this.CloseDatePicker = function (ele)
	{
		if (isVisible)
		{
			isVisible = false;
			$datePickerDialog.hide();
			timeClosed = performance.now();
		}
	};
	this.SelectToday = function ()
	{
		if (suppressDatePickerCallbacks)
			return;
		suppressDatePickerCallbacks = true;
		dp1.SelectToday();
		suppressDatePickerCallbacks = false;
		dp2.SelectToday();
	}
	this.Clear = function ()
	{
		if (suppressDatePickerCallbacks)
			return;
		suppressDatePickerCallbacks = true;
		dp1.Clear();
		dp2.Clear();
		suppressDatePickerCallbacks = false;
		self.BeginDate = self.EndDate = 0;
		$dateRangeLabel.text("All Recent");
		$dateRangeLabel.addClass("oneLine");
		// Maybe change color of calendar icon while there is a date range selected.
		clipLoader.LoadClips();
	}
	/**
	 * Assigns the Date object to the given field without triggering a reload of the clip list.
	 * @param {Date} date Date object.
	 * @param {Number} datePickerNum 1 for start date, 2 for end date
	 */
	this.SelectDate = function (date, datePickerNum)
	{
		if (suppressDatePickerCallbacks)
			return;
		var dateYMD = date.getFullYear() + "-" + (date.getMonth() + 1).padLeft(2, '0') + "-" + date.getDate().padLeft(2, '0');
		var startOfDay = GetReverseServerDate(new Date(date.getFullYear(), date.getMonth(), date.getDate()));
		if ($dateRangeLabel.hasClass("oneLine"))
		{
			$dateRangeLabel.removeClass("oneLine");
			$dateRangeLabel.html('<span id="lblClipDateSub1"></span><br/><span id="lblClipDateSub2"></span>');
		}
		suppressDatePickerCallbacks = true;
		try
		{
			if (datePickerNum == 1)
			{
				self.BeginDate = startOfDay.getTime() / 1000;
				$("#lblClipDateSub1").text(dateYMD);
				dp1.SetDate(dateYMD);
				if (self.BeginDate >= self.EndDate)
				{
					self.EndDate = self.BeginDate + 86400; // (86400 seconds in a day)
					$("#lblClipDateSub2").text(dateYMD);
					dp2.SetDate(dateYMD);
				}
			}
			else
			{
				self.EndDate = (startOfDay.getTime() / 1000) + 86400; // (86400 seconds in a day)
				$("#lblClipDateSub2").text(dateYMD);
				dp2.SetDate(dateYMD);
				if (self.BeginDate >= self.EndDate || self.BeginDate == 0)
				{
					self.BeginDate = self.EndDate - 86400; // (86400 seconds in a day)
					$("#lblClipDateSub1").text(dateYMD);
					dp1.SetDate(dateYMD);
				}
			}
		}
		finally
		{
			suppressDatePickerCallbacks = false;
		}
		// Maybe change color of calendar icon while there is a date range selected.
	}
	this.OnSelect = function (dateCustom, dateYMD, noonDateObj, ele, datePickerNum)
	{
		if (suppressDatePickerCallbacks)
			return;
		self.SelectDate(noonDateObj, datePickerNum);
		clipLoader.LoadClips();
	};
}
function DatePicker(calendarContainerId, datePickerNum, dateFilterObj)
{
	var $calendarContainer = $("#" + calendarContainerId);
	var self = this;
	var suppressDatePickerCallbacks = false;

	$calendarContainer.before('<input type="text" id="datePickerDate_' + calendarContainerId + '" class="takeNoSpace" />');
	var $dateInput = $('#datePickerDate_' + calendarContainerId);
	$dateInput.Zebra_DatePicker({
		always_visible: $calendarContainer
		, first_day_of_week: 0
		, onClear: function (ele)
		{
			if (suppressDatePickerCallbacks)
				return;
			suppressDatePickerCallbacks = true;
			dateFilterObj.Clear();
			suppressDatePickerCallbacks = false;
		}
		, onSelect: function (dateCustom, dateYMD, noonDateObj, ele)
		{
			if (suppressDatePickerCallbacks)
				return;
			suppressDatePickerCallbacks = true;
			dateFilterObj.OnSelect(dateCustom, dateYMD, noonDateObj, ele, datePickerNum);
			suppressDatePickerCallbacks = false;
		}
	});

	this.zebra = $dateInput.data('Zebra_DatePicker');

	this.Clear = function ()
	{
		if (suppressDatePickerCallbacks)
			return;
		suppressDatePickerCallbacks = true;
		$dateInput.data('Zebra_DatePicker').clear_date();
		suppressDatePickerCallbacks = false;
	}
	this.SelectToday = function ()
	{
		$calendarContainer.find("td.dp_today").click();
	}
	this.SetDate = function (dateYMD)
	{
		if (suppressDatePickerCallbacks)
			return;
		suppressDatePickerCallbacks = true;
		$dateInput.data('Zebra_DatePicker').set_date(dateYMD);
		suppressDatePickerCallbacks = false;
	}
	/** Updates the date picker with a new set of dates to mark. */
	this.Update = function (dates)
	{
		this.zebra.update({ custom_classes: { dateHasClip: dates } });
	}
	this.Destroy = function ()
	{
		this.zebra.destroy();
		this.zebra = null;
	}
}
///////////////////////////////////////////////////////////////
// Clip List Filter Search ////////////////////////////////////
///////////////////////////////////////////////////////////////
function ClipFilterSearch()
{
	var self = this;
	var lastQuery = "";
	$("#clipFilterSearch").on('keydown', function (e)
	{
		if (e.key === 'Enter' || e.keyCode === 13)
		{
			e.preventDefault();
			e.stopPropagation();
			$('#clipFilterSearch').blur();
			doFilterSearchImmediately();
		}
	});
	$("#clipFilterSearch").on('input change', function (e)
	{
		debouncedSearch();
	});
	$("#clipFilterSearch").on('blur', function (e)
	{
		doFilterSearchImmediately();
	});
	this.getQuery = function ()
	{
		var queryText = $("#clipFilterSearch").val();
		if (queryText)
			return queryText.trim();
		else
			return "";
	}
	this.setQuery = function (queryText)
	{
		if (queryText)
			queryText = queryText.trim();
		else
			queryText = "";
		$("#clipFilterSearch").val(queryText);
	}
	this.updateVisibility = function ()
	{
		if (settings.ui3_showClipListFilterSearch === "1")
			$("#clipFilterSearch").parent().show();
		else
		{
			$("#clipFilterSearch").parent().hide();
			if (self.getQuery())
			{
				self.setQuery("");
				doFilterSearchImmediately();
			}
		}
	}
	var doFilterSearchImmediately = function ()
	{
		var queryText = self.getQuery();
		if (queryText !== lastQuery)
		{
			lastQuery = queryText;
			console.log("Filter Search", queryText);
			clipLoader.LoadClips();
		}
	};
	var debouncedSearch = debounce(doFilterSearchImmediately, 1000);
}
///////////////////////////////////////////////////////////////
// Playback Controls //////////////////////////////////////////
///////////////////////////////////////////////////////////////
var overridePlaybackSpeedOptions = null;
function GetPlaybackSpeedOptions()
{
	if (overridePlaybackSpeedOptions && overridePlaybackSpeedOptions.length)
		return overridePlaybackSpeedOptions;
	else
		return [0.125, 0.25, 0.5, 1, 2, 4, 6, 8, 16, 32, 64, 128, 256];
}
function GetPlaybackSpeedSubStreamOptions()
{
	var arr = GetPlaybackSpeedOptions();
	arr.push(arr[arr.length - 1] + 1);
	for (var i = 0; i < arr.length; i++)
		arr[i] = arr[i].toString();
	return arr;
}
function GetClosestNumericValueFromArray(arr, val)
{
	if (!arr || !arr.length)
		throw new Error("Input array must be non-empty");
	val = parseFloat(val);
	var closest = parseFloat(arr[0]);
	var minDiff = Math.abs(closest - val);

	for (var i = 1; i < arr.length; i++)
	{
		var diff = Math.abs(parseFloat(arr[i]) - val);
		if (diff < minDiff)
		{
			minDiff = diff;
			closest = parseFloat(arr[i]);
		}
	}

	return closest.toString();
}
function PlaybackControls()
{
	var self = this;
	this.hideTimeMs_Live = 1500;
	this.hideTimeMs_Recordings = 3000;
	var $layoutbody = $("#layoutbody");
	var $layoutbottom = $("#layoutbottom");
	var $pc = $("#playbackControls");
	var $playbackSettings = $();
	var buttonContainer = $("#pcButtonContainer");
	var $progressText = $("#playbackProgressText");
	var hideTimeout = null;
	var showTimeouts = [];
	var isVisible = $pc.is(":visible");
	var settingsClosedAt = -9999;
	var playReverse = settings.ui3_playback_reverse == "1";
	var autoplay = settings.ui3_playback_autoplay == "1";
	var loopingEnabled = settings.ui3_playback_loop == "1";
	var SpeedOptions = GetPlaybackSpeedOptions();
	var playSpeed = 1;
	for (var i = 0; i < SpeedOptions.length; i++)
		if (SpeedOptions[i] == settings.ui3_playback_speed)
			playSpeed = SpeedOptions[i];

	$("#playbackControls").on('mousedown touchstart', function (event)
	{
		// This hack seems to fix [Playback controls click-through bug](https://github.com/bp2008/ui3/issues/122).
		videoPlayer.suppressMouseHelper(true);
	});

	var SetPlaySpeedLabel = function ()
	{
		$("#playbackSpeedText").text(playSpeed + "x");
	};
	SetPlaySpeedLabel();

	var pcFrameTimestampVisible = false;
	var $playbackFrameTimestamp = $('#playbackFrameTimestamp');

	if (!audio_playback_supported)
		$("#volumeBar").addClass("permanentlyUnavailable");

	this.resized = function ()
	{
		var paddingSize = $pc.innerWidth() - $pc.width();
		var width = $pc.parent().width() - paddingSize;
		$pc.css("width", width + "px");
		var o = $pc.offset();
		$pc.get(0).savedBounds = { x: o ? o.left : 0, y: o ? o.top : 0, w: width, h: $pc.height() };
		if (width > 475)
			$("#volumeBar").addClass("wide");
		else
			$("#volumeBar").removeClass("wide");

		seekBar.resized();
		exportControls.resized();
	}
	this.SetProgressText = function (text)
	{
		if ($progressText.text() !== text)
			$progressText.text(text);
	}
	this.IsVisible = function ()
	{
		return isVisible;
	}
	this.Show = function ()
	{
		if (!isVisible)
		{
			self.SetQualityHint();
			$pc.stop(true, true);
			$pc.show();
			isVisible = true;
			self.resized();
		}
		var loadingImg = videoPlayer.Loading().image;
		if (loadingImg.isLive)
		{
			playbackHeader.Hide();
			$("#seekBarWrapper").hide();
		}
		else
		{
			if (loadingImg.isTimeline())
			{
				playbackHeader.Hide();
				$("#seekBarWrapper").hide();
			}
			else
			{
				playbackHeader.Show();
				$("#seekBarWrapper").show();
			}
		}
		evaluateShowHideRules();
	}
	var evaluateShowHideRules = function ()
	{
		var loadingImg = videoPlayer.Loading().image;
		// "hideWhenLive" is used to suppress controls that we want always shown on the timeline tab.
		if (currentPrimaryTab === "timeline")
			$("#pcButtonContainer .hideWhenLive").removeClass('temporarilyUnavailable');
		else if (loadingImg.isLive)
			$("#pcButtonContainer .hideWhenLive").addClass('temporarilyUnavailable');
		else
			$("#pcButtonContainer .hideWhenLive").removeClass('temporarilyUnavailable');

		// "showWhenLive" applies simply during live video playback regardless of UI tab.
		if (loadingImg.isLive)
			$("#pcButtonContainer .showWhenLive").removeClass('temporarilyUnavailable');
		else
			$("#pcButtonContainer .showWhenLive").addClass('temporarilyUnavailable');
		self.setPlayPauseButtonState();
	}
	BI_CustomEvent.AddListener("TabLoaded_live", function () { evaluateShowHideRules(); });
	BI_CustomEvent.AddListener("TabLoaded_clips", function () { evaluateShowHideRules(); });
	BI_CustomEvent.AddListener("TabLoaded_timeline", function () { evaluateShowHideRules(); });
	this.Hide = function ()
	{
		if (isVisible)
		{
			CloseSettings();
			$pc.stop(true, true);
			$pc.hide();
			isVisible = false;
			self.resized();
			seekBar.onHide();
		}
		playbackHeader.Hide();
	}
	this.FadeIn = function ()
	{
		if (!isVisible)
		{
			self.SetQualityHint();
			$pc.stop(true, true);
			$pc.fadeIn(100);
			isVisible = true;
			self.resized();
		}
		var loadingImg = videoPlayer.Loading().image;
		if (loadingImg.isLive || loadingImg.isTimeline())
			playbackHeader.Hide();
		else
			playbackHeader.FadeIn();
	}
	this.FadeOut = function ()
	{
		if (isVisible)
		{
			CloseSettings();
			if (self.IsSeekbarDragging() || exportControls.IsEnabled() || settings.ui3_extra_playback_controls_alwaysVisible === "1")
				return;
			$pc.stop(true, true);
			$pc.fadeOut(100);
			isVisible = false;
			self.resized();
			seekBar.onHide();
		}

		for (var i = 0; i < showTimeouts.length; i++)
			clearTimeout(showTimeouts[i]);
		showTimeouts = [];

		playbackHeader.FadeOut();
	}
	var clearHideTimout = function ()
	{
		if (hideTimeout != null)
		{
			clearTimeout(hideTimeout);
			hideTimeout = null;
		}
	}
	var hideAfterTimeout = function ()
	{
		clearHideTimout();
		hideTimeout = setTimeout(function () { self.FadeOut(); }, videoPlayer.Loading().image.isLive ? self.hideTimeMs_Live : self.hideTimeMs_Recordings);
	}
	this.Live = function ()
	{
		self.Show();
		hideAfterTimeout();
		$pc.addClass("live");
		self.SetProgressText("Loading...");
		self.setPlayPauseButtonState();
	}
	this.Recording = function (clipData)
	{
		self.Show();
		hideAfterTimeout();
		$pc.removeClass("live");
		self.SetProgressText("Loading...");
		self.setPlayPauseButtonState();
		SetDownloadClipLink(clipData);
		if (clipLoader.GetUnexportableReason(clipData))
		{
			$("#clipDownloadButton").show();
			$("#clipExportButton").hide();
		}
		else
		{
			$("#clipDownloadButton").hide();
			$("#clipExportButton").show();
		}
	}
	this.IsSeekbarDragging = function ()
	{
		return seekBar.IsDragging() || exportControls.IsDragging();
	}
	this.setPlayPauseButtonState = function (paused)
	{
		if (videoPlayer.Loading().image.isLive && currentPrimaryTab !== "timeline")
		{
			$("#pcPlay").hide();
			$("#pcPause").hide();
		}
		else
		{
			if (typeof paused === "undefined")
				paused = videoPlayer.Playback_IsPaused();
			if (paused)
			{
				$("#pcPlay").show();
				$("#pcPause").hide();
			}
			else
			{
				$("#pcPlay").hide();
				$("#pcPause").show();
			}
		}
		mediaSessionController.setMediaState();
	}
	var SetDownloadClipLink = function (clipData)
	{
		var clipInfo = clipLoader.GetDownloadClipInfo(clipData);
		var $btn = $("#clipDownloadButton");
		$btn.attr("href", clipInfo.href);
		if (clipInfo.download)
			$btn.attr("download", clipInfo.download);
		else
			$btn.removeAttr("download");
	}
	var mouseLeave = function (e)
	{
		mouseCoordFixer.fix(e);
		if (pointInsideElement($layoutbody, e.mouseX, e.mouseY) || pointInsideElement($layoutbottom, e.mouseX, e.mouseY))
			return;
		CloseSettings();
		clearHideTimout();
		self.FadeOut();
	}
	$layoutbody.on("mouseleave", mouseLeave);
	$layoutbottom.on("mouseleave", mouseLeave);
	var mouseAction = function (e)
	{
		mouseCoordFixer.fix(e);
		showTimeouts.push(setTimeout(self.FadeIn, 30)); // This is carefully tuned to prevent accidental clicks on playback controls that were invisible when the touch began.  Prior to v81 we did this by stopping/preventing the click event, but due to a chrome pinch zooming bug we must use a passive listener for this, which can't cancel the click event.
		clearHideTimout();

		if (!self.MouseInPlaybackControls(e))
			hideAfterTimeout();
	}
	BindEventsPassive($layoutbody.get(0), "mouseenter mousemove mouseup touchmove touchend touchcancel", mouseAction);
	BindEventsPassive($layoutbottom.get(0), "mouseenter mousemove mouseup touchmove touchend touchcancel", mouseAction);
	this.MouseInPlaybackControls = function (e)
	{
		mouseCoordFixer.fix(e);
		return pointInsideElement($pc, e.mouseX, e.mouseY)
			|| pointInsideElement($playbackSettings, e.mouseX, e.mouseY)
			|| pointInsideElement(playbackHeader.Get$Ref(), e.mouseX, e.mouseY)
			|| clipTimeline.pointInsideTimeline(e.mouseX, e.mouseY);
	}
	$(document).mouseup(function (e)
	{
		if (!self.MouseInSettingsPanel(e))
			CloseSettings();
	});
	this.OpenSettingsPanel = function ()
	{
		if (performance.now() - 33 <= settingsClosedAt)
			return;
		if (videoPlayer.Loading().image.isLive)
			return OpenQualityPanel();
		RebuildSettingsPanelEmpty();
		var isTimeline = videoPlayer.Loading().image.isTimeline();
		if (!isTimeline)
			$playbackSettings.append('<div class="playbackSettingsCheckboxWrapper">'
				+ '<input id="cbAutoplay" type="checkbox" class="sliderCb" onclick="playbackControls.AutoplayClicked()" '
				+ (autoplay ? ' checked="checked"' : '')
				+ '/>'
				+ '<label for="cbAutoplay"><span class="ui"></span>Autoplay<div class="playbackSettingsSpacer"></div></label>'
				+ '</div>');
		$playbackSettings.append('<div class="playbackSettingsCheckboxWrapper">'
			+ '<input id="cbReverse" type="checkbox" class="sliderCb" onclick="playbackControls.ReverseClicked()" '
			+ (playReverse ? ' checked="checked"' : '')
			+ '/>'
			+ '<label for="cbReverse"><span class="ui"></span>Reverse<div class="playbackSettingsSpacer"></div></label>'
			+ '</div>');
		if (!isTimeline)
			$playbackSettings.append('<div class="playbackSettingsCheckboxWrapper">'
				+ '<input id="cbLoop" type="checkbox" class="sliderCb" onclick="playbackControls.LoopClicked()" '
				+ (loopingEnabled ? ' checked="checked"' : '')
				+ '/>'
				+ '<label for="cbLoop"><span class="ui"></span>Loop<div class="playbackSettingsSpacer"></div></label>'
				+ '</div>');
		if (isTimeline)
		{
			var $line = $('<label class="playbackSettingsLine">Skip dead-air</label>');
			var $wrapper = $('<span class="playbackSettingsFloatRight"></span>');
			$line.append($wrapper);
			$wrapper.append(UIFormField({
				inputType: "threeState"
				, value: settings.ui3_playback_skipDeadAir
				, tag: "skipDeadAir",
				onChange: function (e, value, $btn)
				{
					self.FadeIn();
					hideAfterTimeout();
					settings.ui3_playback_skipDeadAir = value.toString();
					OnChange_ui3_playback_skipDeadAir();
				}
			}));
			$playbackSettings.append($line);
		}
		var $speedBtn = $('<div class="playbackSettingsLine speedBtn">'
			+ 'Speed<div class="playbackSettingsFloatRight">'
			+ (playSpeed == 1 ? "Normal" : playSpeed)
			+ '<div class="playbackSettingsRightArrow"><svg class="icon"><use xlink:href="#svg_x5F_PTZcardinalRight"></use></svg></div>'
			+ '</div></div>');
		$speedBtn.click(self.OpenSpeedPanel);
		$playbackSettings.append($speedBtn);
		var $qualityBtn = $('<div class="playbackSettingsLine">'
			+ 'Quality<div class="playbackSettingsFloatRight">'
			+ (sessionManager.CanProfileUseOverrides() ? '' : GetStreamOverrideWarningSymbolMarkup(genericQualityHelper.GetCurrentProfileIndex()))
			+ htmlEncode(genericQualityHelper.GetCurrentProfile().GetNameText())
			+ '<div class="playbackSettingsRightArrow"><svg class="icon"><use xlink:href="#svg_x5F_PTZcardinalRight"></use></svg></div>'
			+ '</div></div>');
		$qualityBtn.click(OpenQualityPanel);
		$playbackSettings.append($qualityBtn);
		$layoutbody.append($playbackSettings);
	}
	this.OpenSpeedPanel = function ()
	{
		RebuildSettingsPanelEmpty();
		$playbackSettings.addClass("speedPanel");
		$playbackSettings.append($backBtn);
		if (videoPlayer.Loading().image.isTimeline())
		{
			$playbackSettings.append('<div class="playbackSettingsLine playbackSettingsHeading" style="cursor: default;">Speed</div>');
		}
		else
		{
			var $backBtn = $('<div class="playbackSettingsLine playbackSettingsHeading">'
				+ '<div class="playbackSettingsLeftArrow"><svg class="icon"><use xlink:href="#svg_x5F_PTZcardinalLeft"></use></svg></div> '
				+ 'Speed</div>');
			$backBtn.click(self.OpenSettingsPanel);
			$playbackSettings.append($backBtn);
		}

		for (var i = 0; i < SpeedOptions.length; i++)
		{
			var $item = $('<div class="playbackSettingsLine alignRight"></div>');
			$item.text(SpeedOptions[i] == 1 ? "Normal" : SpeedOptions[i]);
			if (SpeedOptions[i] == playSpeed)
				$item.addClass("selected");
			$item.get(0).listItemIndex = i;
			$item.click(function ()
			{
				settings.ui3_playback_speed = playSpeed = SpeedOptions[this.listItemIndex];
				SetPlaySpeedLabel();
				CloseSettings();
				videoPlayer.PlaybackSpeedChanged(playSpeed);
			});
			$playbackSettings.append($item);
		}

		$layoutbody.append($playbackSettings);
	}
	var OpenQualityPanel = function ()
	{
		RebuildSettingsPanelEmpty();
		$playbackSettings.addClass("qualityPanel");
		var showBackBtn = !videoPlayer.Loading().image.isLive && !videoPlayer.Loading().image.isTimeline();
		var $backBtn = $('<div class="playbackSettingsLine playbackSettingsHeading">'
			+ (showBackBtn ? '<div class="playbackSettingsLeftArrow"><svg class="icon"><use xlink:href="#svg_x5F_PTZcardinalLeft"></use></svg></div> ' : '')
			+ 'Quality</div>');
		if (showBackBtn)
			$backBtn.click(self.OpenSettingsPanel);
		else
			$backBtn.css('cursor', 'default');

		var $editBtn = $('<div class="playbackSettingsEditProfiles" title="Edit Streaming Profiles"><svg class="icon noflip"><use xlink:href="#svg_mio_edit"></use></svg></div>');
		$editBtn.on('click', function (e)
		{
			streamingProfileUI.open();
			CloseSettings();
			return false;
		});
		$backBtn.append($editBtn);

		$playbackSettings.append($backBtn);

		var currentProfile = genericQualityHelper.GetCurrentProfile();
		var $selectedItem = $();
		for (var i = 0; i < genericQualityHelper.profiles.length; i++)
		{
			var p = genericQualityHelper.profiles[i];
			if (!p.IsCompatible())
				continue;
			var $item = $('<div class="playbackSettingsLine alignRight"></div>');
			var name = $item.get(0).qualityName = p.name;
			$item.append(p.GetNameEle());
			var tooltip = p.GetTooltipText();
			if (tooltip)
				$item.attr('title', tooltip);
			if (name === currentProfile.name)
				$selectedItem = $item.addClass("selected");
			$item.click(function ()
			{
				genericQualityHelper.QualityChoiceChanged(this.qualityName);
				self.SetQualityHint();
				CloseSettings();
			});
			$playbackSettings.append($item);
		}

		$layoutbody.append($playbackSettings);

		if ($selectedItem.length > 0)
		{
			// Determine ideal scroll position
			var eleCenter = $selectedItem.position().top + $selectedItem.outerHeight(true) / 2;
			var visibleHeight = $playbackSettings.innerHeight();
			var idealScrollTop = eleCenter - (visibleHeight / 2);
			if (idealScrollTop > 0)
				$playbackSettings.scrollTop(idealScrollTop);
		}
	}
	var CloseSettings = function ()
	{
		if ($playbackSettings.length > 0)
		{
			$playbackSettings.remove();
			$playbackSettings = $();
			settingsClosedAt = performance.now();
		}
	}
	var RebuildSettingsPanelEmpty = function ()
	{
		CloseSettings();

		var pcHeight = $pc.height();
		var availableHeight = $("#layoutbody").height() - pcHeight;

		$playbackSettings = $('<div class="playbackSettings"></div>');
		$playbackSettings.css("bottom", (pcHeight + 12) + "px");
		$playbackSettings.css("max-height", (availableHeight - 44) + "px");
	}
	this.AutoplayClicked = function ()
	{
		self.FadeIn();
		hideAfterTimeout();
		autoplay = $("#cbAutoplay").is(":checked");
		settings.ui3_playback_autoplay = autoplay ? "1" : "0";
	}
	this.ReverseClicked = function ()
	{
		self.FadeIn();
		hideAfterTimeout();
		playReverse = $("#cbReverse").is(":checked");
		settings.ui3_playback_reverse = playReverse ? "1" : "0";
		videoPlayer.PlaybackDirectionChanged(playReverse);
	}
	this.ToggleReverse = function ()
	{
		self.FadeIn();
		hideAfterTimeout();
		if ($("#cbReverse").length > 0)
		{
			if ($("#cbReverse").is(":checked"))
				$("#cbReverse").removeProp("checked");
			else
				$("#cbReverse").prop("checked", "checked");
		}
		playReverse = !playReverse;
		settings.ui3_playback_reverse = playReverse ? "1" : "0";
		videoPlayer.PlaybackDirectionChanged(playReverse);
	}
	this.LoopClicked = function ()
	{
		self.FadeIn();
		hideAfterTimeout();
		loopingEnabled = $("#cbLoop").is(":checked");
		settings.ui3_playback_loop = loopingEnabled ? "1" : "0";
	}
	this.MouseInSettingsPanel = function (e)
	{
		mouseCoordFixer.fix(e);
		return pointInsideElement($playbackSettings, e.mouseX, e.mouseY);
	}
	this.SettingsPanelIsOpen = function (e)
	{
		return $playbackSettings.length > 0;
	}
	this.GetSpeedBasedSubstreamArgument = function ()
	{
		if (playSpeed !== 1)
		{
			var substreamThreshold = playReverse
				? parseFloat(settings.ui3_reverse_speed_substream_threshold)
				: parseFloat(settings.ui3_forward_speed_substream_threshold);
			if (substreamThreshold && !isNaN(substreamThreshold) && playSpeed >= substreamThreshold)
				return "&decode=-1";
		}
		return "";
	}
	this.GetMainStreamSpeedRangeComment = function ()
	{
		var options = GetPlaybackSpeedOptions();
		if (!options || !options.length)
			return "No playback speed options!";
		var subStreamReverseThreshold = parseFloat(settings.ui3_reverse_speed_substream_threshold);
		var subStreamForwardThreshold = parseFloat(settings.ui3_forward_speed_substream_threshold);
		var mainStreamReverseThreshold = 0;
		var mainStreamForwardThreshold = 0;
		for (var i = 0; i < options.length; i++)
		{
			var opt = options[i];
			if (opt < subStreamReverseThreshold)
				mainStreamReverseThreshold = opt;
			if (opt < subStreamForwardThreshold)
				mainStreamForwardThreshold = opt;
		}
		return "-" + mainStreamReverseThreshold + "x to " + mainStreamForwardThreshold + "x";
	}
	this.GetPlaybackSpeed = function ()
	{
		return playSpeed;
	}
	this.GetPlayReverse = function ()
	{
		return playReverse;
	}
	this.GetAutoplay = function ()
	{
		return autoplay;
	}
	this.GetLoopingEnabled = function ()
	{
		return loopingEnabled;
	}
	this.GetSkipDeadAirState = function ()
	{
		return settings.ui3_playback_skipDeadAir;
	}
	this.GetSkipDeadAirArg = function ()
	{
		if (settings.ui3_playback_skipDeadAir === "2")
			return "&skipdeadair=1";
		else if (settings.ui3_playback_skipDeadAir === "1")
			return "&skipdeadair=0";
		else
			return "&skipdeadair=";
	}
	this.ChangePlaySpeed = function (offset)
	{
		for (var i = 0; i < SpeedOptions.length; i++)
			if (SpeedOptions[i] == playSpeed)
			{
				i += offset;
				if (i >= 0 && i < SpeedOptions.length)
				{
					settings.ui3_playback_speed = playSpeed = SpeedOptions[i];
					videoPlayer.PlaybackSpeedChanged(playSpeed);
					self.FadeIn();
					hideAfterTimeout();
					NotifySpeedChanged();
				}
				return;
			}
	}
	this.FrameTimestampUpdated = function (utc)
	{
		if (utc && settings.ui3_extra_playback_controls_timestamp === "1")
		{
			var dateStr = GetDateStr(GetServerDate(new Date(utc)));
			$playbackFrameTimestamp.text(dateStr);
			if (!pcFrameTimestampVisible)
			{
				$playbackFrameTimestamp.show();
				pcFrameTimestampVisible = true;
			}
		}
		else if (pcFrameTimestampVisible)
		{
			$playbackFrameTimestamp.hide();
			pcFrameTimestampVisible = false;
		}
	}
	/** Updates several GUI elements with the new playSpeed value. */
	var NotifySpeedChanged = function ()
	{
		SetPlaySpeedLabel();
		if ($playbackSettings && $playbackSettings.length > 0)
		{
			if ($playbackSettings.hasClass("speedPanel"))
				self.OpenSpeedPanel();
			else
				$playbackSettings.find("div.speedBtn .playbackSettingsFloatRight").html((playSpeed == 1 ? "Normal" : playSpeed));
		}
	}
	this.SetQualityHint = function ()
	{
		var p = genericQualityHelper.GetCurrentProfile();
		if (p.abbr)
		{
			var aClr = p.GetAbbrColor();
			var bgColor = "#" + aClr;
			var fgColor = "#" + GetReadableTextColorHexForBackgroundColorHex(aClr, "000000", "FFFFFF");
			$("#playbackSettingsQualityMark").css("background-color", bgColor).css("color", fgColor).text(p.abbr.substr(0, 4)).show();
		}
		else
			$("#playbackSettingsQualityMark").hide();
	}
	$(document).on("mousemove touchmove", function (e)
	{
		mouseCoordFixer.fix(e);
		if (touchEvents.Gate(e))
			return;
		if (!exportControls.mouseMove(e))
			seekBar.mouseMove(e, true);
	});
	$(document).on("mouseup mouseleave touchend touchcancel", function (e)
	{
		mouseCoordFixer.fix(e);
		if (touchEvents.Gate(e))
			return;
		if (!exportControls.mouseUp(e))
			seekBar.mouseUp(e);
	});
}
function GetStreamOverrideWarningSymbolMarkup(profileIndex)
{
	var button = typeof profileIndex === "number";
	var cssClass = 'warningSymbol' + (button ? ' button' : '');
	var onclick = button ? ' onclick="OpenStreamingProfileEditor(' + profileIndex + ', event)"' : '';
	var tooltip = "This streaming profile is not allowed to override most encoding parameters and may not operate as expected.";
	if (button)
		tooltip += "\n\nClick to edit this profile.";
	return '<div class="' + cssClass + '"' + onclick + ' title="' + tooltip + '"><div class="warningSymbolWhiteInterior"></div><svg class="icon noflip"><use xlink:href="#svg_mio_warning"></use></svg></div>';
}
function OpenStreamingProfileEditor(profileIndex, e)
{
	if (e && e.stopPropagation)
		e.stopPropagation();
	new StreamingProfileEditor(genericQualityHelper.GetProfileWithIndex(profileIndex), function () { });
}
function SyncStreamingQualityWarningIcon(haveNewSessionData)
{
	if (genericQualityHelper && sessionManager)
	{
		if (sessionManager.CanProfileUseOverrides())
			$('#playbackSettingsWarning').hide();
		else
			$('#playbackSettingsWarning').show();

		dropdownBoxes.setLabelText("streamingQuality", genericQualityHelper.GetCurrentProfile().GetNameEle().html(), true);
		if (haveNewSessionData)
			genericQualityHelper.SetStreamingQualityDropdownBoxItems();
	}
}
///////////////////////////////////////////////////////////////
// Playback Controls //////////////////////////////////////////
///////////////////////////////////////////////////////////////
function PlaybackHeader()
{
	var self = this;
	var $layoutbody = $("#layoutbody");
	var $ph = $("#playbackHeader");
	var $closeBtnL = $("#closeClipLeft");
	var $clipNameHeading = $("#clipNameHeading");
	var isVisible = $ph.is(":visible");

	$closeBtnL.click(function ()
	{
		clipLoader.CloseCurrentClip();
	});
	this.resized = function ()
	{
		var o = $ph.offset();
		$ph.get(0).savedBounds = { x: o ? o.left : 0, y: o ? o.top : 0, w: $ph.width(), h: $ph.height() };
	}
	this.Show = function ()
	{
		if (!isVisible)
		{
			$ph.stop(true, true);
			$ph.show();
			isVisible = true;
			self.resized();
		}
	}
	this.Hide = function ()
	{
		if (isVisible)
		{
			$ph.stop(true, true);
			$ph.hide();
			isVisible = false;
			self.resized();
		}
	}
	this.FadeIn = function ()
	{
		if (!isVisible)
		{
			$ph.stop(true, true);
			$ph.fadeIn(100);
			isVisible = true;
			self.resized();
		}
	}
	this.FadeOut = function ()
	{
		if (isVisible)
		{
			$ph.stop(true, true);
			$ph.fadeOut(100);
			isVisible = false;
			self.resized();
		}
	}
	this.SetClipName = function (clipData)
	{
		var name = clipLoader.GetClipDisplayName(clipData);
		$clipNameHeading.text(name);
	}
	this.Get$Ref = function ()
	{
		return $ph;
	}
}
///////////////////////////////////////////////////////////////
// Seek Bar ///////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function SeekBar()
{
	var self = this;
	var $layoutbody = $("#layoutbody");
	var wrapper = $("#seekBarWrapper");
	var bar = $("#seekBarMain");
	var left = $("#seekBarLeft");
	var handle = $("#seekBarHandle");
	var seekhint = $("#seekhint");
	var seekhint_img = $("#seekhint_img");
	var seekhint_canvas = $("#seekhint_canvas");
	var seekhint_img_ele = seekhint_img.get(0);
	var seekhint_canvas_ele = seekhint_canvas.get(0);
	var seekhint_loading = $("#seekhint_loading");
	var seekhint_helper = $("#seekhint_helper");
	var seekhint_label = $("#seekhint_label");
	var highlight = $("#seekBarHighlight");
	var seekHintVisible = false;
	var isDragging = false;
	var isTouchDragging = false;
	var didPauseOnDrag = false;
	var mouseDidActuallyDrag = false; // This is set only for the duration of the mousedown handler which causes playback pausing for dragging.  Helps work around a bug where a seek hint image is loaded simply due to a single click on the seek bar while a clip is playing.
	var seekHintInfo = { canvasVisible: false, helperVisible: false, visibleMsec: -1, queuedMsec: -1, loadingMsec: -1, lastSnapshotId: "" }

	seekhint_img.load(function ()
	{
		if (isDragging)
		{
			jpegPreviewModule.RenderImage(seekhint_img_ele);
			var msecTotal = videoPlayer.Loading().image.msec;
			playbackControls.SetProgressText(msToTime(seekHintInfo.loadingMsec, 0) + " / " + msToTime(msecTotal, 0));
		}
		CopyImageToCanvas(seekhint_img_ele, seekhint_canvas_ele);
		seekhint_loading.addClass('hidden');
		seekHintInfo.loading = false;
		seekHintInfo.visibleMsec = seekHintInfo.loadingMsec;
		if (seekHintInfo.queuedMsec != -1)
			loadSeekHintImg(seekHintInfo.queuedMsec);
	});
	seekhint_img.error(function ()
	{
		ClearCanvas(seekhint_canvas_ele);
		seekhint_loading.addClass('hidden');
		seekHintInfo.loading = false;
		seekHintInfo.loadingMsec = seekHintInfo.visibleMsec = -1;
		if (seekHintInfo.queuedMsec != -1)
			loadSeekHintImg(seekHintInfo.queuedMsec);
	});

	this.resized = function ()
	{
		self.drawSeekbarAtPercent(videoPlayer.GetClipPlaybackPositionPercent());
	}
	var setSeekHintCanvasVisibility = function (visible)
	{
		if (visible)
		{
			if (!seekHintInfo.canvasVisible)
			{
				seekhint_canvas.show();
				seekHintInfo.canvasVisible = true;
			}
		}
		else
		{
			if (seekHintInfo.canvasVisible)
			{
				seekhint_canvas.hide();
				seekhint_loading.addClass('hidden');
				seekHintInfo.canvasVisible = false;
			}
		}
	}
	var setSeekHintHelperVisibility = function (visible)
	{
		if (visible)
		{
			if (!seekHintInfo.helperVisible)
			{
				seekhint_helper.show();
				seekHintInfo.helperVisible = true;
			}
		}
		else
		{
			if (seekHintInfo.helperVisible)
			{
				seekhint_helper.hide();
				seekHintInfo.helperVisible = false;
			}
		}
	}
	var updateSeekHint = function (e)
	{
		if (!seekHintVisible)
			return;
		if (videoPlayer.Loading().image.isLive || videoPlayer.Loading().image.isTimeline())
		{
			console.log("Cannot update seek hint while loading live video or timeline video");
			return;
		}
		// Update seek hint text and location
		var msec = videoPlayer.Loading().image.msec;
		var bodyO = $layoutbody.offset();
		var barO = bar.offset();
		var barW = bar.width();

		var hintX = Clamp(e.mouseX - barO.left, 0, barW);
		var seekHintW = seekhint.outerWidth();
		var seekHintL = (hintX + barO.left) - (seekHintW / 2) - bodyO.left;
		var barMarginL = barO.left - bodyO.left;
		seekHintL = Clamp(seekHintL, barMarginL, (barMarginL + barW) - seekHintW);
		seekhint.css("left", seekHintL + "px");
		var positionRelative = (hintX / barW);
		var seekHintMs = Clamp(parseInt(positionRelative * (msec - 1)), 0, msec);
		if (videoPlayer.Playback_IsPaused() && mouseDidActuallyDrag)
		{
			// show preview image
			setSeekHintCanvasVisibility(!isDragging);
			setSeekHintHelperVisibility(false);
			if (seekHintInfo.visibleMsec == seekHintInfo.loadingMsec)
				loadSeekHintImg(seekHintMs);
			else
				seekHintInfo.queuedMsec = seekHintMs;
		}
		else
		{
			setSeekHintCanvasVisibility(false);
			setSeekHintHelperVisibility(true);
		}
		var seekhintLabelHtml = msToTime(seekHintMs, msec < 30000 ? 1 : 0);
		var clipData = clipLoader.GetClipFromId(videoPlayer.Loading().image.uniqueId);
		if (!clipData)
		{
			console.error("updateSeekHint could not find clipData for ID " + videoPlayer.Loading().image.uniqueId);
			return;
		}
		if (!clipLoader.ClipLikelyHasGaps(clipData))
			seekhintLabelHtml = seekhintLabelHtml + '<div class="seekTimeReal">' + GetTimeStr(new Date(clipData.clipStartDate.getTime() + seekHintMs)) + '</div>';
		seekhint_label.html(seekhintLabelHtml);
		seekhint.css("top", ((barO.top - 10) - seekhint.outerHeight(true) - bodyO.top) + "px");
		highlight.css("width", hintX + "px");
	}
	var loadSeekHintImg = function (msec)
	{
		seekHintInfo.queuedMsec = -1;
		if (seekHintInfo.visibleMsec != msec)
		{
			seekHintInfo.loadingMsec = msec;
			if (seekHintInfo.lastSnapshotId != "" && seekHintInfo.lastSnapshotId == videoPlayer.GetStaticSnapshotId())
				return; // No need to load same snapshot as before

			var loadingImg = videoPlayer.Loading().image;
			seekHintInfo.lastSnapshotId = videoPlayer.GetStaticSnapshotId();
			var sizeToRequest = imageRenderer.GetSizeToRequest(loadingImg);
			sizeToRequest.ApplyBoundingBox(new ui3Rect(160, 160));
			var hintMarginLeft = Clamp((160 - sizeToRequest.w) / 2, 0, 160);
			seekhint_canvas.css("margin-left", hintMarginLeft + "px").css('width', sizeToRequest.w + 'px').css('height', sizeToRequest.h + 'px');
			seekhint_loading.css("margin-left", hintMarginLeft + "px").css('width', sizeToRequest.w + 'px').css('height', sizeToRequest.h + 'px');
			if (seekHintInfo.canvasVisible)
			{
				var loadSize = Math.min(sizeToRequest.w, sizeToRequest.h);
				$("#seekhint_loading_anim").css('width', loadSize + 'px').css('height', loadSize + 'px')
				seekhint_loading.removeClass('hidden');
			}
			var qualityArgs;
			if (isDragging)
			{
				videoOverlayHelper.ShowLoadingOverlay(true, true);

				var subStreamArg = settings.ui3_seek_with_substream === "1" ? "&decode=-1" : "";
				qualityArgs = genericQualityHelper.getSeekPreviewQualityArgs(loadingImg) + subStreamArg;
			}
			else
				qualityArgs = "&w=" + sizeToRequest.w + "&h=" + sizeToRequest.h + "&q=50&stream=0&decode=-1";
			var url = RemoveUrlParameters(videoPlayer.GetLastSnapshotUrl(), "time", "w", "h", "q", "stream");
			url += "&time=" + msec + qualityArgs;
			seekhint_img.attr('src', url);
		}
	}
	this.resetSeekHintImg = function ()
	{
		seekHintInfo.loadingMsec = seekHintInfo.queuedMsec = seekHintInfo.visibleMsec = -1;
		seekhint_canvas.css('height', (160 / videoPlayer.Loading().image.getFullRect().AspectRatio()) + 'px');
		ClearCanvas(seekhint_canvas_ele);
		seekhint_loading.addClass('hidden');
	}
	this.drawSeekbarAtPercent = function (percentValue)
	{
		var seekbarW = bar.width();
		var x = percentValue * seekbarW;
		x = Clamp(x, 0, seekbarW);
		left.css("width", x + "px");
		handle.css("left", x + "px");
		var msec = videoPlayer.Loading().image.msec;
		var timeValue;
		if (percentValue >= 1)
			timeValue = msec;
		else if (percentValue <= 0)
			timeValue = 0;
		else
			timeValue = (msec - 1) * percentValue;
		if (!videoPlayer.Loading().image.isLive && !videoPlayer.Loading().image.isTimeline())
			playbackControls.SetProgressText(msToTime(timeValue, 0) + " / " + msToTime(msec, 0));
	}
	this.drawSeekbarAtTime = function (timeValue)
	{
		var msec = videoPlayer.Loading().image.msec;
		var currentSeekBarPositionRelative;
		if (msec <= 1)
			currentSeekBarPositionRelative = 0;
		else
			currentSeekBarPositionRelative = parseFloat(timeValue / (msec - 1));
		var seekbarW = bar.width();
		var x = currentSeekBarPositionRelative * seekbarW;
		x = Clamp(x, 0, seekbarW);
		left.css("width", x + "px");
		handle.css("left", x + "px");
		if (timeValue == msec - 1)
			timeValue = msec;
		if (!videoPlayer.Loading().image.isLive && !videoPlayer.Loading().image.isTimeline())
			playbackControls.SetProgressText(msToTime(timeValue, 0) + " / " + msToTime(msec, 0));
	}
	this.IsDragging = function ()
	{
		return isDragging;
	}
	this.onHide = function ()
	{
		handle.removeClass("unfocus");
		bar.removeClass("unfocus");
		handle.removeClass("focus");
		bar.removeClass("focus");
	}
	this.getWidth = function ()
	{
		return bar.width();
	}
	this.getOffset = function ()
	{
		return bar.offset();
	}
	var SetBarState = function (state)
	{
		if (state == 1)
		{
			bar.addClass("focus");
			if (!exportControls.IsDragging())
			{
				handle.addClass("focus");
				seekhint.removeClass('hidden');
			}
			seekHintVisible = true;
		}
		else
		{
			handle.removeClass("focus");
			bar.removeClass("focus");
			seekhint.addClass('hidden');
			seekHintVisible = false;
			highlight.css("width", "0px");
		}
	}
	this.mouseUp = function (e)
	{
		if (!isDragging)
			return;

		self.mouseMove(e, true);

		var barO = bar.offset();
		var barW = bar.width();
		var x = (e.mouseX - barO.left);
		x = Clamp(x, 0, barW);
		var msec = videoPlayer.Loading().image.msec;
		if (msec <= 1)
			videoPlayer.SeekToPercent(0, didPauseOnDrag);
		else
		{
			var positionRelative = x / barW;
			videoPlayer.SeekToPercent(positionRelative, didPauseOnDrag);
		}
		didPauseOnDrag = false;

		isTouchDragging = false;
		isDragging = false;
		if (touchEvents.isTouchEvent(e) || !pointInsideElement(wrapper, e.mouseX, e.mouseY))
			SetBarState(0);
		updateSeekHint(e);
	}
	this.mouseMove = function (e, isRealMoveEvent)
	{
		mouseDidActuallyDrag = isRealMoveEvent;
		if (isDragging)
		{
			var barO = bar.offset();
			var barW = bar.width();
			var x = (e.mouseX - barO.left);
			x = Clamp(x, 0, barW);
			left.css("width", x + "px");
			handle.css("left", x + "px");
		}
		updateSeekHint(e);
	}
	this.mouseDown = function (e)
	{
		mouseDidActuallyDrag = false;
		if (e.which != 3)
		{
			isDragging = true;
			didPauseOnDrag = !videoPlayer.Playback_IsPaused();
			videoPlayer.Playback_Pause();
			isTouchDragging = touchEvents.isTouchEvent(e);

			videoOverlayHelper.ShowLoadingOverlay();

			SetBarState(1);

			self.mouseMove(e);
			$.hideAllContextMenus();
			return stopDefault(e);
		}
		else
			self.mouseMove(e);
	}
	wrapper.on("mousedown touchstart", function (e)
	{
		mouseCoordFixer.fix(e);
		if (touchEvents.Gate(e))
			return;
		return self.mouseDown(e);
	});
	wrapper.on("mouseenter", function (e)
	{
		mouseCoordFixer.fix(e);
		SetBarState(1);
		updateSeekHint(e);
	});
	wrapper.on("mouseleave", function (e)
	{
		mouseCoordFixer.fix(e);
		if (!isDragging)
			SetBarState(0);
	});
}
///////////////////////////////////////////////////////////////
// Clip Export Controls ///////////////////////////////////////
///////////////////////////////////////////////////////////////
function ExportControls()
{
	var self = this;
	var $layoutBottom = $('#layoutbottom');
	var $exportOffsetWrapper = $("#exportOffsetWrapper");
	var exportOffsetStart;
	var exportOffsetEnd;

	var clipData = null;
	var fileDuration = 2;
	var fileSizeBytes = 2;

	var controlsEnabled = false;
	var clipStatsLoaded = false;

	var Initialize = function ()
	{
		$exportOffsetWrapper.hide();
		exportOffsetStart = new ExportOffsetControl($("#exportOffsetStart"), 0.25, offsetChanged, onControlFocused);
		exportOffsetEnd = new ExportOffsetControl($("#exportOffsetEnd"), 0.75, offsetChanged, onControlFocused);
		BI_CustomEvent.AddListener("OpenVideo", CheckCurrentClip);
	}
	this.resized = function ()
	{
		if (!controlsEnabled)
			return;

		exportOffsetStart.resized();
		exportOffsetEnd.resized();

		offsetChanged();
	}
	this.IsDragging = function ()
	{
		return exportOffsetStart.IsDragging() || exportOffsetEnd.IsDragging();
	}
	this.IsEnabled = function ()
	{
		return controlsEnabled;
	}
	this.mouseMove = function (e)
	{
		var r1 = exportOffsetStart.mouseMove(e);
		var r2 = exportOffsetEnd.mouseMove(e);
		return r1 || r2;
	}
	this.mouseUp = function (e)
	{
		var r1 = exportOffsetStart.mouseUp(e);
		var r2 = exportOffsetEnd.mouseUp(e);
		return r1 || r2;
	}
	this.Enable = function (recId)
	{
		if (controlsEnabled)
			return;
		controlsEnabled = true;

		if (currentPrimaryTab !== "clips")
			$("#topbar_tab_clips").click();

		clipData = clipLoader.GetClipFromId(recId);

		if (!videoPlayer.Playback_IsPaused())
			videoPlayer.Playback_Pause();

		clipExportPanel.Open([clipData.recId], function (exportOptions)
		{
			self.Disable();
		});

		if (clipData.isClip)
			ClipStatsLoaded();
		else
		{
			// We've probably already loaded the clip duration for this alert because that happens when starting to stream it.
			if (clipData.hasLoadedClipStats)
				ClipStatsLoaded(); // We have
			else // We have not, so our clip duration and size values need updated.
			{
				clipExportPanel.UpdateRangeSelection(exportOffsetStart.getPosition(), exportOffsetEnd.getPosition());
				// call global resized
				resized();
				clipStatsLoader.LoadClipStats("@" + clipData.clipId, function (stats)
				{
					// This success callback can be called more than once. clipStatsLoaded will tell.
					if (clipStatsLoaded || !controlsEnabled)
						return;
					clipLoader.ApplyMissingStatsToClipData(stats, clipData);
					ClipStatsLoaded();
				});
			}
		}
	}
	var ClipStatsLoaded = function ()
	{
		if (!controlsEnabled)
			return;
		clipStatsLoaded = true;

		var msec = clipData.msec;
		if (videoPlayer.Loading().image.uniqueId === clipData.recId)
			msec = videoPlayer.Loading().image.msec;
		fileDuration = Math.max(msec, 2);
		fileSizeBytes = getBytesFromBISizeStr(clipData.fileSize);

		var startTime = 0;
		var endTime = 1;
		if (NumberHasFlags(clipData.flags, BIDBFLAG.ALERT_OFFSETTIME))
		{
			startTime = clipData.offsetMs / (fileDuration - 1);
			endTime = (clipData.offsetMs + clipData.roughLengthMs) / (fileDuration - 1);
		}

		exportOffsetStart.setClipData(clipData);
		exportOffsetEnd.setClipData(clipData);
		exportOffsetStart.setPosition(startTime);
		exportOffsetEnd.setPosition(endTime);

		$exportOffsetWrapper.show();

		var $selectOffsetsMessage = $('<div class="exportOffsetMessage">Choose offsets by dragging the handles</div>');
		var labelFontSize = Clamp($layoutBottom.width() * 0.04, 9, 18);
		$selectOffsetsMessage.css('font-size', labelFontSize + 'px');
		$selectOffsetsMessage.fadeIn(function ()
		{
			setTimeout(function ()
			{
				$selectOffsetsMessage.fadeOut(function ()
				{
					$selectOffsetsMessage.remove();
				});
			}, 4000);
		});
		$exportOffsetWrapper.append($selectOffsetsMessage);

		// call global resized
		resized();
	}
	this.SetStartTime = function (percent)
	{
		exportOffsetStart.setPosition(percent);
	}
	this.SetEndTime = function (percent)
	{
		exportOffsetEnd.setPosition(percent);
	}
	this.Disable = function ()
	{
		if (!controlsEnabled)
			return;
		controlsEnabled = false;
		clipStatsLoaded = false;

		clipData = null;

		$exportOffsetWrapper.hide();

		if (clipExportPanel.IsOpen())
			clipExportPanel.Close();

		// call global resized
		resized();
	}
	var CheckCurrentClip = function ()
	{
		if (!controlsEnabled)
			return;
		if (clipData.recId !== videoPlayer.Loading().image.uniqueId)
		{
			toaster.Info("The clip export operation was canceled because the clip was closed!", 10000);
			self.Disable();
		}
	}
	var offsetChanged = function ()
	{
		if (!controlsEnabled || !clipStatsLoaded)
			return;
		clipExportPanel.UpdateRangeSelection(exportOffsetStart.getPosition(), exportOffsetEnd.getPosition());
	}
	var onControlFocused = function (control)
	{
		exportOffsetStart.setZIndex(1);
		exportOffsetEnd.setZIndex(1);
		control.setZIndex(2);
	}
	Initialize();
}
function ExportOffsetControl($handle, defaultPolePosition, offsetChanged, onFocused)
{
	var self = this;
	var polePosition = defaultPolePosition;
	var $parent = $handle.parent();
	var percent;
	var po = $parent.offset();
	var pw = Math.max(2, $parent.width());
	var pwm1 = pw - 1;
	var w = $handle.width();
	var seekBarW = pw;
	var seekBarO = po;
	var dragOffset = 0;
	var isDragging = false;
	var $label = $('<div class="exportOffsetFlagLabel" style="' + (polePosition > 0.5 ? "right: 0px;" : "left: 0px;") + '"></div>');
	$handle.append($label);
	var $pole = $('<div class="exportOffsetFlagpole" style="left: ' + (polePosition * 100) + '%"></div>');
	$handle.append($pole);
	var clipData;
	this.setClipData = function (cd)
	{
		clipData = cd;
		self.resized();
	}
	this.setPosition = function (newPercent)
	{
		percent = Clamp(newPercent, 0, 1);
		self.resized();
		offsetChanged();
	}
	this.resized = function ()
	{
		if (!seekBar)
			return;
		po = $parent.offset();
		pw = Math.max(2, $parent.width());
		pwm1 = pw - 1;
		w = $handle.width();
		seekBarW = seekBar.getWidth();
		seekBarO = seekBar.getOffset();

		// Flip the flag orientation if too close to an edge.
		var labelW = $label.width();
		var posPx = (seekBarW * percent);
		var newPolePosition = polePosition;
		if (seekBarW > labelW
			&& (defaultPolePosition <= 0.5 && seekBarW - posPx < labelW)
			|| (defaultPolePosition > 0.5 && posPx < labelW
			))
			newPolePosition = 1 - defaultPolePosition;
		else
			newPolePosition = defaultPolePosition;
		if (newPolePosition !== polePosition)
		{
			polePosition = newPolePosition;
			if (polePosition > 0.5)
			{
				$label.css('right', '0px');
				$label.css('left', 'auto');
			}
			else
			{
				$label.css('right', 'auto');
				$label.css('left', '0px');
			}
			$pole.css('left', (polePosition * 100) + "%");
		}
		// Position the flag
		$handle.css('left', (posPx - (w * polePosition) + (seekBarO.left - po.left)) + 'px');


		if (clipData)
		{
			var offsetMs = percent * (videoPlayer.Loading().image.msec - 1); // Don't use clipData.msec here, because that can be out of sync with the seek bar.
			var txt = msToTime(offsetMs);
			if (!clipLoader.ClipLikelyHasGaps(clipData))
			{
				txt += '<br/><span class="realTime">' + GetTimeStr(new Date(clipData.clipStartDate.getTime() + offsetMs)) + '</span>';
				$parent.addClass('hasRealTime');
			}
			else
				$parent.removeClass('hasRealTime');
			$label.html(txt);
		}
	}
	this.getPosition = function ()
	{
		return percent;
	}
	this.IsDragging = function ()
	{
		return isDragging;
	}
	var FakeMouseEventForSeekBar = function (e)
	{
		return {
			mouseX: e.mouseX - dragOffset,
			mouseY: e.mouseY,
			type: e.type,
			noSeekHint: true,
			which: e.which,
			preventDefault: function ()
			{
				if (e.preventDefault)
					e.preventDefault();
			}
		};
	}
	var Initialize = function ()
	{
		$handle.attr('title', 'Right-click handle to set to current playback position');
		$handle.on('contextmenu', function (e)
		{
			self.setPosition(videoPlayer.GetClipPlaybackPositionPercent());
			return false;
		});
		$handle.on("mousedown touchstart", function (e)
		{
			mouseCoordFixer.fix(e);
			if (touchEvents.Gate(e))
				return;
			if (e.which != 3)
			{
				self.mouseDown(e);
				seekBar.mouseDown(FakeMouseEventForSeekBar(e));
				return false;
			}
		});
	}

	this.mouseDown = function (e)
	{
		dragOffset = (e.mouseX - $handle.offset().left) - (w * polePosition);
		isDragging = true;
		if (!videoPlayer.Playback_IsPaused())
			videoPlayer.Playback_Pause();
		if (typeof onFocused === "function")
			onFocused(self);
	}
	this.mouseMove = function (e)
	{
		if (isDragging)
		{
			var newPosX = (e.mouseX - seekBarO.left) - dragOffset;
			self.setPosition(newPosX / seekBarW);
			seekBar.mouseMove(FakeMouseEventForSeekBar(e), true);
			return true;
		}
		return false;
	}
	this.mouseUp = function (e)
	{
		self.mouseMove(e);
		if (isDragging)
		{
			isDragging = false;
			seekBar.mouseUp(FakeMouseEventForSeekBar(e));
			return true;
		}
		return false;
	}
	this.setZIndex = function (idx)
	{
		$handle.css('z-index', idx);
	}

	Initialize();
}
///////////////////////////////////////////////////////////////
// Big Thumbnail Helper (PTZ Presets, Alerts, Clips) //////////
///////////////////////////////////////////////////////////////
var bigThumbHelper = new BigThumbHelper();
function BigThumbHelper()
{
	var self = this;
	var $thumb, $desc, $img, img, $canvas, canvas;
	var isShowing = false;
	var initialized = false;
	var imgCompleteCallback;
	var imgCompleteUserContext;
	var Initialize = function ()
	{
		if (initialized)
			return;
		initialized = true;
		$thumb = $('<div id="bigThumb"></div>');
		$("body").append($thumb);
		$desc = $('<div class="bigThumbDescription"></div>');
		$thumb.append($desc);
		$img = $('<img />');
		$img.on('load', imgLoaded);
		$img.on('error', imgErrored);
		img = $img[0];
		$canvas = $("<canvas>HTML5 canvas not supported</canvas>");
		$thumb.append($canvas);
		canvas = $canvas[0];
	}
	var imgLoaded = function ()
	{
		if ($img.attr("src") != "")
			renderImage(img, $img);
	}
	var renderImage = function (imgEle, $imgEle)
	{
		if (isShowing)
		{
			CopyImageToCanvas(imgEle, canvas);
			if (imgCompleteCallback)
				imgCompleteCallback($imgEle, imgCompleteUserContext, true);
		}
	}
	var imgErrored = function ()
	{
		if (isShowing)
		{
			if (imgCompleteCallback)
				imgCompleteCallback($img, imgCompleteUserContext, false);
		}
	}
	this.Show = function ($vAlign, $hAlign, descriptionText, imgSrc, imgW, imgH, imgComplete, userContext, noClear)
	{
		Initialize();

		isShowing = true;

		// These callbacks are handled really clumsily such that they won't be called correctly if Show() is called again before the callback from the previous Show().
		imgCompleteCallback = null;
		imgCompleteUserContext = null;

		$desc.text(descriptionText);

		var isImgEle = imgSrc && typeof imgSrc == "object" && typeof imgSrc.getAttribute == "function";

		if (!isImgEle && !noClear && (!imgSrc || !imgSrc.startsWith('data:image/')))
		{
			canvas.width = canvas.height = 0;
		}

		var assumedWidth = 0;
		var assumedHeight = 0;
		if (imgSrc)
		{
			if (isImgEle)
			{
				$img.attr("src", "");
				imgCompleteCallback = imgComplete;
				imgCompleteUserContext = userContext;
				renderImage(imgSrc, $(imgSrc));
			}
			else
			{
				imgCompleteCallback = imgComplete;
				imgCompleteUserContext = userContext;
				$img.attr("src", imgSrc);
			}
			assumedWidth = imgW;
			assumedHeight = imgH;
		}
		var bW = $('#layoutbody').width();
		var shrinkBy = assumedWidth ? bW / assumedWidth : 0;
		if (shrinkBy > 0 && shrinkBy < 1)
		{
			var aspectRatio = assumedWidth / assumedHeight;
			assumedHeight = assumedHeight * shrinkBy;
			assumedWidth = assumedHeight * aspectRatio;
		}
		var bH = $('#layoutbody').height();
		shrinkBy = assumedHeight ? bH / assumedHeight : 0;
		if (shrinkBy > 0 && shrinkBy < 1)
		{
			var aspectRatio = assumedWidth / assumedHeight;
			assumedHeight = assumedHeight * shrinkBy;
			assumedWidth = assumedHeight * aspectRatio;
		}
		var wH = $(window).height();
		var wW = $(window).width();
		var top = ($vAlign.offset().top + ($vAlign.height() / 2)) - (assumedHeight / 2) - 20; // 20 for the description
		if (top + (assumedHeight + 20) > wH)
			top = (wH - (assumedHeight + 20));
		if (top < 0)
			top = 0;
		var portrait = uiSizeHelper.UsePortraitLayout(wW, wH);
		if (portrait)
		{
			var layoutsidebar = $("#layoutleft");
			top = $vAlign.offset().top - assumedHeight - 25;
			if (top < 0)
				top = 0;
			var left = $hAlign.offset().left - assumedWidth;
			if (left < 0)
				left = 0;
			$thumb.css("left", left + "px");
			$thumb.css("right", "");
		}
		else if (settings.ui3_sideBarPosition === "Right")
		{
			var right = wW - $hAlign.offset().left;
			$thumb.css("left", "");
			$thumb.css("right", right + "px");
		}
		else
		{
			var left = $hAlign.offset().left + $hAlign.width() + 3;
			$thumb.css("left", left + "px");
			$thumb.css("right", "");
		}
		$thumb.css("top", top + "px");
		if (assumedWidth)
			$thumb.css("width", assumedWidth + "px");
		else
			$thumb.css("width", "");
		$thumb.show();
	}
	this.Hide = function ()
	{
		if (isShowing)
		{
			isShowing = false;
			$thumb.hide();
		}
	}
	this.IsShowing = function ()
	{
		return isShowing;
	}
}
///////////////////////////////////////////////////////////////
// Touch Event Helper /////////////////////////////////////////
///////////////////////////////////////////////////////////////
function TouchEventHelper()
{
	var self = this;
	var mouseEventsBlockedUntil = -60000;
	this.Gate = function (e)
	{
		// Returns true if the event handler should be prevented due to being a non-touch event after recent touch events
		if (self.isTouchEvent(e))
		{
			mouseEventsBlockedUntil = performance.now() + 1000;
			return false;
		}
		else
			return mouseEventsBlockedUntil > performance.now();
	}
	this.isTouchEvent = function (e)
	{
		return e.type.startsWith("touch");
	}
	this.isMultiTouch = function (e)
	{
		if (e.touches && e.touches.length > 1)
			return true;

		// iOS (and maybe other browsers) don't use the identifier field for the finger number, so this code is broken
		//if (e.changedTouches)
		//{
		//	for (var i = 0; i < e.changedTouches.length; i++)
		//	{
		//		if (e.changedTouches[i].identifier !== 0)
		//			return true;
		//	}
		//}
		return false;
	}
}
///////////////////////////////////////////////////////////////
// Load Clip List /////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function ClipData(clip)
{
	var clipData = this;
	clipData.rawData = clip;
	clipData.rawClipData = clip;
	clipData.isClip = !clip.clip; // Only alert items have a clip property.
	//if (isClipListRequest !== clipData.isClip)
	//	continue; // [flagged hack] The "flagged" view loads both alerts and clips at the same time, so this hack skips the unwanted items.
	if (clip.memo)
		clipData.memo = clip.memo;
	if (clip.plate)
		clipData.plate = clip.plate;
	clipData.roughLength = GetClipLengthFromFileSize(clip.filesize);
	clipData.roughLengthMs = GetClipLengthMs(clipData.roughLength);
	clipData.camera = clip.camera;
	clipData.recId = GetRecIdFromPath(clip.path); // Unique ID, not usually used for loading imagery
	clipData.hasHighResJpeg = !clipData.isClip && !DoesFileSizeStringHaveOnlyDuration(clip.filesize);
	clipData.res = clip.res;
	if (clipData.isClip)
	{
		clipData.isSnapshot = clipData.roughLength == "Snapshot"
		clipData.clipId = clipData.recId; // Unique ID of the underlying clip.
		clipData.path = clip.path; // Path used for loading the video stream
	}
	else
	{
		clipData.isSnapshot = clip.clip.startsWith("@-1.");
		if (clipData.isSnapshot)
		{
			clipData.clipId = ""; // Unique ID of the underlying clip.
			clipData.path = clip.path; // Path used for loading the video stream
		}
		else
		{
			clipData.clipId = GetRecIdFromPath(clip.clip); // Unique ID of the underlying clip.
			clipData.path = clip.clip; // Path used for loading the video stream
		}
		clipData.isNew = false;
	}
	clipData.alertPath = clip.path; // Alert path if this is an alert, otherwise just another copy of the clip path.
	clipData.offsetMs = clip.offset ? clip.offset : 0;
	clipData.flags = clip.flags;
	clipData.audio = NumberHasFlags(clip.flags, BIDBFLAG.AUDIO);
	clipData.date = new Date(clip.date * 1000);
	clipData.displayDate = GetServerDate(clipData.date);
	clipData.colorHex = BlueIrisColorToCssColor(clip.color);
	clipData.fileSize = GetClipFileSize(clip.filesize);
	var fileNameParts = ParseFileName(clip.path);
	clipData.fileExtType = fileNameParts.type.toUpperCase();
	if (clipData.isSnapshot)
		clipData.msec = clipData.roughLengthMs = 2000;
	else if (clipData.isClip && typeof clip.msec != "undefined" && !isNaN(clip.msec))
		clipData.msec = clip.msec;
	else
		clipData.msec = clipData.offsetMs + clipData.roughLengthMs;

	clipData.clipStartDate = clipData.displayDate;
	clipData.clipCoverMs = clipData.roughLengthMs;
}
function ClipLoader(clipsBodySelector)
{
	var self = this;
	var HeightOfOneClipTilePx = 53;
	var HeightOfOneSizeSmallClipTilePx = 40;
	var HeightOfOneSizeLargeLargeThumbClipTilePx = 137;
	var HeightOfOneSizeMediumLargeThumbClipTilePx = 130;
	var HeightOfOneSizeSmallLargeThumbClipTilePx = 115;
	var HeightOfOneDateTilePx = 27;
	var asyncThumbnailDownloader = new AsyncClipThumbnailDownloader();
	var $clipsbody = $(clipsBodySelector);
	var $clipListTopDate = $('#clipListTopDate');
	var clipListCache = new Object();
	var clipListIdCache = new Object();
	var loadedClipIds = new Array();
	var isLoadingAClipList = false;
	var QueuedClipListLoad = null;
	var failedClipListLoads = 0;
	var TotalUniqueClipsLoaded = 0;
	var TotalDateTilesLoaded = 0;
	var lastClipTileSize; // Initialized at end of constructor
	var lastClipListLargerThumbs = getLargerClipThumbnails(); // Initialized at end of constructor
	if (lastClipListLargerThumbs)
		$clipsbody.addClass("largerThumbs");
	var currentTopDate = new Date(0);
	var lastLoadedCameraFilter = "index";
	this.suppressClipListLoad = false;
	var startupClipData = null;
	var failedLoadToast = new PersistentToast("failedLoadToast", "ERROR");
	var recoveryFunction = null;

	// For updating an existing clip list
	var newestClipDate = 0;
	var clipListGrew = false;
	var lastClipListLoadedAt = performance.now();

	// For handling multi-select only
	var selectedClips = [];
	var selectedClipsMap = new Object();
	var lastSelectedClipId = null;

	var disabledClipIds = new Object();

	var bulkOperationInProgress = false;

	// Too many clip tiles bogs down the UI, and clip tiles must exist to be selected.
	var clipTileSelectLimit = 1000;
	var clipVisibilityMap = {};

	// For showing alert "new" icon
	var newAlertTimes = {};

	this.LoadView = function (dbView)
	{
		settings.ui3_current_dbView = dbView;
		dropdownBoxes.listDefs["dbView"].rebuildItems();
		$("#topbar_tab_clips").click();
	}
	this.LoadClips = function ()
	{
		var loading = videoPlayer.Loading();
		if (loading.image && (loading.image.isLive || loading.image.isTimeline()))
			lastLoadedCameraFilter = loading.image.id;
		loadClipsInternal(lastLoadedCameraFilter, dateFilter.BeginDate, dateFilter.EndDate, false, false, null, settings.ui3_current_dbView, clipFilterSearch.getQuery());
	}
	this.UpdateClipList = function ()
	{
		if (documentIsHidden())
			return;
		if (isLoadingAClipList)
			return;
		if (performance.now() - lastClipListLoadedAt < 5000)
			return;
		if (newestClipDate == 0)
			return;
		if (!videoPlayer.Loading().cam)
			return;
		if (dateFilter.BeginDate != 0 && dateFilter.EndDate != 0)
			return;
		// We request clips starting from 180 seconds earlier so that metadata of recent clips may be updated.
		loadClipsInternal(lastLoadedCameraFilter, newestClipDate - 180, Math.round(GetUtcNow() / 1000) + 86400, false, true, null, settings.ui3_current_dbView, clipFilterSearch.getQuery());
	}
	this.LoadClipsRange = function (camFilter, dateBegin, dateEnd)
	{
		if (!camFilter)
		{
			var loading = videoPlayer.Loading();
			if (loading.image && loading.image.isLive)
				camFilter = loading.image.id;
		}
		loadClipsInternal(camFilter, dateBegin, dateEnd, false, false, null, settings.ui3_current_dbView, clipFilterSearch.getQuery());
	}
	var loadClipsInternal = function (cameraId, myDateStart, myDateEnd, isContinuationOfPreviousLoad, isUpdateOfExistingList, previousClipDate, dbView, filterSearchQuery)
	{
		if (!videoPlayer.Loading().cam)
			return; // UI hasn't loaded far enough yet.
		if (currentPrimaryTab !== "clips" || self.suppressClipListLoad)
		{
			QueuedClipListLoad = null;
			return;
		}
		if (startupClipFilterSearch)
		{
			filterSearchQuery = startupClipFilterSearch;
			clipFilterSearch.setQuery(startupClipFilterSearch);
			startupClipFilterSearch = null;
		}
		if (startupClipFilterBeginDate || startupClipFilterEndDate)
		{
			if (startupClipFilterBeginDate)
				dateFilter.SelectDate(startupClipFilterBeginDate, 1);
			if (startupClipFilterEndDate)
				dateFilter.SelectDate(startupClipFilterEndDate, 2);
			myDateStart = dateFilter.BeginDate;
			myDateEnd = dateFilter.EndDate;
			startupClipFilterBeginDate = startupClipFilterEndDate = null;
		}
		if (!previousClipDate)
			previousClipDate = new Date(0);
		if (!isContinuationOfPreviousLoad && !isUpdateOfExistingList)
		{
			if (isLoadingAClipList)
			{
				console.log("Clip list loading is already active. Queuing this request.", arguments);
				QueuedClipListLoad = function ()
				{
					loadClipsInternal(cameraId, myDateStart, myDateEnd, isContinuationOfPreviousLoad, isUpdateOfExistingList, previousClipDate, dbView, filterSearchQuery);
				};
				return;
			}

			tileLoader.AppearDisappearCheckEnabled = false;

			self.UnselectAllClips(true);

			TotalUniqueClipsLoaded = 0;
			TotalDateTilesLoaded = 0;
			loadedClipIds = new Array();

			newestClipDate = 0;
			clipListCache = new Object();
			clipListIdCache = new Object();

			clipVisibilityMap = {};

			$clipsbody.empty();
			$clipListTopDate.html("...");
			$clipsbody.html('<div class="clipListText">Loading...<br/><br/><span id="clipListDateRange"></span></div>');
			$.CustomScroll.callMeOnContainerResize();

			tileLoader.unregisterAllOnAppearDisappear();
			asyncThumbnailDownloader.Stop();
		}
		if (isUpdateOfExistingList)
		{
			if (isLoadingAClipList)
				return;
		}
		isLoadingAClipList = true;

		var allowContinuation = false;
		var args = { cmd: "cliplist", camera: cameraId };
		if (myDateStart != 0 && myDateEnd != 0)
		{
			allowContinuation = true;
			args.startdate = myDateStart;
			args.enddate = myDateEnd;
		}
		if (filterSearchQuery)
			args.search = filterSearchQuery;
		if (dbView)
		{
			// When cmd="alertlist" and dbView="flagged", clip items are included too, but they don't have msec metadata.
			// When cmd="cliplist" and dbView="flagged", alert items are included too, but they don't have zones metadata. These alert items have an msec value indicating the length of the alert.  The msec value Prior to version 91, UI3 handled it incorrectly, believing it to be the clip length.
			args.view = dbView;
			if (DbViewIsAlerts(dbView))
			{
				args.cmd = "alertlist";
			}
		}

		SetClipListShortcutIconState("#open_all_clips_btn", !dbView || dbView === "all");
		SetClipListShortcutIconState("#open_alerts_btn", dbView === "alerts");
		SetClipListShortcutIconState("#open_alerts_canceled_btn", dbView === "cancelled");
		SetClipListShortcutIconState("#open_alerts_confirmed_btn", dbView === "confirmed");

		UpdateCurrentURL();

		var isClipListRequest = args.cmd === "cliplist"; // We can't rely on this anymore to tell us if response items are clips or alerts.

		ExecJSON(args, function (response)
		{
			failedLoadToast.hide();
			recoveryFunction = null;
			if (response.result !== "success")
			{
				isLoadingAClipList = false;
				if (sessionManager.IsInvalidSession(response))
				{
					var failMessage = $('<div class="clipListText clipListFailed">Invalid session. Recovering...</div>');
					$clipsbody.empty();
					$clipsbody.append(failMessage);
					sessionManager.ReestablishLostSession();
					return;
				}
				var failMessage = $('<div class="clipListText clipListFailed">Failed to load. Click to learn more.</div>');
				var reason = args.cmd + ' response did not indicate "success" result: ' + JSON.stringify(response) + ". Request was: " + JSON.stringify(args);
				failMessage.on('click', function ()
				{
					ShowErrorDialog(reason);
				});
				$clipsbody.empty();
				$clipsbody.append(failMessage);
				return;
			}
			failedClipListLoads = 0;
			var clipTileHeight = getClipTileHeight();
			var previouslyOpenedClip = null;
			var loadingImage = videoPlayer.Loading().image;
			if (typeof response.data !== "undefined")
			{
				var newUpdateClipIds = [];
				var newUpdateClips = [];
				for (var clipIdx = 0; clipIdx < response.data.length; clipIdx++)
				{
					// clip.camera : "shortname"
					// clip.path : "@0000123.bvr"
					// clip.offset : 0
					// clip.date : 12345
					// clip.color : 8151097
					// clip.flags : 128
					// clip.msec : 6261
					// clip.filesize : "10sec (3.09M)"
					// clip.filetype : "bvr H264 New"

					var clip = response.data[clipIdx];
					if (newestClipDate < clip.date)
						newestClipDate = clip.date;
					var clipData = new ClipData(clip);

					if (!clipData.isClip)
					{
						if (clip.newalerttime)
							newAlertTimes[clipData.camera] = parseInt(clip.newalerttime);
					}
					if (!clipListCache[clipData.camera])
						clipListCache[clipData.camera] = new Object();
					var existingClipData = clipListCache[clipData.camera][clipData.recId];

					if (!isSameDay(previousClipDate, clipData.displayDate))
					{
						if (previousClipDate.getTime() == 0)
							$clipListTopDate.attr("defaultStr", GetDateDisplayStr(clipData.displayDate, true)); // Do not add the first date tile because it is redundant with a date display above the list.
						else
						{
							if (isUpdateOfExistingList)
							{
								if (!existingClipData)
								{
									// This adds the appropriate date tile if a day boundary is found within a background update.
									newUpdateClips.push({ isDateTile: true, date: clipData.displayDate });
									TotalDateTilesLoaded++;
								}
							}
							else
							{
								tileLoader.registerOnAppearDisappear({ isDateTile: true, date: clipData.displayDate }, DateTileOnAppear, DateTileOnDisappear, TileOnMove, clipTileHeight, HeightOfOneDateTilePx);
								TotalDateTilesLoaded++;
							}
						}
					}

					previousClipDate = clipData.displayDate;

					if (existingClipData)
					{
						self.UpdateExistingClipData(existingClipData, clipData);
					}
					else // Only register if not already registered
					{
						if (isUpdateOfExistingList)
						{
							newUpdateClips.push(clipData);
							newUpdateClipIds.push(clipData.recId);
						}
						else
						{
							loadedClipIds.push(clipData.recId);
							tileLoader.registerOnAppearDisappear(clipData, ClipOnAppear, ClipOnDisappear, TileOnMove, clipTileHeight, HeightOfOneDateTilePx);
						}
						TotalUniqueClipsLoaded++;
						clipListCache[clipData.camera][clipData.recId] = clipData;
						clipListIdCache[clipData.recId] = clipData;
						if (!isUpdateOfExistingList && previouslyOpenedClip == null && !loadingImage.isLive && !loadingImage.isTimeline() && loadingImage.uniqueId == clipData.recId)
							previouslyOpenedClip = clipData;
					}
				}

				if (isUpdateOfExistingList && newUpdateClipIds.length > 0)
				{
					var oldestOfNewClipIds = newUpdateClipIds[newUpdateClipIds.length - 1];
					if (loadedClipIds.length > 0 && !isSameDay(clipListIdCache[loadedClipIds[0]].displayDate, clipListIdCache[oldestOfNewClipIds].displayDate))
					{
						// This adds the appropriate date tile if a day boundary is found between a background update and the previously-loaded clips.
						newUpdateClips.push({ isDateTile: true, date: clipListIdCache[loadedClipIds[0]].displayDate });
						TotalDateTilesLoaded++;
					}
					loadedClipIds = newUpdateClipIds.concat(loadedClipIds);
					tileLoader.preserveScrollPosition(clipTileHeight, HeightOfOneDateTilePx, newUpdateClipIds.length);
					tileLoader.injectNewClips(newUpdateClips, ClipOnAppear, ClipOnDisappear, TileOnMove, clipTileHeight, HeightOfOneDateTilePx, DateTileOnAppear, DateTileOnDisappear);
					clipListGrew = true;
				}

				if (QueuedClipListLoad != null)
				{
					isLoadingAClipList = false;
					lastClipListLoadedAt = performance.now();
					QueuedClipListLoad();
					QueuedClipListLoad = null;
					return;
				}

				if (allowContinuation && response.data.length >= 1000)
				{
					if (isUpdateOfExistingList)
					{
						toaster.Info("Automatic " + (args.cmd === "cliplist" ? "clip list" : "alert list") + " update got too many items.  Refreshing clip list now.", 10000);
						isLoadingAClipList = false;
						lastClipListLoadedAt = performance.now();
						self.LoadClips();
						return;
					}
					for (var i = response.data.length - 1; i >= 0 && i >= response.data.length - 200; i--)
						if (typeof response.data[i].newalerts === "undefined")
						{
							//if (isClipListRequest !== !response.data[i].clip)
							//	continue; // [flagged hack] The "flagged" view loads both alerts and clips at the same time, so this hack skips the unwanted items.
							myDateEnd = response.data[i].date;
							break;
						}
					$("#clipListDateRange").html("&nbsp;Remaining to load:<br/>&nbsp;&nbsp;&nbsp;" + parseInt((myDateEnd - myDateStart) / 86400) + " days");
					$.CustomScroll.callMeOnContainerResize();
					return loadClipsInternal(cameraId, myDateStart, myDateEnd, true, isUpdateOfExistingList, previousClipDate, dbView, filterSearchQuery);
				}
			}

			if (!isUpdateOfExistingList && previouslyOpenedClip == null && startupClipData && !loadingImage.isLive && !loadingImage.isTimeline() && loadingImage.uniqueId == startupClipData.recId)
				previouslyOpenedClip = startupClipData;

			isLoadingAClipList = false;
			lastClipListLoadedAt = performance.now();
			self.updateNewAlertIcons();
			if (isUpdateOfExistingList)
			{
				if (clipListGrew)
				{
					resized();
					BI_CustomEvent.Invoke("ClipList_Updated", response);
				}
			}
			else
			{
				$clipsbody.empty();

				// Force clip list to be the correct height before clip tiles load.
				$clipsbody.append('<div id="clipListHeightSetter" style="height:' + ((clipTileHeight * TotalUniqueClipsLoaded) + (HeightOfOneDateTilePx * TotalDateTilesLoaded)) + 'px;width:0px;"></div>');

				if (TotalUniqueClipsLoaded == 0)
				{
					$clipsbody.append('<div class="clipListText">No recordings were found matching your filters.</div>');
				}
				asyncThumbnailDownloader = new AsyncClipThumbnailDownloader();
				tileLoader.AppearDisappearCheckEnabled = true;
				tileLoader.appearDisappearCheck();

				if (!loadingImage.isLive && !loadingImage.isTimeline() && !isUpdateOfExistingList)
				{
					if (previouslyOpenedClip == null)
						self.CloseCurrentClip();
					else
					{
						// A clip is still playing, and it is in the new list.  Select it and scroll to it.
						self.SelectClipIdNoOpen(previouslyOpenedClip.recId);
						self.ScrollClipList(previouslyOpenedClip.y, clipTileHeight);
					}
				}

				$.CustomScroll.callMeOnContainerResize();

				BI_CustomEvent.Invoke("ClipList_Loaded", response);
			}
		}
			, function (jqXHR, textStatus, errorThrown)
			{
				if (isUpdateOfExistingList)
					return; // Failures of a clip list update should just be ignored.
				$clipsbody.html('<div class="clipListText">Failed to load!</div>');
				var tryAgain = !isContinuationOfPreviousLoad && ++failedClipListLoads < 5;
				failedLoadToast.showHtml("Failed to load " + (args.cmd === "cliplist" ? "clip list" : "alert list") + ".<br/>Will " + (tryAgain ? "" : "NOT ") + "try again.<br/>" + jqXHR.ErrorMessageHtml);

				recoveryFunction = function ()
				{
					isLoadingAClipList = false;
					loadClipsInternal(cameraId, myDateStart, myDateEnd, isContinuationOfPreviousLoad, isUpdateOfExistingList, previousClipDate, dbView, filterSearchQuery);
				};

				if (tryAgain)
					setTimeout(recoveryFunction, 1000);
				else
				{
					isLoadingAClipList = false;
					lastClipListLoadedAt = performance.now();
					failedClipListLoads = 0;
				}
			});
	};
	this.reloadIfInFailedState = function ()
	{
		if (recoveryFunction)
		{
			recoveryFunction();
			recoveryFunction = null;
		}
	}
	this.GetCurrentFilteredCamera = function ()
	{
		return lastLoadedCameraFilter;
	}
	this.resizeClipList = function ()
	{
		var currentClipTileSize = getClipTileSize();
		var desiredLargerClipThumbnails = getLargerClipThumbnails();
		if (lastClipTileSize != currentClipTileSize
			|| clipListGrew
			|| lastClipListLargerThumbs != desiredLargerClipThumbnails)
		{
			clipListGrew = false;
			lastClipTileSize = currentClipTileSize;
			lastClipListLargerThumbs = desiredLargerClipThumbnails;
			if (lastClipListLargerThumbs)
				$clipsbody.addClass("largerThumbs");
			else
				$clipsbody.removeClass("largerThumbs");
			var clipTileHeight = getClipTileHeight();
			tileLoader.resizeClipList(clipTileHeight, HeightOfOneDateTilePx);
			$("#clipListHeightSetter").css("height", ((clipTileHeight * TotalUniqueClipsLoaded) + (HeightOfOneDateTilePx * TotalDateTilesLoaded)) + "px");
		}
	}
	var getClipTileHeight = function ()
	{
		var currentClipTileSize = getClipTileSize();
		if (currentClipTileSize == "s")
		{
			if (getLargerClipThumbnails())
				return HeightOfOneSizeSmallLargeThumbClipTilePx;
			else
				return HeightOfOneSizeSmallClipTilePx;
		}
		else if (currentClipTileSize == "m")
		{
			if (getLargerClipThumbnails())
				return HeightOfOneSizeMediumLargeThumbClipTilePx;
			else
				return HeightOfOneClipTilePx;
		}
		else
		{
			if (getLargerClipThumbnails())
				return HeightOfOneSizeLargeLargeThumbClipTilePx;
			else
				return HeightOfOneClipTilePx;
		}
	}
	var getClipTileSize = function ()
	{
		if (uiSizeHelper.GetCurrentSize() == "small" || uiSizeHelper.GetCurrentSize() == "smaller")
			return "s";
		else if (uiSizeHelper.GetCurrentSize() == "medium")
			return "m";
		else
			return "l";
	}
	/**
	 * Remembers that this is the startup clip and begins playback of that clip.
	 * @param {any} clipData Clip Data. If null, the startup clip field is cleared.
	 */
	this.SetStartupClip = function (clipData)
	{
		startupClipData = clipData;
		if (clipData)
			videoPlayer.LoadClip(clipData);
	}
	/**
	 * Gets the clip or alert with the specified camera ID and recording ID. I'm only keeping this more complicated cache around in case I want to enumerate clips by camera ID in the future.
	 * @param {any} cameraId camera ID
	 * @param {any} recId recording ID
	 */
	this.GetCachedClip = function (cameraId, recId)
	{
		var camClips = clipListCache[cameraId];
		if (camClips)
			return camClips[recId];
		return null;
	}
	/**
	 * Gets the clip or alert with the specified recording ID.
	 * @param {any} recId ID of the clip
	 */
	this.GetClipFromId = function (recId)
	{
		if (startupClipData && startupClipData.recId === recId)
			return startupClipData;
		return clipListIdCache[recId];
	}
	/**
	 * Returns the array containing all loaded clip IDs.
	 */
	this.GetAllClipIds = function ()
	{
		return loadedClipIds;
	}
	/**
	 * Returns an array containing clips where the specified function returns true.
	 * @param {Function} predicate A method accepting a clipData and returning true or false.
	 */
	this.GetClips = function (predicate)
	{
		var clips = [];
		if (typeof predicate === "function")
		{
			for (var i = 0; i < loadedClipIds.length; i++)
			{
				var clipData = clipListIdCache[loadedClipIds[i]];
				if (predicate(clipData))
					clips.push(clipData);
			}
		}
		else
		{
			for (var i = 0; i < loadedClipIds.length; i++)
				clips.push(clipListIdCache[loadedClipIds[i]]);
		}
		return clips;
	}
	/**
	 * Returns an array containing clipData for all loaded alert objects that have the isNew flag set.
	 */
	this.GetNewAlerts = function ()
	{
		return self.GetClips(function (clipData)
		{
			return clipData.isNew;
		});
	}
	this.GetClipIdsBetween = function (first, last)
	{
		var between = [];
		var idxFirst = loadedClipIds.indexOf(first);
		if (idxFirst == -1)
			return between;
		var idxLast = loadedClipIds.indexOf(last);
		if (idxLast == -1)
			return between;
		if (idxFirst == idxLast)
		{
			between.push(first);
			return;
		}
		if (idxFirst > idxLast)
		{
			var tmp = idxLast;
			idxLast = idxFirst;
			idxFirst = tmp;
		}
		for (var i = idxFirst; i <= idxLast; i++)
			if (!disabledClipIds[loadedClipIds[i]])
				between.push(loadedClipIds[i]);
		return between;
	}
	this.GetDownloadClipInfo = function (clipData)
	{
		var query = currentServer.GetAPISessionArg("?");
		if (settings.ui3_clipDownloadOriginalName === "1")
		{
			if (query)
				query += '&';
			else
				query = '?';
			query += 'original_name=1';
		}
		var retVal = {};
		retVal.href = currentServer.remoteBaseURL + "clips/" + clipData.path + query;
		var date = GetPaddedDateStr(clipData.displayDate);
		date = FormatFileName(date);
		retVal.fileNameNoExt = cameraListLoader.GetCameraName(clipData.camera) + " " + date;
		var extensionIdx = clipData.path.indexOf(".");
		if (extensionIdx == -1)
		{
			toaster.Warning('Could not find file extension in clip path "' + clipData.path + '"');
			retVal.download = retVal.fileNameNoExt
		}
		else
		{
			retVal.download = retVal.fileNameNoExt + clipData.path.substr(extensionIdx);
		}
		if (!clipData.isClip && clipData.fileSize)
		{
			retVal.originalFileHref = GetThumbnailPath(clipData.recId, true);
			retVal.originalFileName = clipData.rawData.file;
		}
		return retVal;
	}
	this.GetClipDisplayName = function (clipData)
	{
		var date = GetDateStr(clipData.displayDate);
		return cameraListLoader.GetCameraName(clipData.camera) + " " + date;
	}
	this.IsClipSelected = function (recId)
	{
		return selectedClipsMap[recId] ? true : false;
	}
	this.GetAllSelected = function ()
	{
		return selectedClips;
	}
	this.ApplyMissingStatsToClipData = function (stats, clipData)
	{
		if (stats.path != clipData.path)
			return false;
		clipData.hasLoadedClipStats = true;
		clipData.msec = stats.msec;
		clipData.fileSize = GetClipFileSize(stats.filesize);
		clipData.clipStartDate = new Date((stats.date * 1000) + GetServerTimeOffset());
		clipData.clipCoverMs = GetClipLengthMs(GetClipLengthFromFileSize(stats.filesize));
		clipData.rawClipData = stats;
		return true;
	}
	this.UpdateExistingClipData = function (oldClipData, newClipData)
	{
		if (oldClipData.recId != newClipData.recId)
			return;
		var $clip = $("#c" + oldClipData.recId);

		if (oldClipData.roughLength != newClipData.roughLength)
		{
			oldClipData.roughLength = newClipData.roughLength;
			if ($clip.length > 0)
				$clip.find('.clipdur').html(GetClipDurStrFromMs(oldClipData.roughLength));
		}
		if (oldClipData.fileSize != newClipData.fileSize)
		{
			oldClipData.fileSize = newClipData.fileSize;
		}
		if (oldClipData.flags != newClipData.flags)
		{
			oldClipData.flags = newClipData.flags;
			self.RepairClipFlagState(oldClipData);
			self.RepairAiConfirmedState(oldClipData);
		}
		if (oldClipData.isClip && oldClipData.msec != newClipData.msec)
		{
			// Do not update alert duration (msec). We override it with the clip's duration when opening alerts.
			oldClipData.msec = newClipData.msec;
			oldClipData.clipCoverMs = newClipData.clipCoverMs;

			// Do not notify the video player in any way. Blue Iris doesn't update its clip duration metadata in a way I've been able to predict.

			//var loaded = videoPlayer.Loaded().image;
			//if (loaded.uniqueId == newClipData.recId)
			//	loaded.msec = newClipData.msec;

			//var loading = videoPlayer.Loading().image;
			//if (loading.uniqueId == newClipData.recId)
			//{
			//	loading.msec = newClipData.msec;
			//	videoPlayer.NotifyClipMetadataChanged(newClipData);
			//}
		}
		if (oldClipData.memo !== newClipData.memo
			|| oldClipData.plate !== newClipData.plate)
		{
			oldClipData.memo = newClipData.memo;
			oldClipData.plate = newClipData.plate;

			var newOverlayTxt = clipLoader.GetClipOverlayText(newClipData);
			var $overlayEle = $clip.find('.clipmemo');
			if (newOverlayTxt)
			{
				if ($overlayEle.length)
					$overlayEle.text(newOverlayTxt);
				else
					$overlayEle = $clip.find('.clipimghelper').append('<div class="clipmemo">' + htmlEncode(newOverlayTxt) + '</div>');
			}
			else
				$overlayEle.remove();
		}
	}
	var ThumbOnAppear = function (ele)
	{
		if (!ele)
		{
			console.error("ThumbOnAppear called with undefined ele");
			return;
		}
		asyncThumbnailDownloader.Visible(ele, ele.recId);
	}
	var ThumbOnDisappear = function (ele)
	{
		if (!ele)
		{
			console.error("ThumbOnDisappear called with undefined ele");
			return;
		}
		asyncThumbnailDownloader.Invisible(ele.recId);
	}
	var ClipOnAppear = function (clipData)
	{
		ClipTileCreate(clipData);
		ThumbOnAppear($("#t" + clipData.recId).get(0));
		clipVisibilityMap[clipData.recId] = true;
	}
	var ClipOnDisappear = function (clipData)
	{
		if (!clipData)
			return;
		ThumbOnDisappear($("#t" + clipData.recId).get(0));
		clipVisibilityMap[clipData.recId] = false;
		if (!selectedClipsMap[clipData.recId]) // We need clip elements to stick around if they're selected, for the sake of multi-select.
			$("#c" + clipData.recId).remove();
		self.HideBigClipThumb();
	}
	var ClipTileCreateFromId = function (recId)
	{
		var $clip = $("#c" + recId);
		if ($clip.length == 0)
		{
			var clipData = self.GetClipFromId(recId);
			if (clipData)
				$clip = ClipTileCreate(clipData, $clip);
		}
		return $clip;
	}
	var ClipTileCreate = function (clipData, $clip)
	{
		if (!$clip)
			$clip = $("#c" + clipData.recId);
		if ($clip.length == 0)
		{
			var isDeleting = disabledClipIds[clipData.recId];
			var enabledOrDisabled = isDeleting ? "disabled" : "enabled";
			var clipTitle = isDeleting ? ' title="This item was queued for deletion. Refresh list to update status."' : '';
			var timeStr = GetTimeStr(clipData.displayDate);
			var clipDur = GetClipDurStrFromMs(clipData.roughLength);
			var clipDurTitle = clipDur == 'S' ? ' title="Snapshot"' : '';
			var camName = cameraListLoader.GetCameraName(clipData.camera);
			var overlayTxt = self.GetClipOverlayText(clipData);
			var clipOverlayHtml = overlayTxt ? '<div class="clipmemo">' + htmlEncode(overlayTxt) + '</div>' : '';
			$clip = $('<div id="c' + clipData.recId + '" class="cliptile ' + enabledOrDisabled + '" style="top:' + clipData.y + 'px"' + clipTitle + '>'
				+ '<div class="verticalAlignHelper"></div>'
				+ '<div class="clipimghelper">'
				+ '<div class="verticalAlignHelper"></div>'
				+ clipOverlayHtml
				+ '<div class="clipdur"' + clipDurTitle + '>' + clipDur + '</div>'
				+ '<img id="t' + clipData.recId + '" src="ui3/LoadingImage.png' + currentServer.GetLocalSessionArg("?") + '" />'
				+ '</div>'
				+ '<div class="clipcolorbar" style="background-color: #' + clipData.colorHex + ';"></div>'
				+ '<div class="clipdesc"><div class="cliptime">' + timeStr + '</div><div class="clipcam">' + camName + '</div></div>'
				+ '<div class="clipIconWrapper">'
				+ clipIcons.getIconHtmlForClipTile(clipData)
				+ '</div>'
				+ '</div>');
			$clipsbody.append($clip);

			$clip.get(0).clipData = clipData;

			var thumbEle = $("#t" + clipData.recId).get(0);
			thumbEle.recId = clipData.recId;

			if (!isDeleting)
			{
				$clip.on('click', ClipClicked);
				$clip.on("mouseenter touchstart touchmove", function (e)
				{
					if (touchEvents.Gate(e) || touchEvents.isTouchEvent(e))
						return;

					if (getMouseoverClipThumbnails())
					{
						var thumbPath = GetThumbnailPath(clipData.recId, settings.ui3_hires_jpeg_popups === "1");
						if (thumbEle.getAttribute("src") == thumbPath)
							thumbPath = thumbEle;
						var aspectRatio = thumbEle.naturalWidth / thumbEle.naturalHeight;
						var renderH = 240;
						var renderW = renderH * aspectRatio;
						if (clipData.hasHighResJpeg && settings.ui3_hires_jpeg_popups === "1")
						{
							var clipRes = new ClipRes(clipData.res);
							if (clipRes.valid)
							{
								renderW = clipRes.width;
								renderH = clipRes.height;
							}
						}
						bigThumbHelper.Show($clip, $clip, camName + " " + timeStr, thumbPath, renderW, renderH);
						if (!clipData.isSnapshot)
							clipThumbnailVideoPreview.Start($clip, clipData, camName);
					}
				});
				$clip.on("mouseleave touchend touchcancel", function (e)
				{
					touchEvents.Gate(e);
					self.HideBigClipThumb();
				});

				clipListContextMenu.AttachContextMenu($clip);
			}

			if (self.ClipDataIndicatesFlagged(clipData))
				self.ShowClipFlag(clipData);

			if (selectedClipsMap[clipData.recId])
			{
				if (videoPlayer.Loading().image.uniqueId == clipData.recId)
					$clip.addClass("opened");
				$clip.addClass("selected");
			}
		}
		return $clip;
	}
	this.HideBigClipThumb = function ()
	{
		bigThumbHelper.Hide();
		clipThumbnailVideoPreview.Stop();
	}
	this.ScrollToClipObj = function ($clip)
	{
		var offset = ($clipsbody.height() / 2) - ($clip.height() / 2);
		$clipsbody.scrollTop(($clipsbody.scrollTop() + $clip.position().top) - offset);
	}
	this.ScrollClipList = function (yPos, clipHeight)
	{
		var offset = ($clipsbody.height() / 2) - (clipHeight / 2);
		$clipsbody.scrollTop(yPos - offset);
	}
	var ClipClicked = function (e)
	{
		var recId = this.clipData.recId;
		if (e.shiftKey && lastSelectedClipId)
		{
			// Multi-select add-range
			var range = self.GetClipIdsBetween(lastSelectedClipId, this.clipData.recId);

			if (!e.ctrlKey)
			{
				var lastSelSave = lastSelectedClipId;
				self.UnselectAllClips();
				lastSelectedClipId = lastSelSave;
			}

			if (range)
			{
				for (var i = 0; i < range.length; i++)
				{
					if (!selectedClipsMap[range[i]])
					{
						if (CheckSelectionLimit())
							return;
						ClipTileCreateFromId(range[i]);
						$("#c" + range[i]).addClass("selected");
						selectedClips.push(range[i]);
						selectedClipsMap[range[i]] = true;
					}
				}
			}

			if (e.ctrlKey)
				lastSelectedClipId = recId;
		}
		else if (e.ctrlKey)
		{
			// Multi-select toggle item
			lastSelectedClipId = recId;
			if (selectedClipsMap[recId] === true)
			{
				var idx = selectedClips.indexOf(recId);
				if (idx > -1)
				{
					selectedClips.splice(idx, 1);
					if (!clipVisibilityMap[recId])
						ClipOnDisappear(self.GetClipFromId(recId));
				}
				selectedClipsMap[recId] = false;
				$("#c" + recId).removeClass("selected");
			}
			else
			{
				if (CheckSelectionLimit())
					return;
				selectedClips.push(recId);
				selectedClipsMap[recId] = true;
				$("#c" + recId).addClass("selected");
			}
		}
		else
		{
			self.HideBigClipThumb();
			self.OpenClip(this, recId, true);
		}
	}
	var CheckSelectionLimit = function ()
	{
		if (selectedClips.length >= clipTileSelectLimit)
		{
			toaster.Warning("For performance reasons, you can't select more than " + clipTileSelectLimit + " items at once.");
			return true;
		}
		return false;
	}
	this.OpenARecordingAfterNextClipListLoad = function ()
	{
		BI_CustomEvent.AddListener("ClipList_Loaded", openARecordingCallback);
	}
	var openARecordingCallback = function (response)
	{
		BI_CustomEvent.RemoveListener("ClipList_Loaded", openARecordingCallback);
		self.OpenARecording();
	}
	var openARecordingAfterUILoadCallback = function (response)
	{
		BI_CustomEvent.RemoveListener("FinishedLoading", openARecordingAfterUILoadCallback);
		self.OpenARecording();
	}
	this.OpenARecording = function ()
	{
		if (!loadingHelper.DidLoadingFinish())
		{
			BI_CustomEvent.AddListener("FinishedLoading", openARecordingAfterUILoadCallback);
			return;
		}
		if (loadedClipIds.length === 0)
			return;

		var idx;
		if (settings.ui3_openARecording === "First")
			idx = 0;
		else if (settings.ui3_openARecording === "Last")
			idx = loadedClipIds.length - 1;
		else
			return;
		var recId = loadedClipIds[idx];
		var clipData = self.GetClipFromId(recId);
		self.ScrollClipList(clipData.y, getClipTileHeight());
		setTimeout(function ()
		{
			var $ele = $("#c" + recId);
			if ($ele.length > 0)
				self.OpenClip($ele.get(0), recId, true);
		}, 0);
	}
	this.OpenClip = function (clipEle, recId, alsoLoadClip)
	{
		self.SetStartupClip(null);
		self.UnselectAllClips(true);

		$(clipEle).addClass("opened");
		$(clipEle).addClass("selected");
		if (alsoLoadClip)
			videoPlayer.LoadClip(clipEle.clipData);

		// Multi-select start
		lastSelectedClipId = recId;
		selectedClipsMap = new Object();
		selectedClipsMap[recId] = true;
		selectedClips = [];
		selectedClips.push(recId);
	}
	this.SelectClipIdNoOpen = function (recId)
	{
		if (selectedClipsMap[recId] !== true)
		{
			selectedClips.push(recId);
			selectedClipsMap[recId] = true;
			$("#c" + recId).addClass("selected");
		}
	}
	this.CloseCurrentClip = function ()
	{
		var currentClipEle = self.GetCurrentClipEle();
		if (currentClipEle)
		{
			if (selectedClips.length == 1 && selectedClipsMap[currentClipEle.id.substr(1)])
				self.UnselectAllClips(true);
			else
				$(currentClipEle).removeClass("opened");
		}
		this.SetStartupClip(null);
		if (currentPrimaryTab === "timeline")
			videoPlayer.openTimelineAt(videoPlayer.lastFrameUtc);
		else
			videoPlayer.goLive();
	}
	this.UnselectAllClips = function (alsoRemoveOpenedStatus)
	{
		var unselectedOffscreen = new Array();
		var currentClipEle = self.GetCurrentClipEle();
		if (alsoRemoveOpenedStatus && currentClipEle)
			$(currentClipEle).removeClass("opened");
		for (var i = 0; i < selectedClips.length; i++)
		{
			if (!clipVisibilityMap[selectedClips[i]])
				unselectedOffscreen.push(selectedClips[i]);
			$("#c" + selectedClips[i]).removeClass("selected");
		}
		lastSelectedClipId = null;
		selectedClipsMap = new Object();
		selectedClips = [];

		for (var i = 0; i < unselectedOffscreen.length; i++)
			ClipOnDisappear(self.GetClipFromId(unselectedOffscreen[i]));
	}
	this.DisableClipTileById = function (clipId)
	{
		disabledClipIds[clipId] = true;
		var clipData = self.GetClipFromId(clipId);
		if (clipData && clipVisibilityMap[clipId])
		{
			ClipOnDisappear(clipData);
			ClipOnAppear(clipData);
		}
	}
	var DateTileOnAppear = function (dateTileData)
	{
		var time = dateTileData.date.getTime();
		var $dateTile = $("#dt" + time);
		if ($dateTile.length == 0)
		{
			var timeStr = GetDateDisplayStr(dateTileData.date, true);
			$clipsbody.append('<div id="dt' + time + '" class="datetile" style="top:' + dateTileData.y + 'px">'
				+ timeStr
				+ '</div>');
		}
	}
	var DateTileOnDisappear = function (dateTileObj)
	{
	}
	var DateTileOnBecomeCurrent = function (dateTileData)
	{
		if (dateTileData == null)
		{
			currentTopDate = new Date(0);
			$clipListTopDate.html($clipListTopDate.attr("defaultStr"));
		}
		else if (!isSameDay(dateTileData.date, currentTopDate))
		{
			currentTopDate = dateTileData.date;
			$clipListTopDate.html(GetDateDisplayStr(dateTileData.date, true));
		}
	}
	var TileOnMove = function (obj)
	{
		if (obj.isDateTile)
			$("#dt" + obj.date.getTime()).css("top", obj.y + "px");
		else
			$("#c" + obj.recId).css("top", obj.y + "px");
	}
	this.FlagCurrentClip = function ()
	{
		var cli = videoPlayer.Loading().image;
		if (cli.isLive || cli.isTimeline())
			return;
		var clipData = this.GetClipFromId(cli.uniqueId);
		if (!sessionManager.IsAdministratorSession(cli.uniqueId))
		{
			openLoginDialog(function () { self.ToggleClipFlag(clipData); });
			return;
		}
		self.ToggleClipFlag(clipData);
	}
	this.ExportCurrentClip = function ()
	{
		var cli = videoPlayer.Loading().image;
		if (cli.isLive || cli.isTimeline())
			return;
		exportControls.Enable(cli.uniqueId);
	}
	this.updateNewAlertIcons = function ()
	{
		if (currentPrimaryTab !== "clips")
			return;
		if (loadedClipIds.length === 0)
			return;
		var recId = loadedClipIds[0];
		var firstClipData = self.GetClipFromId(recId);
		if (!firstClipData || firstClipData.isClip)
			return;
		for (var i = 0; i < loadedClipIds.length; i++)
		{
			var clipData = self.GetClipFromId(loadedClipIds[i]);
			if (!clipData.isClip)
			{
				var lastSeenAlertTime = newAlertTimes[clipData.camera];
				if (lastSeenAlertTime)
				{
					var val = lastSeenAlertTime < clipData.rawData.date;
					if (clipData.isNew && !val)
					{
						clipData.isNew = false;
						var $clip = $("#c" + clipData.recId);
						if ($clip.length !== 0)
						{
							var $icons = $clip.find(".clipIconWrapper");
							$icons.html(clipIcons.getIconHtmlForClipTile(clipData));
						}
					}
					else if (!clipData.isNew && val)
					{
						clipData.isNew = true;
						var $clip = $("#c" + clipData.recId);
						if ($clip.length !== 0)
						{
							var $icons = $clip.find(".clipIconWrapper");
							$icons.html(clipIcons.getIconHtmlForClipTile(clipData));
						}
					}
				}
			}
		}
	}
	this.GetNewAlertTimes = function ()
	{
		return newAlertTimes;
	}
	this.QueueExportViaAPI = function (clipData, exportOptions, options, onSuccess, onFailure)
	{
		var args = { cmd: "export", path: clipData.path };
		if (exportOptions.startTimeMs >= 0 && exportOptions.endTimeMs > exportOptions.startTimeMs)
		{
			args.startms = exportOptions.startTimeMs;
			args.msec = exportOptions.endTimeMs - exportOptions.startTimeMs;
		}
		else if (clipData.isClip)
		{
			args.startms = 0;
			args.msec = clipData.msec;
		}
		else
		{
			// This is an alert we're trying to export.  We can probably set a range.
			if (NumberHasFlags(clipData.flags, BIDBFLAG.ALERT_OFFSETTIME))
			{
				args.startms = clipData.offsetMs;
				args.msec = clipData.roughLengthMs;
			}
			else
			{
				args.startms = 0;
				args.msec = clipData.msec;
			}
		}
		args.startms = parseInt(args.startms);
		args.msec = parseInt(args.msec);
		args.format = exportOptions.format;
		args.profile = exportOptions.profile;
		args.substream = exportOptions.substream;
		args.audio = exportOptions.audio;
		args.reencode = exportOptions.reencode;
		args.overlay = exportOptions.overlay;
		if (exportOptions.timelapse && exportOptions.timelapseMultiplier && exportOptions.timelapseFps)
			args.timelapse = exportOptions.timelapseMultiplier + "@" + exportOptions.timelapseFps;

		var failCallback = function (msg)
		{
			toaster.Error("Export command failed: " + msg, 15000);
			if (typeof onFailure === "function")
				onFailure(msg);
		};

		ExecJSON(args, function (response)
		{
			if (response.result === "success")
			{
				if (options)
				{
					if (!options.history)
						options.history = [];
					options.history.push(response.data);
				}
				if (typeof onSuccess === "function")
					onSuccess(response);
			}
			else
			{
				console.log("export command failed:", response);
				if (response.result === "fail" && response.status)
					failCallback(response.status);
				else
					failCallback("No reason was given for the failure.");
			}
		}
			, function (jqXHR, textStatus, errorThrown)
			{
				console.log("export command failed:", jqXHR.ErrorMessageHtml);
				failCallback(jqXHR.ErrorMessageHtml);
			});
	}
	this.ToggleClipProtect = function (clipData, onSuccess, onFailure)
	{
		ToggleFlag(clipData, BIDBFLAG.PROTECTED, BIDBFLAG.PROTECTED, function (clipData, flagIsSet)
		{
			if (flagIsSet)
				self.HideClipProtect(clipData);
			else
				self.ShowClipProtect(clipData);
			if (onSuccess)
				onSuccess(clipData);
		}, onFailure);
	}
	this.ToggleClipFlag = function (clipData, onSuccess, onFailure)
	{
		ToggleFlag(clipData, BIDBFLAG.FLAGGED, BIDBFLAG.FLAGGED, function (clipData, flagIsSet)
		{
			if (flagIsSet)
				self.HideClipFlag(clipData);
			else
				self.ShowClipFlag(clipData);
			if (onSuccess)
				onSuccess(clipData);
		}, onFailure);
	}
	this.ToggleAlertAiConfirmed = function (clipData, onSuccess, onFailure)
	{
		var flag;
		if (NumberHasFlags(clipData.flags, BIDBFLAG.AI_CONFIRMED))
			flag = BIDBFLAG.ALERT_CANCELLED;
		else
			flag = BIDBFLAG.AI_CONFIRMED;
		ToggleFlag(clipData, flag, UI3_BINARY_OR(BIDBFLAG.ALERT_CANCELLED, BIDBFLAG.AI_CONFIRMED), function (clipData, flagIsSet)
		{
			if (flagIsSet)
				self.HideAiConfirmed(clipData);
			else
				self.ShowAiConfirmed(clipData);
			if (onSuccess)
				onSuccess(clipData);
		}, onFailure);
	}
	var ToggleFlag = function (clipData, flag, mask, onSuccess, onFailure)
	{
		var flagIsSet = NumberHasFlags(clipData.flags, flag);
		var newFlags = flagIsSet ? 0 : flag;
		UpdateClipFlags('@' + clipData.recId, newFlags, mask, function ()
		{
			// Success setting flag state
			clipData.flags = SetFlags(clipData.flags, newFlags, mask);
			if (onSuccess)
				onSuccess(clipData, flagIsSet);
		}, onFailure);
	}
	/**
	 * @param {Number} flags The original number where each bit is a different flag.
	 * @param {Number} flagsToSet The bits to set.
	 * @param {Number} mask The bits of [mask] which are 1 indicate the bits to copy from [flagsToSet] to [flags]. 
	 * @returns {Number} The modified number with bits changed.
	 */
	function SetFlags(flags, flagsToSet, mask)
	{
		var result = UI3_BINARY_AND(flags, UI3_BINARY_INVERT(mask)); // Clear the bits of flags that are set in mask
		result = UI3_BINARY_OR(result, UI3_BINARY_AND(flagsToSet, mask)); // Set the bits that are set in both mask and flagsToSet
		return result;
	}
	this.HideClipFlag = function (clipData)
	{
		var cli = videoPlayer.Loading().image;
		if (cli.uniqueId === clipData.recId)
			$("#clipFlagButton").removeClass("flagged");
		var $clip = $("#c" + clipData.recId);
		if ($clip.length == 0)
			return;
		var $icons = $clip.find(".clipIconWrapper");
		$icons.html(clipIcons.getIconHtmlForClipTile(clipData));
	}
	this.ShowClipFlag = function (clipData)
	{
		var cli = videoPlayer.Loading().image;
		if (cli.uniqueId === clipData.recId)
			$("#clipFlagButton").addClass("flagged");
		var $clip = $("#c" + clipData.recId);
		if ($clip.length == 0)
			return;
		var $icons = $clip.find(".clipIconWrapper");
		$icons.html(clipIcons.getIconHtmlForClipTile(clipData));
	}
	this.HideClipProtect = function (clipData)
	{
		var $clip = $("#c" + clipData.recId);
		if ($clip.length == 0)
			return;
		var $icons = $clip.find(".clipIconWrapper");
		$icons.html(clipIcons.getIconHtmlForClipTile(clipData));
	}
	this.ShowClipProtect = function (clipData)
	{
		var $clip = $("#c" + clipData.recId);
		if ($clip.length == 0)
			return;
		var $icons = $clip.find(".clipIconWrapper");
		$icons.html(clipIcons.getIconHtmlForClipTile(clipData));
	}
	this.RepairClipFlagState = function (clipData)
	{
		if (self.ClipDataIndicatesFlagged(clipData))
			self.ShowClipFlag(clipData);
		else
			self.HideClipFlag(clipData);
	}
	this.ClipDataIndicatesFlagged = function (clipData)
	{
		return NumberHasFlags(clipData.flags, BIDBFLAG.FLAGGED);
	}
	this.HideAiConfirmed = function (clipData)
	{
		var $clip = $("#c" + clipData.recId);
		if ($clip.length == 0)
			return;
		var $icons = $clip.find(".clipIconWrapper");
		$icons.html(clipIcons.getIconHtmlForClipTile(clipData));
	}
	this.ShowAiConfirmed = function (clipData)
	{
		var $clip = $("#c" + clipData.recId);
		if ($clip.length == 0)
			return;
		var $icons = $clip.find(".clipIconWrapper");
		$icons.html(clipIcons.getIconHtmlForClipTile(clipData));
	}
	this.RepairAiConfirmedState = function (clipData)
	{
		if (self.AlertDataIndicatesAIConfirmed(clipData))
			self.ShowAiConfirmed(clipData);
		else
			self.HideAiConfirmed(clipData);
	}
	this.AlertDataIndicatesAIConfirmed = function (clipData)
	{
		return NumberHasFlags(clipData.flags, BIDBFLAG.AI_CONFIRMED);
	}
	this.Multi_Flag = function (clipIDs, flagEnable, idx, myToast)
	{
		if (!sessionManager.IsAdministratorSession(clipIDs.length > 0 ? clipIDs[0] : null))
			return openLoginDialog(function () { self.Multi_Flag(clipIDs, flagEnable, idx, myToast); });
		Start_Multi_Operation("flag", GetClipDatas(clipIDs), { flagEnable: flagEnable });
	}
	this.Multi_Protect = function (clipIDs, protectEnable, idx, myToast)
	{
		if (!sessionManager.IsAdministratorSession(clipIDs.length > 0 ? clipIDs[0] : null))
			return openLoginDialog(function () { self.Multi_Protect(clipIDs, protectEnable, idx, myToast); });
		Start_Multi_Operation("protect", GetClipDatas(clipIDs), { protectEnable: protectEnable });
	}
	this.Multi_AiConfirm = function (clipIDs, confirm, idx, myToast)
	{
		if (!sessionManager.IsAdministratorSession(clipIDs.length > 0 ? clipIDs[0] : null))
			return openLoginDialog(function () { self.Multi_AiConfirm(clipIDs, confirm, idx, myToast); });
		Start_Multi_Operation("aiconfirm", GetClipDatas(clipIDs), { confirm: confirm });
	}
	this.Multi_Export = function (clipIDs, exportOptions, onFinish)
	{
		var clipDatas = GetClipDatas(clipIDs);
		var filtered = [];
		var removedSnapshots = false;
		var removedNonBvr = false;
		for (var i = 0; i < clipDatas.length; i++)
		{
			if (clipDatas[i].isSnapshot)
				removedSnapshots = true;
			else if (!clipLoader.GetClipFileTypeInfo(clipDatas[i]).isBVR)
				removedNonBvr = true;
			else
				filtered.push(clipDatas[i]);
		}
		if (removedSnapshots)
			toaster.Info("Snapshots are not exportable. You may simply download them instead.", 15000);
		if (removedNonBvr)
			toaster.Info("Non-BVR sources are not exportable. You may simply download them instead.", 15000);
		Start_Multi_Operation("export", filtered, exportOptions, onFinish);
	}
	this.Multi_Delete = function (allSelectedClipIDs)
	{
		if (allSelectedClipIDs.length === 0)
			return;
		if (settings.ui3_allow_clip_deletion === "0")
		{
			toaster.Info("Clip deletion is not allowed by the current configuration.");
			return;
		}
		if (!sessionManager.IsAdministratorSession(allSelectedClipIDs.length > 0 ? allSelectedClipIDs[0] : null))
			return openLoginDialog(function () { self.Multi_Delete(allSelectedClipIDs); });

		// Get a reference to the first clip before we try to close the current clip (which can cause the clip list to be temporarily empty)
		var clipData = self.GetClipFromId(allSelectedClipIDs[0]);

		// Close current clip if it is among those being deleted.
		var loadingClipId = videoPlayer.Loading().image.uniqueId;
		for (var i = 0; i < allSelectedClipIDs.length; i++)
		{
			if (loadingClipId === allSelectedClipIDs[i])
			{
				if (allSelectedClipIDs.length === 1)
					videoPlayer.Playback_NextClip();
				loadingClipId = videoPlayer.Loading().image.uniqueId;
				if (loadingClipId === allSelectedClipIDs[i])
					self.CloseCurrentClip();
				break;
			}
		}

		var allIdsCommaSeparated = '@' + allSelectedClipIDs.join(',@'); // Separated by ';' or ','
		console.log("Deleting ", allIdsCommaSeparated);
		DeleteAlert(allIdsCommaSeparated, clipData.isClip,
			function ()
			{
				self.UnselectAllClips();
				if (!videoPlayer.Loading().image.isLive && !videoPlayer.Loading().image.isTimeline())
					clipLoader.SelectClipIdNoOpen(videoPlayer.Loading().image.uniqueId);
				for (var i = 0; i < allSelectedClipIDs.length; i++)
					self.DisableClipTileById(allSelectedClipIDs[i]);
			},
			function (message)
			{
				toaster.Warning(message, 10000);
			});
	}
	this.DeleteCurrentClip = function ()
	{
		if (!videoPlayer.Loading().image.isLive && !videoPlayer.Loading().image.isTimeline())
		{
			var clip_to_delete = videoPlayer.Loading().image.uniqueId;
			var deleter = function ()
			{
				videoPlayer.Playback_NextClip();
				clipLoader.Multi_Delete([clip_to_delete]);
			};
			if (settings.ui3_askForDelete === "All")
			{
				var whichKind = (DbViewIsAlerts(settings.ui3_current_dbView) ? "alert" : "clip");
				AskYesNo("Confirm deletion of 1 " + whichKind + "?", deleter);
			}
			else
			{
				deleter();
			}
		}
	}
	var GetClipDatas = function (clipIds)
	{
		var clipDatas = new Array(clipIds.length);
		for (var i = 0; i < clipIds.length; i++)
			clipDatas[i] = self.GetClipFromId(clipIds[i]);
		return clipDatas;
	};
	var Start_Multi_Operation = function (operation, clipDatas, args, onFinish)
	{
		var options = {
			operation: operation
			, clips: clipDatas
			, recordingType: DbViewIsAlerts(settings.ui3_current_dbView) ? "alert" : "clip"
			, args: args
			, idx: 0
			, myToast: null
			, errorCount: 0
			, onFinish: onFinish
		};
		Multi_Operation(options);
	}
	var Multi_Operation = function (o)
	{
		if (o.idx == 0 && bulkOperationInProgress)
		{
			toaster.Warning("Another bulk operation is in progress.  Please wait for it to finish before starting another.", 10000);
			return;
		}

		if (o.idx >= o.clips.length)
		{
			Multi_Operation_Stop(o);
			return;
		}

		bulkOperationInProgress = true;

		if (o.myToast)
		{
			var $root = $("#multi_" + o.operation + "_status_toast");
			if ($root.length > 0)
			{
				var $count = $root.find(".multi_operation_count");
				$count.text(o.idx + 1);
				var $wrap = $root.find(".multi_operation_status_wrapper");
				var $bar = $wrap.find(".multi_operation_status_bar");
				var progressPercent = o.idx / o.clips.length;
				$bar.css("width", (progressPercent * 100) + "%");
			}
		}
		else
		{
			var verb = "ERROR";
			if (o.operation == "flag")
				verb = o.args.flagEnable ? "Flagging" : "Unflagging";
			else if (o.operation == "protect")
				verb = o.args.protectEnable ? "Protecting" : "Unprotecting";
			else if (o.operation == "export")
				verb = "Queueing export of";
			else if (o.operation == "aiconfirm")
				verb = o.args.confirm ? "Marking AI-confirmed" : "Unmarking AI-confirmed";
			o.myToast = toaster.Info('<div id="multi_' + o.operation + '_status_toast" class="multi_operation_status_toast">'
				+ '<div>' + verb + ' ' + o.recordingType + ' <span class="multi_operation_count">' + (o.idx + 1) + '</span> / ' + o.clips.length + '</div>'
				+ '<div class="multi_operation_status_wrapper"><div class="multi_operation_status_bar"></div></div>'
				+ '</div>', 86400000, true);
		}

		var clipData = o.clips[o.idx];
		if (clipData)
		{
			o.idx++;
			if (o.operation == "flag")
			{
				var isFlagged = self.ClipDataIndicatesFlagged(clipData);
				if ((isFlagged && !o.args.flagEnable) || (!isFlagged && o.args.flagEnable))
				{
					self.ToggleClipFlag(clipData, function ()
					{
						Multi_Operation(o);
					}, function ()
					{
						o.errorCount++;
						Multi_Operation(o);
					});
					return;
				}
			}
			else if (o.operation == "protect")
			{
				var isProtected = NumberHasFlags(clipData.flags, BIDBFLAG.PROTECTED);
				if ((isProtected && !o.args.protectEnable) || (!isProtected && o.args.protectEnable))
				{
					self.ToggleClipProtect(clipData, function ()
					{
						Multi_Operation(o);
					}, function ()
					{
						o.errorCount++;
						Multi_Operation(o);
					});
					return;
				}
			}
			else if (o.operation == "export")
			{
				self.QueueExportViaAPI(clipData, o.args, o, function ()
				{
					Multi_Operation(o);
				}, function ()
				{
					o.errorCount++;
					Multi_Operation(o);
				});
				return;
			}
			else if (o.operation == "aiconfirm")
			{
				var isConfirmed = self.AlertDataIndicatesAIConfirmed(clipData);
				if ((isConfirmed && !o.args.confirm) || (!isConfirmed && o.args.confirm))
				{
					self.ToggleAlertAiConfirmed(clipData, function ()
					{
						Multi_Operation(o);
					}, function ()
					{
						o.errorCount++;
						Multi_Operation(o);
					});
					return;
				}
			}
		}
		else
		{
			console.error('Null clipData encountered at index ' + o.idx);
			o.idx++;
			o.errorCount++;
		}
		setTimeout(function ()
		{
			Multi_Operation(o);
		}, 0);
	}
	var Multi_Operation_Stop = function (o)
	{
		bulkOperationInProgress = false;
		if (o.myToast)
			o.myToast.remove();
		if (o.errorCount > 0)
			toaster.Error("Bulk " + o.operation + " operation failed on<br/> " + o.errorCount + " / " + o.clips.length + " items.", 15000);
		if (typeof o.onFinish === "function")
			o.onFinish(o);
	}
	this.GetCurrentClipEle = function ()
	{
		var img = videoPlayer.Loading().image;
		if (!img.isLive && !videoPlayer.Loading().image.isTimeline())
		{
			var $clip = $("#c" + img.uniqueId);
			if ($clip.length)
				return $clip.get(0);
		}
		return null;
	}
	this.ClipLikelyHasGaps = function (clipData)
	{
		var diff = Math.abs(clipData.clipCoverMs - clipData.msec);
		var allowedDiff = Math.sqrt(clipData.msec) * 25;
		return diff > allowedDiff;
	}
	// Next / Previous Clip Helpers
	var GetClipIdFromClip = function ($clip)
	{
		try
		{
			return $clip.attr('id').substr(1);
		}
		catch (ex)
		{
			return "";
		}
	}
	this.GetClipBelowClip = function ($clip)
	{
		var clipIdx = GetClipIndexFromClipId(GetClipIdFromClip($clip));
		if (clipIdx != -1 && clipIdx + 1 < loadedClipIds.length)
			return ClipTileCreateFromId(loadedClipIds[clipIdx + 1]);
		return null;
	}
	this.GetClipAboveClip = function ($clip)
	{
		var clipIdx = GetClipIndexFromClipId(GetClipIdFromClip($clip));
		if (clipIdx > 0 && clipIdx - 1 < loadedClipIds.length)
			return ClipTileCreateFromId(loadedClipIds[clipIdx - 1]);
		return null;
	}
	var GetClipIndexFromClipId = function (recId)
	{
		if (loadedClipIds == null || loadedClipIds.length == 0)
			return -1;
		for (var i = 0; i < loadedClipIds.length; i++)
		{
			if (loadedClipIds[i] == recId)
				return i;
		}
		return -1;
	}
	// End of Helpers
	this.GetUnexportableReason = function (clipData)
	{
		if (clipData.isSnapshot)
			return "Snapshots are not exportable. You may simply download them instead.";
		else if (!clipLoader.GetClipFileTypeInfo(clipData).isBVR)
			return "Non-BVR sources are not exportable. You may simply download them instead.";
		return null;
	}
	this.GetClipFileTypeInfo = function (clipData)
	{
		var info = { isBVR: false, isH264: false };
		if (clipData)
		{
			if (clipData.rawClipData.filetype)
			{
				var fileTypeParts = clipData.rawClipData.filetype.split(' ');
				for (var i = 0; i < fileTypeParts.length; i++)
					fileTypeParts[i] = fileTypeParts[i].toLowerCase();
				info.isBVR = fileTypeParts.indexOf("bvr") > -1;
				info.isH264 = fileTypeParts.indexOf("h264") > -1;
			}
			else
			{
				info.isBVR = clipData.path.endsWithCaseInsensitive(".bvr");
			}
		}
		return info;
	};
	var ClipList_Updated = function (response)
	{
		if ($clipsbody.scrollTop() > 30)
		{
			EndNewDataFlashing();
			$clipListTopDate.addClass("newData");
			var ele = $clipListTopDate.get(0);
			ele.defaultTitle = $clipListTopDate.attr("title");
			$clipListTopDate.attr("title", "Click to see new items at top");
			ele.flashInterval = setInterval(function ()
			{
				$clipListTopDate.toggleClass("newData");
			}, 1000);
		}
	}
	this.ScrollToTop = function ()
	{
		$clipsbody.scrollTop(0);
	}
	var ClipsBodyScroll = function ()
	{
		if ($clipsbody.scrollTop() < 30)
			EndNewDataFlashing();
	}
	var EndNewDataFlashing = function ()
	{
		var ele = $clipListTopDate.get(0);
		if (ele.flashInterval)
		{
			clearInterval(ele.flashInterval);
			ele.flashInterval = null;
			$clipListTopDate.removeClass("newData");
			$clipListTopDate.attr("title", ele.defaultTitle);
			$clipListTopDate.off('click', self.ScrollToTop);
		}
	}
	this.RedrawClipList = function ()
	{
		tileLoader.appearDisappearCheck();
	}
	this.GetClipOverlayText = function (clipData)
	{
		var str = "";
		if (clipData.plate)
			str = clipData.plate;
		if (clipData.memo)
		{
			if (str)
				str += "; ";
			str += clipData.memo;
		}
		if (!str)
			str = null;
		return str;
	}
	this.GetClipDownloadText = function (clipData)
	{
		var str = "Download " + clipData.fileExtType;
		if (clipData.fileSize)
			str += " (" + htmlEncode(clipData.fileSize) + ")";
		return str;
	}
	// Some things must be initialized after methods are defined ...
	lastClipTileSize = getClipTileSize();
	var tileLoader = new ClipListDynamicTileLoader(clipsBodySelector, DateTileOnBecomeCurrent);
	setInterval(self.UpdateClipList, 6000);
	BI_CustomEvent.AddListener("ClipList_Updated", ClipList_Updated);
	$clipsbody.on('scroll', ClipsBodyScroll);
}
function OpenClipFromStats(stats)
{
	if (stats)
	{
		var clipData = new ClipData(stats);
		clipLoader.SetStartupClip(clipData);
	}
	else
	{
		videoPlayer.LoadHomeGroup();
	}
}
function DbViewIsAlerts(dbView)
{
	return dbView === "alerts" || dbView === "cancelled" || dbView === "confirmed" || dbView === "people" || dbView === "vehicles" || dbView.match("zone[a-h]") || dbView === "dio" || dbView === "onvif" || dbView === "audio" || dbView === "external";
}
function SetClipListShortcutIconState(iconSelector, selected)
{
	if (selected)
		$(iconSelector).addClass("selected");
	else
		$(iconSelector).removeClass("selected");
}
function GetThumbnailPath(pathOrRecId, nativeRes)
{
	var id = GetRecIdFromPath(pathOrRecId);
	if (nativeRes)
	{
		var clipData = clipLoader.GetClipFromId(id);
		if (!clipData)
		{
			toaster.Warning("Unable to find clip with ID " + id);
			return "";
		}
		nativeRes = clipData.hasHighResJpeg;
	}
	var qs = (nativeRes ? "fulljpeg" : "") + currentServer.GetAPISessionArg("&");
	if (qs)
		qs = "?" + qs;
	return currentServer.remoteBaseURL + (nativeRes ? "alerts" : "thumbs") + "/@" + id + qs;
}
///////////////////////////////////////////////////////////////
// Learn Which Days Have Clips ////////////////////////////////
///////////////////////////////////////////////////////////////
function ClipCalendarLoadData(callbackSuccess, callbackFailure)
{
	var camera = clipLoader.GetCurrentFilteredCamera();
	var loading = videoPlayer.Loading();
	if (loading.image && loading.image.isLive)
		camera = loading.image.id;
	var args = {
		cmd: "cliplist",
		view: settings.ui3_current_dbView,
		camera: camera,
		tiles: true
	};

	ExecJSON(args
		, function (response)
		{
			if (response.result !== "success")
			{
				callbackFailure("Clip calendar data load did not have success response: " + htmlEncode(JSON.stringify(response)));
			}
			else
			{
				var addedDates = {};
				var datesWithClips = [];
				var allClips = response.data ? response.data : [];
				for (var i = 0; i < allClips.length; i++)
				{
					var date = GetServerDate(new Date(allClips[i].date * 1000));
					var dateStr = date.getDate() + " " + (date.getMonth() + 1) + " " + date.getFullYear();
					if (!addedDates[dateStr])
					{
						addedDates[dateStr] = true;
						datesWithClips.push(dateStr);
					}
				}
				callbackSuccess(datesWithClips, camera);
			}
		}
		, function (jqXHR)
		{
			console.log("Failed to load list of dates with clips for the calendar.", args);
			callbackFailure("Failed to load list of dates with clips for the calendar. " + jqXHR.ErrorMessageHtml);
		});
}
///////////////////////////////////////////////////////////////
// Clip Res Parser ////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function ClipRes(res)
{
	this.width = 0;
	this.height = 0;
	this.valid = false;

	if (typeof res === "string" && res.length >= 3)
	{
		var idxX = res.indexOf('x');
		if (idxX > 0 && idxX + 1 < res.length)
		{
			this.width = parseInt(res.substr(0, idxX));
			this.height = parseInt(res.substr(idxX + 1));
			if (!isNaN(this.width) && !isNaN(this.height) && this.width > 0 && this.height > 0)
				this.valid = true;
		}
	}
}
///////////////////////////////////////////////////////////////
// Clip Thumbnail Video Preview ///////////////////////////////
///////////////////////////////////////////////////////////////
function ClipThumbnailVideoPreview_BruteForce()
{
	var self = this;
	var lastThumbLoadTime = -60000;
	var thumbVideoTimeout = null;
	var clipPreviewNumLoopsAllowed = 3;
	var clipThumbPlaybackActive = false;
	var clipPreviewStartTimeout = null;
	var queuedPreview = null;
	var lastItemId = null;
	var averageFrameLoadTime = null;

	this.Start = function ($clip, clipData, camName, frameNum, loopNum)
	{
		var duration = clipData.isClip ? clipData.msec : clipData.roughLengthMs;
		if (settings.ui3_clipPreviewEnabled !== "1" || duration < 500)
			return;
		if (clipData.hasHighResJpeg && settings.ui3_hires_jpeg_popups === "1" && settings.ui3_hires_jpeg_disables_preview_animation === "1")
			return;
		if (lastItemId != clipData.recId)
		{
			if (clipPreviewStartTimeout != null)
			{
				// A preview recently started. Schedule this to start later.
				queuedPreview = { clip: $clip, clipData: clipData, camName: camName };
				return;
			}
			clipPreviewStartTimeout = setTimeout(function ()
			{
				clipPreviewStartTimeout = null;
				if (queuedPreview)
				{
					averageFrameLoadTime = new RollingAverage(self.GetClipPreviewNumFrames());
					self.Start(queuedPreview.clip, queuedPreview.clipData, queuedPreview.camName);
				}
			}, 500);
		}

		queuedPreview = null;
		if (!frameNum)
			frameNum = 0;
		if (!loopNum)
			loopNum = 0;
		if (!averageFrameLoadTime)
			averageFrameLoadTime = new RollingAverage(self.GetClipPreviewNumFrames());

		// Throttle image loads to one per 200ms.
		var perfNow = performance.now();
		var timeWaited = perfNow - lastThumbLoadTime;
		var waitTime = PreviewSpeedToDelayMs(parseInt(settings.ui3_clip_preview_speed));
		var timeToWait = Clamp(waitTime - timeWaited, 0, 1000);
		if (timeToWait > 0)
		{
			clearTimeout(thumbVideoTimeout);
			thumbVideoTimeout = setTimeout(function ()
			{
				self.Start($clip, clipData, camName, frameNum, loopNum);
			}, timeToWait);
			return;
		}
		lastThumbLoadTime = perfNow;
		lastItemId = clipData.recId;
		var aspectRatio;
		var camData = cameraListLoader.GetCameraWithId(clipData.camera);
		if (camData && camData.height != 0)
			aspectRatio = camData.width / camData.height;
		else
			aspectRatio = 16 / 9;
		var expectedHeight = 240;
		var expectedWidth = expectedHeight * aspectRatio;
		if (clipData.hasHighResJpeg && settings.ui3_hires_jpeg_popups === "1")
		{
			var clipRes = new ClipRes(clipData.res);
			if (clipRes.valid)
			{
				expectedWidth = clipRes.width;
				expectedHeight = clipRes.height;
			}
		}
		clipThumbPlaybackActive = true;
		var clipPreviewNumFrames = self.GetClipPreviewNumFrames();
		var timeValue = ((frameNum % clipPreviewNumFrames) / clipPreviewNumFrames) * duration;
		var thumbPath = currentServer.remoteBaseURL + "file/clips/@" + clipData.recId + '?time=' + timeValue + "&cache=1&h=" + expectedHeight + currentServer.GetAPISessionArg("&");
		var thumbLabel = camName + " " + GetTimeStr(new Date(clipData.displayDate.getTime() + timeValue));
		bigThumbHelper.Show($clip, $clip, thumbLabel, thumbPath, expectedWidth, expectedHeight, function ($img, userContext, success)
		{
			if (clipThumbPlaybackActive)
			{
				frameNum++;
				if (frameNum >= clipPreviewNumFrames)
				{
					frameNum = 0;
					loopNum++;
				}
				var timeToLoadThisFrame = performance.now() - lastThumbLoadTime;
				averageFrameLoadTime.Add(timeToLoadThisFrame);
				if (loopNum >= clipPreviewNumLoopsAllowed && averageFrameLoadTime.Get() > 10) // Only allow looping past the limit if images are loading fast
					return;

				self.Start($clip, clipData, camName, frameNum, loopNum);
			}
		}, null, true);
	}
	this.Stop = function ()
	{
		ClearTimeouts();
		clipThumbPlaybackActive = false;
		bigThumbHelper.Hide();
		averageFrameLoadTime = new RollingAverage(self.GetClipPreviewNumFrames());
	}
	this.GetClipPreviewNumFrames = function ()
	{
		var clipPreviewNumFrames = parseInt(settings.ui3_clip_preview_num_frames);
		if (!clipPreviewNumFrames)
			clipPreviewNumFrames = 8;
		clipPreviewNumFrames = Clamp(clipPreviewNumFrames, 2, 100);
		return clipPreviewNumFrames;
	}
	var ClearTimeouts = function ()
	{
		if (thumbVideoTimeout != null)
		{
			clearTimeout(thumbVideoTimeout);
			thumbVideoTimeout = null;
		}
		if (clipPreviewStartTimeout != null)
		{
			clearTimeout(clipPreviewStartTimeout);
			clipPreviewStartTimeout = null;
		}
	}
}
///////////////////////////////////////////////////////////////
// Asynchronous Image Downloading /////////////////////////////
///////////////////////////////////////////////////////////////
function AsyncClipThumbnailDownloader()
{
	var asyncThumbnailDownloader = new AsyncThumbnailDownloader(3, onLoad, onError, loadCondition, 250, true);
	var fallbackImg = 'ui3/noimage.png' + currentServer.GetLocalSessionArg("?");
	this.Stop = function ()
	{
		asyncThumbnailDownloader.Stop();
	}
	this.Visible = function (img, recId)
	{
		var path = GetThumbnailPath(recId, false);
		asyncThumbnailDownloader.Visible(recId, path, img);
	}
	this.Invisible = function (recId)
	{
		asyncThumbnailDownloader.Invisible(recId);
	}

	function onLoad(img)
	{
		var $img = $(img);
		$img.css("width", "auto");
		$img.css("height", "auto");
	}
	function onError(img)
	{
		var $img = $(img);
		$img.css("width", "auto");
		$img.css("height", "auto");
		$img.attr('src', fallbackImg);
	}
	function loadCondition(obj)
	{
		var src = obj.img.getAttribute('src');
		return !src || src.length == 0 || src == "ui3/LoadingImage.png" + currentServer.GetLocalSessionArg("?") || (src != obj.path && src != fallbackImg);
	}
}
function AsyncPresetThumbnailDownloader(thumbLoaded, thumbError)
{
	var asyncThumbnailDownloader = new AsyncThumbnailDownloader(3, thumbLoaded, thumbError, loadCondition, 250, true);

	this.Stop = function ()
	{
		asyncThumbnailDownloader.Stop();
	}
	this.VisiblePath = function (img, src)
	{
		asyncThumbnailDownloader.Visible(src, src, img);
	}
	function loadCondition(obj)
	{
		return true;
	}
}
function AsyncOffscreenThumbnailDownloader(onLoadCallback)
{
	var asyncThumbnailDownloader = new AsyncThumbnailDownloader(3, onLoad, onError, loadCondition, 50, false);
	var imgIdMap = new FasterObjectMap();

	this.Stop = function ()
	{
		asyncThumbnailDownloader.Stop();
		imgIdMap = new FasterObjectMap();
	}
	this.Visible = function (recId)
	{
		if (!imgIdMap[recId])
			imgIdMap[recId] = document.createElement("img");
		var path = GetThumbnailPath(recId);
		asyncThumbnailDownloader.Visible(recId, path, imgIdMap[recId]);
	}
	this.Invisible = function (recId)
	{
		asyncThumbnailDownloader.Invisible(recId);
	}
	this.GetImg = function (recId)
	{
		return imgIdMap[recId];
	}

	function onLoad(img)
	{
		img.loadedSuccessfully = true;
		onLoadCallback();
	}
	function onError(img)
	{
	}
	function loadCondition(obj)
	{
		var src = obj.img.getAttribute('src');
		return !src || src.length == 0 || src != obj.path;
	}
}
function AsyncThumbnailDownloader(numThreads, onLoad, onError, loadCondition, idleSleepMs, useTemporaryLoadingImage)
{
	var self = this;
	/** Map of key to objects that are queued for loading.  Objects are moved to the [currentlyLoadingObjects] map when they begin loading. */
	var queuedObjectMap = new FasterObjectMap();
	/** The queue of image object keys which defines their load order. */
	var queuedKeys = new Queue();
	/** Map of key to objects that are currently loading. */
	var currentlyLoadingObjects = new FasterObjectMap();
	var stopImageQueue = false;
	numThreads = Clamp(numThreads, 1, 5);
	var loadTimeoutMs = 5000;
	if (!idleSleepMs)
		idleSleepMs = 250;
	if (typeof useTemporaryLoadingImage === "undefined")
		useTemporaryLoadingImage = true;

	this.Stop = function ()
	{
		stopImageQueue = true;
		queuedObjectMap = new FasterObjectMap();
		queuedKeys = new Queue();
		currentlyLoadingObjects = new FasterObjectMap();
	}
	var AsyncDownloadQueuedImage = function ()
	{
		if (stopImageQueue || currentServer.isLoggingOut)
			return;
		var obj = popHighestPriorityImage();
		if (!obj)
			setTimeout(AsyncDownloadQueuedImage, idleSleepMs);
		else
		{
			if (loadCondition(obj))
			{
				var $img = $(obj.img);
				$img.bind("load.asyncimage", function ()
				{
					delete currentlyLoadingObjects[obj.key];
					clearTimeout(obj.loadTimeout);
					$img.unbind("load.asyncimage error.asyncimage");
					if (onLoad)
						onLoad(obj.img);
					if (!obj.timedOut)
						AsyncDownloadQueuedImage();
				});
				$img.bind("error.asyncimage", function ()
				{
					delete currentlyLoadingObjects[obj.key];
					clearTimeout(obj.loadTimeout);
					$img.unbind("load.asyncimage error.asyncimage");
					if (onError)
						onError(obj.img);
					if (!obj.timedOut)
						AsyncDownloadQueuedImage();
				});
				obj.loadTimeout = setTimeout(function ()
				{
					delete currentlyLoadingObjects[obj.key];
					$img.unbind("load.asyncimage error.asyncimage");
					obj.timedOut = true; // This timeout occurs if the element is removed from the DOM before the load is completed.
					AsyncDownloadQueuedImage();
				}, loadTimeoutMs);
				obj.timedOut = false;
				currentlyLoadingObjects[obj.key] = obj;
				$img.attr('src', obj.path);
			}
			else // Image is already loaded
			{
				self.Invisible(obj.key);
				AsyncDownloadQueuedImage();
			}
		}
	}
	var popHighestPriorityImage = function ()
	{
		var key = queuedKeys.dequeue();
		if (key)
		{
			var obj = queuedObjectMap[key];
			delete queuedObjectMap[key];
			return obj;
		}
		return null;
	}
	/**
	 * Adds or updates the given image and queues it for loading.
	 * @param {String} key Unique identifier string for the image, used for keying.
	 * @param {String} path URL to load the image from.
	 * @param {Object} img DOM image element.
	 */
	this.Visible = function (key, path, img)
	{
		if (currentlyLoadingObjects[key])
			return;
		if (queuedObjectMap[key])
			return;
		var obj = new Object();
		obj.img = img;
		obj.key = key;
		obj.path = path;
		queuedObjectMap[key] = obj;
		queuedKeys.enqueue(key);
	}
	/**
	 * Removes the image from the queue, canceling it if it is already downloading.
	 * @param {String} key Unique identifier string for the image, used for keying.
	 */
	this.Invisible = function (key)
	{
		var obj = currentlyLoadingObjects[key];
		if (obj)
		{
			delete currentlyLoadingObjects[key];
			clearTimeout(obj.loadTimeout);
			var $img = $(obj.img);
			$img.unbind("load.asyncimage error.asyncimage");
			if (useTemporaryLoadingImage)
				$img.attr('src', 'ui3/LoadingImage.png' + currentServer.GetLocalSessionArg("?"));
			setTimeout(AsyncDownloadQueuedImage, idleSleepMs);
			return;
		}
		else if (queuedObjectMap[key])
		{
			delete queuedObjectMap[key];
			queuedKeys.removeAll(function (item)
			{
				return item === key;
			});
		}
	}

	for (var i = 0; i < numThreads; i++)
		AsyncDownloadQueuedImage();
}
///////////////////////////////////////////////////////////////
// Appear / Disappear in clips body logic /////////////////////
///////////////////////////////////////////////////////////////
function ClipListDynamicTileLoader(clipsBodySelector, callbackCurrentDateFunc)
{
	var self = this;
	var $clipsbody = $(clipsBodySelector);
	var aboveAllowance = 500;
	var belowAllowance = 1000;
	var appearDisappearRegisteredObjects = new Array();
	var appearedObjects = new Array();
	var callbackCurrentDateFunc = callbackCurrentDateFunc;
	this.AppearDisappearCheckEnabled = true;
	var nextY = 0;
	var scrollToAtEnd = -1;

	this.appearDisappearCheck = function ()
	{
		if (!self.AppearDisappearCheckEnabled || appearDisappearRegisteredObjects.length == 0 || currentPrimaryTab != "clips")
			return;
		var scrollTop = $clipsbody.scrollTop();
		var yMin = scrollTop - aboveAllowance;
		var yMax = scrollTop + $clipsbody.height() + belowAllowance;
		var yTopmostMin = scrollTop;
		for (var i = 0; i < appearedObjects.length; i++)
		{
			var obj = appearedObjects[i];
			if (obj.y < yMin || obj.y > yMax)
			{
				obj.isAppeared = false;
				if (obj.callbackOnDisappearFunc)
					obj.callbackOnDisappearFunc(obj);
				appearedObjects.splice(i, 1);
				i--;
			}
		}
		// The registered objects are sorted by Y coordinate, so we can quickly find the first item that should be visible.
		var idx = binarySearch(appearDisappearRegisteredObjects, yMin, compare_y_with_obj);
		if (idx < 0)
			idx = (-idx) - 1;
		var firstVisibleObjIdx = idx;
		for (var i = idx; i < appearDisappearRegisteredObjects.length; i++)
		{
			var obj = appearDisappearRegisteredObjects[i];
			if (obj.y >= yMin && obj.y <= yMax)
			{
				// obj is Visible (or nearly visible)
				if (!obj.isAppeared)
				{
					appearedObjects.push(obj);
					obj.isAppeared = true;
					if (obj.callbackOnAppearFunc)
						obj.callbackOnAppearFunc(obj);
				}
				if (obj.y >= yTopmostMin && firstVisibleObjIdx == idx)
					firstVisibleObjIdx = i;
			}
			else
				break;
		}
		var foundCurrentDate = false;
		for (var i = firstVisibleObjIdx; i >= 0; i--)
		{
			var obj = appearDisappearRegisteredObjects[i];
			if (obj.isDateTile)
				if (obj.y <= yTopmostMin)
				{
					foundCurrentDate = true;
					callbackCurrentDateFunc(obj);
					break;
				}
		}
		if (!foundCurrentDate)
			callbackCurrentDateFunc(null);
	}
	// This method was not needed and is not supported
	//this.unregisterOnAppearDisappear = function (obj)
	//{
	//	for (var i = 0; i < appearDisappearRegisteredObjects.length; i++)
	//	{
	//		if (appearDisappearRegisteredObjects[i] == obj)
	//		{
	//			appearDisappearRegisteredObjects.splice(i, 1);
	//			return;
	//		}
	//	}
	//}
	this.registerOnAppearDisappear = function (obj, callbackOnAppearFunc, callbackOnDisappearFunc, callbackOnMoveFunc, HeightOfOneClipTilePx, HeightOfOneDateTilePx)
	{
		prepareClipDataForRegistration(obj, callbackOnAppearFunc, callbackOnDisappearFunc, callbackOnMoveFunc, HeightOfOneClipTilePx, HeightOfOneDateTilePx);
		appearDisappearRegisteredObjects.push(obj);
	}
	var prepareClipDataForRegistration = function (obj, callbackOnAppearFunc, callbackOnDisappearFunc, callbackOnMoveFunc, HeightOfOneClipTilePx, HeightOfOneDateTilePx)
	{
		obj.isAppeared = false;
		//obj.isDateTile = obj.isDateTile;
		obj.y = nextY;
		obj.h = obj.isDateTile ? HeightOfOneDateTilePx : HeightOfOneClipTilePx;
		nextY += obj.h;
		obj.callbackOnAppearFunc = callbackOnAppearFunc;
		obj.callbackOnDisappearFunc = callbackOnDisappearFunc;
		obj.callbackOnMoveFunc = callbackOnMoveFunc;
	}
	this.unregisterAllOnAppearDisappear = function ()
	{
		nextY = 0;
		appearDisappearRegisteredObjects = new Array();
		appearedObjects = new Array();
	}
	this.injectNewClips = function (newClips, ClipOnAppear, ClipOnDisappear, callbackOnMoveFunc, HeightOfOneClipTilePx, HeightOfOneDateTilePx, DateTileOnAppear, DateTileOnDisappear)
	{
		for (var i = 0; i < newClips.length; i++)
		{
			if (newClips[i].isDateTile)
				prepareClipDataForRegistration(newClips[i], DateTileOnAppear, DateTileOnDisappear, callbackOnMoveFunc, HeightOfOneClipTilePx, HeightOfOneDateTilePx);
			else
				prepareClipDataForRegistration(newClips[i], ClipOnAppear, ClipOnDisappear, callbackOnMoveFunc, HeightOfOneClipTilePx, HeightOfOneDateTilePx);
		}
		appearDisappearRegisteredObjects = newClips.concat(appearDisappearRegisteredObjects);
	}
	/**
	 * Calculates new positions for all clip and date tiles in the list. Should be called after UI resizes and after registering new objects.
	 */
	this.resizeClipList = function (HeightOfOneClipTilePx, HeightOfOneDateTilePx)
	{
		nextY = 0;
		var scrollTop = $clipsbody.scrollTop();
		var topmostVisibleElement = null;
		for (var i = 0; i < appearDisappearRegisteredObjects.length; i++)
		{
			var obj = appearDisappearRegisteredObjects[i];
			var myHeight = obj.isDateTile ? HeightOfOneDateTilePx : HeightOfOneClipTilePx;
			if (scrollToAtEnd == -1 && obj.y + obj.h >= scrollTop)
			{
				var offset = (obj.y + obj.h) - scrollTop;
				var offsetPercent = 1 - (obj.h == 0 ? 0 : (offset / obj.h));
				scrollToAtEnd = nextY + (myHeight * offsetPercent);
			}
			obj.y = nextY;
			obj.h = myHeight;
			obj.callbackOnMoveFunc(obj);
			nextY += myHeight;
		}
		if (scrollToAtEnd > -1)
			$clipsbody.scrollTop(scrollToAtEnd);
		scrollToAtEnd = -1;
		self.appearDisappearCheck();
	}
	this.preserveScrollPosition = function (HeightOfOneClipTilePx, HeightOfOneDateTilePx, numNewClipTiles)
	{
		// Preserves the current scroll position plus the height of a number of new clip tiles, unless the current scroll position is near 0
		scrollToAtEnd = -1;
		var tmpY = 0;
		var scrollTop = $clipsbody.scrollTop();
		if (scrollTop <= 10)
			return;
		var topmostVisibleElement = null;
		for (var i = 0; i < appearDisappearRegisteredObjects.length; i++)
		{
			var obj = appearDisappearRegisteredObjects[i];
			var myHeight = obj.isDateTile ? HeightOfOneDateTilePx : HeightOfOneClipTilePx;
			if (scrollToAtEnd == -1 && obj.y + obj.h >= scrollTop)
			{
				var offset = (obj.y + obj.h) - scrollTop;
				var offsetPercent = 1 - (obj.h == 0 ? 0 : (offset / obj.h));
				scrollToAtEnd = tmpY + (myHeight * offsetPercent) + (numNewClipTiles * HeightOfOneClipTilePx);
				return;
			}
			tmpY += myHeight;
		}
	}
	var compare_y_with_obj = function (a, b)
	{
		return a - b.y;
	}
	$(window).resize(self.appearDisappearCheck);
	$clipsbody.scroll(self.appearDisappearCheck);
}
///////////////////////////////////////////////////////////////
// Status Update //////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var serverTimeZoneOffsetMs = 0;
/** Millisecond offset to be added to the local clock to make it match the server clock. */
var currentServerTimeOffset = 0;
/** Gets the current time in milliseconds since the epoch, from the perspective of the server. This method corrects clock sync differences between client and server. */
function GetUtcNow()
{
	return GetSyncedTime(Date.now());
}
/** Offsets the given client timestamp to correct for time sync error between client and server (trusts server clock). */
function GetSyncedTime(time)
{
	return time + currentServerTimeOffset;
}
function StatusLoader()
{
	var self = this;
	var updateDelay = 5000;
	var lastStatusUpdateAt = performance.now() - 600000;
	var lastResponse = null;
	var currentProfileNames = null;
	var currentlySelectedSchedule = null;
	var globalScheduleEnabled = false;
	var profileButtonsEnabled = true;
	var profileChangedTimeout = null;
	var statusUpdateTimeout = null;
	var $profileDropdown = $('.dropdownBox[name="profile"]');
	var $scheduleLockBtn = $("#schedule_lock_button");
	var $scheduleLockIcon = $("#schedule_lock_icon use");

	this.LoadStatus = function ()
	{
		loadStatusInternal();
	}
	this.LoadProfile = function (profileNum)
	{
		if (profileNum >= -1 && profileNum <= 7)
			loadStatusInternal({ profileNum: profileNum });
		else
			toaster.Error("Cannot load profile " + profileNum);
	}
	this.SetStoplight = function (signal)
	{
		if (typeof signal !== "undefined" && signal >= 0 && signal <= 2)
			loadStatusInternal({ stoplightState: signal });
		else
			toaster.Error("Cannot set Shield state: " + signal);
	}
	this.InstallUpdate = function (version)
	{
		if (version)
			loadStatusInternal({ installVersion: version });
	}
	var loadStatusInternal = function (statusArgs)
	{
		if (statusUpdateTimeout != null)
			clearTimeout(statusUpdateTimeout);
		if (documentIsHidden())
		{
			if (browser_is_android || browser_is_ios || performance.now() - lastStatusUpdateAt < 45000)
			{
				statusUpdateTimeout = setTimeout(function ()
				{
					self.LoadStatus();
				}, updateDelay);
				return;
			}
		}
		var args = { cmd: "status" };
		if (statusArgs)
		{
			if (typeof statusArgs.profileNum != "undefined" && statusArgs.profileNum != null)
			{
				if (sessionManager.HasPermission_ChangeProfile())
					args.profile = parseInt(statusArgs.profileNum);
				else
					openLoginDialog(function () { loadStatusInternal(statusArgs); });
			}
			if (typeof statusArgs.stoplightState != "undefined" && statusArgs.stoplightState != null)
			{
				if (sessionManager.HasPermission_ChangeProfile())
					args.signal = parseInt(statusArgs.stoplightState);
				else
					openLoginDialog(function () { loadStatusInternal(statusArgs); });
			}
			if (typeof statusArgs.schedule != "undefined" && statusArgs.schedule != null)
			{
				if (sessionManager.HasPermission_ChangeProfile())
					args.schedule = statusArgs.schedule;
				else
					openLoginDialog(function () { loadStatusInternal(statusArgs); });
			}
			if (typeof statusArgs.installVersion != "undefined" && statusArgs.installVersion != null)
			{
				if (sessionManager.HasPermission_InstallUpdate())
					args.update = ConvertVersionNumberToInsaneInt(statusArgs.installVersion) + ", 0";
				else
					openLoginDialog(function () { loadStatusInternal(statusArgs); });
			}
		}
		var requestStart = performance.now();
		ExecJSON(args, function (response)
		{
			var requestEnd = performance.now();
			EndConnectionErrors();
			lastStatusUpdateAt = performance.now();
			if (sessionManager.IsInvalidSession(response))
			{
				sessionManager.ReestablishLostSession();
				return;
			}
			var lrSave = lastResponse;
			lastResponse = response;
			HandleChangesInStatus(lrSave, response);
			if (response && response.data)
			{
				//data:
				// {"signal":"1", "cxns":23, "cpu":9, "gpu":0, "ram":"3418931200", "bits":28, "mem":"3.18G", "memphys":"31.9G", "memload":"27%", "folders":[...], "disks":[...], "profile":1, "lock":"0", "schedule":"Default", "dio":[...], "uptime":"4:20:55:44", "clips":"Clips: 123 items, 1.23T/1.23T; D: +108.6G, E: +69.7G", "time":"1685468503006", "tmessage":"1685468502981", "clipprocess":"", "warnings":"4", "alerts":"5854", "tzone":"-360"}
				statusAreaApi.setStoplightSignal(parseInt(lastResponse.data.signal));
				statusAreaApi.setValue("Server CPU", Clamp(parseFloat(response.data.cpu) / 100, 0, 1));
				var memObj = {
					bi: response.data.ram && parseInt(response.data.ram)
						? parseInt(response.data.ram)
						: getBytesFromBISizeStr(response.data.mem),
					memPhys: response.data.memphys
						? getBytesFromBISizeStr(response.data.memphys)
						: 0,
					load: parseFloat(response.data.memload) / 100
				};
				statusAreaApi.setValue("Server Memory", memObj);

				// Disk info example: "disks":[{ "disk":"V:", "allocated":1841152, "used":1563676, "free":343444, "total":1907599 }]
				// Values are in Mebibytes (MiB)
				if (response.data.disks)
				{
					var totalAvailable = 0;
					var totalUsed = 0;
					for (var i = 0; i < response.data.disks.length; i++)
					{
						var disk = response.data.disks[i];
						totalAvailable += disk.allocated;
						totalUsed += disk.used;
					}
					var diskPercent = totalAvailable == 0 ? 0 : totalUsed / totalAvailable;
					statusAreaApi.setValue("Server Disk", { fullness: diskPercent, tooltip: "Click to visualize disk usage." + (response.data.clips ? "\n\n" + response.data.clips : "") });
				}
				else if (response.data.clips)
				{
					// Fall back to old format
					var match = new RegExp(", (.+)/(.+);").exec(response.data.clips);
					if (match)
					{
						var used = getBytesFromBISizeStr(match[1]);
						var total = getBytesFromBISizeStr(match[2]);
						var diskPercent = total == 0 ? 0 : used / total;
						statusAreaApi.setValue("Server Disk", { fullness: diskPercent, tooltip: response.data.clips });
					}
					else
					{
						statusAreaApi.setValue("Server Disk", { fullness: 0, tooltip: "Disk information was in an unexpected format: " + response.data.clips, error: true });
					}
				}

				statusAreaApi.setValue("Server Uptime", { uptime: response.data.uptime });

				notificationCounters.setCounter("#btn_main_menu .notificationCounter", settings.ui3_topbar_warnings_counter === "1"
					? Math.min(99, self.getNotificationCounterValue("warnings"))
					: 0);
				notificationCounters.setCounter("#open_alerts_btn .notificationCounter", settings.ui3_topbar_alerts_shortcut_counter === "1"
					? Math.min(99999, self.getNotificationCounterValue("alerts"))
					: 0);

				UpdateProfileStatus();
				UpdateScheduleStatus();
				dropdownBoxes.listDefs["dbView"].rebuildItems();
				serverTimeZoneOffsetMs = parseInt(parseFloat(response.data.tzone) * -60000);
				if (response.data.time)
				{
					var requestDuration = requestEnd - requestStart;
					var timeOfRequest = Date.now() - (requestDuration / 2);
					currentServerTimeOffset = Math.round(parseInt(response.data.time) - timeOfRequest);
				}
			}
			loadingHelper.SetLoadedStatus("status");
			BI_CustomEvent.Invoke("StatusLoaded", response);

			var nextStatusUpdateDelay = updateDelay;
			if (typeof args.schedule != "undefined")
				nextStatusUpdateDelay = 1000; // We just updated the schedule. Refresh again soon in case of profile change.
			if (statusUpdateTimeout != null)
				clearTimeout(statusUpdateTimeout);
			statusUpdateTimeout = setTimeout(function ()
			{
				self.LoadStatus();
			}, nextStatusUpdateDelay);
		}, function (jqXHR, textStatus, errorThrown)
		{
			if (statusUpdateTimeout != null)
				clearTimeout(statusUpdateTimeout);
			if (!HandleGroupableConnectionError(jqXHR))
				toaster.Error("An error occurred loading the server status.<br>" + jqXHR.ErrorMessageHtml);
			statusUpdateTimeout = setTimeout(function ()
			{
				self.LoadStatus();
			}, updateDelay);
		});
	}
	var HandleChangesInStatus = function (oldStatus, newStatus)
	{
		if (oldStatus && oldStatus.data && newStatus && newStatus.data)
		{
			if (oldStatus.data.profile != newStatus.data.profile)
				ProfileChanged(oldStatus.data.profile, newStatus.data.profile);
		}
	}
	var ProfileChanged = function (oldProfileNum, newProfileNum)
	{
		// Refresh the clips and camera lists.
		toaster.Info("Your profile has changed from &quot;<b>" + self.GetProfileName(oldProfileNum)
			+ "</b>&quot; to &quot;<b>" + self.GetProfileName(newProfileNum) + "</b>&quot;", 5000);
		if (profileChangedTimeout != null)
		{
			clearTimeout(profileChangedTimeout);
			profileChangedTimeout = null;
		}
		profileChangedTimeout = setTimeout(function ()
		{
			cameraListLoader.LoadCameraList();
		}, 5000);
	}
	this.getProfileDropdownHtml = function (profileNum)
	{
		var profileName;
		if (currentProfileNames && currentProfileNames.length > profileNum)
			profileName = currentProfileNames[profileNum];
		if (profileNum === 0 && !profileName)
			profileName = 'Inactive';
		else if (!profileName)
			profileName = "Profile " + profileNum;
		if (profileNum === 0)
			return getProfileDropdownHtml_Internal(profileNum, '#EEEEEE; background-color: #EE232C; padding: 0px 3px', profileName);
		else if (profileNum === 1)
			return getProfileDropdownHtml_Internal(profileNum, '#00FF00', profileName);
		else if (profileNum === 2)
			return getProfileDropdownHtml_Internal(profileNum, '#0097F0', profileName);
		else if (profileNum === 3)
			return getProfileDropdownHtml_Internal(profileNum, '#FF0000', profileName);
		else if (profileNum === 4)
			return getProfileDropdownHtml_Internal(profileNum, '#FFFF00', profileName);
		else if (profileNum === 5)
			return getProfileDropdownHtml_Internal(profileNum, '#FF8800', profileName);
		else if (profileNum === 6)
			return getProfileDropdownHtml_Internal(profileNum, '#FF00FF', profileName);
		else if (profileNum === 7)
			return getProfileDropdownHtml_Internal(profileNum, '#00FFFF', profileName);
		else
			return getProfileDropdownHtml_Internal(profileNum, '#FF0000', "Unknown Profile");
	}
	var getProfileDropdownHtml_Internal = function (profileNum, color, profileName)
	{
		return '<span style="color: ' + color + '; font-weight: bold;">' + profileNum + '</span>' + (profileName ? (' &nbsp; ' + htmlEncode(profileName)) : '');
	}
	var UpdateProfileStatus = function ()
	{
		if (lastResponse != null)
		{
			dropdownBoxes.setLabelText("profile", self.getProfileDropdownHtml(parseInt(lastResponse.data.profile)), true);
			var schedule = lastResponse.data.schedule;
			if (schedule == "")
				schedule = "N/A";
			var lock = lastResponse.data.lock;
			if (lock == 0)
			{
				$scheduleLockBtn.removeClass("hold");
				$scheduleLockBtn.removeClass("temp");
				$scheduleLockIcon.attr("href", "#svg_x5F_Play");
				$scheduleLockBtn.attr("title", 'Schedule "' + schedule + '" is active. Long press to disable automatic scheduling.');
			}
			else if (lock == 1)
			{
				$scheduleLockBtn.addClass("hold");
				$scheduleLockBtn.removeClass("temp");
				$scheduleLockIcon.attr("href", "#svg_square");
				$scheduleLockBtn.attr("title", 'Schedule "' + schedule + '" is currently disabled. Click to re-enable.');
			}
			else if (lock == 2)
			{
				$scheduleLockBtn.removeClass("hold");
				$scheduleLockBtn.addClass("temp");
				$scheduleLockIcon.attr("href", "#svg_x5F_Pause");
				$scheduleLockBtn.attr("title", 'Schedule "' + schedule + '" is temporarily overridden. Click to resume schedule, or wait some hours and it should return to normal.');
			}
			else
				toaster.Error("unexpected <b>lock</b> value from Blue Iris status");
		}
	}
	this.SetCurrentProfileNames = function (newProfileNames)
	{
		currentProfileNames = newProfileNames;
		dropdownBoxes.listDefs["profile"].rebuildItems();
		UpdateProfileStatus();
	}
	this.GetProfileName = function (profileNum)
	{
		profileNum = parseInt(profileNum);
		if (currentProfileNames && profileNum >= 0 && profileNum < currentProfileNames.length)
			return currentProfileNames[profileNum];
		return "Profile " + profileNum;
	}
	/**
	 * Gets the folder at the specified index, returning null if it does not exist or if its path has not been configured in Blue Iris.
	 * @param {Number} index 0-based index
	 */
	this.GetFolder = function (index)
	{
		if (lastResponse && lastResponse.data && lastResponse.data.folders && index >= 0 && index < lastResponse.data.folders.length)
		{
			var folder = lastResponse.data.folders[index];
			// Previously this was just the folder name. BI 5.7.2.1 made it {name: "New", clips: 123, age: 0, used: 1791998, allocated: 1792000}. Sizes assumed to be MB, assuming folders are configured as MiB. BI does not follow abbreviation standards.
			if (typeof folder === "string")
				return { name: folder, clips: 1, age: 0, used: 1, allocated: 1 };
			else if (folder.name)
				return folder;
			else
				return null;
		}
		else
			return null;
	}
	var UpdateScheduleStatus = function ()
	{
		if (lastResponse == null)
			return;
		currentlySelectedSchedule = lastResponse.data.schedule;
		globalScheduleEnabled = currentlySelectedSchedule != "";
		if (!globalScheduleEnabled)
			currentlySelectedSchedule = "N/A";
		dropdownBoxes.listDefs["schedule"].rebuildItems();
		dropdownBoxes.setLabelText("schedule", currentlySelectedSchedule);
	}
	this.IsGlobalScheduleEnabled = function ()
	{
		return globalScheduleEnabled;
	}
	this.GetCurrentlySelectedScheduleName = function ()
	{
		return currentlySelectedSchedule;
	}
	this.ChangeSchedule = function (scheduleName)
	{
		loadStatusInternal({ schedule: scheduleName });
	}
	this.SetProfileButtonsEnabled = function (enabled)
	{
		if (enabled)
		{
			$scheduleLockBtn.removeClass("disabled");
			$profileDropdown.removeClass("disabled");
		}
		else
		{
			$scheduleLockBtn.addClass("disabled");
			$profileDropdown.addClass("disabled");
		}
		profileButtonsEnabled = enabled;
	}
	this.GetProfileButtonsEnabled = function ()
	{
		return profileButtonsEnabled;
	}
	this.SetStoplightButtonEnabled = function (enabled)
	{
		statusAreaApi.setStoplightEnabled(enabled);
	}
	$scheduleLockBtn.longpress(
		function ()
		{
			if (!lastResponse || $scheduleLockBtn.hasClass("disabled"))
				return;
			loadStatusInternal({ profileNum: -1 });
		},
		function ()
		{
			if (!lastResponse || $scheduleLockBtn.hasClass("disabled"))
				return;
			if (parseInt(lastResponse.data.lock) !== 0)
				loadStatusInternal({ profileNum: -1 });
			else
				toaster.Info("Long press to disable automatic scheduling.");
		});
	this.diskUsageClick = function ()
	{
		if (lastResponse == null)
		{
			toaster.Error("Server status was not loaded!");
			return;
		}
		if (lastResponse.data && lastResponse.data.disks && lastResponse.data.disks.length > 0)
			diskUsageGUI.open(lastResponse.data.disks);
	};
	this.getLastResponse = function ()
	{
		return lastResponse;
	}
	this.getNotificationCounterValue = function (key)
	{
		if (lastResponse && lastResponse.data)
		{
			var value = lastResponse.data[key];
			if (value)
			{
				value = parseInt(value);
				if (value)
					return value;
			}
		}
		return 0;
	}
}
function ConvertVersionNumberToInsaneInt(version)
{
	var parts = version.split('.');
	if (parts.length !== 4)
		throw new Error('"' + version + '" is not a recognized version number format.');
	// Convert each part to a two-digit HEX and concatenate
	var hexString =
		('00' + parseInt(parts[0], 10).toString(16)).slice(-2) +
		('00' + parseInt(parts[1], 10).toString(16)).slice(-2) +
		('00' + parseInt(parts[2], 10).toString(16)).slice(-2) +
		('00' + parseInt(parts[3], 10).toString(16)).slice(-2);
	// Parse the HEX string as a 32-bit integer (big-endian order)
	var bigEndianInt32 =
		parseInt(hexString.slice(6, 8), 16) * Math.pow(256, 0) +
		parseInt(hexString.slice(4, 6), 16) * Math.pow(256, 1) +
		parseInt(hexString.slice(2, 4), 16) * Math.pow(256, 2) +
		parseInt(hexString.slice(0, 2), 16) * Math.pow(256, 3);
	return bigEndianInt32;
}
///////////////////////////////////////////////////////////////
// Disk Usage GUI /////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function DiskUsageGUI()
{
	var self = this;
	var exceededAllocationOccurred = false;
	var overAllocatedOccurred = false;
	var normalStateOccurred = false;
	var currentDialog = null;
	this.open = function (disks)
	{
		self.close();
		exceededAllocationOccurred = overAllocatedOccurred = normalStateOccurred = false;
		var $dud = $('<div id="diskUsageDialog"></div>');
		$dud.append('<div class="diskUsageSeparator"></div>');
		var $legend = $('<div class="pieLegend"></div>');
		$dud.append($legend);
		for (var i = 0; i < disks.length; i++)
		{
			var disk = disks[i];
			$dud.append(GetDisk(disk));
		}
		//var fakeDisk =
		//	{
		//		disk: "Y:",
		//		allocated: 102400,
		//		used: 122880,
		//		free: 30720,
		//		total: 163840
		//	};
		//$dud.append(GetDisk(fakeDisk));
		//var fakeDisk2 =
		//	{
		//		disk: "Z:",
		//		allocated: 140,
		//		used: 100,
		//		free: 25,
		//		total: 150
		//	};
		//$dud.append(GetDisk(fakeDisk2));
		$legend.append(CreateLegendItem('#333333', 'Other files'));
		if (normalStateOccurred || overAllocatedOccurred)
		{
			$legend.append(CreateLegendItem('#0065AA', 'Used by recordings'));
			$legend.append(CreateLegendItem('#0097F0', 'Allocated free space'));
		}
		if (exceededAllocationOccurred)
		{
			$legend.append(CreateLegendItem('#FF9900', 'Allocated space (exceeded)'));
			$legend.append(CreateLegendItem('#FF0000', 'Recordings exceeding allocation'));
		}
		if (overAllocatedOccurred)
		{
			$legend.append(CreateLegendItem('#FF00FF', 'Overallocated space'));
		}
		$legend.append(CreateLegendItem('#66DD66', 'Unallocated free space'));
		currentDialog = $dud.dialog({
			title: "Disk Usage",
			onClosing: function () { currentDialog = null; }
		});
	}
	this.close = function ()
	{
		if (currentDialog)
		{
			currentDialog.close();
			currentDialog = null;
		}
	}
	var CreateLegendItem = function (color, label)
	{
		return $('<div class="pieLegendItem"><div class="pieLegendBox" style="background-color:' + color + ';"></div>' + label + '</div>');
	}
	var GetDisk = function (disk)
	{
		// Make sure we have numeric values for all of these, no strings. Units are MiB.
		disk.allocated = parseInt(disk.allocated);
		disk.used = parseInt(disk.used);
		disk.free = parseInt(disk.free);
		disk.total = parseInt(disk.total);

		var bi_allocated = disk.allocated;
		var bi_used = disk.used;
		var disk_freeSpace = disk.free;
		var disk_capacity = disk.total;

		// Compensate for minor rounding errors.
		if (disk_capacity !== 0 && disk_capacity - disk.used - disk.free < -5)
			toaster.Warning("Reported disk info is invalid.  Possibly Blue Iris's clip database is corrupt and needs repaired.", 30000);
		if (disk_capacity - disk.used - disk.free < 0)
			disk_capacity = disk.used + disk.free;

		// Extrapolate complete disk usage information from the 4 values provided
		var bi_free = bi_allocated - bi_used; // Remaining space in allocation.  This may be negative, or may be larger than actual free space.
		var disk_usedSpace = disk_capacity - disk_freeSpace; // Overall disk used space
		var other_used = disk_usedSpace - bi_used; // Space used by other files
		var other_free = disk_freeSpace - bi_free; // Free space outside BI's allocation
		var exceededAllocation = bi_free < 0; // We have more recordings than we're supposed to
		var overAllocated = bi_free > disk_freeSpace;  // There isn't enough free space for BI to fill its allocation.
		var freeSpaceNotMonitored = disk.total === 0;

		var diskStatus;
		var problemExplanation = "";
		var chartData;
		if (freeSpaceNotMonitored)
		{
			if (exceededAllocation)
			{
				exceededAllocationOccurred = true;
				diskStatus = '<span class="diskStatusOverallocated">Exceeded allocation</span>';
				problemExplanation = "Blue Iris is currently keeping more recordings than allowed.";
				chartData =
					[
						[bi_allocated, '#FF9900']
						, [-bi_free, '#FF0000'] // Amount over allocation
					];
			}
			else
			{
				normalStateOccurred = true;
				diskStatus = '<span class="diskStatusNormal">Normal</span>';
				problemExplanation = "Free space is not being monitored.";
				chartData =
					[
						[bi_used, '#0065AA']
						, [bi_free, '#0097F0']
					];
			}
		}
		else if (exceededAllocation)
		{
			exceededAllocationOccurred = true;
			diskStatus = '<span class="diskStatusOverallocated">Exceeded allocation</span>';
			problemExplanation = "Blue Iris is currently keeping more recordings than allowed.";
			chartData =
				[
					[other_used, '#333333']
					, [bi_allocated, '#FF9900']
					, [-bi_free, '#FF0000'] // Amount over allocation
					, [other_free, '#66DD66']
				];
		}
		else if (overAllocated)
		{
			overAllocatedOccurred = true;
			diskStatus = '<span class="diskStatusOverallocated">Overallocated</span>';
			problemExplanation = "There is not enough free space on the disk for Blue Iris to fill its allocation.";
			var unavailableAllocatedSpace = bi_free - disk_freeSpace;
			chartData =
				[
					[other_used, '#333333']
					, [bi_used, '#0065AA']
					, [disk_freeSpace, '#0097F0'] // Unused available allocation
					, [bi_free - disk_freeSpace, '#FF00FF'] // Unused unavailable allocation
				];
		}
		else
		{
			normalStateOccurred = true;
			diskStatus = '<span class="diskStatusNormal">Normal</span>';
			chartData =
				[
					[other_used, '#333333']
					, [bi_used, '#0065AA']
					, [bi_free, '#0097F0']
					, [other_free, '#66DD66']
				];
		}

		var $disk = $('<div class="diskUsageDisk"></div>');
		$disk.append('<div class="diskName">' + disk.disk + ' ' + diskStatus + '</div>');
		$disk.append(GetPieChart(chartData));
		if (problemExplanation != "")
		{
			$disk.append('<div class="diskInfo">' + problemExplanation + '</div>');
			$disk.append('<div class="diskUsageSeparator"></div>');
		}

		var allocatedSpaceUsage = (bi_allocated == 0 ? 0 : parseInt((bi_used / bi_allocated) * 100)) + "%";
		var allocatedSpaceUsagePercentStr = (exceededAllocation ? '<span class="diskStatusOverallocated">' + allocatedSpaceUsage + '</span>' : allocatedSpaceUsage);

		$disk.append('<div class="diskInfo">Allocated: ' + formatBytes(getBytesFrom_MiB(bi_allocated)) + '</div>');
		$disk.append('<div class="diskInfo">Used: ' + formatBytes(getBytesFrom_MiB(bi_used)) + ' (' + allocatedSpaceUsagePercentStr + ')</div>');
		if (overAllocated)
			$disk.append('<div class="diskInfo">Overallocated by: ' + formatBytes(getBytesFrom_MiB(bi_free - disk_freeSpace)) + '</div>');

		if (!freeSpaceNotMonitored)
			$disk.attr('title', 'Disk "' + disk.disk + '" is ' + parseInt(disk_usedSpace / disk_capacity * 100) + '% full.'
				+ '\n\n' + formatBytes(getBytesFrom_MiB(disk_freeSpace)) + ' free of ' + formatBytes(getBytesFrom_MiB(disk_capacity)));

		return $disk;
	}
	var GetPieChart = function (data, sizePx)
	{
		if (sizePx)
			sizePx = parseInt(sizePx);
		else
			sizePx = 200;

		var $canvas = $('<canvas width="' + sizePx + '" height="' + sizePx + '" />');
		var canvas = $canvas.get(0);
		var ctx = canvas.getContext("2d");
		var lastend = 0;

		var myTotal = 0;
		for (var i = 0; i < data.length; i++)
			myTotal += data[i][0];

		for (var i = 0; i < data.length; i++)
		{
			ctx.fillStyle = data[i][1];
			ctx.beginPath();
			ctx.moveTo(canvas.width / 2, canvas.height / 2);
			ctx.arc(canvas.width / 2, canvas.height / 2, canvas.height / 2, lastend, lastend + (Math.PI * 2 * (data[i][0] / myTotal)), false);
			ctx.lineTo(canvas.width / 2, canvas.height / 2);
			ctx.fill();
			lastend += Math.PI * 2 * (data[i][0] / myTotal);
		}
		return $canvas;
	}
}
///////////////////////////////////////////////////////////////
// Session Manager ////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function SessionManager()
{
	var self = this;
	var isAdministratorSession = false;
	var lastResponse = null;
	var remoteServerSession = null;
	var permission_changeprofile = false;
	var permission_ptz = true;
	var permission_ptzpresetset = false;
	var permission_audio = true;
	var permission_clips = true;
	var permission_clipcreate = false;
	var permission_installupdate = false;
	var biSoundOptions = ["None"];
	var biStreamingProfiles = [];
	var sessionExpiredToast = null;
	var isRecoveringFromInvalidSession = false;
	this.supportedHTML5AudioFormats = [".mp3", ".wav"]; // File extensions, in order of preference
	this.sysName = $("#systemname").text();
	this.Initialize = function ()
	{
		// Called once during page initialization
		if (currentServer.isUsingRemoteServer)
		{
			LogInWithCredentials(currentServer.remoteServerUser, currentServer.remoteServerPass, function (failResponse, errorMessage)
			{
				// The login failed
				loadingHelper.SetErrorStatus("login", 'UI3 was unable to log in to the remote server. ' + errorMessage, false);
			}, true);
		}
		else
		{
			// First, check the current session status
			var oldSession = self.GetAPISession();
			if (!oldSession)
			{
				loadingHelper.SetErrorStatus("login", "Blue Iris did not provide the expected session data. This version of UI3 requires Blue Iris 4.8.2.3 or newer.", false);
				return;
			}
			ExecJSON({ cmd: "login", session: oldSession }, function (response)
			{
				lastResponse = response;
				if (response.result)
				{
					if (response.result == "success")
					{
						if (settings.bi_rememberMe == "1")
						{
							var user = Base64.decode(settings.bi_username);
							if (user != "")
							{
								var sessionUser = response && response.data && response.data.user ? response.data.user : "";
								if (user.toLowerCase() != sessionUser.toLowerCase())
								{
									var pass = Base64.decode(settings.bi_password);
									LogInWithCredentials(user, pass, function (failResponse, errorMessage)
									{
										// The login failed
										toaster.Error(errorMessage, 3000);
										self.HandleSuccessfulLogin(response, true); // Session is valid
									}, true);
									return;
								}
							}
						}
						self.HandleSuccessfulLogin(response, true);
					}
					else if (response.result == "fail")
					{
						if (response.data && response.data.reason)
						{
							if (response.data.reason == "missing response")
							{
								// The { cmd: "login", session: oldSession } method of learning session status always seemed a little hacky.  If this error ever arises, it means Blue Iris has broken this method and we need a replacement.
								loadingHelper.SetErrorStatus("login", 'Blue Iris sent an authentication challenge instead of session data (probably indicates a Blue Iris bug).', false);
							}
							else if (self.IsInvalidSession(response))
							{
								loadingHelper.SetErrorStatus("login", 'Blue Iris says your session is invalid.', true);
							}
							else 
							{
								loadingHelper.SetErrorStatus("login", 'Session status check failed: ' + htmlEncode(response.data.reason), true);
							}
						}
						else
						{
							loadingHelper.SetErrorStatus("login", 'Session status check failed without giving a reason. ' + htmlEncode(JSON.stringify(response)), true);
						}
					}
					else
					{
						loadingHelper.SetErrorStatus("login", 'Unrecognized response when getting session status. ' + htmlEncode(JSON.stringify(response)), true);
					}
				}
			}, function (jqXHR, textStatus, errorThrown)
			{
				loadingHelper.SetErrorStatus("login", 'Error contacting Blue Iris server to check session status.<br/>' + jqXHR.ErrorMessageHtml, true);
			});
		}
	}
	var LogInWithCredentials = function (user, pass, onFail, isAutomatic)
	{
		var oldSession = self.GetAPISession();
		var args = { cmd: "login" };
		ExecJSON(args, function (response)
		{
			// We expect a result of "fail" and data.reason of "missing response"
			if (response && response.result == "fail" && response.data && response.data.reason == "missing response")
			{
				// We need to log in
				args.session = response.session;
				args.response = md5(user + ":" + response.session + ":" + pass);
				ExecJSON(args, function (response)
				{
					lastResponse = response;
					if (response.result && response.result == "success")
					{
						self.HandleSuccessfulLogin(response, isAutomatic);
						setTimeout(function () { logoutOldSession(oldSession); }, 1000);
					}
					else
					{
						settings.bi_username = "";
						settings.bi_password = "";
						onFail(response, 'Failed to log in. ' + GetFailReason(response));
					}
				}, function (jqXHR, textStatus, errorThrown)
				{
					onFail(null, 'Error contacting Blue Iris server during login phase 2.<br/>' + jqXHR.ErrorMessageHtml);
				});
			}
			else
				onFail(response, 'Blue Iris sent session data instead of an authentication challenge (probably indicates a Blue Iris bug): ' + JSON.stringify(args) + " -> " + JSON.stringify(response));
		}, function (jqXHR, textStatus, errorThrown)
		{
			onFail(null, 'Error contacting Blue Iris server during login phase 1.<br/>' + jqXHR.ErrorMessageHtml);
		});
	}
	var GetFailReason = function (response)
	{
		if (response)
			return response.data && response.data.reason ? " " + response.data.reason : JSON.stringify(response);
		else
			return "null response";
	}
	this.HandleSuccessfulLogin = function (response, wasAutomatic)
	{
		lastResponse = response;
		var user = response && response.data && response.data.user ? response.data.user : "";
		loadingHelper.SetLoadedStatus("login");
		self.SetAPISession(lastResponse.session);

		this.sysName = lastResponse.data["system name"];
		var appName = SysNameToAppName(this.sysName);
		setSystemNameButtonTextState();
		document.title = appName;
		if (lastResponse.data && lastResponse.data.profiles && lastResponse.data.profiles.length > 0)
			statusLoader.SetCurrentProfileNames(lastResponse.data.profiles);
		if (lastResponse && lastResponse.data && lastResponse.data.schedules)
			dropdownBoxes.listDefs["schedule"].rebuildItems();

		if (typeof lastResponse.data.tzone != "undefined")
			serverTimeZoneOffsetMs = parseInt(parseFloat(lastResponse.data.tzone) * -60000);

		isAdministratorSession = !!lastResponse.data.admin;

		permission_changeprofile = getBoolMaybe(lastResponse.data.changeprofile, isAdministratorSession);
		permission_ptz = getBoolMaybe(lastResponse.data.ptz, true);
		permission_ptzpresetset = isAdministratorSession;
		permission_audio = getBoolMaybe(lastResponse.data.audio, true);
		permission_clips = getBoolMaybe(lastResponse.data.clips, true);
		permission_clipcreate = getBoolMaybe(lastResponse.data.clipcreate, isAdministratorSession);
		permission_installupdate = isAdministratorSession;

		HandleUpdatedPermissions();

		statusLoader.LoadStatus();
		cameraListLoader.LoadCameraList();
		if (isRecoveringFromInvalidSession)
			clipLoader.LoadClips();

		if (isAdministratorSession)
		{
			if (user == "")
				user = "administrator";
			if (typeof adminLoginCallbackSuccess == "function")
			{
				adminLoginCallbackSuccess(lastResponse);
				adminLoginCallbackSuccess = null;
			}
			closeLoginDialog();
		}
		else
		{
			if (user == "")
				user = "user";
		}
		if (!wasAutomatic || settings.ui3_show_session_success == "1")
		{
			var message = 'Logged in as ' + htmlEncode(user) + '<br/>(' + (isAdministratorSession ? "Administrator" : "Limited User") + ')<br/><br/>Server "' + lastResponse.data["system name"] + '"<br/>UI3 version: ' + ui_version + '<br>Blue Iris version: ' + lastResponse.data.version;
			if (isAdministratorSession)
				toaster.Success(message);
			else
				toaster.Info(message);
		}
		if (lastResponse.data.version)
			$("#bi_version_label").text(lastResponse.data.version);

		ProcessSoundsArray();
		ProcessStreamsArray();
		SyncStreamingQualityWarningIcon(true);
		self.ProcessVersionAvailability();

		BI_CustomEvent.Invoke("Login Success", response);

		isRecoveringFromInvalidSession = false;
	}
	var ProcessSoundsArray = function ()
	{
		biSoundOptions = ["None"];
		// Find the best format of each sound.
		var formats = new FasterObjectMap(); // This object maps file names without extensions to the best format available.
		if (lastResponse && lastResponse.data)
		{
			var soundsArr = lastResponse.data.www_sounds;
			if (!soundsArr)
				soundsArr = lastResponse.data["www-sounds"];
			if (!soundsArr)
				soundsArr = lastResponse.data.sounds;
			if (soundsArr)
			{
				for (var i = 0; i < soundsArr.length; i++)
				{
					var file = soundsArr[i];
					// Determine the format of this file.
					for (var f = 0; f < self.supportedHTML5AudioFormats.length; f++)
					{
						var ext = self.supportedHTML5AudioFormats[f];
						if (file.endsWithCaseInsensitive(ext))
						{
							// This file is one of our supported formats.
							var nameNoExt = file.substr(0, file.length - ext.length)

							var previousFormat = formats[nameNoExt];
							if (previousFormat && previousFormat.priority < i)
								continue; // Already found a better format.

							// The format is an improvement over the last one we found (or this is the first we found).
							formats[nameNoExt] = {
								ext: ext
								, priority: i
								, fullName: file
							};
							break;
						}
					}
				}
				var choices = new Array(); // This array is used for ordering
				for (var nameNoExt in formats)
					choices.push(formats[nameNoExt].fullName);
				choices.sort();

				for (var i = 0; i < choices.length; i++)
					biSoundOptions.push(choices[i]);
			}
		}
	}
	var getBoolMaybe = function (boolMaybe, defaultValue)
	{
		if (typeof boolMaybe === "undefined")
			return defaultValue;
		return boolMaybe ? true : false;
	}
	var HandleUpdatedPermissions = function ()
	{
		if (permission_ptz)
			$("#ptzControlsBox").show();
		else
			$("#ptzControlsBox").hide();

		if (permission_audio)
			$("#volumeBar").removeClass("audioNoPermission");
		else
			$("#volumeBar").addClass("audioNoPermission");

		if (permission_clips)
		{
			$("#topbar_tab_clips,#topbar_tab_timeline").show();
		}
		else
		{
			$("#topbar_tab_clips,#topbar_tab_timeline").hide();
			if (currentPrimaryTab != "live")
			{
				console.log("Session does not have permission to use " + currentPrimaryTab + ". Switching to live tab.");
				$("#topbar_tab_live").click();
			}
		}

		if (permission_changeprofile)
			$("#profileStatusBox,#globalScheduleBox").show();
		else
			$("#profileStatusBox,#globalScheduleBox").hide();

		OnChange_ui3_topbar_allclips_shortcut_show();
		OnChange_ui3_topbar_alerts_shortcut_show();
		OnChange_ui3_topbar_alerts_confirmed_shortcut_show();
		OnChange_ui3_topbar_alerts_canceled_shortcut_show();
	}
	/**
	 * Gets the session ID that is currently used for API and video access.
	 * @returns {String} Session ID currently used for api and video access.
	 */
	this.GetAPISession = function ()
	{
		return currentServer.isUsingRemoteServer ? remoteServerSession : local_bi_session;
	}
	/**
	 * Sets the session ID that is currently used for API and video access.
	 * @param {String} session Session ID currently used for api and video access.
	 */
	this.SetAPISession = function (session)
	{
		var oldSession = self.GetAPISession();
		if (oldSession !== session)
		{
			console.log("SessionManager changing API session from " + self.GetAPISession() + " to " + session);
			if (currentServer.isUsingRemoteServer)
				remoteServerSession = session;
			else
			{
				local_bi_session = session;
				if (cookies_accessible)
					$.cookie("session", session, { path: "/" });
				else
				{
					if (navigator.cookieEnabled)
					{
						// Cookies are enabled, but not accessible by script (HttpOnly flag is probably present).
						// The only way we can update our session cookie is to reload the page and add the new session string as an argument.
						// Doing this lets us continue suppressing the session argument on a lot of requests, which is good for caching.
						var url = RemoveUrlParams("session");
						if (location.hash)
							url = url.substr(0, url.length - location.hash.length);
						url += currentServer.GetLocalSessionArg(url.indexOf("?") === -1 ? "?" : "&", true) + location.hash;
						location.href = url;
					}
				}
			}
		}
	}
	/**
	 * Gets the session ID that is used for static resource requests. It may be different from the one used for API requests, if we are using UI3 as a client app for a different server.
	 * @returns {String} Session ID used for static resource requests.
	 */
	this.GetLocalSession = function ()
	{
		// Right now we're trusting that BI doesn't spontaneously change the session
		//if (cookies_accessible)
		//{
		//	var cookieSession = $.cookie("session");
		//	if (cookieSession)
		//		return cookieSession;
		//}
		return local_bi_session;
	}

	this.AdminLoginRememberMeChanged = function ()
	{
		if ($("#cbRememberMe").is(":checked"))
		{
			settings.bi_rememberMe = "1";
			settings.bi_username = Base64.encode($('#loginDialog input[type="text"][varname="user"]').val());
			settings.bi_password = Base64.encode($('#loginDialog input[type="password"][varname="pass"]').val());
		}
		else
		{
			settings.bi_rememberMe = "0";
			settings.bi_username = "";
			settings.bi_password = "";
		}
	}
	this.DoAdministratorDialogLogin = function ()
	{
		self.AdminLoginRememberMeChanged();
		LogInWithCredentials($('#loginDialog input[type="text"][varname="user"]').val(), $('#loginDialog input[type="password"][varname="pass"]').val(),
			function (response, errorMessage)
			{
				// The login failed
				toaster.Error(errorMessage, 3000);
			});
	}
	this.IsInvalidSession = function (response)
	{
		if (compareVersions(bi_version, "5.8.1.1") >= 0)
		{
			return response
				&& response.result === "fail"
				&& response.data
				&& typeof response.data.reason === "string"
				&& response.data.reason.toUpperCase() === "INVALID SESSION";
		}
		else
		{
			// BI prior to 5.8.1.1 did not return a data.reason string in the case of invalid session.
			return response
				&& response.result === "fail";
		}
	}
	this.ReestablishLostSession = function ()
	{
		if (sessionExpiredToast)
			return;
		isRecoveringFromInvalidSession = true;
		sessionExpiredToast = toaster.Warning("Your Blue Iris session has expired. Attempting recovery...", 99999999);

		var args = { cmd: "login" };
		ExecJSON(args, function (response)
		{
			// We expect a result of "fail" and data.reason of "missing response"
			if (response && response.result == "fail" && response.data && response.data.reason == "missing response")
			{
				// We need to log in
				args.session = response.session;
				if (settings.bi_username && settings.bi_password)
					args.response = md5(Base64.decode(settings.bi_username) + ":" + response.session + ":" + Base64.decode(settings.bi_password));
				else if (response.data["auth-exempt"])
					args.response = md5("Anonymous:" + response.session + ":");
				else
				{
					self.ReloadAfterWarning();
					return;
				}
				ExecJSON(args, function (response)
				{
					lastResponse = response;
					if (response.result && response.result == "success")
					{
						self.HandleSuccessfulLogin(response, true);
						sessionExpiredToast.remove();
						sessionExpiredToast = null;
						videoPlayer.ReopenStreamAtCurrentSeekPosition();
					}
					else
					{
						settings.bi_username = "";
						settings.bi_password = "";
						toaster.Error('Failed to log in. ' + GetFailReason(response));
						self.ReloadAfterWarning();
					}
				}, function (jqXHR, textStatus, errorThrown)
				{
					toaster.Error('Error contacting Blue Iris server during login phase 2.<br/>' + jqXHR.ErrorMessageHtml);
					self.ReloadAfterWarning();
				});
			}
			else
			{
				toaster.Error('Blue Iris sent session data instead of an authentication challenge (probably indicates a Blue Iris bug): ' + JSON.stringify(args) + " -> " + JSON.stringify(response));
				self.ReloadAfterWarning();
			}
		}, function (jqXHR, textStatus, errorThrown)
		{
			toaster.Error('Error contacting Blue Iris server during login phase 1.<br/>' + jqXHR.ErrorMessageHtml);
			self.ReloadAfterWarning();
		});
	}
	this.ReloadAfterWarning = function ()
	{
		toaster.Info("Reloading UI3", 3000);
		setTimeout(ReloadInterface, 3000);
		programmaticSoundPlayer.NotifyReloadingUI();
	}
	this.PwKeypress = function (ele, e)
	{
		var keycode;
		if (window.event) keycode = window.event.keyCode;
		else if (typeof e != "undefined" && e) keycode = e.which;
		else return true;

		if (keycode == 13)
		{
			self.DoAdministratorDialogLogin();
			return false;
		}
		else
			return true;
	}
	this.IsAdministratorSession = function (objectId)
	{
		if (objectId)
		{
			var cam;
			if (objectId.startsWith('@'))
				objectId = objectId.substr(1);
			var clipData = clipLoader.GetClipFromId(objectId);
			if (clipData)
				cam = cameraListLoader.GetCameraWithId(clipData.camera);
			else
				cam = cameraListLoader.GetCameraWithId(objectId);
			if (cam && cam.admin)
				return true;
		}
		return isAdministratorSession;
	}
	this.GetSchedulesArray = function ()
	{
		if (lastResponse && lastResponse.data)
			return lastResponse.data.schedules;
		return null;
	}
	var ProcessStreamsArray = function ()
	{
		if (lastResponse && lastResponse.data && lastResponse.data.streams && lastResponse.data.streams.length)
		{
			if (typeof lastResponse.data.streams[0] !== "string")
				toaster.Warning("Blue Iris session data included the array of streams metadata in an unknown format.");
			else
			{
				var streams = [];
				for (var i = 0; i < lastResponse.data.streams.length; i++)
					streams.push(MakeStreamObject(lastResponse.data.streams[i]));
				biStreamingProfiles = streams;
				return;
			}
		}
		else
			toaster.Warning("Blue Iris session data did not include the array of streams metadata.");
		biStreamingProfiles = [MakeStreamObject(), MakeStreamObject(), MakeStreamObject()];
	}
	var MakeStreamObject = function (str)
	{
		if (!str)
			str = "";
		var o = { str: str };
		if (str)
		{
			if (str.startsWithCaseInsensitive("VBR"))
				o.control = "VBR";
			else if (str.startsWithCaseInsensitive("CBR"))
				o.control = "CBR";

			var m = str.match(/q=(\d+)%/i);
			if (m)
				o.q = parseInt(m[1]);

			m = str.match(/(\d+)kbps/i);
			if (m)
				o.kbps = parseInt(m[1]);

			m = str.match(/gop=(\d+)/);
			if (m)
				o.gop = parseInt(m[1]);

			m = str.match(/ (\d+)p/);
			if (m)
				o.res = parseInt(m[1]);

			if (compareVersions(bi_version, "5.7.5.3") >= 0)
				o.overrides = str.indexOf("*") > -1;
			else
				o.overrides = true;
		}
		return o;
	}
	this.GetStreamsArray = function ()
	{
		return biStreamingProfiles;
	}
	this.GetServersideStream = function (stream_index)
	{
		if (stream_index >= 0 && stream_index < biStreamingProfiles.length)
			return biStreamingProfiles[stream_index];
	}
	this.CanProfileUseOverrides = function (i)
	{
		if (typeof i === "undefined" || i === null)
		{
			i = genericQualityHelper.GetCurrentProfileIndex();
			if (i < 0)
			{
				genericQualityHelper.QualityChoiceChanged('');
				i = genericQualityHelper.GetCurrentProfileIndex();
			}
		}
		var p = genericQualityHelper.GetProfileWithIndex(i);
		if (p.vcodec === "jpeg")
			return true;
		return self.DoesStreamAllowOverrides(p.stream);
	}
	this.DoesStreamAllowOverrides = function (stream_index)
	{
		if (typeof stream_index === "undefined" || stream_index === null)
			stream_index = genericQualityHelper.GetCurrentProfile().stream;
		var stream = sessionManager.GetServersideStream(stream_index);
		if (stream)
			return stream.overrides;
		return true;
	}
	this.ProcessVersionAvailability = function ()
	{
		if (self.UpdateAvailable() && settings.ui3_show_update_available_notice === "1")
		{
			$("#btn_main_menu .updateAvailable").show();
		}
		else
		{
			$("#btn_main_menu .updateAvailable").hide();
		}
	}
	this.UpdateAvailable = function ()
	{
		return !!(lastResponse && lastResponse.data && lastResponse.data.newversion && lastResponse.data.version
			&& lastResponse.data.version !== lastResponse.data.newversion
			&& permission_installupdate);
	}
	this.HasPermission_ChangeProfile = function ()
	{
		return permission_changeprofile;
	}
	this.HasPermission_Ptz = function ()
	{
		return permission_ptz;
	}
	this.HasPermission_PtzPresetSet = function ()
	{
		return permission_ptzpresetset || cameraListLoader.hasCameraAdminPrivilege();
	}
	this.HasPermission_Audio = function ()
	{
		return permission_audio;
	}
	this.HasPermission_Clips = function ()
	{
		return permission_clips;
	}
	this.HasPermission_ClipCreate = function ()
	{
		return permission_clipcreate;
	}
	this.HasPermission_InstallUpdate = function ()
	{
		return permission_installupdate;
	}
	this.HasPermission_DownloadClip = function (clipData)
	{
		if (!permission_clips)
			return false;
		if (clipData.fileExtType === "BVR")
			return self.IsAdministratorSession();
		return true;
	}
	this.GetBISoundOptions = function ()
	{
		return biSoundOptions;
	}
	this.GetLastResponse = function ()
	{
		return lastResponse;
	}
}
function getBISoundOptions()
{
	return sessionManager.GetBISoundOptions();
}
///////////////////////////////////////////////////////////////
// Camera List ////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function CameraListLoader()
{
	var self = this;
	var lastResponse = null;
	var lastLoadAt = -999999;
	var cameraIdToCameraMap = new Object();
	var singleCameraGroupNameMap = {};
	var firstCameraListLoaded = false;
	var cameraListUpdateTimeout = null;
	var webcastingWarning;
	this.clearNewAlertsCounterOnNextLoad = false;

	var CallScheduler = function (successCallbackFunc)
	{
		clearTimeout(cameraListUpdateTimeout);
		cameraListUpdateTimeout = setTimeout(function ()
		{
			var shouldDelay = true;
			var timeSinceLastLoad = performance.now() - lastLoadAt;
			if (timeSinceLastLoad > 4500)
				shouldDelay = false;
			else if (AnyTimeSensitiveCameraStatusEffectsEnabled() || videoPlayer.PrioritizeTriggeredEnabled() || $("#campropdialog").length)
				shouldDelay = false;
			if (shouldDelay)
				CallScheduler(successCallbackFunc);
			else
				self.LoadCameraList(successCallbackFunc);
		}, 1000);
	};

	this.LoadCameraList = function (successCallbackFunc)
	{
		if (documentIsHidden() && lastResponse !== null && typeof successCallbackFunc !== "function")
		{
			CallScheduler(successCallbackFunc);
			return;
		}
		clearTimeout(cameraListUpdateTimeout);
		var args = { cmd: "camlist" };
		if (self.clearNewAlertsCounterOnNextLoad)
		{
			self.clearNewAlertsCounterOnNextLoad = false;
			args.reset = 2;
		}
		ExecJSON(args, function (response)
		{
			lastLoadAt = performance.now();
			EndConnectionErrors();
			if (sessionManager.IsInvalidSession(response))
			{
				sessionManager.ReestablishLostSession();
				return;
			}
			if (typeof (response.data) == "undefined" || response.data.length == 0)
			{
				if (firstCameraListLoaded)
				{
					toaster.Error("Camera list is empty!");
					CallScheduler(successCallbackFunc);
				}
				else
				{
					lastResponse = response;
					loadingHelper.SetErrorStatus("cameraList", "Camera list is empty! Try reloading the page.", true);
				}
				return;
			}
			var previousResponse = lastResponse;
			lastResponse = response;
			var numGroups = 0;
			var numCameras = 0;
			var camIdsInGroups = {};
			//var allCameras = {};
			singleCameraGroupNameMap = {};
			// See what we've got
			for (var i = 0; i < lastResponse.data.length; i++)
			{
				var o = lastResponse.data[i];
				if (typeof o.webcast === "undefined")
					o.webcast = true;
				if (typeof o.ptzdirect === "undefined" && o.ptz)
					o.ptzdirect = true;
				//allCameras[o.optionValue.toLowerCase()] = o;
			}
			for (var i = 0; i < lastResponse.data.length; i++)
			{
				var obj = lastResponse.data[i];
				if (obj.group)
				{
					if (obj.group.length >= 1)
					{
						if (obj.group.length === 1 && !obj.isFakeGroup && settings.ui3_bypass_single_camera_groups === "1")
						{
							// Blue Iris recently started including single-camera group metadata, causing a number of undesired effects.
							// My current best fix is to maintain this map of group name to camera short name for every group that has just a single camera.
							// When the LoadLiveCamera method is instructed to load a group in this map, the single camera is loaded instead.
							// So the dropdown box behaves a little inconsistently, but the group still exists in UI3.
							singleCameraGroupNameMap[obj.optionValue.toLowerCase()] = obj.group[0];
						}
						else
						{
							numGroups++;
							for (var n = 0; n < obj.group.length; n++)
								camIdsInGroups[obj.group[n]] = true;
						}
					}
					else if (obj.group.length === 0)
					{
						if (!firstCameraListLoaded)
							console.log("Found empty camera group: " + obj.optionDisplay + " (" + obj.optionValue + ")");
						delete obj.group;
						delete obj.rects;
						obj.optionDisplay = CleanUpGroupName(obj.optionDisplay)
						numCameras++;
					}
				}
				else
					numCameras++;
			}
			// Is this a single-camera system without a visible camera group?
			if (numGroups === 0 && numCameras > 0)
			{
				var camsNotInGroup = [];
				for (var i = 0; i < lastResponse.data.length; i++)
				{
					var obj = lastResponse.data[i];
					if (!self.CameraIsGroupOrCycle(obj) && obj.isEnabled && obj.webcast)
					{
						if (!camIdsInGroups[obj.optionValue])
							camsNotInGroup.push(obj);
					}
				}
				if (camsNotInGroup.length > 0)
				{
					// Create a fake group for each of these cameras.
					var anyFakeGroupsNotHidden = false;
					for (var i = 0; i < camsNotInGroup.length; i++)
					{
						var fakeGroup = MakeFakeGroup(camsNotInGroup[i]);
						InsertFakeGroup(lastResponse.data, fakeGroup);
						if (!camsNotInGroup[i].hidden)
							anyFakeGroupsNotHidden = true;
					}

					//if (!firstCameraListLoaded && numCameras > 1 && anyFakeGroupsNotHidden && settings.ui3_webcasting_disabled_dontShowAgain != "1")
					//{
					//	webcastingWarning = toaster.Info(camsNotInGroup.length + ' camera' + (camsNotInGroup.length == 1 ? ' has' : 's have')
					//		+ ' been individually added to the Current Group dropdown list because ' + (camsNotInGroup.length == 1 ? 'it was' : 'they were')
					//		+ ' not visible in any group streams.<br><br>'
					//		+ '<input type="button" class="simpleTextButton btnGreen" value="Learn more" onclick="UIHelp.LearnMore(\'Camera Group Webcasting\')" /><br><br>'
					//		+ '<input type="button" class="simpleTextButton btnRed" value="Do not warn again" onclick="DontShowWebcastingWarningAgain()" />'
					//		, 60000, true);
					//}
				}
			}

			dropdownBoxes.listDefs["currentGroup"].rebuildItems(lastResponse.data);
			cameraIdToCameraMap = new Object();
			for (var i = 0; i < lastResponse.data.length; i++)
				cameraIdToCameraMap[lastResponse.data[i].optionValue.toLowerCase()] = lastResponse.data[i];
			if (!firstCameraListLoaded
				|| (self.GetCameraWithId(videoPlayer.Loading().image.id) == null
					&& videoPlayer.Loading().image
					&& (videoPlayer.Loading().image.isLive
						|| videoPlayer.Loading().image.isTimeline()))) // isLive/isTimeline check allows clips to continue playing if their camera instance is missing
			{
				if (self.GetGroupCamera(settings.ui3_defaultCameraGroupId))
					videoPlayer.SetCurrentlySelectedHomeGroupId(settings.ui3_defaultCameraGroupId);
				else if (self.CameraIsGroup(lastResponse.data[0]))
					videoPlayer.SetCurrentlySelectedHomeGroupId(lastResponse.data[0].optionValue);

				var didLoadStream = false;
				if (!firstCameraListLoaded)
				{
					var cam;
					if (mqttClient.preLoadVideoSpecified) // MQTT instruction takes precidence over URL parameter.
					{
						cam = self.GetCameraWithId(mqttClient.preLoadVideoSpecified);
						if (cam)
						{
							videoPlayer.LoadLiveCamera(cam);
							didLoadStream = iEquals(videoPlayer.Loading().image.id, cam.optionValue);
						}
					}
					if (!didLoadStream)
					{
						cam = UrlParameters.Get("cam", "c");
						if (cam)
						{
							cam = self.GetCameraWithId(cam);
							if (cam)
							{
								videoPlayer.LoadLiveCamera(cam);
								didLoadStream = iEquals(videoPlayer.Loading().image.id, cam.optionValue);
							}
						}
					}
				}
				if (!didLoadStream)
				{
					if (self.GetGroupCamera(settings.ui3_defaultCameraGroupId))
						videoPlayer.SelectCameraGroup(settings.ui3_defaultCameraGroupId);
					else if (self.CameraIsGroup(lastResponse.data[0]))
						videoPlayer.SelectCameraGroup(lastResponse.data[0].optionValue);
					else
						videoPlayer.LoadLiveCamera(lastResponse.data[0], clipTimeline ? clipTimeline.getTimelineArgsForCameraSwitch() : null);
				}
			}
			if (!firstCameraListLoaded)
			{
				loadingHelper.SetLoadedStatus("cameraList");
				firstCameraListLoaded = true;
			}
			try
			{
				if (successCallbackFunc)
					successCallbackFunc(lastResponse);
			}
			catch (ex)
			{
				toaster.Error(ex, 30000);
			}
			biSoundPlayer.PlayEventSounds(lastResponse, previousResponse);

			BI_CustomEvent.Invoke("CameraListLoaded", lastResponse);
			CallScheduler();
		}, function (jqXHR, textStatus, errorThrown)
		{
			CallScheduler(successCallbackFunc);
			if (!HandleGroupableConnectionError(jqXHR))
				toaster.Error("An error occurred loading the camera list.<br>" + jqXHR.ErrorMessageHtml);
		});
	}
	var MakeFakeGroup = function (cameraObj)
	{
		return $.extend({}, cameraObj, {
			optionDisplay: "+" + cameraObj.optionDisplay
			, xsize: 1
			, ysize: 1
			, group: []
			, rects: []
			, isFakeGroup: true
		});
	}
	var InsertFakeGroup = function (cams, fakeGroup)
	{
		var i;
		for (i = 0; i < cams.length; i++)
		{
			if (self.CameraIsGroup(cams[i]))
				continue;
			else
				break;
		}
		cams.splice(i, 0, fakeGroup);
	}
	this.GetGroupRects = function (groupId)
	{
		// Get from dynamic layout
		var imgLoaded = videoPlayer.Loaded().image;
		if (imgLoaded.id === groupId && imgLoaded.rects)
			return ScaledRectsWorkaround(imgLoaded);

		var imgLoading = videoPlayer.Loading().image;
		if (imgLoading.id === groupId && imgLoading.rects)
			return ScaledRectsWorkaround(imgLoading);

		// Get from default layout
		var cam = self.GetCameraWithId(groupId);
		if (cam)
			return cam.rects;
		return null;
	}
	function ScaledRectsWorkaround(image)
	{
		var condition;

		// Noted in BI 5.5.6.2:
		// H.264 group streams
		//  * Dynamic Layout: scaled reclist
		//  * Static Layout: scaled reclist
		// JPEG group streams
		//  * Dynamic Layout: scaled reclist
		//  * Static Layout: unscaled reclist (if the Aspect Ratio of the group is fixed in the local console)
		// To work around this inconsistency, this method will unscale the static layout reclist for static layout h264 group streams..

		//condition = image.rects && videoPlayer.CurrentPlayerModuleName() === "h264" && !cameraListLoader.isDynamicLayoutEnabled(image.id);

		// In 2025-01-21 (BI 5.9.9.22) it was noted that jpeg group streams configured serverside to allow dynamic layout have incorrect click handling in UI3 when dynamic layout is disabled in UI3.
		// Therefore I am changing the scaling condition.

		condition = image.rects && !cameraListLoader.isDynamicLayoutEnabled(image.id)
			&& (videoPlayer.CurrentPlayerModuleName() === "h264" ||
				!self.IsRectsOutOfBounds(image));

		//console.log(condition, JSON.stringify(image.rects));
		if (condition)
		{
			var nativeRes = image.getFullRect();
			var actualRes = image.getActualRect();
			var scaleX = nativeRes.w / actualRes.w;
			var scaleY = nativeRes.h / actualRes.h;
			var scale = (scaleX + scaleY) / 2;
			if (scale !== 1)
			{
				var rects = new Array(image.rects.length);
				for (var i = 0; i < rects.length; i++)
				{
					var r = image.rects[i];
					rects[i] = [r[0] * scale, r[1] * scale, r[2] * scale, r[3] * scale];
				}
				return rects;
			}
		}
		return image.rects;
	}
	/**
	 * Returns true if the given image's rects array contains coordinates outside the image's actual dimensions. 
	 * @param {BICameraData} image BICameraData instance
	 */
	this.IsRectsOutOfBounds = function (image)
	{
		if (image.rects)
		{
			var actualRes = image.getActualRect();
			var roundingError = 2;
			actualRes.w += roundingError;
			actualRes.h += roundingError;
			for (var i = 0; i < image.rects.length; i++)
			{
				var r = image.rects[i];
				if (r[0] > actualRes.w || r[1] > actualRes.h || r[2] > actualRes.w || r[3] > actualRes.h)
					return true;
			}
		}
		return false;
	}
	this.GetGroupCams = function (groupId)
	{
		// Get from dynamic layout
		var imgLoaded = videoPlayer.Loaded().image;
		if (imgLoaded.id === groupId && imgLoaded.cams)
			return imgLoaded.cams;

		var imgLoading = videoPlayer.Loading().image;
		if (imgLoading.id === groupId && imgLoading.cams)
			return imgLoading.cams;

		// Get from default layout
		var cam = self.GetCameraWithId(groupId);
		if (cam)
			return cam.group;
		return null;
	}
	this.isDynamicLayoutEligible = function (groupId)
	{
		var cam = self.GetCameraWithId(groupId);
		if (cam && !self.IsFakeGroup(groupId))
		{
			if (self.CameraIsGroup(cam))
				return !!cam.dynamic;
			else if (self.CameraIsCycle(cam) && iEquals(groupId, "@index"))
			{
				cam = self.GetCameraWithId(groupId.substr(1));
				if (cam && !self.IsFakeGroup(groupId))
					return !!cam.dynamic;
			}
		}
		return false;
	}
	this.isDynamicLayoutEnabled = function (groupId)
	{
		var cam = self.GetCameraWithId(groupId);
		return cam && self.isDynamicLayoutEligible(groupId) && settings.ui3_dynamicGroupLayout === "1";
	}
	this.HideWebcastingWarning = function ()
	{
		if (webcastingWarning)
			webcastingWarning.remove();
	}
	this.GetCameraBoundsInCurrentGroupImageScaled = function (cameraId, groupId)
	{
		var coordScale = self.isDynamicLayoutEnabled(groupId) ? 1 : (videoPlayer.Loaded().image.actualwidth / videoPlayer.Loaded().image.fullwidth);
		var unscaled = self.GetCameraBoundsInCurrentGroupImageUnscaled(cameraId, groupId);
		if (unscaled == null)
			return null;
		// The first line of the array definition must be on the same line as the return statement
		return [Math.round(unscaled[0] * coordScale)
			, Math.round(unscaled[1] * coordScale)
			, Math.round(unscaled[2] * coordScale)
			, Math.round(unscaled[3] * coordScale)];
	}
	this.GetCameraBoundsInCurrentGroupImageUnscaled = function (cameraId, groupId)
	{
		var cams = self.GetGroupCams(groupId);
		if (cams)
		{
			var rects = self.GetGroupRects(groupId);
			if (rects)
				for (var j = 0; j < rects.length; j++)
					if (cams[j] == cameraId)
						return rects[j];
		}
		return null;
	}
	/**
	 * Finds a camera by case-insensitive match of its ID.
	 * @param {String} cameraId Camera ID to search for.
	 * @return {Object} Camera object if found, or undefined if not found.
	 */
	this.GetCameraWithId = function (cameraId)
	{
		if (typeof cameraId !== "string")
			return undefined;
		return cameraIdToCameraMap[cameraId.toLowerCase()];
	}
	/**
	 * (deprecated) Finds a camera by case-insensitive match of its ID.
	 * @param {String} cameraId Camera ID to search for.
	 * @return {Object} Camera object if found, or undefined if not found.
	 */
	this.FindCameraWithSimilarId = function (cameraId)
	{
		return self.GetCameraWithId(cameraId);
	}
	this.MakeFakeCamBasedOnClip = function (clipData)
	{
		var clipRes = new ClipRes(clipData.res);
		if (!clipRes.valid)
		{
			clipRes.width = 1920;
			clipRes.height = 1080;
		}
		var fake = {
			optionDisplay: clipData.camera,
			optionValue: clipData.camera,
			active: true,
			FPS: 15,
			color: 16744448,
			audio: true,
			width: clipRes.width,
			height: clipRes.height
		};
		return fake;
	}
	this.GetCameraName = function (cameraId)
	{
		var cam = self.GetCameraWithId(cameraId);
		if (cam)
		{
			if (self.CameraIsGroupOrCycle(cam))
				return CleanUpGroupName(cam.optionDisplay);
			return cam.optionDisplay;
		}
		return cameraId;
	}
	this.GetGroupCamera = function (groupId)
	{
		if (lastResponse && lastResponse.data)
		{
			for (var i = 0; i < lastResponse.data.length; i++)
			{
				if (self.CameraIsGroupOrCycle(lastResponse.data[i]))
				{
					if (iEquals(lastResponse.data[i].optionValue, groupId))
					{
						return lastResponse.data[i];
					}
				}
			}
		}
		return null;
	}
	this.GetGroupAndCycleList = function ()
	{
		var arr = new Array();
		if (lastResponse && lastResponse.data)
		{
			for (var i = 0; i < lastResponse.data.length; i++)
			{
				if (self.CameraIsGroupOrCycle(lastResponse.data[i]))
				{
					arr.push(lastResponse.data[i]);
				}
			}
		}
		return arr;
	}
	this.CameraIsGroup = function (cameraObj)
	{
		return cameraObj.group;
	}
	this.CameraIsGroupOrCycle = function (cameraObj)
	{
		return cameraObj.group || cameraObj.optionValue.startsWith("@");
	}
	this.CameraIsCycle = function (cameraObj)
	{
		return cameraObj.optionValue.startsWith("@");
	}
	this.CameraIsGroupOrCamera = function (cameraObj)
	{
		return cameraObj.group || !cameraObj.optionValue.startsWith("@");
	}
	this.CameraIsAlone = function (cameraObj)
	{
		return cameraObj.isFakeGroup || !self.CameraIsGroupOrCycle(cameraObj);
	}
	this.IsFakeGroup = function (cameraId)
	{
		var cameraObj = self.GetCameraWithId(cameraId);
		return !!(cameraObj && cameraObj.isFakeGroup);
	}
	this.GetLastResponse = function ()
	{
		return lastResponse;
	}
	/**
	 * Returns an array containing all stream objects (groups, cycles, cameras) currently known, including any fake ones created by UI3.
	 */
	this.GetAllStreamObjects = function ()
	{
		if (lastResponse && lastResponse.data && lastResponse.data.length >= 0)
			return lastResponse.data;
		return [];
	}
	/**
	 * Returns true if the current user has admin privilege for any camera
	 */
	this.hasCameraAdminPrivilege = function ()
	{
		if (lastResponse && lastResponse.data)
		{
			for (var i = 0; i < lastResponse.data.length; i++)
			{
				if (lastResponse.data[i].admin)
					return true;
			}
		}
		return false;
	}
	/**
	 * Returns the group object for a single-camera group, if it exists.
	 * @param {String} groupId ID of the group to check (not case sensitive).
	 */
	this.getSingleCameraGroupNameById = function (groupId)
	{
		if (typeof groupId !== "string")
			return undefined;
		return singleCameraGroupNameMap[groupId.toLowerCase()];
	}
	/**
	 * Gets the current camera ID to camera object map (a new map is created each time the camlist is polled).
	 * @returns {Object} Map of camera ID string (normalized to lower case) to camera object.
	 */
	this.getCameraIdToCameraMap = function ()
	{
		return cameraIdToCameraMap;
	}
}
function DontShowWebcastingWarningAgain()
{
	settings.ui3_webcasting_disabled_dontShowAgain = "1";
	cameraListLoader.HideWebcastingWarning();
}
///////////////////////////////////////////////////////////////
// Video Player Controller ////////////////////////////////////
///////////////////////////////////////////////////////////////
var firstStreamHasBeenRequested = false;
var tabVisibleStopwatch = new UI3Stopwatch();
function VideoPlayerController()
{
	/*
	This object is intended to be a high level interface for video playback and related operations (such as video surface click handling).
	*/
	var self = this;
	var isInitialized = false;

	var playerModule = null;
	var moduleHolder = {};

	var currentlyLoadingCamera = null;
	var currentlyLoadedCamera = null;
	var currentlyLoadingImage = new BICameraData();
	var currentlyLoadedImage = new BICameraData();

	var lastLiveCameraOrGroupId = "";
	var currentlySelectedHomeGroupId = null;
	var $layoutbody = $("#layoutbody");
	var $camimg_wrapper = $("#camimg_wrapper");

	var mouseHelper = null;

	// Prioritize Triggered
	var pt_currentCam = null;

	/**
	 * Call this from mouse or touch events that conflict with the VideoPlayer's double-click helper, and past events will no longer count toward new clicks or drags.
	 */
	this.suppressMouseHelper = function (invalidateNextEvent)
	{
		if (mouseHelper)
			mouseHelper.Invalidate(invalidateNextEvent);
	}

	this.getDoubleClickTime = function ()
	{
		return mouseHelper.getDoubleClickTime();
	}

	this.CurrentPlayerModuleName = function ()
	{
		if (playerModule === moduleHolder["jpeg"])
			return "jpeg";
		else if (playerModule === moduleHolder["h264"])
			return "h264";
		return "none";
	}
	this.DeactivatePlayer = function ()
	{
		if (playerModule)
			playerModule.Deactivate();
	}
	this.SetPlayerModule = function (moduleName, refreshVideoNow)
	{
		var position = 0;
		var paused = false;
		if (playerModule != null)
		{
			if (playerModule === moduleHolder[moduleName])
				return;
			position = playerModule.GetSeekPercent();
			paused = playerModule.Playback_IsPaused();
			playerModule.Deactivate();
		}

		if (moduleName === "jpeg")
		{
			playerModule = moduleHolder[moduleName];
		}
		else if (moduleName === "h264")
		{
			playerModule = moduleHolder[moduleName];
		}
		else
			toaster.Error("Video Player was asked to load unexpected module \"" + moduleName + "\".", 30000);

		if (pictureInPictureController)
			pictureInPictureController.updatePictureInPictureButtonState();

		if (!playerModule)
			toaster.Error("Video Player was asked to load module \"" + moduleName + "\" which does not exist.", 30000);
		else if (refreshVideoNow)
			playerModule.OpenVideo(currentlyLoadingImage.UpdateTimelineStart(), position, paused);
	}
	this.RefreshVideoStream = function ()
	{
		if (playerModule)
			playerModule.OpenVideo(currentlyLoadingImage.UpdateTimelineStart(), playerModule.GetSeekPercent(), playerModule.Playback_IsPaused());
	}
	this.PreLoadPlayerModules = function ()
	{
		if (!moduleHolder["jpeg"])
			moduleHolder["jpeg"] = new JpegVideoModule();
		if (any_h264_playback_supported)
		{
			if (!moduleHolder["h264"])
				moduleHolder["h264"] = new FetchH264VideoModule();
		}
		else
			$("#loadingH264").parent().hide();
	}
	this.GetPlayerElement = function ()
	{
		if (typeof playerModule.GetPlayerElement === "function")
			return playerModule.GetPlayerElement();
		return null;
	}
	/**
	 * Gets a reference to the current player's h264_player field.  Returns null if using a Jpeg streaming method. (For use by UI extensions)
	 */
	this.GetPlayerObject = function ()
	{
		if (playerModule && typeof playerModule.GetPlayerObject === "function")
			return playerModule.GetPlayerObject();
		return null;
	}

	this.Initialize = function ()
	{
		if (isInitialized)
			return;
		isInitialized = true;

		setPrioritizeTriggeredButtonState();

		self.PreLoadPlayerModules();
		self.SetPlayerModule(genericQualityHelper.GetCurrentProfile().vcodec, true);

		var visProp = getHiddenProp();
		if (visProp)
		{
			var evtname = visProp.replace(/[H|h]idden/, '') + 'visibilitychange';
			document.addEventListener(evtname, function ()
			{
				// Called when page visibility changes.
				var visibleNow = !documentIsHidden();
				developerLog("Tab is " + (visibleNow ? "visible now" : "hidden"));
				if (moduleHolder["jpeg"])
					moduleHolder["jpeg"].VisibilityChanged(visibleNow);
				if (moduleHolder["h264"])
					moduleHolder["h264"].VisibilityChanged(visibleNow);
				if (visibleNow)
					tabVisibleStopwatch.Restart();
				else
					tabVisibleStopwatch.Reset();
				BI_CustomEvent.Invoke("VisibilityChanged", visibleNow);
			});
		}
		mouseHelper = new MouseEventHelper($("#layoutbody,#zoomhint")
			, $("#playbackHeader,#playbackControls") // Excludes clicks while viewing recordings
			, $("#playbackControls .pcButton,#volumeBar,#closeClipLeft") // Excludes clicks while viewing live and excludes dragging always
			, function (e) { return playbackControls.MouseInSettingsPanel(e) || playbackControls.MouseInPlaybackControls(e); } // exclude click if returns true
			, function (e, confirmed) // Single Click
			{
				videoOverlayHelper.HideFalseLoadingOverlay();
				if (currentlyLoadingImage.isLive || currentlyLoadingImage.isTimeline())
				{
					// Live View or Timeline
					if (IsDoubleClickFullscreenEnabled())
					{
						if (confirmed)
							ImgClick(e);
						else
							self.DoThingIfImgClickEligible(e, videoOverlayHelper.ShowFalseLoadingOverlay);
					}
					else if (!confirmed)
						ImgClick(e);
				}
				else
				{
					// Recording
					if (!confirmed)
					{
						if (self.Playback_IsPaused())
							videoOverlayHelper.ShowTemporaryPlayIcon();
						else
							videoOverlayHelper.ShowTemporaryPauseIcon();
					}
					var dblClickEnabled = IsDoubleClickFullscreenEnabled();
					if ((confirmed && dblClickEnabled) || (!confirmed && !dblClickEnabled))
					{
						self.Playback_PlayPause();
					}
				}
			}
			, function (e) // Double Click
			{
				if (!IsDoubleClickFullscreenEnabled())
					return;
				videoOverlayHelper.HideFalseLoadingOverlay();
				if (currentlyLoadingImage.isLive || currentlyLoadingImage.isTimeline())
				{
					fullScreenModeController.toggleFullScreen();
				}
				else
				{
					videoOverlayHelper.HideTemporaryIcons();
					fullScreenModeController.toggleFullScreen();
				}
			}
			, imageRenderer.CamImgDragStart
			, imageRenderer.CamImgDragMove
			, imageRenderer.CamImgDragEnd
		);

		$("#prioritizeTriggeredButton").longpress(self.PrioritizeTriggeredToggle, self.PrioritizeTriggeredClick);

		BI_CustomEvent.AddListener("CameraListLoaded", UpdatedCurrentCameraData);
		BI_CustomEvent.AddListener("OpenVideo", OnOpenVideo);
	}
	var UpdatedCurrentCameraData = function (lastResponse)
	{
		currentlyLoadingCamera = GetUpdatedCameraData(currentlyLoadingCamera);
		currentlyLoadedCamera = GetUpdatedCameraData(currentlyLoadedCamera);

		if (currentlyLoadingCamera.width != currentlyLoadingImage.fullwidth
			|| currentlyLoadingCamera.height != currentlyLoadingImage.fullheight)
		{
			currentlyLoadingImage.fullwidth = currentlyLoadingCamera.width;
			currentlyLoadingImage.fullheight = currentlyLoadingCamera.height;
			//self.CameraOrResolutionChange(); // May be necessary, but maybe not?
		}
		if (currentlyLoadingImage.isLive)
		{
			var wasAutoMaximized = pt_currentCam && iEquals(pt_currentCam, currentlyLoadingCamera.optionValue);
			if (self.PrioritizeTriggeredEnabled())
			{
				if (pt_currentCam)
				{
					var cam = cameraListLoader.GetCameraWithId(pt_currentCam);
					if (!self.CamIsConsideredTriggered(cam))
						pt_currentCam = null;
				}
				if (!pt_currentCam)
				{
					var group = self.GetCurrentHomeGroupObj();
					var cams = cameraListLoader.GetGroupCams(group.optionValue);
					if (group && cams)
					{
						var camsInGroup = {};
						for (var i = 0; i < cams.length; i++)
							camsInGroup[cams[i]] = true;

						for (var i = 0; i < lastResponse.data.length; i++)
						{
							var cam = lastResponse.data[i];
							if (camsInGroup[cam.optionValue])
							{
								if (self.CamIsConsideredTriggered(cam))
								{
									pt_currentCam = cam.optionValue;
									self.ImgClick_Camera(cam);
									break;
								}
							}
						}
					}
				}
			}
			else
				pt_currentCam = null;

			if (wasAutoMaximized && pt_currentCam === null)
			{
				var cam = cameraListLoader.GetCameraWithId(currentlyLoadingCamera.optionValue);
				self.ImgClick_Camera(cam);
			}
		}
	}
	var OnOpenVideo = function (loading)
	{
		firstStreamHasBeenRequested = true;
		if (loading.id.startsWith('@'))
			$("#prioritizeTriggeredButton").hide();
		else
			$("#prioritizeTriggeredButton").show();
	}
	this.CamIsConsideredTriggered = function (camData)
	{
		if (camData && camData.isEnabled && camData.active && camData.webcast)
		{
			if (settings.ui3_prioritizeTriggered_triggerMode === "Alert")
			{
				if (camData.isAlerting)
					return true;
			}
			else if (settings.ui3_prioritizeTriggered_triggerMode === "Trigger")
			{
				if (camData.isTriggered)
					return true;
			}
			else if (settings.ui3_prioritizeTriggered_triggerMode === "Motion")
			{
				if (camData.isMotion)
					return true;
			}
		}
		return false;
	}
	var GetUpdatedCameraData = function (currentCameraData)
	{
		if (currentCameraData)
		{
			var updatedCameraData = cameraListLoader.GetCameraWithId(currentCameraData.optionValue);
			if (updatedCameraData)
				return updatedCameraData;
		}
		return currentCameraData;
	}
	var IsDoubleClickFullscreenEnabled = function ()
	{
		if (settings.ui3_doubleClick_behavior === "Both")
			return true;
		if (currentlyLoadingImage.isLive || currentlyLoadingImage.isTimeline())
			return settings.ui3_doubleClick_behavior === "Live View";
		else
			return settings.ui3_doubleClick_behavior === "Recordings";
	}
	// Methods for querying what is currently playing
	this.Loading = function ()
	{
		return { cam: currentlyLoadingCamera, image: currentlyLoadingImage };
	}
	this.Loaded = function ()
	{
		return { cam: currentlyLoadedCamera, image: currentlyLoadedImage };
	}
	this.GetExpectedFrameIntervalOfCurrentCamera = function ()
	{
		if (currentlyLoadingImage.isTimeline() && currentlyLoadingImage.isGroup)
			return 1000 / 30; // Timeline groups are at 30 FPS as of 2022-03.
		if (typeof currentlyLoadingCamera.FPS === "number")
			return 1000 / currentlyLoadingCamera.FPS;
		else
			return 100;
	}
	this.GetCurrentHomeGroupObj = function ()
	{
		return cameraListLoader.GetGroupCamera(currentlySelectedHomeGroupId);
	}
	this.GetClipPlaybackPositionPercent = function ()
	{
		if (currentlyLoadingImage.isLive || currentlyLoadingImage.isTimeline())
			return 0;
		return playerModule.GetSeekPercent();
	}
	this.GetClipPlaybackPositionMs = function ()
	{
		if (currentlyLoadingImage.isLive || currentlyLoadingImage.isTimeline())
			return 0;
		return playerModule.GetClipPlaybackPositionMs();
	}
	this.IsFrameVisible = function ()
	{
		if (playerModule)
			return playerModule.LoadedFrameSinceActivate();
		return false;
	}
	this.GetLastSnapshotUrl = function ()
	{
		return playerModule.GetLastSnapshotUrl();
	}
	this.GetLastSnapshotFullUrl = function ()
	{
		return playerModule.GetLastSnapshotFullUrl();
	}
	this.GetStaticSnapshotId = function ()
	{
		return playerModule.GetStaticSnapshotId();
	}
	this.Playback_IsPaused = function ()
	{
		return !playerModule || playerModule.Playback_IsPaused();
	}
	/**
	 * Returns the number of milliseconds that have passed since the most recent stream was started.
	 */
	this.GetOffsetFromStartMs = function ()
	{
		if (playerModule)
			return playerModule.GetOffsetFromStartMs();
		return 0;
	}

	// Methods dealing with mouse clicks.
	this.GetCameraUnderMousePointer = function (event)
	{
		// Find out which camera is under the mouse pointer, if any.
		imageRenderer.SetMousePos(event.mouseX, event.mouseY);

		var imgPos = imageRenderer.GetSimulatedCamimgWrapperPosition();
		var layoutbodyOffset = $layoutbody.offset();
		var mouseRelX = parseFloat((event.mouseX - layoutbodyOffset.left) - imgPos.left) / imageRenderer.GetPreviousImageDrawInfo().w;
		var mouseRelY = parseFloat((event.mouseY - layoutbodyOffset.top) - imgPos.top) / imageRenderer.GetPreviousImageDrawInfo().h;

		var dyn = cameraListLoader.isDynamicLayoutEnabled(currentlyLoadedImage.id);
		var nativeRes = dyn
			? { w: currentlyLoadedImage.actualwidth, h: currentlyLoadedImage.actualheight }
			: { w: currentlyLoadedImage.fullwidth, h: currentlyLoadedImage.fullheight };
		var x = nativeRes.w * mouseRelX;
		var y = nativeRes.h * mouseRelY;
		var camData = currentlyLoadedCamera;
		if (camData)
		{
			if (camData.group && !camData.isFakeGroup)
			{
				var cams = cameraListLoader.GetGroupCams(camData.optionValue);
				var rects = cameraListLoader.GetGroupRects(camData.optionValue);
				if (cams && rects && cams.length === rects.length)
				{
					for (var j = 0; j < rects.length; j++)
					{
						if (x > rects[j][0] && y > rects[j][1] && x < rects[j][2] && y < rects[j][3])
							return cameraListLoader.GetCameraWithId(cams[j]);
					}
				}
			}
			else
				return camData;
		}
		return null;
	}
	/**
	 * Does all the validation and clicked-camera identification from the ImgClick function, then calls a callback method where the clicked camera is passed in.
	 * @param {any} event Mouse event object
	 * @param {Function} thing Function to call after validation
	 */
	this.DoThingIfImgClickEligible = function (event, thing)
	{
		if (!currentlyLoadingImage.isLive && !currentlyLoadingImage.isTimeline())
			return;
		// mouseCoordFixer.fix(event); // Don't call this more than once per event!
		var camData = self.GetCameraUnderMousePointer(event);
		if (!camData || cameraListLoader.CameraIsCycle(camData))
		{
			// Do nothing
		}
		else if (camData.isFakeGroup && iEquals(settings.ui3_defaultCameraGroupId, camData.optionValue))
		{
			// Do nothing
		}
		else if (cameraListLoader.getSingleCameraGroupNameById(settings.ui3_defaultCameraGroupId) && iEquals(cameraListLoader.getSingleCameraGroupNameById(settings.ui3_defaultCameraGroupId), camData.optionValue))
		{
			// Do nothing
		}
		else
		{
			thing(camData);
		}
	}
	var ImgClick = function (event)
	{
		self.DoThingIfImgClickEligible(event, self.ImgClick_Camera);
	}
	this.ImgClick_Camera = function (camData)
	{
		if (iEquals(camData.optionValue, currentlyLoadedImage.id))
		{
			// Back to Group
			camData = self.GetCurrentHomeGroupObj();
			if (iEquals(camData.optionValue, currentlyLoadedImage.id))
				return;
			var didRenderThing = false;
			if (debug_cameraChange_scaleOut && playerModule.DrawFullCameraAsThumb)
				didRenderThing = playerModule.DrawFullCameraAsThumb(currentlyLoadedImage.id, camData.optionValue);
			self.LoadLiveCamera(camData, clipTimeline.getTimelineArgsForCameraSwitch());
			if (didRenderThing)
				self.CameraOrResolutionChange();
		}
		else
		{
			// Maximize
			var didRenderThing = false;
			if (playerModule.DrawThumbAsFullCamera)
			{
				var loadedImg = videoPlayer.Loaded().image;
				if (loadedImg.id)
					didRenderThing = playerModule.DrawThumbAsFullCamera(camData.optionValue, loadedImg.id);
			}
			self.LoadLiveCamera(camData, clipTimeline.getTimelineArgsForCameraSwitch());
			if (didRenderThing)
				self.CameraOrResolutionChange();
		}
	}

	// Methods for changing what the player is playing
	this.goLive = function ()
	{
		if (currentlyLoadingImage == null || currentlyLoadingImage.isLive)
			return;
		var camData = cameraListLoader.GetCameraWithId(lastLiveCameraOrGroupId);
		if (camData && camData.isEnabled && camData.webcast)
		{
			clipLoader.suppressClipListLoad = true;
			self.LoadLiveCamera(camData);
			clipLoader.suppressClipListLoad = false;
		}
		else
		{
			self.LoadLiveCamera(cameraListLoader.GetGroupCamera(currentlySelectedHomeGroupId));
		}
	}
	this.openTimelineAt = function (timelineMs)
	{
		if (currentlyLoadingImage == null || currentlyLoadingImage.isLive)
			return;
		if (currentPrimaryTab !== "timeline")
			$('.topbar_tab[name="timeline"]').click();
		if (!timelineMs)
			timelineMs = videoPlayer.lastFrameUtc;
		var timelineArgs = clipTimeline.getTimelineArgsForCameraSwitch();
		if (!timelineArgs)
			timelineArgs = { timelineMs: timelineMs, startPaused: videoPlayer.Playback_IsPaused() && !clipTimeline.timelineDidPauseVideo() };
		timelineArgs.timelineMs = timelineMs;
		var camData = cameraListLoader.GetCameraWithId(lastLiveCameraOrGroupId);
		if (camData && camData.isEnabled && camData.webcast)
		{
			self.LoadLiveCamera(camData, timelineArgs);
		}
		else
		{
			self.LoadLiveCamera(cameraListLoader.GetGroupCamera(currentlySelectedHomeGroupId), timelineArgs);
		}
	}
	this.isLive = function ()
	{
		return currentlyLoadingImage != null && currentlyLoadingImage.isLive;
	}
	this.handleDisabledCamera = function (videoData)
	{
		if (videoData.isLive && !videoData.isGroup)
		{
			var camData = cameraListLoader.GetCameraWithId(videoData.id);
			if (!camData || !camData.isEnabled || !camData.webcast)
			{
				cameraListLoader.LoadCameraList();
				self.LoadHomeGroup();
				return true;
			}
		}
		return false;
	}
	this.LoadHomeGroup = function (groupId)
	{
		if (typeof groupId == "undefined")
			groupId = currentlySelectedHomeGroupId;
		self.LoadLiveCamera(cameraListLoader.GetGroupCamera(groupId), clipTimeline.getTimelineArgsForCameraSwitch());
	}
	this.LoadFirstAvailableCameraGroup = function ()
	{
		var camList = cameraListLoader.GetLastResponse();
		for (var i = 0; i < camList.data.length; i++)
		{
			if (cameraListLoader.CameraIsGroup(camList.data[i]))
			{
				self.SelectCameraGroup(camList.data[i].optionValue);
				break;
			}
		}
	}
	this.SelectCameraGroup = function (groupId)
	{
		dropdownBoxes.setLabelText("currentGroup", "...");
		var camList = cameraListLoader.GetLastResponse();
		for (var i = 0; i < camList.data.length; i++)
		{
			if (iEquals(camList.data[i].optionValue, groupId))
			{
				if (cameraListLoader.CameraIsGroupOrCycle(camList.data[i]))
				{
					self.SetCurrentlySelectedHomeGroupId(groupId);
					self.LoadLiveCamera(camList.data[i], clipTimeline.getTimelineArgsForCameraSwitch());
					break;
				}
			}
		}
	}
	this.SetCurrentlySelectedHomeGroupId = function (id)
	{
		settings.ui3_defaultCameraGroupId = currentlySelectedHomeGroupId = id;
	}
	this.LoadLiveCamera = function (camData, timelineArgs)
	{
		developerLog("LoadLiveCamera(", camData, timelineArgs, ")");
		if (camData == null)
		{
			toaster.Error("The target camera or group could not be found.");
			return;
		}
		if (timelineArgs)
		{
			if (typeof timelineArgs.timelineMs === "number")
			{
				var beforeBoundsCheck = timelineArgs.timelineMs;
				timelineArgs.timelineMs = clipTimeline.BoundsCheckTimelineMs(timelineArgs.timelineMs);
				if (timelineArgs.timelineMs !== beforeBoundsCheck)
					developerLog("clipTimeline.BoundsCheckTimelineMs(" + beforeBoundsCheck + ") -> " + timelineArgs.timelineMs);
			}
			if (typeof timelineArgs.timelineMs !== "number")
			{
				if (timelineArgs.timelineMs !== beforeBoundsCheck)
					developerLog("LoadLiveCamera saw that timelineArgs.timelineMs was type " + typeof timelineArgs.timelineMs + ", so is disregarding timelineArgs object.");
				timelineArgs = {}; // Nothing else matters if timelineMs is not defined.
			}
		}
		developerLog("LoadLiveCamera timelineArgs ", timelineArgs);
		timelineArgs = $.extend({
			timelineMs: undefined,
			timelineJump: undefined,
			startPaused: false
		}, timelineArgs);
		developerLog("LoadLiveCamera timelineArgs ", timelineArgs);

		if ((!camData.isEnabled || !camData.webcast) && !cameraListLoader.CameraIsGroupOrCycle(camData))
		{
			if (currentPrimaryTab !== "timeline")
			{
				console.log("LoadLiveCamera will not try to load " + camData.optionValue + ".", "Enabled: " + camData.isEnabled, "Webcast: " + camData.webcast, "IsGroupOrCycle: " + cameraListLoader.CameraIsGroupOrCycle(camData));
				if (!camData.webcast)
					toaster.Warning("The camera you clicked has webcasting disabled. Enable it in Blue Iris Camera Properties > Webcast tab.", 15000);
				return;
			}
		}
		if (cameraListLoader.getSingleCameraGroupNameById(camData.optionValue))
		{
			var maybeCamData = cameraListLoader.GetCameraWithId(cameraListLoader.getSingleCameraGroupNameById(camData.optionValue));
			if (maybeCamData.isEnabled && maybeCamData.webcast)
				camData = maybeCamData;
		}

		var cli = currentlyLoadingImage;
		var clc = currentlyLoadingCamera = camData;
		var previousId = cli.id;
		cli.id = clc.optionValue;
		cli.fullwidth = cli.actualwidth = clc.width;
		cli.fullheight = cli.actualheight = clc.height;
		cli.path = clc.optionValue;
		cli.uniqueId = clc.optionValue;
		cli.isLive = typeof timelineArgs.timelineMs !== "number";
		cli.timelineStart = timelineArgs.timelineMs;
		cli.timelineJump = timelineArgs.timelineJump;
		cli.ptz = clc.ptz;
		cli.audio = clc.audio;
		cli.msec = -1;
		cli.isGroup = clc.group ? true : false;
		if (previousId !== cli.id)
		{
			cli.cams = null;
			cli.rects = null;
		}

		developerLog("LoadLiveCamera cli ", cli);

		lastLiveCameraOrGroupId = clc.optionValue;

		playbackControls.Live();
		ptzButtons.UpdatePtzControlDisplayState();
		relativePTZ.disable3dPositioning();
		dropdownBoxes.setLabelText("currentGroup", CleanUpGroupName(clc.optionDisplay));

		if (clipLoader.GetCurrentFilteredCamera() !== cli.id)
			clipLoader.LoadClips(); // This method does not waste resources if not on the clips tab.

		videoOverlayHelper.ShowLoadingOverlay(true);
		var startPaused = timelineArgs.startPaused;
		if (playerModule)
			playerModule.OpenVideo(cli, 0, startPaused);
		else
			developerLog("LoadLiveCamera playerModule not yet loaded");

		fullScreenModeController.updateFullScreenButtonState();

		mediaSessionController.setMediaMetadata(CleanUpGroupName(clc.optionDisplay));
	}
	this.LoadClip = function (clipData)
	{
		var fileTypeInfo = clipLoader.GetClipFileTypeInfo(clipData);
		if (NumberHasFlags(clipData.flags, BIDBFLAG.RECORDING) && !fileTypeInfo.isBVR)
		{
			toaster.Info("Unable to open this " + (clipData.isClip ? "clip" : "alert") + " because the clip is still recording and the file type is not bvr.");
			return;
		}

		var cam = cameraListLoader.GetCameraWithId(clipData.camera);
		if (!cam)
			cam = cameraListLoader.MakeFakeCamBasedOnClip(clipData);
		if (cam)
		{
			var cli = currentlyLoadingImage;
			var clc = currentlyLoadingCamera = cam;
			cli.id = clc.optionValue;
			cli.fullwidth = cli.actualwidth = clc.width;
			cli.fullheight = cli.actualheight = clc.height;
			var clipRes = new ClipRes(clipData.res);
			if (clipRes.valid)
			{
				cli.fullwidth = clipRes.width;
				cli.fullheight = clipRes.height;
			}
			cli.path = clipData.path;
			cli.uniqueId = clipData.recId;
			cli.isLive = false;
			cli.timelineStart = false;
			cli.ptz = false;
			cli.audio = clipData.audio || (!clipData.isClip && cli.audio); // Alerts never have the audio flag set.
			cli.msec = parseInt(clipData.msec);
			cli.isGroup = false;
			cli.cams = null;
			cli.rects = null;

			playbackHeader.SetClipName(clipData);
			playbackControls.Recording(clipData);
			if (clipLoader.ClipDataIndicatesFlagged(clipData))
				$("#clipFlagButton").addClass("flagged");
			else
				$("#clipFlagButton").removeClass("flagged");
			seekBar.drawSeekbarAtPercent(0);
			seekBar.resetSeekHintImg();

			videoOverlayHelper.ShowLoadingOverlay(true);
			if (playerModule)
				playerModule.OpenVideo(cli, -1, false);

			mediaSessionController.setMediaMetadata(clipLoader.GetClipDisplayName(clipData));
		}
		else
			toaster.Error("Could not find camera " + htmlEncode(clipData.camera) + " associated with clip.");

		fullScreenModeController.updateFullScreenButtonState();
	}
	this.TimelineJump = function (direction)
	{
		if (currentPrimaryTab !== "timeline")
			return;
		direction = (direction > 0 ? 1 : -1);
		if (currentlyLoadingImage.isLive || !currentlyLoadingImage.isTimeline() || self.Playback_IsPaused())
		{
			var args = clipTimeline.getTimelineArgsForCameraSwitch(true);
			if (currentlyLoadingImage.isLive)
				args.timelineMs = clipTimeline.getNewestAllowableTime();
			args.timelineJump = direction;
			self.LoadLiveCamera(currentlyLoadingCamera, args);
		}
		else
			self.TimelineSet("&jump=" + direction);
	}
	this.TimelineSeek = function (pos)
	{
		if (self.lastFrameUtc === pos)
			return;
		self.lastFrameUtc = pos;
		var speedArg = "&speed=" + Math.round(100 * playbackControls.GetPlaybackSpeed());
		self.TimelineSet(speedArg + "&pos=" + parseInt(pos));
	}
	/** Instructs Blue Iris to stop the current timeline stream. Useful only for Jpeg streams. */
	this.TimelineStop = function ()
	{
		self.TimelineSet("&speed=0");
	}
	this.TimelineSet = function (urlParams)
	{
		if (!currentlyLoadingImage.isTimeline())
			return;
		timelineSync.run(this, function ()
		{
			var url = currentServer.remoteBaseURL + "time/set" + currentServer.GetAPISessionArg("?", true) + '&opaque=' + ui3InstanceId + urlParams;
			$.ajax(url)
				.fail(function (jqXHR, textStatus, errorThrown)
				{
					if (jqXHR && jqXHR.status !== 0)
						toaster.Error("Blue Iris failed to modify the timeline video stream. HTTP " + jqXHR.status + " " + jqXHR.statusText);
					else
						toaster.Error("Unable to contact Blue Iris to modify the timeline video stream.");
				})
				.always(function ()
				{
					timelineSync.unlock();
				});
		});
	}
	this.SeekToPercent = function (pos, play)
	{
		pos = Clamp(pos, 0, 1);
		seekBar.drawSeekbarAtPercent(pos);
		playerModule.OpenVideo(currentlyLoadingImage.UpdateTimelineStart(), pos, !play);
	}
	this.SeekByMs = function (offset, play)
	{
		if (currentlyLoadingImage.isTimeline())
			clipTimeline.seekTo(videoPlayer.lastFrameUtc + offset);
		else
		{
			var msLength = currentlyLoadingImage.msec - 1;
			if (msLength <= 0)
				return;
			var currentMs = playerModule.GetSeekPercent() * msLength;
			var newPos = (currentMs + offset) / msLength;
			newPos = Clamp(newPos, 0, 1);
			if (typeof play == "undefined")
				play = !playerModule.Playback_IsPaused();
			self.SeekToPercent(newPos, play);
		}
	}
	this.AudioToggleNotify = function (audioEnabled)
	{
		if (playerModule && typeof playerModule.AudioToggleNotify == "function")
			playerModule.AudioToggleNotify(audioEnabled);
	}
	this.Playback_Pause = function ()
	{
		playerModule.Playback_Pause();
		UpdateCurrentURL();
	}
	this.Playback_Play = function ()
	{
		playerModule.Playback_Play();
	}
	this.Playback_PlayPause = function ()
	{
		if (playerModule.Playback_IsPaused())
			self.Playback_Play();
		else
			self.Playback_Pause();
	}
	this.Playback_NextClip = function ()
	{
		if (videoPlayer.Loading().image.isTimeline())
			videoPlayer.TimelineJump(1);
		else if (currentPrimaryTab === "timeline")
			return;
		else
		{
			var clipEle = clipLoader.GetCurrentClipEle();
			if (clipEle && clipLoader.GetAllSelected().length <= 1)
			{
				if (clipLoader.GetAllSelected().length === 0 || clipLoader.IsClipSelected(clipEle.id.substr(1)))
				{
					var $clip;
					if (settings.ui3_clip_navigation_direction === "Oldest First")
						$clip = clipLoader.GetClipAboveClip($(clipEle));
					else
						$clip = clipLoader.GetClipBelowClip($(clipEle));
					if (Playback_ClipObj($clip))
						return;
				}
			}
			self.Playback_Pause();
		}
	}
	this.Playback_PreviousClip = function ()
	{
		if (videoPlayer.Loading().image.isTimeline() || currentPrimaryTab === "timeline")
			videoPlayer.TimelineJump(-1);
		else
		{
			var clipEle = clipLoader.GetCurrentClipEle();
			if (clipEle && clipLoader.GetAllSelected().length <= 1)
			{
				if (clipLoader.GetAllSelected().length === 0 || clipLoader.IsClipSelected(clipEle.id.substr(1)))
				{
					var $clip;
					if (settings.ui3_clip_navigation_direction === "Oldest First")
						$clip = clipLoader.GetClipBelowClip($(clipEle));
					else
						$clip = clipLoader.GetClipAboveClip($(clipEle));
					if (Playback_ClipObj($clip))
						return;
				}
			}
			self.Playback_Pause();
		}
	}
	var Playback_ClipObj = function ($clip)
	{
		if ($clip != null && $clip.length > 0)
		{
			clipLoader.ScrollToClipObj($clip);
			$clip.click();
			return true;
		}
		return false;
	}
	this.PlaybackSpeedChanged = function (playSpeed)
	{
		if (typeof playerModule.PlaybackSpeedChanged == "function")
			playerModule.PlaybackSpeedChanged(playSpeed);
	}
	this.SelectedQualityChanged = function ()
	{
		var requiredPlayer = genericQualityHelper.GetCurrentProfile().vcodec;
		if (requiredPlayer != self.CurrentPlayerModuleName())
		{
			// playerModule must change, no need to notify the new one of the quality change.
			self.SetPlayerModule(requiredPlayer, true);
		}
		else
		{
			// playerModule remains the same, so we should notify it of the quality change.
			if (typeof playerModule.SelectedQualityChanged == "function")
				playerModule.SelectedQualityChanged();
		}
	}
	this.ReopenStreamAtCurrentSeekPosition = function ()
	{
		if (playerModule && typeof playerModule.ReopenStreamAtCurrentSeekPosition === "function")
			playerModule.ReopenStreamAtCurrentSeekPosition();
	}
	this.PlaybackDirectionChanged = function (playReverse)
	{
		if (typeof playerModule.PlaybackDirectionChanged == "function")
			playerModule.PlaybackDirectionChanged(playReverse);
	}
	this.ShowDelayWarning = function ()
	{
		if (typeof playerModule.ShowDelayWarning === "function")
			playerModule.ShowDelayWarning();
	}
	/**
	 * Tells the video player about a clip's new duration.
	 * As of BI 4.6.5.2, this currently should not be called as it will make UI3 and Blue Iris disagree about the clip duration.
	 * @param {any} clipData
	 */
	this.NotifyClipMetadataChanged = function (clipData)
	{
		if (videoPlayer.Loading().image.uniqueId === clipData.recId && typeof playerModule.NotifyClipMetadataChanged === "function")
			playerModule.NotifyClipMetadataChanged(clipData);
	}
	// Callback methods for a player module to inform the VideoPlayerController of state changes.
	this.CameraOrResolutionChange = function ()
	{
		var idChanged = currentlyLoadedImage.uniqueId !== currentlyLoadingImage.uniqueId;
		var wasZoomedToFit = imageRenderer.zoomHandler.IsZoomedToFit();
		currentlyLoadedImage.CopyValuesFrom(currentlyLoadingImage);
		currentlyLoadedCamera = currentlyLoadingCamera;
		if (idChanged || wasZoomedToFit)
			imageRenderer.zoomHandler.ZoomToFit();
		resized();
	}
	this.notifyImageLoading = function (loading, sizeToRequest)
	{
		loading.reqwidth = sizeToRequest.w;
		loading.reqheight = sizeToRequest.h;
		if (loading.id === currentlyLoadingImage.id)
		{
			currentlyLoadingImage.reqwidth = loading.reqwidth;
			currentlyLoadingImage.reqheight = loading.reqheight;
		}
	}
	this.lastFrameUtc = 0;
	this.ImageRendered = function (properties)
	{
		if (properties.id !== currentlyLoadingImage.uniqueId)
		{
			console.log("ImageRendered called for wrong video source.", properties.id, properties, "Currently loading: " + currentlyLoadingImage.id);
			return;
		}
		jpegPreviewModule.Hide();

		var imageSizeIsChanging = currentlyLoadingImage.actualwidth !== properties.w || currentlyLoadingImage.actualheight !== properties.h;

		currentlyLoadingImage.actualwidth = properties.w;
		currentlyLoadingImage.actualheight = properties.h;

		if (imageSizeIsChanging || currentlyLoadedImage.uniqueId != properties.id || currentlyLoadingImage.isTimeline() !== currentlyLoadedImage.isTimeline())
			self.CameraOrResolutionChange();

		if (imageSizeIsChanging)
			imageRenderer.ImgResized(false);

		RefreshFps(properties.loadingTime);

		if (typeof properties.utc === "number")
		{
			self.lastFrameUtc = properties.utc;
			if (currentlyLoadingImage.isLive)
			{
				var str = "";
				var w = $layoutbody.width();
				if (w < 240)
					str = "LIVE";
				else if (w < 325)
					str = "LIVE: " + GetTimeStr(GetServerDate(new Date(properties.utc)));
				else
					str = "LIVE: " + GetDateStr(GetServerDate(new Date(properties.utc)));
				playbackControls.SetProgressText(str);
			}
			else if (currentlyLoadingImage.isTimeline())
			{
				var str = GetDateStr(GetServerDate(new Date(properties.utc)));
				playbackControls.SetProgressText(str);
			}
		}

		if (currentlyLoadingImage.uniqueId != properties.id)
			return;

		if (!currentlyLoadedImage.isLive && !currentlyLoadedImage.isTimeline())
			seekBar.drawSeekbarAtPercent(playerModule.GetSeekPercent());
		videoOverlayHelper.HideLoadingOverlay();

		mediaSessionController.setMediaState();

		BI_CustomEvent.Invoke("ImageRendered", properties);
		if (properties.isFirstFrame)
			BI_CustomEvent.Invoke("FirstFrameLoaded");
	}
	/**
	 * Called when clip playback ends. Not called for live or timeline video.
	 * @param {any} isLeftBoundary Playback ended at the start of the clip.
	 */
	this.Playback_Ended = function (isLeftBoundary)
	{
		// The module may call this repeatedly 
		videoOverlayHelper.HideLoadingOverlay();
		if (isLeftBoundary)
		{
			seekBar.drawSeekbarAtPercent(0);
			if (playbackControls.GetPlayReverse())
			{
				if (playbackControls.GetLoopingEnabled())
					self.SeekToPercent(1, true);
				else if (playbackControls.GetAutoplay())
					self.Playback_PreviousClip();
				else
					self.Playback_Pause();
			}
		}
		else
		{
			seekBar.drawSeekbarAtPercent(1);
			if (!playbackControls.GetPlayReverse())
			{
				if (playbackControls.GetLoopingEnabled())
					self.SeekToPercent(0, true);
				else if (playbackControls.GetAutoplay())
					self.Playback_NextClip();
				else
					self.Playback_Pause();
			}
		}
	}
	var fpsZeroTimeout = null;
	var setFpsStatusBarThrottled = throttle(function (currentFps, maxFps)
	{
		statusAreaApi.setValue("Stream FPS", { fps: currentFps, maxFps: maxFps });
	}, 250);
	var currentFps = 0;
	var maxFps = 0;
	var RefreshFps = function (imgRequestMs)
	{
		currentFps = fpsCounter.getFPS(imgRequestMs);
		maxFps = currentlyLoadingCamera.FPS || 10;
		setFpsStatusBarThrottled(currentFps, maxFps);

		// This allows the FPS to change to 0 if connectivity is lost or greatly reduced
		if (fpsZeroTimeout != null)
			clearTimeout(fpsZeroTimeout);
		fpsZeroTimeout = setTimeout(ZeroFps, 4000);
	}
	setInterval(function ()
	{
		currentFps = fpsCounter.peekFPS();
		setFpsStatusBarThrottled(currentFps, maxFps);
	}, 250);
	var ZeroFps = function ()
	{
		statusAreaApi.setValue("Stream FPS", { fps: 0, maxFps: 0 });
	}
	this.GetFpsData = function ()
	{
		return { currentFps: currentFps, maxFps: maxFps };
	}
	this.PrioritizeTriggeredEnabled = function ()
	{
		return settings.ui3_prioritizeTriggered === "1";
	}
	this.PrioritizeTriggeredClick = function ()
	{
		toaster.Info("Long press to toggle Auto-Maximize.");
	}
	this.PrioritizeTriggeredToggle = function ()
	{
		if (self.PrioritizeTriggeredEnabled())
		{
			settings.ui3_prioritizeTriggered = "0";
			toaster.Success("Auto-Maximize is disabled.");
		}
		else
		{
			settings.ui3_prioritizeTriggered = "1";
			toaster.Success("Auto-Maximize is enabled upon " + settings.ui3_prioritizeTriggered_triggerMode + ". Configure feature at UI Settings > Video Player.");
		}
		self.PrioritizeTriggeredWasToggled();
	}
	this.PrioritizeTriggeredWasToggled = function ()
	{
		setPrioritizeTriggeredButtonState();
		UpdatedCurrentCameraData(cameraListLoader.GetLastResponse());
	}
	var setPrioritizeTriggeredButtonState = function ()
	{
		if (self.PrioritizeTriggeredEnabled())
			$(".prioritizeTriggeredButton").addClass("on");
		else
			$(".prioritizeTriggeredButton").removeClass("on");
	}
	this.GroupLayoutMetadataReceived = function (camId, xCamList, xRecList)
	{
		if (!xCamList || !xRecList)
			return;
		try
		{
			xCamList = UTF8Fix(xCamList);
			var cams = xCamList ? JSON.parse('[' + xCamList + ']') : null;
			var rects = xRecList ? JSON.parse('[' + xRecList + ']') : null;
			if (!cams.length || !rects.length)
				return;
			if (iEquals(currentlyLoadingImage.id, camId))
			{
				var oldSerialized = JSON.stringify(currentlyLoadingImage.cams) + JSON.stringify(currentlyLoadingImage.rects);
				var newSerialized = JSON.stringify(cams) + JSON.stringify(rects);
				if (oldSerialized !== newSerialized)
				{
					currentlyLoadingImage.cams = cams;
					currentlyLoadingImage.rects = rects;
					BI_CustomEvent.Invoke("DynamicGroupLayoutLoaded");
				}
			}
			if (iEquals(currentlyLoadedImage.id, camId))
			{
				currentlyLoadedImage.cams = cams;
				currentlyLoadedImage.rects = rects;
			}
		}
		catch (ex)
		{
			toaster.Error(ex);
		}
	}
	/**
	 * Fixes a string that contains UTF-8 characters but was read as ISO-8859-1, e.g. from an HTTP header value.  If a case is found where this doesn't work right, it should be resolved by correctly encoding the string in the first place, not by making this function even more hacky.
	 * @param {String} str String containing malformed UTF-8 characters.
	 */
	function UTF8Fix(str)
	{
		var bytes = new Uint8Array(str.length);
		for (var i = 0; i < str.length; i++)
			bytes[i] = str.charCodeAt(i);
		return Utf8ArrayToStr(bytes);
	}
	/* utf.js - UTF-8 <=> UTF-16 convertion
	 *
	 * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
	 * Version: 1.0
	 * LastModified: Dec 25 1999
	 * This library is free.  You can redistribute it and/or modify it.
	 */

	function Utf8ArrayToStr(array)
	{
		var out, i, len, c;
		var char2, char3;

		out = "";
		len = array.length;
		i = 0;
		while (i < len)
		{
			c = array[i++];
			switch (c >> 4)
			{
				case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
					// 0xxxxxxx
					out += String.fromCharCode(c);
					break;
				case 12: case 13:
					// 110x xxxx   10xx xxxx
					char2 = array[i++];
					out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
					break;
				case 14:
					// 1110 xxxx  10xx xxxx  10xx xxxx
					char2 = array[i++];
					char3 = array[i++];
					out += String.fromCharCode(((c & 0x0F) << 12) |
						((char2 & 0x3F) << 6) |
						((char3 & 0x3F) << 0));
					break;
			}
		}
		return out;
	}
}
function BICameraData()
{
	var self = this;
	/** Group Name or Cycle Name or Camera Short Name.  For recordings, this is the Camera Short Name. */
	this.id = "";
	/** Native width of image.  Used when calculating with group rects and as a base for digital zoom. */
	this.fullwidth = 1280;
	/** Native height of image.  Used when calculating with group rects and as a base for digital zoom. */
	this.fullheight = 720;
	/** Actual width of image (can be smaller than fullwidth) */
	this.actualwidth = 1280;
	/** Actual width of image (can be smaller than fullheight) */
	this.actualheight = 720;
	/** "Native resolution" of dynamically sized group frame. */
	this.dynamicNativeW = 0;
	/** "Native resolution" of dynamically sized group frame. */
	this.dynamicNativeH = 0;
	/** Resolution that was last requested. */
	this.reqwidth = 0;
	/** Resolution that was last requested. */
	this.reqheight = 0;
	/** Path component to use in URLs.  For live/timeline streams, this is the same as [id] and [uniqueId].  For clips, this is a string like "@12345.bvr". */
	this.path = "";
	/** Unique ID of the image provider. One of:
	 * * Group Name
	 * * Cycle Name
	 * * Camera Short Name
	 * * Clip ID
	 */
	this.uniqueId = "";
	/** True if this is a live stream. False if this is a clip or timeline stream. */
	this.isLive = true;
	/** If set to a number, this is a recorded timeline video feed that began at this time (some UI elements such as the progress bar should not be shown). */
	this.timelineStart = false;
	/** If 1, playback should seek to the next clip.  If -1, playback should seek to the previous clip. */
	this.timelineJump = 0;
	/** True if this image provider supports PTZ controls. */
	this.ptz = false;
	/** True if this image provider supports audio. */
	this.audio = false;
	/** Millisecond duration of clips/alerts.  Ignore this if isLive is set. */
	this.msec = 10000;
	/** True if this represents a group of cameras. */
	this.isGroup = false;
	/**
	 This is the dynamic cams array defining the cameras visible in the group, in order from left to right, top to bottom.
	 Populated when HTTP headers arrive with a video frame/stream.
	 If null, you should fall back to the default layout for the group.
	 */
	this.cams = null;
	/**
	 This is the dynamic rects array defining the coordinates of cameras visible in the group, in order matching the [cams] array.
	 Populated when HTTP headers arrive with a video frame/stream.
	 If null, you should fall back to the default layout for the group.*/
	this.rects = null;
	/**
	 * Sets the property values of this instance to the same as another instance.
	 * @param {Object} other Another BICameraData to copy values from.
	 */
	this.CopyValuesFrom = function (other)
	{
		self.id = other.id;
		self.fullwidth = other.fullwidth;
		self.fullheight = other.fullheight;
		self.actualwidth = other.actualwidth;
		self.actualheight = other.actualheight;
		self.dynamicNativeW = other.dynamicNativeW;
		self.dynamicNativeH = other.dynamicNativeH;
		self.reqwidth = other.reqwidth;
		self.reqheight = other.reqheight;
		self.path = other.path;
		self.uniqueId = other.uniqueId;
		self.isLive = other.isLive;
		self.timelineStart = other.timelineStart;
		self.timelineJump = other.timelineJump;
		self.ptz = other.ptz;
		self.audio = other.audio;
		self.msec = other.msec;
		self.isGroup = other.isGroup;
		self.cams = other.cams;
		self.rects = other.rects;
	}
	/** Returns true if this is a historical timeline video provider ([timelineStart] is a number). */
	this.isTimeline = function ()
	{
		return typeof self.timelineStart === "number";
	}
	/** If [isTimeline], then sets [timelineStart] = videoPlayer.lastFrameUtc. Returns a reference to this instance. */
	this.UpdateTimelineStart = function ()
	{
		if (self.isTimeline() && firstStreamHasBeenRequested)
		{
			developerTrace("BICameraData.UpdateTimelineStart() is resetting timelineStart from " + self.timelineStart + " to " + videoPlayer.lastFrameUtc);
			self.timelineStart = videoPlayer.lastFrameUtc;
		}
		return self;
	}
	/** Returns a new ui3Rect representing the native resolution of the image as defined by camera or clip metadata. */
	this.getFullRect = function ()
	{
		return new ui3Rect(self.fullwidth, self.fullheight);
	}
	/** Returns a new ui3Rect representing the intended resolution of the image. The "intended" resolution is meaningful only for dynamically-sized group frames, and is quite hacky. */
	this.getDynamicNativeRect = function ()
	{
		return new ui3Rect(self.dynamicNativeW || 0, self.dynamicNativeH || 0);
	}
	/** Returns a new ui3Rect representing the actual resolution of the last frame that was loaded for this video source.  If none has loaded yet, it will be equal to the native resolution. */
	this.getActualRect = function ()
	{
		return new ui3Rect(self.actualwidth, self.actualheight);
	}
	/** Returns a new ui3Rect representing the resolution that was last requested. */
	this.getRequestedRect = function ()
	{
		return new ui3Rect(self.reqwidth, self.reqheight);
	}
}
///////////////////////////////////////////////////////////////
// Jpeg Preview Module ////////////////////////////////////////
///////////////////////////////////////////////////////////////
/** Manages showing and hiding a canvas as necessary to render seek previews in the full video area. */
var jpegPreviewModule = new (function JpegPreviewModule()
{
	var self = this;
	var isVisible = false;
	var $camimg_wrapper = $("#camimg_wrapper");
	var $camimg_store = $("#camimg_store");
	var $camimg_preview = $('<canvas id="camimg_preview" class="videoCanvas"></canvas>');
	var camimg_preview_ele = $camimg_preview.get(0);
	var Show = function ()
	{
		if (isVisible)
			return;
		isVisible = true;
		$camimg_preview.appendTo($camimg_wrapper);
	}
	this.Hide = function ()
	{
		if (!isVisible)
			return;
		isVisible = false;
		$camimg_preview.appendTo($camimg_store);
	}
	this.RenderImage = function (imgEle)
	{
		CopyImageToCanvas(imgEle, camimg_preview_ele);
		Show();
		videoOverlayHelper.HideLoadingOverlay();
		playbackControls.FrameTimestampUpdated(false);
	}
	this.RenderDataURI = function (startTime, uniqueId, dataUri, utc, headers, isTimelineJump)
	{
		LoadImagePromise(dataUri)
			.then(function (data)
			{
				var img = data.image;
				if (!img.complete || typeof img.naturalWidth == "undefined" || img.naturalWidth == 0)
				{
					// Failed
					toaster.Error("Unable to decode jpeg image.");
				}
				else
				{
					if (headers)
						videoPlayer.GroupLayoutMetadataReceived(uniqueId, headers["x-camlist"], headers["x-reclist"]);
					// Calling ImageRendered will hide the jpegPreviewModule so we should call it before rendering the image
					videoPlayer.ImageRendered({ id: uniqueId, w: img.naturalWidth, h: img.naturalHeight, loadingTime: performance.now() - startTime, utc: utc, isSeekPreview: true, isTimelineJump: !!isTimelineJump });
					// Rendering the image shows the jpegPreviewModule again.
					self.RenderImage(img);
				}
			})
			.catch(function (err)
			{
				console.log('Bad image assigned to jpegPreviewModule.RenderDataURI.');
			});
	}
})();
///////////////////////////////////////////////////////////////
// Video Player Modules Shared ////////////////////////////////
///////////////////////////////////////////////////////////////
// ScaleOut behavior is disabled because it is jarring, and also is incorrect when dynamic group layouts are being used.
var debug_cameraChange_scaleOut = false;
var debug_cameraChange_scaleOut_spotlight = false;
/**
 Contains components shared between JpegVideoModule and HTML5_MSE_Player.
 */
var videoModulesShared = new (function VideoModulesShared()
{
	var self = this;
	var isInitialized = false;
	var $canvas = null;
	var canvas = null;
	var backbuffer_canvas = null;
	var $camimg_wrapper = $("#camimg_wrapper");
	var $camimg_store = $("#camimg_store");

	this.GetCanvas = function ()
	{
		return canvas;
	}
	this.Get$Canvas = function ()
	{
		return $canvas;
	}
	var Initialize = function ()
	{
		if (isInitialized)
			return;
		isInitialized = true;
		// Do one-time initialization here
		$canvas = $('<canvas id="camimg_canvas" class="videoCanvas"></canvas>');
		canvas = $canvas.get(0);

		var ctx = canvas.getContext("2d");
		//ctx.translate(0.5, 0.5);
		//ctx.imageSmoothingEnabled = false;

		var $backbuffer_canvas = $('<canvas id="backbuffer_canvas" style="display: none;"></canvas>');
		backbuffer_canvas = $backbuffer_canvas.get(0);
		$camimg_store.append($canvas);
		$camimg_store.append($backbuffer_canvas);
	}
	this.ClearFrontCanvas = function ()
	{
		ClearCanvas(canvas);
	}
	this.DrawFullCameraAsThumb = function (cameraId, groupId, CANVAS)
	{
		var thumbBounds = cameraListLoader.GetCameraBoundsInCurrentGroupImageUnscaled(cameraId, groupId);
		if (!thumbBounds)
			return false;
		var groupObj = cameraListLoader.GetCameraWithId(groupId);
		if (!groupObj)
			return false;

		if (!CANVAS)
			CANVAS = canvas;
		backbuffer_canvas.width = groupObj.width;
		backbuffer_canvas.height = groupObj.height;
		FitRectangleIntoCanvas(thumbBounds, backbuffer_canvas);

		var backbuffer_context2d = backbuffer_canvas.getContext("2d");
		backbuffer_context2d.clearRect(0, 0, backbuffer_canvas.width, backbuffer_canvas.height);

		var thumbW = thumbBounds[2] - thumbBounds[0];
		var thumbH = thumbBounds[3] - thumbBounds[1];

		if (debug_cameraChange_scaleOut_spotlight)
		{
			// Draw radial gradient under the thumbnail image
			var thumbCenterX = thumbBounds[0] + (thumbW / 2);
			var thumbCenterY = thumbBounds[1] + (thumbH / 2);
			var innerR = (thumbW + thumbH) / 2;
			var outerR = (groupObj.width + groupObj.height) / 4;
			var grd = backbuffer_context2d.createRadialGradient(thumbCenterX, thumbCenterY, innerR, thumbCenterX, thumbCenterY, outerR);
			grd.addColorStop(0, "#666666");
			grd.addColorStop(1, "#000000");
			backbuffer_context2d.fillStyle = grd;
			backbuffer_context2d.fillRect(0, 0, backbuffer_canvas.width, backbuffer_canvas.height);
		}

		// Draw rectangles around each image's grid space
		backbuffer_context2d.strokeStyle = "#888888";
		backbuffer_context2d.lineWidth = 2;
		var rects = cameraListLoader.GetGroupRects(groupId);
		for (var i = 0; i < rects.length; i++)
		{
			var rect = rects[i];
			backbuffer_context2d.strokeRect(rect[0], rect[1], rect[2] - rect[0], rect[3] - rect[1]);
		}
		backbuffer_context2d.drawImage(CANVAS
			, 0, 0, CANVAS.width, CANVAS.height
			, thumbBounds[0], thumbBounds[1], thumbW, thumbH);

		CANVAS.width = backbuffer_canvas.width;
		CANVAS.height = backbuffer_canvas.height;
		var context2d = CANVAS.getContext("2d");
		context2d.drawImage(backbuffer_canvas, 0, 0, CANVAS.width, CANVAS.height, 0, 0, CANVAS.width, CANVAS.height);
		return true;
	}
	this.DrawThumbAsFullCamera = function (cameraId, groupId, CANVAS)
	{
		var thumbBounds = cameraListLoader.GetCameraBoundsInCurrentGroupImageScaled(cameraId, groupId);
		if (!thumbBounds)
			return false;
		var cameraObj = cameraListLoader.GetCameraWithId(cameraId);
		if (!cameraObj)
			return false;

		if (!CANVAS)
			CANVAS = canvas;
		FitRectangleIntoCanvas(thumbBounds, CANVAS);

		backbuffer_canvas.width = cameraObj.width;
		backbuffer_canvas.height = cameraObj.height;

		var backbuffer_context2d = backbuffer_canvas.getContext("2d");

		backbuffer_context2d.drawImage(CANVAS
			, thumbBounds[0], thumbBounds[1], thumbBounds[2] - thumbBounds[0], thumbBounds[3] - thumbBounds[1]
			, 0, 0, backbuffer_canvas.width, backbuffer_canvas.height);

		$camimg_wrapper.css("width", backbuffer_canvas.width + "px").css("height", backbuffer_canvas.height + "px");
		CANVAS.width = backbuffer_canvas.width;
		CANVAS.height = backbuffer_canvas.height;
		var context2d = CANVAS.getContext("2d");
		context2d.drawImage(backbuffer_canvas, 0, 0, CANVAS.width, CANVAS.height, 0, 0, CANVAS.width, CANVAS.height);
		return true;
	}
	this.RenderImage = function (image)
	{
		CopyImageToCanvas(image, canvas);
	}
	this.RenderVideoFrame = function (video)
	{
		CopyVideoFrameToCanvas(video, canvas);
	}

	Initialize();
})();
///////////////////////////////////////////////////////////////
// Jpeg Video Module //////////////////////////////////////////
///////////////////////////////////////////////////////////////
function JpegVideoModule()
{
	/*
	A low level video player module which refreshes jpeg images using http.
	*/
	var self = this;
	var isInitialized = false;
	var isCurrentlyActive = false;
	var timeLastClipFrame = 0;
	var repeatedSameImageURLs = 1;
	var loadedFirstFrame = false;
	var lastRequestedSize = { w: 0, h: 0 };
	var lastReceivedSize = { w: 0, h: 0 };
	var lastLoadedTimeValue = -1;

	var currentImageRequestedAtMs = performance.now();
	var currentImageTimestampGuessUtc = -1;
	var staticSnapshotId = "";
	var lastSnapshotUrl = "";
	var lastSnapshotFullUrl = "";
	var honorAlertOffset = false;

	var playbackPaused = false;

	var clipPlaybackPosition = 0; // milliseconds

	var loading = new BICameraData();

	var $layoutbody = $("#layoutbody");
	var $camimg_wrapper = $("#camimg_wrapper");
	var $camimg_store = $("#camimg_store");
	// Contains URLs of the last image we started loading and the last image we loaded.
	var imageLoadingState = { loadingUrl: "", loadedUrl: "" };
	/** Contains critical timeline arguments which, if changed, will break the current timeline stream. If this string has changed, a new timeline stream must be started. */
	var lastTimelineCriticalArgs = "";
	/** A counter that is incremented each time we open a new video stream. Frames that arrive from a previous stream are discarded without being rendered.
	 * This was made necessary in Feb 2022 due to Jpeg video player changes to support the timeline. Specifically when timelineSync was added, it added an 
	 * unpredictable delay between updating the [loading] field and updating the [imageLoadingState] field... it is complicated. */
	var currentStreamId = 0;

	var Initialize = function ()
	{
		if (isInitialized)
			return;
		isInitialized = true;
		// Do one-time initialization here
		// Currently all relevant initialization is in videoModulesShared
	}
	function LoadImageFromUrl(url, streamId)
	{
		imageLoadingState.loadingUrl = url;

		var loadWithHeaders = true;
		var promise;
		if (loadWithHeaders)
			promise = DownloadToDataUri(url);
		else
			promise = new Promise(function (resolve, reject) { resolve({ dataUri: url, headers: null }); });

		promise
			.then(function (result)
			{
				if (currentStreamId !== streamId || imageLoadingState.loadingUrl !== url)
					return; // A new image began loading before this one completed; this result is no longer needed.
				return LoadImagePromise(result.dataUri, result.headers, result.imageSizeBytes);
			})
			.then(function (data)
			{
				if (currentStreamId !== streamId || imageLoadingState.loadingUrl !== url)
					return; // A new image began loading before this one completed; this result is no longer needed.
				var image = data.image;
				var headers = data.headers;
				var imageSizeBytes = data.imageSizeBytes;
				if (!imageSizeBytes)
					imageSizeBytes = 0;
				else
					bitRateCalc_Video.AddDataPoint(imageSizeBytes);

				ClearImageLoadTimeout();
				if (!isCurrentlyActive)
					return;

				if (!image.complete || typeof image.naturalWidth == "undefined" || image.naturalWidth == 0)
				{
					// Failed
					programmaticSoundPlayer.NotifyDisconnected();
				}
				else
				{
					programmaticSoundPlayer.NotifyReconnected();
					var isFirstFrame = !loadedFirstFrame;
					loadedFirstFrame = true;
					imageLoadingState.loadedUrl = url;
					var msLoadingTime = performance.now() - currentImageRequestedAtMs;
					if (lastReceivedSize.w !== image.naturalWidth || lastReceivedSize.h !== image.naturalHeight)
					{
						lastReceivedSize.w = image.naturalWidth;
						lastReceivedSize.h = image.naturalHeight;
					}
					if (headers)
						videoPlayer.GroupLayoutMetadataReceived(loading.id, headers["x-camlist"], headers["x-reclist"]);
					var frameUtc = currentImageTimestampGuessUtc >= 0 ? currentImageTimestampGuessUtc : parseInt(headers["x-utc"]);
					if (loading.isTimeline())
						clipPlaybackPosition = frameUtc;
					videoPlayer.ImageRendered({ id: loading.uniqueId, w: image.naturalWidth, h: image.naturalHeight, loadingTime: msLoadingTime, utc: frameUtc, isFirstFrame: isFirstFrame });
					playbackControls.FrameTimestampUpdated(false);

					videoModulesShared.RenderImage(image);

					var bitRate_Video = bitRateCalc_Video.GetBPS() * 8;

					if (nerdStats.IsOpen())
					{
						var loaded = videoPlayer.Loaded().image;
						var nativeRes = "";
						if (cameraListLoader.isDynamicLayoutEligible(loaded.id))
							nativeRes = ' <a href="javascript:OpenGroupSettings()">[edit]</a>';
						else
						{
							nativeRes = " (Native: " + loading.getFullRect().toString() + ")";
							if (loading.fullwidth !== loaded.actualwidth || loading.fullheight !== loaded.actualheight)
								nativeRes = '<span class="nonMatchingNativeRes">' + nativeRes + '</span>';
						}

						var digitalZoom = '<span title="Digital Zoom Factor"> \uD83D\uDD0D' + imageRenderer.zoomHandler.GetZoomFactor().toFixed(2) + 'x</span>';

						nerdStats.BeginUpdate();
						nerdStats.UpdateStat("Viewport", null, $layoutbody.width() + "x" + $layoutbody.height() + GetDevicePixelRatioTag() + digitalZoom);
						nerdStats.UpdateStat("Stream Resolution", null, loaded.getActualRect().toString() + nativeRes);
						if (!loaded.getActualRect().Equals(loaded.getRequestedRect()))
							nerdStats.UpdateStat("Requested Res", null, '<span class="requestedRes">' + loaded.getRequestedRect().toString() + '</span>');
						if (loading.isLive)
							nerdStats.UpdateStat("Seek Position", "LIVE");
						else if (loading.isTimeline())
							nerdStats.UpdateStat("Seek Position", MsToDHMS(frameUtc - GetUtcNow(), false, true));
						else
							nerdStats.UpdateStat("Seek Position", (self.GetSeekPercent() * 100).toFixed() + "%");
						nerdStats.UpdateStat("Frame Time", GetDateStr(new Date(frameUtc + GetServerTimeOffset()), true));
						nerdStats.UpdateStat("Codecs", "jpeg");
						nerdStats.UpdateStat("Jpeg Bit Rate", bitRate_Video, formatBitsPerSecond(bitRate_Video, 1), true);
						var fps = fpsCounter.peekFPS();
						nerdStats.UpdateStat("Jpeg Frame Size", imageSizeBytes, formatBytes(imageSizeBytes, 2), true);
						nerdStats.UpdateStat("Jpeg Loading Time", msLoadingTime, Math.round(msLoadingTime) + "ms", true);
						nerdStats.UpdateStat("Jpeg Frame Rate", fps, fps.toFixed(0) + " FPS", true);
						nerdStats.EndUpdate();
					}

					statusAreaApi.setValue("Stream Bit Rate", { video: bitRate_Video, audio: 0 });
					statusAreaApi.setValue("Stream Delay", { netDelay: msLoadingTime, playerDelay: 0 });
					statusAreaApi.setValue("Audio Buffer", 0);
				}
				GetNewImage();
			})
			.catch(function (data)
			{
				programmaticSoundPlayer.NotifyDisconnected();
				ClearImageLoadTimeout();
				setTimeout(GetNewImage, 1000);
			})
			.finally(function ()
			{
				timelineSync.unlock();
			});
	}
	var Activate = function ()
	{
		if (isCurrentlyActive)
			return;
		isCurrentlyActive = true;
		// Show yourself
		videoModulesShared.ClearFrontCanvas();
		videoOverlayHelper.ShowLoadingOverlay(true);
		videoModulesShared.Get$Canvas().appendTo($camimg_wrapper);
	}
	this.Deactivate = function ()
	{
		if (!isCurrentlyActive)
			return;
		isCurrentlyActive = false;
		loadedFirstFrame = false;
		// Stop what you are doing and hide
		//clipPlaybackPosition = 0;
		ClearImageLoadTimeout();
		ClearGetNewImageTimeout();
		videoModulesShared.Get$Canvas().appendTo($camimg_store);
	}
	this.GetPlayerElement = function ()
	{
		return videoModulesShared.GetCanvas();
	}
	this.VisibilityChanged = function (visible)
	{
	}
	this.LoadedFrameSinceActivate = function ()
	{
		return loadedFirstFrame;
	}
	var openVideoTimeout = null;
	var lastOpenVideoCallAt = -60000;
	var lastStreamBeganAt = 0;
	var timeBetweenOpenVideoCalls = 300;
	this.OpenVideo = function (videoData, offsetPercent, startPaused)
	{
		developerLog("JpegVideoModule.OpenVideo(", videoData, offsetPercent, startPaused, ")");
		if (skipLoadingFirstVideoStream || skipLoadingAllVideoStreams)
		{
			developerLog("JpegVideoModule.OpenVideo -> Skipping Stream");
			skipLoadingFirstVideoStream = false;
			return;
		}
		if (!videoData || !videoData.id)
			return;
		if (openVideoTimeout != null)
			clearTimeout(openVideoTimeout);

		var perfNow = performance.now();
		var waited = perfNow - lastOpenVideoCallAt;
		if (waited < timeBetweenOpenVideoCalls)
		{
			openVideoTimeout = setTimeout(function ()
			{
				self.OpenVideo(videoData, offsetPercent, startPaused);
			}, timeBetweenOpenVideoCalls - waited);
			return;
		}
		lastOpenVideoCallAt = perfNow;
		developerLog("jpeg.OpenVideo");

		if (videoPlayer.handleDisabledCamera(videoData))
			return;
		var previousStreamWasTimeline = loading && loading.isTimeline();
		loading.CopyValuesFrom(videoData);
		honorAlertOffset = offsetPercent === -1;
		if (!offsetPercent)
			offsetPercent = 0;
		if (loading.isLive)
			startPaused = false;
		if (!loading.isLive && startupPaused)
		{
			// We don't allow live video to start paused due to a long-standing bugs where the live video will just render black if we do.
			console.log("Starting video paused");
			startPaused = true;
		}
		startupPaused = false;
		Activate();
		if (playbackControls.GetPlayReverse() && offsetPercent === 0)
			offsetPercent = 1;
		clipPlaybackPosition = Clamp(offsetPercent, 0, 1) * (loading.msec - 1);
		timeLastClipFrame = performance.now();
		if (startPaused)
			self.Playback_Pause();
		else
			self.Playback_Play();
		videoOverlayHelper.ShowLoadingOverlay(true);
		currentStreamId++;
		if (loading.isTimeline())
		{
			developerLog("JpegVideoModule -> isTimeline");
			videoPlayer.lastFrameUtc = loading.timelineStart;
			clipPlaybackPosition = loading.timelineStart;
			loading.newTimelineStream = true;
		}
		else if (!loading.isLive)
		{
			var clipData = clipLoader.GetClipFromId(loading.uniqueId);
			if (clipData)
			{
				var offset = clipData.isClip ? 0 : clipData.offsetMs;
				videoPlayer.lastFrameUtc = (clipData.date.getTime() - offset) + clipPlaybackPosition;
				if (!clipData.isSnapshot && !clipData.isClip)
				{
					if (honorAlertOffset && !NumberHasFlags(clipData.flags, BIDBFLAG.ALERT_OFFSETTIME))
						toaster.Warning("Blue Iris did not provide an offset in milliseconds for this alert, so it may begin at the wrong position.", 10000);
					// Load clip stats for this alert.
					clipStatsLoader.LoadClipStats("@" + clipData.clipId, function (stats)
					{
						clipLoader.ApplyMissingStatsToClipData(stats, clipData);
						if (loading.uniqueId == clipData.recId)
							loading.msec = stats.msec;
						var loadingImg = videoPlayer.Loading().image;
						if (loadingImg.uniqueId == clipData.recId)
							loadingImg.msec = stats.msec;
					});
				}
			}
		}
		else
			videoPlayer.lastFrameUtc = GetUtcNow();
		GetNewImage();
		UpdateCurrentURL();
		BI_CustomEvent.Invoke("OpenVideo", loading);
	}
	this.GetSeekPercent = function ()
	{
		var lastMs = loading.msec - 1;
		if (lastMs === 0)
			return 0;
		else
			return Clamp(clipPlaybackPosition / lastMs, 0, 1);
	}
	this.GetLastSnapshotUrl = function ()
	{
		// This is the jpeg video player.
		var sizeQualityArgs = JpegSnapshotArgs(loading);
		var groupArgs = groupCfg.GetUrlArgs(loading);
		if (loading.isLive)
			return RemoveUrlParameters(lastSnapshotUrl, "w", "h", "q", "stream") + sizeQualityArgs + groupArgs;
		else if (loading.isTimeline())
			return RemoveUrlParameters(lastSnapshotUrl, "pos", "speed", "skipdeadair", "opaque", "w", "h", "q", "stream", "nc") + "&isolate&pos=" + videoPlayer.lastFrameUtc.dropDecimalsStr() + sizeQualityArgs + groupArgs;
		else
			return RemoveUrlParameters(lastSnapshotUrl, "w", "h", "q", "stream") + sizeQualityArgs;
	}
	this.GetLastSnapshotFullUrl = function ()
	{
		return lastSnapshotFullUrl;
	}
	this.GetClipPlaybackPositionMs = function ()
	{
		return clipPlaybackPosition.dropDecimals();
	}
	this.GetStaticSnapshotId = function ()
	{
		return staticSnapshotId;
	}
	this.GetOffsetFromStartMs = function ()
	{
		if (self.Playback_IsPaused())
			return 0;
		else
			return performance.now() - lastStreamBeganAt;
	}
	var GetNewImage = function ()
	{
		timelineSync.run(this, GNI_Internal);
	}
	/** Called by GetNewImage to do all the real work after obtaining the lock on timelineSync. */
	var GNI_Internal = function ()
	{
		ClearGetNewImageTimeout();
		if (currentServer.isLoggingOut || !isCurrentlyActive)
		{
			timelineSync.unlock();
			return;
		}
		var timeValue = currentImageRequestedAtMs = performance.now();
		var isLoadingRecordedSnapshot = false;
		var isVisible = !documentIsHidden();

		var sizeToRequest = imageRenderer.GetSizeToRequest(loading);
		var sizeArgs = "&w=" + sizeToRequest.w + "&h=" + sizeToRequest.h; // Also included in qualityArg later

		var overlayArgs = "";
		var timelineSpeedArg = "";
		var timelinePosArg = "";
		var timelineCriticalArgs = null;

		if (loading.isTimeline())
		{
			if (!clipPlaybackPosition)
				clipPlaybackPosition = clipTimeline.getCurrentTime();
			clipPlaybackPosition = clipTimeline.BoundsCheckTimelineMs(clipPlaybackPosition);
			if (!clipPlaybackPosition)
			{
				timelineSync.unlock();
				videoPlayer.goLive();
				return;
			}

			overlayArgs = clipOverlayCfg.GetUrlArgs("*ui3_timeline_pseudocam");

			var speedMultiplier = playbackControls.GetPlaybackSpeed();
			if (playbackPaused || clipTimeline.timelineDidPauseVideo() || !isVisible)
			{
				self.Playback_Pause();
				speedMultiplier = 0;
				loading.newTimelineStream = true;
			}
			else
				speedMultiplier = (Math.round(100 * speedMultiplier) * (playbackControls.GetPlayReverse() ? -1 : 1));
			var speedArg = "&speed=" + speedMultiplier;
			timelineCriticalArgs = overlayArgs + speedArg;
			if (cameraListLoader.CameraIsGroup(cameraListLoader.GetCameraWithId(loading.id)))
				timelineCriticalArgs += sizeArgs;
			if (lastTimelineCriticalArgs !== timelineCriticalArgs)
			{
				clipPlaybackPosition = clipTimeline.getCurrentTime();
				loading.newTimelineStream = true;
			}

			if (loading.newTimelineStream)
			{
				currentStreamId++;
				timelineSpeedArg = speedArg;
				timelinePosArg = "&pos=" + clipPlaybackPosition.dropDecimalsStr();
				timelinePosArg += playbackControls.GetSkipDeadAirArg();
				if (loading.timelineJump)
				{
					timelinePosArg += "&jump=" + loading.timelineJump;
					loading.timelineJump = 0;
				}
			}
			else
			{
				timelinePosArg = "&nc=" + timeValue.dropDecimalsStr(); // "nc" is for redundant cache-busting and also so some later code knows the player isn't paused.
			}
		}
		else if (!loading.isLive)
		{
			var timePassed = timeValue - timeLastClipFrame;
			timeLastClipFrame = timeValue.toFixed(0);
			var speedMultiplier = playbackControls.GetPlaybackSpeed();
			timePassed *= speedMultiplier;
			if (playbackPaused || playbackControls.IsSeekbarDragging() || !isVisible)
				timePassed = 0;
			else if (playbackControls.GetPlayReverse())
				timePassed *= -1;
			clipPlaybackPosition += timePassed;

			var clipData = clipLoader.GetClipFromId(loading.uniqueId);
			if (honorAlertOffset && clipData)
			{
				clipPlaybackPosition = clipData.offsetMs; // This offset is where the alert begins within the clip.
				if (playbackControls.GetPlayReverse()) // If playing in reverse, lets start at the end of the alert's bounds.
					clipPlaybackPosition += clipData.roughLengthMs;
			}
			honorAlertOffset = false;

			if (clipPlaybackPosition < 0)
			{
				clipPlaybackPosition = 0;
				videoPlayer.Playback_Ended(true);
			}
			else if (clipPlaybackPosition >= loading.msec)
			{
				clipPlaybackPosition = loading.msec - 1;
				videoPlayer.Playback_Ended(false);
			}
			timeValue = clipPlaybackPosition;
			if (clipData)
			{
				isLoadingRecordedSnapshot = clipData.isSnapshot;
				if (isLoadingRecordedSnapshot)
					staticSnapshotId = loading.uniqueId;
				else
					staticSnapshotId = "";
				overlayArgs = clipOverlayCfg.GetUrlArgs(clipData.camera);
			}
		}

		var qualityArg = genericQualityHelper.GetCurrentProfile().GetUrlArgs(loading);

		var groupArgs = groupCfg.GetUrlArgs(loading);

		// We force the session arg into all image requests because we don't need them to be cached and we want copied URLs to work without forcing login.
		if (loading.isTimeline())
			lastSnapshotUrl = currentServer.remoteBaseURL + "time/" + loading.path + '?jpeg' + timelineSpeedArg + timelinePosArg + currentServer.GetAPISessionArg("&", true) + '&opaque=' + ui3InstanceId + overlayArgs + playbackControls.GetSpeedBasedSubstreamArgument();
		else if (loading.isLive)
			lastSnapshotUrl = currentServer.remoteBaseURL + "image/" + loading.path + '?nc=' + timeValue.dropDecimalsStr() + currentServer.GetAPISessionArg("&", true);
		else
			lastSnapshotUrl = currentServer.remoteBaseURL + "file/clips/" + loading.path + '?time=' + timeValue.dropDecimalsStr() + currentServer.GetAPISessionArg("&", true) + overlayArgs + playbackControls.GetSpeedBasedSubstreamArgument();
		var imgSrcPath = lastSnapshotFullUrl = lastSnapshotUrl + qualityArg + groupArgs;

		if (imageLoadingState.loadedUrl == imgSrcPath)
		{
			timelineSync.unlock();
			videoOverlayHelper.HideLoadingOverlay();
			GetNewImageAfterTimeout();
		}
		else
		{
			if ((lastLoadedTimeValue == timeValue
				&& loading.uniqueId == videoPlayer.Loaded().image.uniqueId
				&& !CouldBenefitFromSizeChange(sizeToRequest)
				&& loadedFirstFrame)
				|| !isVisible
				|| (playbackPaused && loading.isLive) // Live video can be paused since UI3-175
			)
			{
				timelineSync.unlock();
				if (isLoadingRecordedSnapshot)
					videoOverlayHelper.HideLoadingOverlay();
				GetNewImageAfterTimeout();
			}
			else
			{
				if (timelineCriticalArgs !== null)
					lastTimelineCriticalArgs = timelineCriticalArgs;
				loading.newTimelineStream = false;
				lastRequestedSize = sizeToRequest;
				repeatedSameImageURLs = 1;
				SetImageLoadTimeout();
				lastLoadedTimeValue = timeValue;
				currentImageTimestampGuessUtc = loading.isLive ? GetUtcNow() : -1;
				videoPlayer.notifyImageLoading(loading, lastRequestedSize);
				LoadImageFromUrl(imgSrcPath, currentStreamId);
			}
		}
	}
	var CouldBenefitFromSizeChange = function (newSize)
	{
		if (cameraListLoader.isDynamicLayoutEnabled(loading.id))
			return (newSize.w > lastRequestedSize.w && loading.fullwidth > lastRequestedSize.w)
				|| (newSize.h > lastRequestedSize.h && loading.fullheight > lastRequestedSize.h);
		else
			return (newSize.w > lastRequestedSize.w && loading.fullwidth > lastRequestedSize.w);
	}

	this.Playback_IsPaused = function ()
	{
		return playbackPaused;
	}
	this.Playback_Pause = function ()
	{
		if (!playbackPaused)
		{
			playbackPaused = true;
			playbackControls.setPlayPauseButtonState(playbackPaused);
			BI_CustomEvent.Invoke("Playback_Pause", loading);
		}
	}
	this.Playback_Play = function ()
	{
		if (playbackPaused)
		{
			lastStreamBeganAt = performance.now();
			playbackPaused = false;
			playbackControls.setPlayPauseButtonState(playbackPaused);
			if (loading.isTimeline())
			{
				loading.newTimelineStream = true;
				clipPlaybackPosition = clipTimeline.getCurrentTime();
			}
			else if (!loading.isLive)
			{
				if (clipPlaybackPosition >= loading.msec - 1 && !playbackControls.GetPlayReverse())
					clipPlaybackPosition = 0;
				else if (clipPlaybackPosition <= 0 && playbackControls.GetPlayReverse())
					clipPlaybackPosition = loading.msec - 1;
				if (clipPlaybackPosition < 0)
					clipPlaybackPosition = 0;
			}
			BI_CustomEvent.Invoke("Playback_Play", loading);
		}
	}
	this.NotifyClipMetadataChanged = function (clipData)
	{
		loading.msec = clipData.msec;
	}
	this.DrawFullCameraAsThumb = function (cameraId, groupId)
	{
		return videoModulesShared.DrawFullCameraAsThumb(cameraId, groupId);
	}
	this.DrawThumbAsFullCamera = function (cameraId, groupId)
	{
		return videoModulesShared.DrawThumbAsFullCamera(cameraId, groupId);
	}
	var imgLoadTimeout = null;
	var SetImageLoadTimeout = function ()
	{
		ClearImageLoadTimeout();
		imgLoadTimeout = setTimeout(function ()
		{
			console.error("Image load timed out");
			GetNewImage();
		}, 15000);
	}
	var ClearImageLoadTimeout = function ()
	{
		if (imgLoadTimeout != null)
		{
			clearTimeout(imgLoadTimeout);
			imgLoadTimeout = null;
		}
	}
	var getNewImageTimeout = null;
	/** Calls GetNewImage after increasing delay, to reduce CPU usage a bit while idling */
	var GetNewImageAfterTimeout = function ()
	{
		getNewImageTimeout = setTimeout(GetNewImage, Math.min(500, 25 + 2 * repeatedSameImageURLs++));
	}
	var ClearGetNewImageTimeout = function ()
	{
		if (getNewImageTimeout != null)
		{
			clearTimeout(getNewImageTimeout);
			getNewImageTimeout = null;
		}
	}
	Initialize();
}
///////////////////////////////////////////////////////////////
// Fetch H264 Video Module ////////////////////////////////////
// Using OpenH264_Player or Pnacl_Player or HTML5_MSE_Player //
// or WebCodec_Player ////////////////////////////////////////
///////////////////////////////////////////////////////////////
var currentH264Player = null;
function SetH264PlayerPreference(val)
{
	settings.ui3_h264_choice4 = val;
}
function FetchH264VideoModule()
{
	/*
	A low level video player module which streams H.264 using the fetch API, and decodes/plays it using JavaScript.
	*/
	var self = this;
	var isInitialized = false;
	var isCurrentlyActive = false;
	var lastActivatedAt = 0;
	var h264_player;
	var currentSeekPositionPercent = 0;
	var lastFrameAt = 0;
	var lastStreamBeganAt = 0;
	var playbackPaused = false;
	var perfMonInterval;
	var nerdStatsRefreshInterval = null;
	var isLoadingRecordedSnapshot = false;
	var endSnapshotDisplayTimeout = null;
	var failLimiter = new FailLimiter(5, 20000);
	var reconnectDelayedToast = new PersistentToast("reconnectDelayedToast", "ERROR", true);
	var reconnectingToast = new PersistentToast("reconnectingToast", "WARNING");
	var failureRecoveryTimeout = null;
	var didRequestAudio = false;
	var canRequestAudio = false;
	var streamHasAudio = 0; // -1: no audio, 0: unknown, 1: audio
	var lastFrameMetadata = { width: 0, height: 0, pos: 0, timestamp: 0, rawtime: 0, utc: Date.now(), expectedInterframe: 100, size: 0 };
	var framesSinceLastKeyframe = 0;
	var audioCodec = "";

	var loading = new BICameraData();

	var $layoutbody = $("#layoutbody");
	var $volumeBar = $("#volumeBar");

	var lastStatusBlock = null;

	var lastRequestedSize = null;
	var AfterResized2Debounced = debounce(AfterResized2, 250);
	BI_CustomEvent.AddListener("afterResize", AfterResized);

	var Initialize = function (h264PlayerChoice)
	{
		if (isInitialized)
			return;
		isInitialized = true;
		// Do one-time initialization here
		//console.log("Initializing h264_player");

		// Automatic player selection works by having the value "Automatic" fail to match any of the H.264 players.
		// So control falls to the automatic player selection algorithm which recursively calls Initialize() with the chosen player as an argument.
		if (!h264PlayerChoice)
			h264PlayerChoice = settings.ui3_h264_choice4;
		else if (settings.ui3_h264_choice4 !== H264PlayerOptions.Automatic)
			SetH264PlayerPreference(h264PlayerChoice);

		currentH264Player = h264PlayerChoice;

		if (webcodecs_h264_player_supported && h264PlayerChoice === H264PlayerOptions.WebCodecs)
			h264_player = window.webcodec_player_instance = new WebCodec_Player(FrameRendered, PlaybackReachedNaturalEnd);
		else if (mse_mp4_h264_supported &&
			(h264PlayerChoice === H264PlayerOptions.HTML5
				|| (h264PlayerChoice === H264PlayerOptions.WebCodecs && !webcodecs_h264_player_supported)))
			h264_player = new HTML5_MSE_Player(FrameRendered, PlaybackReachedNaturalEnd, playerErrorCb);
		else if (pnacl_player_supported &&
			(h264PlayerChoice === H264PlayerOptions.NaCl_HWVA_Auto
				|| h264PlayerChoice === H264PlayerOptions.NaCl_HWVA_No
				|| h264PlayerChoice === H264PlayerOptions.NaCl_HWVA_Yes))
			h264_player = new Pnacl_Player(FrameRendered, PlaybackReachedNaturalEnd);
		else if (h264_js_player_supported && h264PlayerChoice === H264PlayerOptions.JavaScript)
			h264_player = new OpenH264_Player(FrameRendered, PlaybackReachedNaturalEnd);
		else
		{
			// This is the automatic player selection algorithm:
			var isAndroidFF = BrowserIsAndroid() && BrowserIsFirefox();
			var isIOS16_4_upto17 = GetIOSVersion()[0] === 16 && GetIOSVersion()[1] >= 4;
			var isIOS17_ornewer = GetIOSVersion()[0] >= 17;

			var preferredOrder = [H264PlayerOptions.HTML5, H264PlayerOptions.WebCodecs, H264PlayerOptions.JavaScript, H264PlayerOptions.NaCl_HWVA_Auto];
			if (isIOS17_ornewer)
				preferredOrder = [H264PlayerOptions.WebCodecs, H264PlayerOptions.JavaScript, H264PlayerOptions.HTML5];
			else if (isIOS16_4_upto17)
				preferredOrder = [H264PlayerOptions.JavaScript];
			else if (isAndroidFF)
				preferredOrder = [H264PlayerOptions.WebCodecs, H264PlayerOptions.JavaScript];

			for (var i = 0; i < preferredOrder.length; i++)
			{
				var player = preferredOrder[i];
				if (isCompatiblePlayer(player))
				{
					isInitialized = false;
					Initialize(player);
					return;
				}
			}
			toaster.Error("No H.264 player is supported.");
		}
	}
	var postInitialize = function ()
	{
		if (h264_player)
		{
			perfMonInterval = setInterval(MeasurePerformance, 2500);
			nerdStatsRefreshInterval = setInterval(refreshNerdStats, 16);
		}
	}
	var isCompatiblePlayer = function (player)
	{
		if (player === H264PlayerOptions.HTML5)
			return mse_mp4_h264_supported;
		else if (player === H264PlayerOptions.WebCodecs)
			return webcodecs_h264_player_supported;
		else if (player === H264PlayerOptions.JavaScript)
			return h264_js_player_supported;
		else if (player === H264PlayerOptions.NaCl_HWVA_Auto || player === H264PlayerOptions.NaCl_HWVA_Yes || player === H264PlayerOptions.NaCl_HWVA_No)
			return pnacl_player_supported;
		else
			return false;
	}
	var Activate = function ()
	{
		if (isCurrentlyActive)
			return;
		isCurrentlyActive = true;
		lastActivatedAt = performance.now();
		// Show yourself
		//console.log("Activating h264_player");
		$volumeBar.removeClass("audioTemporarilyUnavailable");
		h264_player.Toggle(true);
		h264_player.ClearDrawingSurface();
		videoOverlayHelper.ShowLoadingOverlay(true);
	}
	this.Deactivate = function ()
	{
		if (!isCurrentlyActive)
			return;
		isCurrentlyActive = false;
		// Stop what you are doing and hide
		//console.log("Deactivating h264_player");
		$volumeBar.addClass("audioTemporarilyUnavailable");
		StopStreaming();
		h264_player.Toggle(false);
	}
	this.GetPlayerElement = function ()
	{
		return h264_player.GetPlayerElement();
	}
	this.GetPlayerObject = function ()
	{
		return h264_player;
	}
	var StopStreaming = function ()
	{
		clearTimeout(failureRecoveryTimeout);
		clearTimeout(endSnapshotDisplayTimeout);
		safeFetch.CloseStream();
		h264_player.Flush();
		pcmPlayer.Reset();
		if (!safeFetch.IsActive())
			volumeIconHelper.setColorIdle();
		setTimeout(MeasurePerformance, 0);
	}
	this.VisibilityChanged = function (visible)
	{
		if (settings.ui3_pause_when_hidden !== "1")
			return;
		if (pictureInPictureController.isPictureInPictureEnabled())
			return;
		if (visible && isCurrentlyActive)
		{
			if (loading.isLive)
				self.OpenVideo(loading.UpdateTimelineStart());
			else if (!playbackPaused)
				self.Playback_Play();
		}
		else if (!ui3ClipIsExporting)
		{
			StopStreaming();
		}
	}
	this.LoadedFrameSinceActivate = function ()
	{
		return h264_player.GetRenderedFrameCount() > 0;
	}
	var AreSameClip = function (uid1, uid2)
	{
		var cd1 = clipLoader.GetClipFromId(uid1);
		var cd2 = clipLoader.GetClipFromId(uid2);
		if (cd1 && cd2 && cd1.clipId == cd2.clipId)
			return true;
		return false;
	}
	var openVideoTimeout = null;
	this.OpenVideo = function (videoData, offsetPercent, startPaused)
	{
		developerLog("FetchH264VideoModule.OpenVideo(", videoData, offsetPercent, startPaused, ")");
		if (skipLoadingFirstVideoStream || skipLoadingAllVideoStreams)
		{
			developerLog("FetchH264VideoModule.OpenVideo -> Skipping Stream");
			skipLoadingFirstVideoStream = false;
			return;
		}
		if (!videoData || !videoData.id)
			return;
		// Delay if the player has not fully loaded yet.
		if (openVideoTimeout != null)
			clearTimeout(openVideoTimeout);
		if (!h264_player.IsLoaded())
		{
			developerLog("!h264_player.IsLoaded(). Re-queuing action.");
			openVideoTimeout = setTimeout(function ()
			{
				self.OpenVideo(videoData, offsetPercent, startPaused);
			}, 5);
			return;
		}
		developerLog("h264.OpenVideo");

		if (videoPlayer.handleDisabledCamera(videoData))
			return;
		var isSameClipAsBefore = AreSameClip(loading.uniqueId, videoData.uniqueId);
		loading = new BICameraData();
		loading.CopyValuesFrom(videoData);
		var honorAlertOffset = offsetPercent === -1;
		if (!offsetPercent)
			offsetPercent = 0;
		if (loading.isLive)
			startPaused = false;
		if (!loading.isLive && startupPaused)
		{
			// We don't allow live video to start paused due to a long-standing bugs where the live video will just render black if we do.
			console.log("Starting video paused");
			startPaused = true;
		}
		startupPaused = false;
		Activate();
		lastStatusBlock = null;
		if (playbackControls.GetPlayReverse() && offsetPercent === 0)
			offsetPercent = 1;
		currentSeekPositionPercent = Clamp(offsetPercent, 0, 1);
		lastStreamBeganAt = lastFrameAt = performance.now();
		isLoadingRecordedSnapshot = false;
		clearTimeout(failureRecoveryTimeout);
		clearTimeout(endSnapshotDisplayTimeout);
		streamHasAudio = 0;
		didRequestAudio = pcmPlayer.AudioEnabled();
		canRequestAudio = true;
		var audioArg = "&audio=";
		if (!didRequestAudio)
			audioArg += "0";
		else if (flac_supported && settings.ui3_audio_codec === "FLAC")
			audioArg += "2";
		else
			audioArg += "1";
		var overlayArgs = "";
		var videoUrl;
		var groupArgs = groupCfg.GetUrlArgs(loading);
		var profileArgs = genericQualityHelper.GetCurrentProfile().GetUrlArgs(loading);
		lastRequestedSize = imageRenderer.GetSizeToRequest(loading, genericQualityHelper.GetCurrentProfile());
		videoPlayer.notifyImageLoading(loading, lastRequestedSize);
		var fetchOptions = { timestampScale: 1 };
		if (loading.isTimeline())
		{
			developerLog("FetchH264VideoModule -> isTimeline");
			// Seeking with /time/set is disabled because its performance was terrible during testing. 
			// Besides, the video stream ends when the user begins to seek, so /time/set is not even 
			// appropriate unless we change how pausing works just for the timeline stream... yuck.
			//var loaded = videoPlayer.Loaded().image;
			//if (loaded.isTimeline() && loaded.id === loading.id && !self.Playback_IsPaused())
			//{
			//	videoPlayer.TimelineSeek(loading.timelineStart);
			//	return;
			//}
			videoPlayer.lastFrameUtc = loading.timelineStart;
			var jumpArg = "";
			if (loading.timelineJump)
			{
				jumpArg = "&jump=" + loading.timelineJump;
				loading.timelineJump = 0;
			}
			if (startPaused)
			{
				// I hate hacks. This is definitely a hack, but it is a lot easier to load a scrubbing jpeg than it is to play one frame of H.264 video in the HTML5 player.
				StopStreaming();
				reconnectDelayedToast.hide();
				self.Playback_Pause();
				// Must delay for a 0ms timeout so that StopStreaming() method has a chance to take effect (aborting a fetch is asynchronous, but otherwise should be immediate).
				// Otherwise the downloadSeekPreview method will see a fetch is still active, and will not proceed.
				setTimeout(function ()
				{
					timelineSync.run(this, function ()
					{
						clipTimeline.getVue().downloadSeekPreview(loading.timelineStart, jumpArg);
						UpdateCurrentURL();
						BI_CustomEvent.Invoke("OpenVideo", loading);
					});
				}, 0);
				return;
			}
			var speed = 100 * playbackControls.GetPlaybackSpeed();
			if (playbackControls.GetPlayReverse())
				speed *= -1;
			var speedArg = "&speed=" + Math.round(speed);
			var skipDeadAirArg = playbackControls.GetSkipDeadAirArg();
			overlayArgs = clipOverlayCfg.GetUrlArgs("*ui3_timeline_pseudocam");
			videoUrl = currentServer.remoteBaseURL + "time/" + loading.path + currentServer.GetAPISessionArg("?", true) + '&opaque=' + ui3InstanceId + '&pos=' + Math.floor(loading.timelineStart) + jumpArg + audioArg + profileArgs + groupArgs + speedArg + skipDeadAirArg + "&extend=2" + overlayArgs + playbackControls.GetSpeedBasedSubstreamArgument();
		}
		else if (loading.isLive)
		{
			videoPlayer.lastFrameUtc = GetUtcNow();
			videoUrl = currentServer.remoteBaseURL + "video/" + loading.path + "/2.0" + currentServer.GetAPISessionArg("?", true) + audioArg + profileArgs + groupArgs + "&extend=2";
		}
		else
		{
			var speed = 100 * playbackControls.GetPlaybackSpeed();
			if (playbackControls.GetPlayReverse())
				speed *= -1;
			if (startPaused)
				speed = 0;
			var clipData = clipLoader.GetClipFromId(loading.uniqueId);
			var reqMs = null;
			var path = loading.path;
			if (clipData)
			{
				isLoadingRecordedSnapshot = clipData.isSnapshot;
				if (!clipData.isSnapshot && !clipData.isClip)
				{
					clipStatsLoader.LoadClipStats("@" + clipData.clipId, function (stats)
					{
						clipLoader.ApplyMissingStatsToClipData(stats, clipData);
						if (loading.uniqueId == clipData.recId)
							loading.msec = stats.msec;
						var loadingImg = videoPlayer.Loading().image;
						if (loadingImg.uniqueId == clipData.recId)
							loadingImg.msec = stats.msec;
					});
				}
				var lastMs = (clipData.msec - 1);
				if (honorAlertOffset && !clipData.isSnapshot)
				{
					var offsetMs = clipData.offsetMs;
					if (!clipData.isClip && !NumberHasFlags(clipData.flags, BIDBFLAG.ALERT_OFFSETTIME))
					{
						toaster.Warning("Blue Iris did not provide an offset in milliseconds for this alert, so it may begin at the wrong position.", 10000);
						path = clipData.alertPath;
					}
					else
					{
						// We are starting the alert at a specific offset that was provided in milliseconds.
						if (speed < 0) // If playing in reverse, lets start at the end of the alert's bounds.
							offsetMs += clipData.roughLengthMs;
						reqMs = offsetMs;
					}
					// The "pos" argument must be provided alongside "kbseek", even though "pos" will be ignored by Blue Iris.
					// We recalculate the seek position here anyway because it helps with UI accuracy before the first frame arrives.
					if (lastMs === 0)
						currentSeekPositionPercent = 0;
					else
						currentSeekPositionPercent = Clamp(offsetMs / lastMs, 0, 1);
				}
				videoPlayer.lastFrameUtc = clipData.date.getTime() + (currentSeekPositionPercent * lastMs);
				overlayArgs = clipOverlayCfg.GetUrlArgs(clipData.camera);
			}
			if (speed !== 100)
			{
				canRequestAudio = false; // We won't receive audio if speed isn't exactly 100
				didRequestAudio = false;
				audioArg = "";
			}
			var posInt = parseInt(currentSeekPositionPercent * 10000);
			if (speed === 0 && posInt >= 10000)
				posInt = 9999;
			var posArg = "&pos=" + posInt;
			if (honorAlertOffset)
				posArg = "";
			if (isSameClipAsBefore && reqMs === null)
			{
				// Another hack to work around API limitations.
				// This allows us to seek frame-by-frame with millisecond precision 
				// instead of precision equalling 1/10000th of the clip's duration.
				// isSameClipAsBefore helps ensure we have an accurate msec value.
				var offsetMsec = currentSeekPositionPercent === 1 && !startPaused ? 0 : -1;
				reqMs = (currentSeekPositionPercent * (loading.msec + offsetMsec)).dropDecimals();
				posArg = "";
			}
			if (speed === 0)
			{
				// speed == 0 means we'll get a jpeg
				// set quality to 50
				profileArgs = RemoveUrlParameters(profileArgs, "q") + "&q=50";
			}
			var offsetArg = "";
			if (reqMs !== null)
			{
				reqMs = Clamp(reqMs, 0, loading.msec - 1);
				offsetArg = "&time=" + reqMs;
				loading.requestedMs = reqMs;
			}
			speed = Math.round(speed);
			fetchOptions.timestampScale = speed / 100;
			videoUrl = currentServer.remoteBaseURL + "file/clips/" + path + currentServer.GetAPISessionArg("?", true) + posArg + "&speed=" + speed + audioArg + profileArgs + "&extend=2" + offsetArg + overlayArgs + playbackControls.GetSpeedBasedSubstreamArgument();
		}
		// We can't 100% trust loading.audio, but we can trust it enough to use it as a hint for the GUI.
		volumeIconHelper.setEnabled(loading.audio);
		if (didRequestAudio && loading.audio)
			volumeIconHelper.setColorLoading();
		else
			volumeIconHelper.setColorIdle();
		videoOverlayHelper.ShowLoadingOverlay(true);
		reconnectDelayedToast.hide();
		if (startPaused)
		{
			self.Playback_Pause(); // If opening the stream while paused, the stream will stop after one frame.
			safeFetch.OpenStream(videoUrl, headerCallback, acceptFrame, acceptStatusBlock, streamInfoCallback, StreamEnded, fetchOptions);
		}
		else
		{
			playbackPaused = false;
			playbackControls.setPlayPauseButtonState(playbackPaused);
			// Calling StopStream before opening the new stream will drop any buffered frames in the decoder, allowing the new stream to begin playback immediately.
			StopStreaming();
			safeFetch.OpenStream(videoUrl, headerCallback, acceptFrame, acceptStatusBlock, streamInfoCallback, StreamEnded, fetchOptions);
		}
		UpdateCurrentURL();
		BI_CustomEvent.Invoke("OpenVideo", loading);
	}
	var headerCallback = function (headers)
	{
		videoPlayer.GroupLayoutMetadataReceived(loading.id, headers.get("X-CAMLIST"), headers.get("X-RECLIST"));
	}
	var acceptFrame = function (frame, streams)
	{
		programmaticSoundPlayer.NotifyReconnected();
		reconnectingToast.hide();
		if (documentIsHidden())
		{
			console.log("Stopping H.264 stream because the page is believed to be inactive.");
			StopStreaming();
			return;
		}
		if (streamHasAudio === 0 && didRequestAudio && streams !== 2)
		{
			// We requested audio, but the stream says it doesn't contain any.
			canRequestAudio = false;
			volumeIconHelper.setEnabled(false);
		}
		streamHasAudio = streams === 2 ? 1 : -1;
		if (frame.isVideo)
		{
			if (frame.jpeg)
			{
				if (isLoadingRecordedSnapshot && !playbackPaused)
				{
					clearTimeout(endSnapshotDisplayTimeout);
					endSnapshotDisplayTimeout = setTimeout(function ()
					{
						PlaybackReachedNaturalEnd(1);
					}, loading.msec);
				}
				jpegPreviewModule.RenderDataURI(frame.startTime, loading.uniqueId, frame.jpeg, frame.utc);
			}
			else
			{
				// If the clip is currently recording, frame.pos provided by the server will likely be calculated 
				// against the new length of the clip, which UI3 has no way of reliably knowing!
				// As a workaround, we will recalculate the pos using the length we know.
				if (typeof loading.requestedMs !== "undefined")
				{
					if (loading.msec < loading.requestedMs) // In case msec somehow gets lower when being updated.
					{
						var offset = frame.time * playbackControls.GetPlaybackSpeed();
						if (playbackControls.GetPlayReverse())
							offset *= -1;
						var realmsec = loading.requestedMs + offset;
						frame.pos = frame.meta.pos = ((realmsec / loading.msec) * 10000).dropDecimals();
					}
				}
				if (loading.msec < frame.meta.rawtime)
				{
					loading.msec = frame.meta.rawtime;
					var loadingImg = videoPlayer.Loading().image;
					if (loadingImg.uniqueId == loading.uniqueId)
						loadingImg.msec = frame.meta.rawtime;
				}
				h264_player.AcceptFrame(frame);
			}
		}
		else if (frame.isAudio)
		{
			// The only supported format is mu-law encoding with one audio channel.
			if (frame.format.wFormatTag === 7 && frame.format.nChannels === 1)
			{
				// 7 is mu-law, mu-law is 8 bits per sample but decodes to 16 bits per sample.
				audioCodec = "\u03BC-law " + frame.format.nSamplesPerSec + "hz";
				var pcm16Bit = muLawDecoder.DecodeUint8ArrayToFloat32Array(frame.frameData);
				pcmPlayer.AcceptBuffer([pcm16Bit], frame.format.nSamplesPerSec);
			}
			else if (frame.format.wFormatTag === 61868) // 0xF1AC (FLAC)
			{
				if (audioCodec.indexOf("flac") !== 0)
					audioCodec = "flac";
				//if (!flacDecoder)
				//	flacDecoder = window.UI3FLACDecoder(pcmPlayer.AcceptFrame);
				//flacDecoder.DecodeUint8Array(frame.frameData);
				pcmPlayer.DecodeAndPlayAudioData(frame.frameData, frame.format.nSamplesPerSec, setAudioCodecString);
			}
			else
			{
				audioCodec = "";
				console.log("Unsupported audio frame format", frame.format, frame);
			}
		}
	}
	var setAudioCodecString = function (codecString)
	{
		audioCodec = codecString;
	}
	var acceptStatusBlock = function (status)
	{
		if (!status)
		{
			cornerStatusIcons.HideAll();
			lastStatusBlock = null;
			return;
		}
		cornerStatusIcons.Set("motion", status.bMotion);
		cornerStatusIcons.Set("trigger", status.bTriggered);
		cornerStatusIcons.Set("recording", status.bRec);

		if (status.bMotion && (!lastStatusBlock || !lastStatusBlock.bMotion))
			biSoundPlayer.PlayEvent("motion");
		if (status.bTriggered && (!lastStatusBlock || !lastStatusBlock.bTriggered))
			biSoundPlayer.PlayEvent("trigger");

		BI_CustomEvent.Invoke("Video Status Block", arguments);

		lastStatusBlock = status;
	}
	var streamInfoCallback = function (bitmapInfoHeader, waveFormatEx)
	{
		if (typeof h264_player.streamInfoCallback === "function")
			h264_player.streamInfoCallback(bitmapInfoHeader, waveFormatEx);
	}
	this.GetSeekPercent = function ()
	{
		return currentSeekPositionPercent;
	}
	this.GetLastSnapshotUrl = function ()
	{
		// This is the H.264 video player.
		var sizeQualityArgs = JpegSnapshotArgs(loading);
		var groupArgs = groupCfg.GetUrlArgs(loading);
		if (loading.isLive)
			return currentServer.remoteBaseURL + "image/" + loading.path + '?time=' + Date.now() + groupArgs + currentServer.GetAPISessionArg("&", true) + sizeQualityArgs;
		else if (loading.isTimeline())
			return currentServer.remoteBaseURL + "time/" + loading.path + '?jpeg&isolate&pos=' + videoPlayer.lastFrameUtc.dropDecimalsStr() + groupArgs + currentServer.GetAPISessionArg("&", true) + sizeQualityArgs + clipOverlayCfg.GetUrlArgs("*ui3_timeline_pseudocam");
		else
			return currentServer.remoteBaseURL + "file/clips/" + loading.path + '?time=' + self.GetClipPlaybackPositionMs() + currentServer.GetAPISessionArg("&", true) + sizeQualityArgs + clipOverlayCfg.GetUrlArgs(loading.id);
	}
	this.GetLastSnapshotFullUrl = function ()
	{
		return self.GetLastSnapshotUrl();
	}
	this.GetClipPlaybackPositionMs = function ()
	{
		return Clamp((currentSeekPositionPercent * loading.msec).dropDecimals(), 0, loading.msec - 1);
	}
	this.GetStaticSnapshotId = function ()
	{
		if (isLoadingRecordedSnapshot)
			return loading.uniqueId;
		else
			return "";
	}
	this.GetOffsetFromStartMs = function ()
	{
		if (self.Playback_IsPaused())
			return 0;
		else
			return performance.now() - lastStreamBeganAt;
	}
	this.Playback_IsPaused = function ()
	{
		return playbackPaused;
	}
	this.Playback_Pause = function ()
	{
		playbackPaused = true;
		playbackControls.setPlayPauseButtonState(playbackPaused);
		if (h264_player.GetRenderedFrameCount() > 0)
			StopStreaming();
		BI_CustomEvent.Invoke("Playback_Pause", loading);
	}
	this.Playback_Play = function ()
	{
		playbackPaused = false;
		playbackControls.setPlayPauseButtonState(playbackPaused);
		ReopenStreamAtCurrentSeekPosition();
		BI_CustomEvent.Invoke("Playback_Play", loading);
	}
	this.PlaybackSpeedChanged = function (playSpeed)
	{
		if (!playbackPaused)
			ReopenStreamAtCurrentSeekPosition();
	}
	this.SelectedQualityChanged = function ()
	{
		ReopenStreamAtCurrentSeekPosition();
	}
	this.PlaybackDirectionChanged = function (playReverse)
	{
		if (!playbackPaused)
			ReopenStreamAtCurrentSeekPosition();
	}
	this.NotifyClipMetadataChanged = function (clipData)
	{
		loading.msec = clipData.msec;
	}
	this.AudioToggleNotify = function (audioEnabled)
	{
		if (!safeFetch.IsActive())
			return;
		if (audioEnabled)
		{
			if (canRequestAudio && !didRequestAudio)
				ReopenStreamAtCurrentSeekPosition(); // We want audio. We didn't request it yet, so we should do it now.
		}
		else
		{
			if (didRequestAudio && streamHasAudio != -1)
				ReopenStreamAtCurrentSeekPosition(); // We don't want audio, but we requested it and may be receiving it.
		}
	}
	this.ReopenStreamAtCurrentSeekPosition = function ()
	{
		ReopenStreamAtCurrentSeekPosition();
	}
	var ReopenStreamAtCurrentSeekPosition = function ()
	{
		if (loading.isLive)
			currentSeekPositionPercent = 0;
		else if (loading.isTimeline())
		{
		}
		else
		{
			if (currentSeekPositionPercent >= 1 && !playbackControls.GetPlayReverse())
				currentSeekPositionPercent = 0;
			else if (currentSeekPositionPercent <= 0 && playbackControls.GetPlayReverse())
				currentSeekPositionPercent = 1;
			currentSeekPositionPercent = Clamp(currentSeekPositionPercent, 0, 1);
		}
		self.OpenVideo(loading.UpdateTimelineStart(), currentSeekPositionPercent, playbackPaused);
	}
	/** Handler for "afterResized" custom event. The video viewport may have resized, or layout may have just been re-done. */
	function AfterResized()
	{
		if (isCurrentlyActive && cameraListLoader.isDynamicLayoutEnabled(loading.id) && !groupCfg.GetLockedResolution(loading))
		{
			var sizeToRequest = imageRenderer.GetSizeToRequest(loading, genericQualityHelper.GetCurrentProfile(), true);
			if (!sizeToRequest.Equals(lastRequestedSize))
				AfterResized2Debounced();
		}
	}
	/** Should only be called via [AfterResized2Debounced] when it has been confirmed that the ideal resolution of the video frame has changed. */
	function AfterResized2()
	{
		if (isCurrentlyActive && cameraListLoader.isDynamicLayoutEnabled(loading.id) && !groupCfg.GetLockedResolution(loading))
		{
			var sizeToRequest = imageRenderer.GetSizeToRequest(loading, genericQualityHelper.GetCurrentProfile(), true);
			if (!sizeToRequest.Equals(lastRequestedSize))
				ReopenStreamAtCurrentSeekPosition();
		}
	}
	var FrameRendered = function (frame)
	{
		if (typeof frame.width === "undefined")
			return;

		var timeNow = performance.now();

		framesSinceLastKeyframe = frame.keyframe ? 0 : (framesSinceLastKeyframe + 1);

		// Copy everything needed by "Stats for nerds".
		lastFrameMetadata.width = frame.width;
		lastFrameMetadata.height = frame.height;
		lastFrameMetadata.pos = frame.pos;
		lastFrameMetadata.timestamp = frame.timestamp;
		lastFrameMetadata.rawtime = frame.rawtime;
		lastFrameMetadata.utc = frame.utc;
		lastFrameMetadata.size = frame.size;
		lastFrameMetadata.duration = frame.duration;
		lastFrameMetadata.expectedInterframe = frame.expectedInterframe;
		lastFrameMetadata.actualInterframe = frame.actualInterframe = timeNow - lastFrameAt;
		lastFrameMetadata.keyframe = frame.keyframe;
		lastFrameMetadata.framesSinceKey = framesSinceLastKeyframe;

		currentSeekPositionPercent = frame.rawtime / loading.msec;

		videoPlayer.ImageRendered({ id: loading.uniqueId, w: frame.width, h: frame.height, loadingTime: frame.actualInterframe, utc: frame.utc, isFirstFrame: lastStreamBeganAt === lastFrameAt });
		if (loading.isLive || loading.isTimeline())
			playbackControls.FrameTimestampUpdated(false);
		else
			playbackControls.FrameTimestampUpdated(frame.utc);
		//refreshNerdStats(frame, timeNow); // UI3-295: "Stats for nerds" refreshes are now decoupled from video frame rendering for H.264 players.
		lastFrameAt = timeNow;
		if (playbackPaused)
		{
			StopStreaming();
		}
	}
	var playerErrorCb = function (message)
	{
		StopStreaming();
		if (message !== "INPUT REQUIRED")
			toaster.Error(message, 15000);
	}
	var StreamEnded = function (message, wasJpeg, wasAppTriggered, videoFinishedStreaming, responseError, isSessionLoss)
	{
		if (currentServer.isLoggingOut)
			return;
		developerLog("fetch stream ended: ", message);
		cornerStatusIcons.Hide("trigger");
		cornerStatusIcons.Hide("motion");
		cornerStatusIcons.Hide("recording");
		if (videoFinishedStreaming || videoPlayer.Playback_IsPaused())
		{
			BI_CustomEvent.Invoke("Video Stream Ended", arguments);
			if (!safeFetch.IsActive())
				volumeIconHelper.setColorIdle();
		}
		if (wasJpeg)
			return;
		if (videoFinishedStreaming)
			h264_player.PreviousFrameIsLastFrame();
		else
		{
			if (!wasAppTriggered && !safeFetch.IsActive())
			{
				StopStreaming();
				if (failLimiter.Fail())
				{
					programmaticSoundPlayer.NotifyDisconnected();
					reconnectingToast.hide();
					var delayMs = 300000; // 5 minutes
					reconnectDelayedToast.showText("The video stream was lost.  Due to rapid failures, automatic reconnection will resume at " + GetTimeStr(new Date(Date.now() + delayMs)) + ".");
					clearTimeout(failureRecoveryTimeout);
					failureRecoveryTimeout = setTimeout(ReopenStreamAtCurrentSeekPosition, delayMs);
				}
				else if (!serverTimeLimiter.isNearStreamLimit())
				{
					programmaticSoundPlayer.NotifyDisconnected();
					clearTimeout(failureRecoveryTimeout);
					if (isSessionLoss)
					{
						reconnectingToast.showText("The video player is waiting for session recovery...");
						sessionManager.ReestablishLostSession();
					}
					else
					{
						reconnectingToast.showText("The video stream was lost. Attempting to reconnect...");
						failureRecoveryTimeout = setTimeout(ReopenStreamAtCurrentSeekPosition, 2000);
					}
				}
			}
		}
	}
	var PlaybackReachedNaturalEnd = function (frameCount)
	{
		//console.log("playback reached natural end of file after " + frameCount + " frames");
		if (!safeFetch.IsActive())
			volumeIconHelper.setColorIdle();
		if (loading.isLive)
			return;
		if (loading.isTimeline())
		{
			toaster.Info("Timeline playback ended unexpectedly."); // This toast message could be removed if it isn't helpful.
			return;
		}
		var reverse = playbackControls.GetPlayReverse();
		if (reverse)
			currentSeekPositionPercent = 0;
		else
			currentSeekPositionPercent = 1;
		videoPlayer.Playback_Ended(reverse);
	}
	var refreshNerdStats = function ()
	{
		if (isCurrentlyActive && ui3_loading_ended)
			writeNerdStats();
	}
	var writeNerdStats = function ()
	{
		var frame = lastFrameMetadata;

		var netDelay = h264_player.GetNetworkDelay().toFloat();
		var decoderDelay = h264_player.GetBufferedTime().toFloat();
		var audioBufferSize = pcmPlayer.GetBufferedMs();
		var bitRate_Video = bitRateCalc_Video.GetBPS() * 8;
		var bitRate_Audio = bitRateCalc_Audio.GetBPS() * 8;

		if (nerdStats.IsOpen())
		{
			var loaded = videoPlayer.Loaded().image;
			var codecs = "h264";
			if (streamHasAudio == 1 && audioCodec)
				codecs += ", " + audioCodec;
			var interFrame = frame.expectedInterframe;
			var interFrameError = Math.abs(frame.expectedInterframe - frame.actualInterframe);
			if (h264_player.isMsePlayer)
				interFrame = frame.duration ? frame.duration : 0;
			var nativeRes = "";
			if (cameraListLoader.isDynamicLayoutEligible(loading.id))
				nativeRes = ' <a href="javascript:OpenGroupSettings()">[edit]</a>';
			else
			{
				nativeRes = " (Native: " + loading.fullwidth + "x" + loading.fullheight + ")";
				if (loading.fullwidth !== frame.width || loading.fullheight !== frame.height)
					nativeRes = '<span class="nonMatchingNativeRes">' + nativeRes + '</span>';
			}
			var digitalZoom = '<span title="Digital Zoom Factor"> \uD83D\uDD0D' + imageRenderer.zoomHandler.GetZoomFactor().toFixed(2) + 'x</span>';
			var playerName = self.GetPlayerName();
			if (playerName)
			{
				var hwva = self.IsUsingHardwareAcceleration();
				if (hwva == 0)
					playerName += " (no Hardware Accel)";
				else if (hwva == 1)
					playerName += " (Hardware Accel)";
			}

			nerdStats.BeginUpdate();
			nerdStats.UpdateStat("Viewport", null, $layoutbody.width() + "x" + $layoutbody.height() + GetDevicePixelRatioTag() + digitalZoom);
			nerdStats.UpdateStat("Stream Resolution", null, frame.width + "x" + frame.height + nativeRes);
			if (!loaded.getActualRect().Equals(loaded.getRequestedRect()))
				nerdStats.UpdateStat("Requested Res", null, '<span class="requestedRes">' + loaded.getRequestedRect().toString() + '</span>');
			if (loading.isLive)
				nerdStats.UpdateStat("Seek Position", "LIVE");
			else if (loading.isTimeline())
				nerdStats.UpdateStat("Seek Position", MsToDHMS(videoPlayer.lastFrameUtc - GetUtcNow(), false, true));
			else
				nerdStats.UpdateStat("Seek Position", (frame.pos / 100).toFixed() + "%");
			nerdStats.UpdateStat("Frame Time", GetDateStr(new Date(frame.utc + GetServerTimeOffset()), true));
			nerdStats.UpdateStat("Stream Timestamp", frame.timestamp + "ms");
			if (playerName)
				nerdStats.UpdateStat("Video Player", playerName);
			nerdStats.UpdateStat("Codecs", codecs);
			nerdStats.UpdateStat("Video Bit Rate", bitRate_Video, formatBitsPerSecond(bitRate_Video, 1), true);
			nerdStats.UpdateStat("Audio Bit Rate", bitRate_Audio, formatBitsPerSecond(bitRate_Audio, 1), true);
			nerdStats.UpdateStat("Audio Buffer", audioBufferSize, audioBufferSize.toFixed(0) + "ms", true);
			nerdStats.UpdateStat("Frames since key", frame.framesSinceKey, frame.framesSinceKey, true);
			nerdStats.UpdateStat("Frame Size", frame.size, formatBytes(frame.size, 2), true, (frame.keyframe ? "#FF0000" : undefined));
			nerdStats.UpdateStat("Inter-Frame Time", interFrame, interFrame.toFixed() + "ms", true);
			if (!h264_player.isMsePlayer)
				nerdStats.UpdateStat("Frame Timing Error", interFrameError, interFrameError.toFixed() + "ms", true);
			var currentFps = fpsCounter.peekFPS();
			nerdStats.UpdateStat("Frame Rate", currentFps, currentFps.toFixed(0) + " FPS", true);
			nerdStats.UpdateStat("Src/Network Delay", netDelay, netDelay.toFixed().padLeft(4, '0') + "ms", true);
			nerdStats.UpdateStat("Player Delay", decoderDelay, decoderDelay.toFixed().padLeft(4, '0') + "ms", true);
			nerdStats.UpdateStat("Delayed Frames", h264_player.GetBufferedFrameCount(), h264_player.GetBufferedFrameCount(), true);
			if (typeof h264_player.UpdateNerdStats === "function")
				h264_player.UpdateNerdStats();
			nerdStats.EndUpdate();
		}

		statusAreaApi.setValue("Stream Bit Rate", { video: bitRate_Video, audio: bitRate_Audio });
		statusAreaApi.setValue("Stream Delay", { netDelay: netDelay, playerDelay: decoderDelay });
		statusAreaApi.setValue("Audio Buffer", audioBufferSize);
	}
	var perf_warning_net = null;
	var perf_warning_cpu = null;
	var perf_warning_net_ticks = 0;
	var perf_warning_cpu_ticks = 0;
	var MeasurePerformance = function (showCommonWarnings)
	{
		var perfNow = performance.now();
		if (!h264_player || !isCurrentlyActive || !safeFetch.IsActive() || isLoadingRecordedSnapshot || perfNow - lastActivatedAt < 1000)
		{
			if (showCommonWarnings)
				toaster.Warning('The video player is not currently active.', 10000);
			return;
		}
		//if (perf_warning_net)
		//{
		//	perf_warning_net.remove();
		//	perf_warning_net = null;
		//}
		//if (perf_warning_cpu)
		//{
		//	perf_warning_cpu.remove();
		//	perf_warning_cpu = null;
		//}
		var bufferedTime = h264_player.GetBufferedTime();
		var netDelay = h264_player.GetNetworkDelay();
		var maxDelaySec = Clamp(parseFloat(settings.ui3_h264_reset_at_delay), 0, 9999);
		if (netDelay + bufferedTime > maxDelaySec * 1000)
		{
			toaster.Warning("Video delay has exceeded " + maxDelaySec.toFloat(2) + " seconds. The stream is being automatically reinitialized.");
			ReopenStreamAtCurrentSeekPosition();
			return;
		}
		var delayed = false;

		var uiSettingsDelayLinkout = 'You can <a href="javascript:uiSettingsPanel.open(\'threshold\')">adjust the delay thresholds in UI Settings</a>.';
		if (netDelay > parseFloat(settings.ui3_h264_net_delay_threshold) * 1000)
		{
			delayed = true;
			if (perf_warning_net_ticks++ > 0)
			{
				// Blue Iris appears to drop frames when it detects the network buffer getting too large, so this delay limit needs to be fairly low.
				if (showCommonWarnings)
					perf_warning_net = toaster.Warning('Your network connection is not fast enough to handle this stream in realtime. Consider changing the streaming quality. ' + uiSettingsDelayLinkout, 10000);
			}
		}
		else
			perf_warning_net_ticks = 0;
		if (h264_player.isMsePlayer)
		{
			if (bufferedTime > parseFloat(settings.ui3_h264_html5_delay_threshold) * 1000)
			{
				delayed = true;
				if (perf_warning_cpu_ticks++ > 0)
				{
					if (showCommonWarnings)
						perf_warning_cpu = toaster.Warning('This stream is becoming very delayed, which may indicate a compatibility issue with the browser you are using. Please try a different browser, or <a href="javascript:uiSettingsPanel.open(\'H.264 Player\')">open UI Settings and change the H.264 player to a different option</a>. ' + uiSettingsDelayLinkout, 10000);
				}
			}
			else
				perf_warning_cpu_ticks = 0;
		}
		else if (bufferedTime > parseFloat(settings.ui3_h264_delay_threshold) * 1000)
		{
			delayed = true;
			if (perf_warning_cpu_ticks++ > 0)
			{
				if (showCommonWarnings)
					perf_warning_cpu = toaster.Warning('This stream is becoming delayed because your CPU is not fast enough. Consider changing the streaming quality. ' + uiSettingsDelayLinkout, 10000);
			}
		}
		else
			perf_warning_cpu_ticks = 0;

		if (delayed)
			cornerStatusIcons.Show("streamDelay");
		else
			cornerStatusIcons.Hide("streamDelay");
	}
	this.ShowDelayWarning = function ()
	{
		MeasurePerformance(true);
	}
	this.DrawFullCameraAsThumb = function (cameraId, groupId)
	{
		if (h264_player.DrawFullCameraAsThumb)
			return h264_player.DrawFullCameraAsThumb(cameraId, groupId);
		return false;
	}
	this.DrawThumbAsFullCamera = function (cameraId, groupId)
	{
		if (h264_player.DrawThumbAsFullCamera)
			return h264_player.DrawThumbAsFullCamera(cameraId, groupId);
		return false;
	}
	this.GetPlayerName = function ()
	{
		return typeof h264_player.GetPlayerName === "function" ? h264_player.GetPlayerName() : "";
	}
	this.GetPlayerNameShort = function ()
	{
		return typeof h264_player.GetPlayerNameShort === "function" ? h264_player.GetPlayerNameShort() : "";
	}
	/**
	 * -1: unknown, 0: false, 1: true
	 */
	this.IsUsingHardwareAcceleration = function ()
	{
		return typeof h264_player.IsUsingHardwareAcceleration === "function" ? h264_player.IsUsingHardwareAcceleration() : -1;
	}
	Initialize();
	postInitialize();
}
///////////////////////////////////////////////////////////////
// openh264_player ////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function OpenH264_Player(frameRendered, PlaybackReachedNaturalEndCB)
{
	var self = this;
	var $canvas;
	var canvas;
	var canvasW = 0;
	var canvasH = 0;
	var display;
	var decoder;
	var acceptedFrameCount = 0; // Number of frames submitted to the decoder.
	var decodedFrameCount = 0; // Number of frames rendered.
	var finishedFrameCount = 0; // Number of frames rendered or dropped.
	var netDelayCalc = new NetDelayCalc();
	var timestampFirstAcceptedFrame = -1; // Frame timestamp (ms) of the first frame to be submitted to the decoder.
	var timestampFirstDecodedFrame = -1; // Frame timestamp (ms) of the first frame to be decoded.
	var timestampFirstRenderedFrame = -1; // Frame timestamp (ms) of the first frame to be rendered.
	var timestampLastAcceptedFrame = -1; // Frame timestamp (ms) of the last frame to be submitted to the decoder.
	var timestampLastDecodedFrame = -1; // Frame timestamp (ms) of the last frame to be decoded.
	var timestampLastRenderedFrame = -1; // Frame timestamp (ms) of the last frame to be rendered.
	var firstFrameReceivedAt = performance.now(); // The performance.now() reading at the moment the first frame was received from the network.
	var lastFrameReceivedAt = performance.now(); // The performance.now() reading at the moment the last frame was received from the network.
	var firstFrameDecodedAt = performance.now(); // The performance.now() reading at the moment the first frame was finished decoding.
	var lastFrameDecodedAt = performance.now(); // The performance.now() reading at the moment the last frame was finished decoding.
	var firstFrameRenderedAt = performance.now(); // The performance.now() reading at the moment the first frame was finished rendering.
	var lastFrameRenderedAt = performance.now(); // The performance.now() reading at the moment the last frame was finished rendering.
	var lastFrameRenderTime = 0; // Milliseconds it took to render the last frame.
	var averageRenderTime = new RollingAverage();
	var averageDecodeTime = new RollingAverage();
	var loadState = 0; // 0: Initial, 1: Loading, 2: Ready to accept frames
	var isValid = true;
	var allFramesAccepted = false;
	var renderScheduler = null;
	var lastFrameWarning = performance.now() - 60000;
	var nonKeyframeDropper = new NonKeyframeDropper();

	var onLoad = function ()
	{
		loadState = 2;
		loadingHelper.SetLoadedStatus("h264");
	}
	var onLoadFail = function ()
	{
		isValid = false;
		toaster.Error("Failed to load H.264 player.", 15000);
		decoder.Dispose();
	}
	var frameDecoded = function (frame)
	{
		var timeNow = performance.now();
		decodedFrameCount++;
		timestampLastDecodedFrame = frame.timestamp;
		lastFrameDecodedAt = timeNow;
		if (timestampFirstDecodedFrame == -1)
		{
			timestampFirstDecodedFrame = frame.timestamp;
			firstFrameDecodedAt = timeNow;
		}
		renderScheduler.AddFrame(frame, averageRenderTime);
	}
	var renderFrame = function (frame)
	{
		if (canvasW != frame.width)
			canvas.width = canvasW = frame.width;
		if (canvasH != frame.height)
			canvas.height = canvasH = frame.height;
		var drawStart = performance.now();
		display.drawNextOutputPicture(frame.width, frame.height, null, frame);
		var drawEnd = performance.now();
		lastFrameRenderTime = drawEnd - drawStart;
		averageRenderTime.Add(lastFrameRenderTime);
		finishedFrameCount++;
		timestampLastRenderedFrame = frame.timestamp;
		lastFrameRenderedAt = drawEnd;
		if (timestampFirstRenderedFrame == -1)
		{
			timestampFirstRenderedFrame = frame.timestamp;
			firstFrameRenderedAt = drawEnd;
		}
		frameRendered(frame);
		CheckStreamEndCondition();
	}
	var dropFrame = function (frame)
	{
		finishedFrameCount++;
		CheckStreamEndCondition();
	}
	var CheckStreamEndCondition = function ()
	{
		if (allFramesAccepted && (finishedFrameCount) >= acceptedFrameCount)
		{
			if (PlaybackReachedNaturalEndCB)
				PlaybackReachedNaturalEndCB(finishedFrameCount);
		}
	}

	var frameError = function (badFrame)
	{
		console.log("Frame Error", badFrame);
		var timeNow = performance.now();
		if (timeNow - lastFrameWarning > 3000)
		{
			lastFrameWarning = timeNow;
			toaster.Warning("Error decoding H.264 frame(s)", 3000);
		}
	}
	var lastCriticalError = performance.now() - 60000;
	var criticalWorkerError = function (error)
	{
		toaster.Error('H.264 decoder error!<br/><br/>' + error.message + '<br/><br/>Check your encoder profiles in Blue Iris Options &gt; Web server &gt; Advanced, and try a lower bit rate.', 15000, true);
		var timeNow = performance.now();
		if (timeNow - lastCriticalError < 2000)
		{
			toaster.Error('H.264 decoder errors occurred too rapidly.  Decoder will not be restarted automatically.', 600000, true);
		}
		else
		{
			if (decoder)
			{
				decoder.Dispose();
				decoder = new OpenH264_Decoder(onLoad, onLoadFail, frameDecoded, frameError, criticalWorkerError);
			}
		}
		lastCriticalError = timeNow;
	}

	var Initialize = function ()
	{
		if (loadState != 0)
			return;
		loadState = 1;

		renderScheduler = new RenderScheduler(renderFrame, dropFrame);
		decoder = new OpenH264_Decoder(onLoad, onLoadFail, frameDecoded, frameError, criticalWorkerError);

		var createNewCanvas = function ()
		{
			$("#openh264_player_canvas").remove();
			$canvas = $('<canvas id="openh264_player_canvas" class="videoCanvas" width="100%" height="100%"></canvas>');
			canvas = $canvas.get(0);
			return canvas;
		}

		display = new WebGLCanvas(createNewCanvas);
	}
	this.Dispose = function ()
	{
		decoder.Dispose();
	}
	this.IsLoaded = function ()
	{
		return loadState == 2;
	}
	this.IsValid = function ()
	{
		return isValid;
	}
	this.GetRenderedFrameCount = function ()
	{
		return finishedFrameCount;
	}
	/**
	 * Returns the number of buffered video frames that have not yet been rendered.
	 * If the system has sufficient computational power, this number should remain close to 0.
	 */
	this.GetBufferedFrameCount = function ()
	{
		return acceptedFrameCount - finishedFrameCount;
	}
	/**
	 * Returns the approximate number of milliseconds of video delay caused by insufficient network speed.
	 * If the system has sufficient network bandwidth, this number should remain close to 0.
	 * One or two frames worth of delay is nothing to worry about.
	 */
	this.GetNetworkDelay = function ()
	{
		return netDelayCalc.Calc();
	}
	/**
	 * Returns the number of milliseconds of buffered video frames, calculated as 
	 * timestampLastAcceptedFrame - timestampLastRenderedFrame.
	 * If the system has sufficient computational power, this number should remain close to 0.
	 */
	this.GetBufferedTime = function ()
	{
		return timestampLastAcceptedFrame - timestampLastRenderedFrame;
	}
	this.GetLastFrameRenderTime = function ()
	{
		return lastFrameRenderTime;
	}
	this.Flush = function ()
	{
		decoder.Flush();
		renderScheduler.Reset(averageRenderTime);
		nonKeyframeDropper.Reset();
		acceptedFrameCount = 0;
		decodedFrameCount = 0;
		finishedFrameCount = 0;
		netDelayCalc.Reset();
		timestampFirstAcceptedFrame = -1;
		timestampFirstDecodedFrame = -1;
		timestampFirstRenderedFrame = -1;
		timestampLastAcceptedFrame = -1;
		timestampLastDecodedFrame = -1;
		timestampLastRenderedFrame = -1;
		var timeNow = performance.now();
		firstFrameReceivedAt = timeNow;
		lastFrameReceivedAt = timeNow;
		firstFrameDecodedAt = timeNow;
		lastFrameDecodedAt = timeNow;
		firstFrameRenderedAt = timeNow;
		lastFrameRenderedAt = timeNow;
		allFramesAccepted = false;
	}
	this.AcceptFrame = function (frame)
	{
		if (nonKeyframeDropper.shouldAccept(frame))
		{
			acceptedFrameCount++;
			decoder.Decode(frame);
			timestampLastAcceptedFrame = frame.time;
			lastFrameReceivedAt = performance.now();
			if (timestampFirstAcceptedFrame == -1)
			{
				timestampFirstAcceptedFrame = frame.time;
				firstFrameRenderedAt = lastFrameReceivedAt; // This value is faked so the timing starts more reasonably.
			}
			netDelayCalc.Frame(frame.time, lastFrameReceivedAt);
		}
	}
	this.Toggle = function (activate)
	{
		$canvas.appendTo(activate ? $("#camimg_wrapper") : $("#camimg_store"));
	}
	this.GetPlayerElement = function ()
	{
		return canvas;
	}
	this.ClearDrawingSurface = function ()
	{
		ClearCanvas(canvas);
	}
	this.PreviousFrameIsLastFrame = function ()
	{
		allFramesAccepted = true;
		CheckStreamEndCondition();
	}
	this.GetPlayerName = function ()
	{
		return "JavaScript";
	}
	this.GetPlayerNameShort = function ()
	{
		return "js";
	}
	/**
	 * -1: unknown, 0: false, 1: true
	 */
	this.IsUsingHardwareAcceleration = function ()
	{
		return 0;
	}
	/**
	 * -1: unknown, 0: false, 1: true
	 */
	this.IsUsingWebGL = function ()
	{
		if (display.contextName === "2d")
			return 0;
		else if (display.contextName)
			return 1;
		else
			return -1;
	}
	this.UpdateNerdStats = function ()
	{
		if (display.contextName === "2d")
			nerdStats.UpdateStat("Renderer", "2d canvas, no WebGL");
		else if (display.contextName)
			nerdStats.UpdateStat("Renderer", display.contextName);
		else
			nerdStats.UpdateStat("Renderer", "Unknown");
	}

	Initialize();
}
/**
 * Manages the playback clock and keeps frames rendering as closely as possible to their intended timestamps while adding a minimum amount of video latency.
 * @param {Function} renderFunc
 * @param {Function} dropFunc
 * @param {any} averageRenderTime
 */
function RenderScheduler(renderFunc, dropFunc, averageRenderTime)
{
	var self = this;
	var frameQueue = [];
	var timeout = null;
	var maxQueuedFrames = 2; // Do not set this negative, but 0 is okay.
	var playbackClockStart = performance.now();
	var playbackClockOffset = 0;
	var numFramesAccepted = 0;
	var lastFrameTS = 0;
	this.AddFrame = function (frame)
	{
		if (numFramesAccepted == 0)
			playbackClockStart = performance.now();
		numFramesAccepted++;
		frame.expectedInterframe = (frame.timestamp - lastFrameTS);
		lastFrameTS = frame.timestamp;
		frameQueue.push(frame);
		// Sort the frame queue by timestamp, as this can improve playback if frames come in out-of-order.
		frameQueue.sort(function (a, b) { return a.timestamp - b.timestamp; });

		if (frameQueue.length > maxQueuedFrames)
		{
			// Frame queue is overfull.
			// Adjust the playback clock to match the oldest queued frame.
			// When we MaintainSchedule later, this will cause at least one frame to be rendered immediately.
			var timeRemaining = GetTimeUntilRenderOldest();
			if (timeRemaining > 0)
				OffsetPlaybackClock(timeRemaining); // Jump the clock ahead because we are getting too many frames queued.
		}
		MaintainSchedule();
	}
	/**
	 * Renders or queues a frame, if any are available. This method will call itself if necessary after rendering until the frame queue is empty.
	 */
	var MaintainSchedule = function ()
	{
		clearTimeout(timeout);
		if (frameQueue.length > 0)
		{
			var clock = ReadPlaybackClock();
			var timeToWait = GetTimeUntilRenderOldest();
			if (timeToWait <= 0)
			{
				if (timeToWait < 0)
					OffsetPlaybackClock(timeToWait); // Roll the clock back because frames are coming in late.
				renderFunc(DequeueOldest());
				MaintainSchedule();
			}
			else
			{
				timeout = setTimeout(function ()
				{
					renderFunc(DequeueOldest());
					MaintainSchedule();
				}, timeToWait);
			}
		}
	}
	var OffsetPlaybackClock = function (offset)
	{
		playbackClockOffset += offset;
	}
	var GetTimeUntilRenderOldest = function ()
	{
		return (PeekOldest().timestamp - ReadPlaybackClock()) - averageRenderTime.Get();
	}
	var ReadPlaybackClock = function ()
	{
		return (performance.now() - playbackClockStart) + playbackClockOffset;
	}
	/** Returns a reference to the first item in the queue. Do not call if the queue is empty. */
	var PeekOldest = function ()
	{
		return frameQueue[0];
	}
	/** Removes and returns a reference to the first item in the queue. Do not call if the queue is empty. */
	var DequeueOldest = function ()
	{
		return frameQueue.splice(0, 1)[0];
	}
	this.Reset = function (newAverageRenderTime)
	{
		averageRenderTime = newAverageRenderTime;
		clearTimeout(timeout);
		numFramesAccepted = 0;
		playbackClockOffset = 0;
		playbackClockStart = performance.now();
		while (frameQueue.length > 0)
			dropFunc(DequeueOldest());
	}
}
///////////////////////////////////////////////////////////////
// openh264_decoder ///////////////////////////////////////////
///////////////////////////////////////////////////////////////
function OpenH264_Decoder(onLoad, onLoadError, onFrameDecoded, onFrameError, onCriticalWorkerError)
{
	var self = this;
	// Note: I hand-edited openh264_decoder.js to remove {u, v, y} attributes of 
	// each decoded frame because I don't need them.  I'm not sure how significant 
	// this optimization is (each removed field was a new Uint8ClampedArray of 
	// significant size, but maybe data didn't have to be copied to make them).
	var worker = new Worker("ui3/openh264_decoder.js?v=" + combined_version + currentServer.GetLocalSessionArg("&"));
	var encodedFrameQueue = new Queue();
	var is_decoding = false;
	var dropNextDecodedFrame = false;

	this.Decode = function (frame)
	{
		if (!worker)
		{
			console.log("OpenH264_Decoder.Decode called after Dispose.");
			return;
		}
		if (is_decoding)
		{
			encodedFrameQueue.enqueue(frame);
			return;
		}
		dropNextDecodedFrame = false;
		is_decoding = true;
		worker.onmessage = function (ev2)
		{
			ev2.data.timestamp = frame.time;
			ev2.data.pos = frame.pos;
			ev2.data.utc = frame.utc;
			ev2.data.size = frame.size;
			ev2.data.rawtime = frame.meta.rawtime;
			DecodeDone(ev2.data);
		};
		worker.postMessage({ timestamp: frame.time, data: frame.frameData.buffer });
	}
	var DecodeDone = function (frame)
	{
		is_decoding = false;
		if (!encodedFrameQueue.isEmpty())
			self.Decode(encodedFrameQueue.dequeue());
		if (dropNextDecodedFrame)
			return;

		if (frame.status == 0)
		{
			try
			{
				onFrameDecoded(frame);
			}
			catch (ex)
			{
				toaster.Warning(ex);
			}
		}
		else
			onFrameError(frame);
	}
	this.Flush = function ()
	{
		if (!encodedFrameQueue.isEmpty())
			encodedFrameQueue = new Queue();
		if (is_decoding)
			dropNextDecodedFrame = true;
	}

	this.Dispose = function ()
	{
		if (worker)
			worker.terminate();
		worker = null;
	}
	// Initialize
	worker.onerror = function (error)
	{
		if (onCriticalWorkerError)
			onCriticalWorkerError(error);
	}
	worker.onmessage = function (ev)
	{
		if (ev.data.status == 0)
			onLoad(ev.data);
		else
			onLoadError(ev.data);
	};
	worker.postMessage({
		params: {},
		packet: null
	});
}
///////////////////////////////////////////////////////////////
// pnacl_player ///////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function Pnacl_Player(frameRendered, PlaybackReachedNaturalEndCB)
{
	var self = this;
	var player;
	var acceptedFrameCount = 0; // Number of frames submitted to the decoder.
	var finishedFrameCount = 0; // Number of frames rendered or dropped.
	var netDelayCalc = new NetDelayCalc();
	var timestampLastAcceptedFrame = -1; // Frame timestamp (ms) of the last frame to be submitted to the decoder.
	var timestampLastRenderedFrame = -1; // Frame timestamp (ms) of the last frame to be rendered.
	var lastFrameReceivedAt = performance.now(); // The performance.now() reading at the moment the last frame was received from the network.
	var averageRenderTime = new RollingAverage();
	var isLoaded = false;
	var allFramesAccepted = false;
	var frameMetadataCache = new FrameMetadataCache();
	var loadingTimeout = null;
	var nonKeyframeDropper = new NonKeyframeDropper();

	var moduleDidLoad = function ()
	{
		developerLog("NACL Module loaded");
		clearTimeout(loadingTimeout);
	}
	var onLoadFail = function ()
	{
		toaster.Error("Failed to load H.264 player.", 999999);
		self.Dispose();
	}
	var handleError = function (event)
	{
		console.error(event);
		checkErrorBeforeLoad(false);
	}
	var handleCrash = function (event)
	{
		try
		{
			if (player.exitStatus == -1)
				console.error("Pnacl_Player CRASH! Last error: " + player.lastError);
			else
				console.error("Pnacl_Player EXITED [" + player.exitStatus + "]");
		}
		catch (ex)
		{
			console.error(ex);
		}
		console.error(event);
		checkErrorBeforeLoad(true);
	}
	var checkErrorBeforeLoad = function (isCrash)
	{
		var selectionToast = null;
		var $err = $('<div>Native H.264 player ' + (isCrash ? "crashed" : "error") + '!<br><br>' + player.lastError + '</div>');
		if (!isLoaded)
		{
			loadingHelper.SetErrorStatus("h264", "The NACL video player failed to load.", true);
			$err.append($disablePnaclButton);
			var $explanation = mse_mp4_h264_supported || h264_js_player_supported || webcodecs_h264_player_supported ? $('<div>You can load UI3 by changing to a different player:</div>') : $('<div>You can load UI3 by changing to a JPEG streaming method:</div>');
			$explanation.css('margin-top', '12px');
			$err.append($explanation);
			var $automatic = $('<input type="button" value="Automatic" />');
			$automatic.css('margin-top', '10px').css('padding', '6px').css('display', 'block');
			$automatic.on('click', function ()
			{
				SetH264PlayerPreference(H264PlayerOptions.Automatic);
				ReloadInterface();
			});
			$err.append($automatic);
			if (webcodecs_h264_player_supported)
			{
				var $disablePnaclButton3 = $('<input type="button" value="WebCodecs (new)" />');
				$disablePnaclButton3.css('margin-top', '10px').css('padding', '6px').css('display', 'block');
				$disablePnaclButton3.on('click', function ()
				{
					SetH264PlayerPreference(H264PlayerOptions.WebCodecs);
					ReloadInterface();
				});
				$err.append($disablePnaclButton3);
			}
			if (mse_mp4_h264_supported)
			{
				var $disablePnaclButton2 = $('<input type="button" value="HTML5 (fast)" />');
				$disablePnaclButton2.css('margin-top', '10px').css('padding', '6px').css('display', 'block');
				$disablePnaclButton2.on('click', function ()
				{
					SetH264PlayerPreference(H264PlayerOptions.HTML5);
					ReloadInterface();
				});
				$err.append($disablePnaclButton2);
			}
			if (h264_js_player_supported)
			{
				var $disablePnaclButton = $('<input type="button" value="JavaScript (slow)" />');
				$disablePnaclButton.css('margin-top', '10px').css('padding', '6px').css('display', 'block');
				$disablePnaclButton.on('click', function ()
				{
					SetH264PlayerPreference(H264PlayerOptions.JavaScript);
					ReloadInterface();
				});
				$err.append($disablePnaclButton);
			}
			var $disablePnaclButton4 = $('<input type="button" value="JPEG mode (no H.264)" />');
			$disablePnaclButton4.css('margin-top', '10px').css('padding', '6px').css('display', 'block');
			$disablePnaclButton4.on('click', function ()
			{
				any_h264_playback_supported = pnacl_player_supported = false;
				genericQualityHelper.QualityChoiceChanged('');
				selectionToast.remove();
			});
			$err.append($disablePnaclButton4);
		}
		selectionToast = toaster.Error($err, isCrash || !isLoaded ? 9999999 : 60000, true);
	}
	var handleMessage = function (message_event)
	{
		if (typeof message_event.data === 'string')
		{
			if (message_event.data == "decoder initialized")
			{
				isLoaded = true;
				loadingHelper.SetLoadedStatus("h264");
			}
			else if (message_event.data.startsWith("rf ")) // Rendered Frame
			{
				//console.log(message_event.data);
				var dataObj = JSON.parse(message_event.data.substr("rf ".length));
				handleFrameRendered(dataObj);
			}
			else if (message_event.data.startsWith("df ")) // Dropped Frame
			{
				var dataObj = JSON.parse(message_event.data.substr("df ".length));
				var loading = videoPlayer.Loading().image;
				//console.log(message_event.data);
				dropFrame(dataObj);
			}
			else if (message_event.data.startsWith("vr ")) // Video Resized and the player is about to start painting a frame of this size.
			{
				videoPlayer.CameraOrResolutionChange();
			}
			//else if (message_event.data.startsWith("Received frame "))
			//{
			//	console.log(message_event.data);
			//}
			else
			{
				console.log("NaCl Player Message: " + message_event.data);
			}
		}
		else
		{
			console.log("NaCl Player Message of unhandled type: " + (typeof message_event.data));
			console.log(message_event.data);
		}
	}
	var handleFrameRendered = function (dataObj)
	{
		var meta = frameMetadataCache.Remove(dataObj.t);
		if (!meta)
			return; // Most likely from a stream we canceled
		finishedFrameCount++;
		if (meta === true)
			return; // Special case: the frameMetadataCache will return true if the same frame as last time is removed again.
		meta.width = dataObj.w;
		meta.height = dataObj.h;
		meta.expectedInterframe = dataObj.i;
		meta.timestamp = meta.time;
		timestampLastRenderedFrame = meta.timestamp;
		frameRendered(meta);
		CheckStreamEndCondition();
	}
	var dropFrame = function (dataObj)
	{
		var meta = frameMetadataCache.Remove(dataObj.t);
		if (meta)
		{
			finishedFrameCount++;
			CheckStreamEndCondition();
		}
	}
	var CheckStreamEndCondition = function ()
	{
		if (allFramesAccepted && (finishedFrameCount) >= acceptedFrameCount)
		{
			if (PlaybackReachedNaturalEndCB)
				PlaybackReachedNaturalEndCB(finishedFrameCount);
		}
	}

	var Initialize = function ()
	{
		developerLog("pnacl_player.Initialize()");
		var $parent = $("#videoElement_wrapper");
		$parent.remove();
		$parent = $('<div id="videoElement_wrapper" class="deactivated"></div>');
		$("#camimg_wrapper").append($parent);

		var listenerDiv = $parent.get(0);
		listenerDiv.addEventListener('load', moduleDidLoad, true);
		listenerDiv.addEventListener('message', handleMessage, true);
		listenerDiv.addEventListener('error', handleError, true);
		listenerDiv.addEventListener('crash', handleCrash, true);

		var hwva = "0";
		if (currentH264Player === H264PlayerOptions.NaCl_HWVA_Auto)
			hwva = "1";
		else if (currentH264Player === H264PlayerOptions.NaCl_HWVA_Yes)
			hwva = "2";
		var $player = $('<embed id="pnacl_player_module" name="pnacl_player_module" width="100%" height="100%" path="pnacl" src="ui3/pnacl/pnacl_player.nmf' + currentServer.GetLocalSessionArg("?") + '" type="application/x-pnacl" hwaccel="' + hwva + '" />');
		$parent.append($player);
		player = document.getElementById("pnacl_player_module");
		loadingTimeout = setTimeout(function ()
		{
			player.lastError = "The PNaCl module did not load.";
			checkErrorBeforeLoad(false);
		}, 5000);
	}
	this.Dispose = function ()
	{
		console.log("pnacl_player.Dispose()");
		var $parent = $("#videoElement_wrapper");
		var listenerDiv = $parent.get(0);
		listenerDiv.removeEventListener('load', moduleDidLoad, true);
		listenerDiv.removeEventListener('message', handleMessage, true);
		listenerDiv.removeEventListener('error', handleError, true);
		listenerDiv.removeEventListener('crash', handleCrash, true);
		$parent.remove();
	}
	this.IsLoaded = function ()
	{
		return isLoaded;
	}
	this.IsValid = function ()
	{
		return true;
	}
	this.GetRenderedFrameCount = function ()
	{
		return finishedFrameCount;
	}
	/**
	 * Returns the number of buffered video frames that have not yet been rendered. 
	 * If the system has sufficient computational power, this number should remain close to 0.
	 */
	this.GetBufferedFrameCount = function ()
	{
		return acceptedFrameCount - finishedFrameCount;
	}
	/**
	 * Returns the approximate number of milliseconds of video delay caused by insufficient network speed.
	 * If the system has sufficient network bandwidth, this number should remain close to 0.
	 * One or two frames worth of delay is nothing to worry about.
	 */
	this.GetNetworkDelay = function ()
	{
		return netDelayCalc.Calc();
	}
	/**
	 * Returns the number of milliseconds of buffered video frames, calculated as timestampLastAcceptedFrame - timestampLastRenderedFrame.
	 * If the system has sufficient computational power, this number should remain close to 0.
	 */
	this.GetBufferedTime = function ()
	{
		return timestampLastAcceptedFrame - timestampLastRenderedFrame;
	}
	this.Flush = function ()
	{
		developerLog("Posting reset");
		player.postMessage("reset");
		nonKeyframeDropper.Reset();
		acceptedFrameCount = 0;
		finishedFrameCount = 0;
		frameMetadataCache.Reset();
		netDelayCalc.Reset();
		timestampLastAcceptedFrame = -1;
		timestampLastRenderedFrame = -1;
		var timeNow = performance.now();
		lastFrameReceivedAt = timeNow;
		allFramesAccepted = false;
	}
	this.AcceptFrame = function (frame)
	{
		if (nonKeyframeDropper.shouldAccept(frame))
		{
			frameMetadataCache.Add(frame);
			//developerLog("Posting frame " + frame.time);
			acceptedFrameCount++;
			player.postMessage("f " + frame.time);
			player.postMessage(frame.frameData.buffer);
			timestampLastAcceptedFrame = frame.time;
			lastFrameReceivedAt = performance.now();
			netDelayCalc.Frame(frame.time, lastFrameReceivedAt);
		}
	}
	this.Toggle = function (activate)
	{
		if (activate)
			$("#videoElement_wrapper").removeClass('deactivated');
		else
			$("#videoElement_wrapper").addClass('deactivated');
	}
	this.GetPlayerElement = function ()
	{
		return player;
	}
	this.ClearDrawingSurface = function ()
	{
	}
	this.PreviousFrameIsLastFrame = function ()
	{
		allFramesAccepted = true;
		CheckStreamEndCondition();
	}
	this.GetPlayerName = function ()
	{
		return "NaCl";
	}
	this.GetPlayerNameShort = function ()
	{
		return "NaCl";
	}
	/**
	 * -1: unknown, 0: false, 1: true
	 */
	this.IsUsingHardwareAcceleration = function ()
	{
		if (currentH264Player === H264PlayerOptions.NaCl_HWVA_Yes)
			return 1;
		else if (currentH264Player === H264PlayerOptions.NaCl_HWVA_No)
			return 0;
		return -1;
	}

	Initialize();
}
///////////////////////////////////////////////////////////////
// WebCodec Player ////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function WebCodec_Player(frameRendered, PlaybackReachedNaturalEndCB)
{
	var self = this;
	var videoDecoder;
	var canvas;
	var $canvas;
	var ctx;
	var canvasW = 0;
	var canvasH = 0;
	var frameCache = new FasterObjectMap();
	var acceptedFrameCount = 0; // Number of frames submitted to the decoder.
	var decodedFrameCount = 0; // Number of frames rendered.
	var finishedFrameCount = 0; // Number of frames rendered or dropped.
	var netDelayCalc = new NetDelayCalc();
	var timestampFirstAcceptedFrame = -1; // Frame timestamp (ms) of the first frame to be submitted to the decoder.
	var timestampFirstDecodedFrame = -1; // Frame timestamp (ms) of the first frame to be decoded.
	var timestampFirstRenderedFrame = -1; // Frame timestamp (ms) of the first frame to be rendered.
	var timestampLastAcceptedFrame = -1; // Frame timestamp (ms) of the last frame to be submitted to the decoder.
	var timestampLastDecodedFrame = -1; // Frame timestamp (ms) of the last frame to be decoded.
	var timestampLastRenderedFrame = -1; // Frame timestamp (ms) of the last frame to be rendered.
	var firstFrameReceivedAt = performance.now(); // The performance.now() reading at the moment the first frame was received from the network.
	var lastFrameReceivedAt = performance.now(); // The performance.now() reading at the moment the last frame was received from the network.
	var firstFrameDecodedAt = performance.now(); // The performance.now() reading at the moment the first frame was finished decoding.
	var lastFrameDecodedAt = performance.now(); // The performance.now() reading at the moment the last frame was finished decoding.
	var firstFrameRenderedAt = performance.now(); // The performance.now() reading at the moment the first frame was finished rendering.
	var lastFrameRenderedAt = performance.now(); // The performance.now() reading at the moment the last frame was finished rendering.
	var lastFrameRenderTime = 0; // Milliseconds it took to render the last frame.
	var averageRenderTime = new RollingAverage();
	var averageDecodeTime = new RollingAverage();
	var lastFrameDecodedTimestamp = -1;
	var allFramesAccepted = false;
	var renderScheduler = null;
	var lastFrameWarning = performance.now() - 60000;
	var nonKeyframeDropper = new NonKeyframeDropper();

	var frameDecoded = function (nativeFrame)
	{
		var frame = frameCache[nativeFrame.timestamp];
		if (!frame)
		{
			if (nativeFrame.timestamp !== lastFrameDecodedTimestamp)
			{
				console.log("A frame was decoded with a timestamp that is not in the frame cache.", nativeFrame);
				toaster.Error("A frame was decoded with a timestamp that is not in the frame cache.");
			}
			decodedFrameCount++;
			finishedFrameCount++;
			nativeFrame.close();
			return;
		}
		lastFrameDecodedTimestamp = nativeFrame.timestamp;
		delete frameCache[nativeFrame.timestamp];
		frame.nativeFrame = nativeFrame;
		frame.width = nativeFrame.displayWidth;
		frame.height = nativeFrame.displayHeight;
		frame.timestamp = frame.time;
		frame.rawtime = frame.meta.rawtime;

		var timeNow = performance.now();
		decodedFrameCount++;
		timestampLastDecodedFrame = frame.timestamp;
		lastFrameDecodedAt = timeNow;
		if (timestampFirstDecodedFrame == -1)
		{
			timestampFirstDecodedFrame = timestampLastDecodedFrame;
			firstFrameDecodedAt = timeNow;
		}
		renderScheduler.AddFrame(frame, averageRenderTime);
	}
	var renderFrame = function (frame)
	{
		if (canvasW != frame.width)
			canvas.width = canvasW = frame.width;
		if (canvasH != frame.height)
			canvas.height = canvasH = frame.height;
		var drawStart = performance.now();
		ctx.drawImage(frame.nativeFrame, 0, 0, canvas.width, canvas.height);
		var drawEnd = performance.now();
		frame.nativeFrame.close();
		frame.nativeFrame = null;
		lastFrameRenderTime = drawEnd - drawStart;
		averageRenderTime.Add(lastFrameRenderTime);
		finishedFrameCount++;
		timestampLastRenderedFrame = frame.timestamp;
		lastFrameRenderedAt = drawEnd;
		if (timestampFirstRenderedFrame == -1)
		{
			timestampFirstRenderedFrame = frame.timestamp;
			firstFrameRenderedAt = drawEnd;
		}
		frameRendered(frame);
		CheckStreamEndCondition();
	}
	var dropFrame = function (frame)
	{
		frame.nativeFrame.close();
		frame.nativeFrame = null;
		finishedFrameCount++;
		CheckStreamEndCondition();
	}
	var CheckStreamEndCondition = function ()
	{
		if (allFramesAccepted && (finishedFrameCount) >= acceptedFrameCount)
		{
			if (PlaybackReachedNaturalEndCB)
				PlaybackReachedNaturalEndCB(finishedFrameCount);
		}
	}
	var decoderError = function (error)
	{
		if (error.message.match(/Codec reclaimed/i))
		{
			// This is an expected error in Chromium-based browsers if the video decoder is idle for about a minute.
			console.log("WebCodecs", error);
			return;
		}
		console.log("Frame Error", error);
		var timeNow = performance.now();
		if (timeNow - lastFrameWarning > 3000)
		{
			lastFrameWarning = timeNow;
			toaster.Warning("Error decoding video frame(s)", 3000);
		}
	}
	var RecoverVideoDecoder = function ()
	{
		if (!videoDecoder || videoDecoder.state === "closed")
		{
			videoDecoder = new VideoDecoder({ output: frameDecoded, error: decoderError });
			videoDecoder.reset();
			nonKeyframeDropper.Reset();
			ConfigureVideoDecoder();
		}
	}
	var ConfigureVideoDecoder = function ()
	{
		videoDecoder.configure({ codec: "avc1.640029", optimizeForLatency: true });
	}
	var Initialize = function ()
	{
		renderScheduler = new RenderScheduler(renderFrame, dropFrame);

		RecoverVideoDecoder();

		$("#webcodec_player_canvas").remove();
		$canvas = $('<canvas id="webcodec_player_canvas" class="videoCanvas" width="100%" height="100%"></canvas>');
		canvas = $canvas.get(0);
		ctx = canvas.getContext('2d');

		loadingHelper.SetLoadedStatus("h264");
	}
	this.Dispose = function ()
	{
		if (videoDecoder.state === "configured")
			videoDecoder.close();
	}
	this.IsLoaded = function ()
	{
		return true;
	}
	this.IsValid = function ()
	{
		return true;
	}
	this.GetRenderedFrameCount = function ()
	{
		return finishedFrameCount;
	}
	this.GetBufferedFrameCount = function ()
	{
		return acceptedFrameCount - finishedFrameCount;
	}
	this.GetNetworkDelay = function ()
	{
		return netDelayCalc.Calc();
	}
	this.GetBufferedTime = function ()
	{
		return timestampLastAcceptedFrame - timestampLastRenderedFrame;
	}
	/** Clears the state of the video player, making it ready to accept a new stream. */
	this.Flush = function ()
	{
		if (videoDecoder.state === "configured")
		{
			videoDecoder.reset();
			ConfigureVideoDecoder();
		}
		renderScheduler.Reset(averageRenderTime);
		nonKeyframeDropper.Reset();
		acceptedFrameCount = 0;
		decodedFrameCount = 0;
		finishedFrameCount = 0;
		netDelayCalc.Reset();
		timestampFirstAcceptedFrame = -1;
		timestampFirstDecodedFrame = -1;
		timestampFirstRenderedFrame = -1;
		timestampLastAcceptedFrame = -1;
		timestampLastDecodedFrame = -1;
		timestampLastRenderedFrame = -1;
		var timeNow = performance.now();
		firstFrameReceivedAt = timeNow;
		lastFrameReceivedAt = timeNow;
		firstFrameDecodedAt = timeNow;
		lastFrameDecodedAt = timeNow;
		firstFrameRenderedAt = timeNow;
		lastFrameRenderedAt = timeNow;
		lastFrameDecodedTimestamp = -1;
		allFramesAccepted = false;
		frameCache = {};
	}
	/**
	 * Accepts a compressed frame from the network.
	 * @param {any} frame
	 */
	this.AcceptFrame = function (frame)
	{
		if (nonKeyframeDropper.shouldAccept(frame))
		{
			acceptedFrameCount++;
			timestampLastAcceptedFrame = frame.time;
			lastFrameReceivedAt = performance.now();
			if (timestampFirstAcceptedFrame == -1)
			{
				timestampFirstAcceptedFrame = frame.time;
				firstFrameRenderedAt = lastFrameReceivedAt; // This value is faked so the timing starts more reasonably.
			}
			netDelayCalc.Frame(frame.time, lastFrameReceivedAt);
			var chunkArgs = {
				type: frame.isKeyframe() ? "key" : "delta",
				timestamp: frame.time * 1000,
				duration: 0,
				data: frame.frameData.buffer
			};
			frameCache[chunkArgs.timestamp] = frame;
			var chunk = new EncodedVideoChunk(chunkArgs);
			RecoverVideoDecoder();
			try
			{
				videoDecoder.decode(chunk);
			}
			catch (ex)
			{
				decoderError(ex);
			}
		}
	}
	this.Toggle = function (activate)
	{
		$canvas.appendTo(activate ? $("#camimg_wrapper") : $("#camimg_store"));
	}
	/**Gets the visible DOM element that shows the video. */
	this.GetPlayerElement = function ()
	{
		return canvas;
	}
	this.ClearDrawingSurface = function ()
	{
		ClearCanvas(canvas);
	}
	this.PreviousFrameIsLastFrame = function ()
	{
		allFramesAccepted = true;
		CheckStreamEndCondition();
	}
	this.GetVideoDecoder = function ()
	{
		return videoDecoder;
	}
	this.DrawFullCameraAsThumb = function (cameraId, groupId)
	{
		return videoModulesShared.DrawFullCameraAsThumb(cameraId, groupId, canvas);
	}
	this.DrawThumbAsFullCamera = function (cameraId, groupId)
	{
		return videoModulesShared.DrawThumbAsFullCamera(cameraId, groupId, canvas);
	}
	this.GetPlayerName = function ()
	{
		return "WebCodecs";
	}
	this.GetPlayerNameShort = function ()
	{
		return "wc";
	}
	/**
	 * -1: unknown, 0: false, 1: true
	 */
	this.IsUsingHardwareAcceleration = function ()
	{
		return -1;
	}

	Initialize();
}
///////////////////////////////////////////////////////////////
// Frame Metadata Cache ///////////////////////////////////////
///////////////////////////////////////////////////////////////
function FrameMetadataCache()
{
	var self = this;
	var cache = {};
	var lastRemoved = -1;
	this.Add = function (frame)
	{
		cache[frame.time] = frame.meta;
	}
	this.Get = function (timestamp)
	{
		return cache[timestamp];
	}
	this.Remove = function (timestamp)
	{
		var value = cache[timestamp];
		if (!value)
		{
			if (timestamp === lastRemoved)
				return true;
			console.log("FrameMetadataCache missing value for timestamp " + timestamp);
		}
		else
			delete cache[timestamp];
		lastRemoved = timestamp;
		return value;
	}
	this.Reset = function ()
	{
		cache = {};
		lastRemoved = -1;
	}
}
function FrameMetadataQueue()
{
	var self = this;
	var q = new Queue();
	this.Add = function (frame)
	{
		q.enqueue(frame.meta);
	}
	this.Get = function ()
	{
		return q.peek();
	}
	this.Remove = function ()
	{
		return q.dequeue();
	}
	this.IsEmpty = function ()
	{
		return q.isEmpty();
	}
	this.GetLength = function ()
	{
		return q.getLength();
	}
	this.Reset = function ()
	{
		q = new Queue();
	}
	this.ToArray = function ()
	{
		return q.toArray();
	}
}
///////////////////////////////////////////////////////////////
// HTML5 + Media Source Extensions Player /////////////////////
///////////////////////////////////////////////////////////////
var jmuxerDeveloperMode = false;
function HTML5_MSE_Player(frameRendered, PlaybackReachedNaturalEndCB, playerErrorHandler)
{
	var self = this;
	var jmuxer;
	var player;
	var isActivated = false;
	var acceptedFrameCount = 0; // Number of frames submitted to the decoder.
	var finishedFrameCount = 0; // Number of frames rendered or dropped.
	var fedFrameCount = 0; // Number of frames fed to jmuxer
	var earlyFrameRenderCalled = false;
	var netDelayCalc = new NetDelayCalc();
	var timestampLastAcceptedFrame = -1; // Frame timestamp (ms) of the last frame to be submitted to the decoder.
	var timestampLastRenderedFrame = -1; // Frame timestamp (ms) of the last frame to be rendered.
	var lastFrameReceivedAt = performance.now(); // The performance.now() reading at the moment the last frame was received from the network.
	var isLoaded = false;
	var allFramesAccepted = false;
	var frameMetadataQueue = new FrameMetadataQueue();
	var currentStreamBitmapInfo = null;
	var nonKeyframeDropper = new NonKeyframeDropper();
	var isRenderingToCanvas = null;
	var disableRenderingStateChangesUntilNextFrame = false;
	var aFrameWasOnceRendered = false; // Set = true when the first frame is rendered.  Never reset to false.

	var lastFrame;
	var lastFrameDuration = 16;
	var hasToldPlayerToPlay = false;

	var earlyFrames = new Queue();
	var mseReady = false;

	this.isMsePlayer = true;

	var delayCompensation;
	var badAutoplay = new BadAutoplayPreventionDetector();

	var onTimeUpdate = function (e)
	{
		finishFramesToTime(player.currentTime * 1000);
	}
	var finishFramesToTime = function (currentTime)
	{
		var w = player.videoWidth;
		var h = player.videoHeight;
		if (w === 0 && h === 0)
			return;
		if (isActivated && acceptedFrameCount > 0 && isRenderingToCanvas)
			videoModulesShared.RenderVideoFrame(player);
		while (!frameMetadataQueue.IsEmpty())
		{
			var meta = frameMetadataQueue.Get();
			if (meta.time > currentTime)
				break;
			frameMetadataQueue.Remove();
			meta.width = w;
			meta.height = h;
			meta.timestamp = meta.time;
			finishedFrameCount++;
			aFrameWasOnceRendered = true;
			timestampLastRenderedFrame = meta.timestamp;
			frameRendered(meta);
			if (finishedFrameCount === 2)
			{
				// This code is to restore the correct rendering state after it was changed to <canvas> when maximizing a camera.
				// For an unknown reason, the first frame is black, so we shouldn't change rendering state until the second frame is rendered.
				self.setCanvasRenderingState();
			}
			CheckStreamEndCondition();
		}
		if (finishedFrameCount > 1)
			badAutoplay.Reset();
		if (finishedFrameCount > 3)
			delayCompensation.Tick(self.GetBufferedTime());
	}
	var onVideoError = function (e)
	{
		var errMsg = player.error && player.error.message ? player.error.message : "[player.error.message unavailable]";
		if (errMsg.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN: MediaSource endOfStream before demuxer initialization completes") === 0)
			return; // Happens sometimes if the video stream ends very quickly. Some clips may do this if you seek to the very end while they are playing.
		if (!inputRequiredOverlay.IsActive())
		{
			var clickForHelp = '<br><br><a href="javascript:UIHelp.LearnMore(\'Video Player Error\')" class="videoPlayerTroubleshootLink">Click for Help</a>';
			var errCode = player.error && typeof player.error.code === "number" ? player.error.code : -1;
			playerErrorHandler(htmlEncode(errMsg) + ": " + GetMediaErrorMessage(errCode) + clickForHelp);
		}
	}
	var onPlayerPaused = function (e)
	{
		if (hasToldPlayerToPlay)
		{
			if (badAutoplay.NotifyPause())
			{
				// This is a sign that playback is being prevented without the courtesy of telling us explicitly.
				InputIsRequiredToPlay();
			}
			else
			{
				setTimeout(function ()
				{
					StartPlayback();
				}, 1);
			}
		}
	}
	var onPlayerStalled = function (e)
	{
		if (acceptedFrameCount > 0)
		{
			if (developerMode)
				toaster.Error("HTML5 video stalled", 60000);
			else
				console.log("HTML5 video stalled");
		}
	}
	var onPlayerWaiting = function (e)
	{
		// Sometimes at the end of a clip, we don't get the final progress update.  This works around an issue where UI3 thinks the clip never finished.
		// This event can be raised before the video player knows the video resolution, so we shouldn't announce finished frames based on this.
		if (allFramesAccepted)
		{
			var allQueuedFrames = frameMetadataQueue.ToArray();
			if (allQueuedFrames.length > 0)
				finishFramesToTime(allQueuedFrames[allQueuedFrames.length - 1].time);
		}
		HTML5VideoBreakDetector.NotifyWaitingState();
	}
	var dropFrame = function ()
	{
		finishedFrameCount++;
		CheckStreamEndCondition();
	}
	var CheckStreamEndCondition = function ()
	{
		if (allFramesAccepted && (finishedFrameCount) >= acceptedFrameCount)
		{
			if (PlaybackReachedNaturalEndCB)
				PlaybackReachedNaturalEndCB(finishedFrameCount);
		}
	}

	var Initialize = function ()
	{
		developerLog("HTML5_MSE_Player.Initialize()");

		// Since UI3-228, in some circumstances, the HTML5 player copies video frames to a canvas and hides the <video> element. See setCanvasRenderingState function.
		var $parent = $("#videoElement_wrapper");
		$parent.remove();
		$parent = $('<div id="videoElement_wrapper"></div>');
		$("#camimg_store").append($parent);

		// If the video element is muted, browsers are more likely to allow it play without user interaction.
		var $player = $('<video id="html5MseVideoEle" muted></video>');
		$parent.append($player);
		player = $player.get(0);
		delayCompensation = new HTML5DelayCompensationHelper(player);

		//player.addEventListener('abort', function (e) { console.log("HTML5 video abort"); });
		player.addEventListener('error', onVideoError);
		player.addEventListener('timeupdate', onTimeUpdate);
		player.addEventListener('loadedmetadata', onTimeUpdate);
		player.addEventListener('pause', onPlayerPaused);
		player.addEventListener('stalled', onPlayerStalled);
		player.addEventListener('waiting', onPlayerWaiting);
		player.addEventListener('suspend', function (e)
		{
			if (developerMode)
				toaster.Error("HTML5 video suspended", 60000);
			else
				console.log("HTML5 video suspended");
		});
		HTML5BetterFrameTiming(player, onTimeUpdate);
		self.setCanvasRenderingState(false);

		isLoaded = true;
		loadingHelper.SetLoadedStatus("h264");
	}
	this.Dispose = function ()
	{
		developerLog("HTML5_MSE_Player.Dispose()");
		var $parent = $("#videoElement_wrapper");
		$parent.remove();
		if (jmuxer)
		{
			jmuxer.destroy();
			jmuxer = null;
		}
	}
	this.IsLoaded = function ()
	{
		return isLoaded;
	}
	this.IsValid = function ()
	{
		return true;
	}
	this.GetRenderedFrameCount = function ()
	{
		return finishedFrameCount;
	}
	/**
	 * Returns the number of buffered video frames that have not yet been rendered.
	 * If the system has sufficient computational power, this number should remain close to 0.
	 */
	this.GetBufferedFrameCount = function ()
	{
		return acceptedFrameCount - finishedFrameCount;
	}
	/**
	 * Returns the approximate number of milliseconds of video delay caused by insufficient network speed.
	 * If the system has sufficient network bandwidth, this number should remain close to 0.
	 * One or two frames worth of delay is nothing to worry about.
	 */
	this.GetNetworkDelay = function ()
	{
		if (allFramesAccepted)
			return 0;
		return netDelayCalc.Calc();
	}
	/**
	 * Returns the number of milliseconds of buffered video frames, calculated as timestampLastAcceptedFrame - timestampLastRenderedFrame.
	 * If the system has sufficient computational power, this number should remain close to 0.
	 */
	this.GetBufferedTime = function ()
	{
		return timestampLastAcceptedFrame - timestampLastRenderedFrame;
	}
	this.Flush = function ()
	{
		earlyFrames = new Queue();
		if (jmuxer && fedFrameCount > 0)
		{
			mseReady = false;
			player.pause();
			jmuxer.destroy();
			jmuxer = null;
		}
		HTML5VideoBreakDetector.Reset();
		nonKeyframeDropper.Reset();
		hasToldPlayerToPlay = false;
		player.pause();
		delayCompensation = new HTML5DelayCompensationHelper(player);
		lastFrame = false;
		lastFrameDuration = 16;
		acceptedFrameCount = 0;
		finishedFrameCount = 0;
		earlyFrameRenderCalled = false;
		fedFrameCount = 0;
		frameMetadataQueue.Reset();
		netDelayCalc.Reset();
		timestampLastAcceptedFrame = -1;
		timestampLastRenderedFrame = -1;
		var timeNow = performance.now();
		lastFrameReceivedAt = timeNow;
		allFramesAccepted = false;
		currentStreamBitmapInfo = null;
		badAutoplay.Reset();
	}
	var onMSEReady = function ()
	{
		mseReady = true;
		while (!earlyFrames.isEmpty())
			self.AcceptFrame(earlyFrames.dequeue());
	}
	var StartPlayback = function ()
	{
		if (documentIsHidden())
			return;
		hasToldPlayerToPlay = true;
		var playPromise = badAutoplay.Play(player);
		if (playPromise && playPromise.catch)
			playPromise.catch(function (ex)
			{
				if (ex.name === "NotAllowedError")
				{
					InputIsRequiredToPlay();
				}
				else if (acceptedFrameCount === 0)
				{
					// Probably we just Flushed the player.
				}
				else if (ex.code === 20)
				{
					// The play() request was interrupted by a call to pause(). https://goo.gl/LdLk22
				}
				else
					toaster.Warning("HTML5 Player: " + ex.message, 15000);
				//toaster.Warning(ex);
				//if (ex.name === "DOMException")
				//{
				//}
			});
	}
	var InputIsRequiredToPlay = function ()
	{
		hasToldPlayerToPlay = false;
		inputRequiredOverlay.Show("HTML5 player", function ()
		{
			var playPromise = player.play();
			if (playPromise && typeof playPromise.then === "function")
				playPromise.then(function ()
				{
					player.pause()
				});
			videoPlayer.RefreshVideoStream();
		});
		playerErrorHandler("INPUT REQUIRED");
	}
	this.AcceptFrame = function (frame)
	{
		if (nonKeyframeDropper.shouldAccept(frame))
		{
			if (!jmuxer)
			{
				jmuxer = new JMuxer({
					node: 'html5MseVideoEle',
					mode: 'video',
					flushingTime: 1,
					clearBuffer: true,
					cleanOffset: 600, // This is an extension of the original jmuxer.
					onReady: onMSEReady,
					debug: jmuxerDeveloperMode
				});
			}
			if (!mseReady)
			{
				earlyFrames.enqueue(frame);
				return;
			}

			disableRenderingStateChangesUntilNextFrame = false;
			acceptedFrameCount++;
			if (HTML5VideoBreakDetector.CheckForBreak(player, acceptedFrameCount, finishedFrameCount))
			{
				toaster.Warning("Detected HTML5 video player stall. Reopening video stream.", 5000);
				videoPlayer.ReopenStreamAtCurrentSeekPosition();
				return;
			}
			timestampLastAcceptedFrame = frame.time;
			lastFrameReceivedAt = performance.now();
			netDelayCalc.Frame(frame.time, lastFrameReceivedAt);

			frame.meta.duration = lastFrameDuration;
			frame.meta.expectedInterframe = lastFrameDuration;
			frameMetadataQueue.Add(frame);

			if (lastFrame)
			{
				lastFrameDuration = frame.time - lastFrame.time;
				jmuxer.feed({
					video: lastFrame.frameData,
					duration: lastFrameDuration
				});
				if (finishedFrameCount === 0 && !earlyFrameRenderCalled && currentStreamBitmapInfo)
				{
					// Some browsers started having a noticeable delay before their first onTimeUpdate call, so we call frameRendered early for the first frame, causing the video element to be resized at a more appropriate time.
					earlyFrameRenderCalled = true;
					var startMeta = $.extend({}, lastFrame.meta);
					startMeta.width = currentStreamBitmapInfo.biWidth;
					startMeta.height = currentStreamBitmapInfo.biHeight;
					startMeta.timestamp = startMeta.time;
					frameRendered(startMeta);
				}
				fedFrameCount++;
				if (!hasToldPlayerToPlay || player.paused)
				{
					if (hasToldPlayerToPlay && player.paused)
						console.log("Detected that the video player is paused when it should not be. Instructing to play.");
					StartPlayback();
				}
				// Evidently jmuxer can be set to null by some callback method by the time we get to here.
				if (jmuxer && jmuxer.bufferControllers && jmuxer.bufferControllers.video)
				{
					jmuxer.bufferControllers.video.cleanOffset = 600;
				}
			}
			lastFrame = frame;
		}
	}
	this.Toggle = function (activate)
	{
		isActivated = activate;
		if (activate)
		{
			$("#videoElement_wrapper").add(videoModulesShared.Get$Canvas()).appendTo($("#camimg_wrapper"));
			self.setCanvasRenderingState();
		}
		else
		{
			$("#videoElement_wrapper").add(videoModulesShared.Get$Canvas()).appendTo($("#camimg_store"));
			isRenderingToCanvas = null;
			videoModulesShared.Get$Canvas().removeClass('deactivated'); // Remove deactivated class on <canvas> because it is a shared resource.
		}
	}
	this.GetPlayerElement = function ()
	{
		return player;
	}
	this.ClearDrawingSurface = function ()
	{
		videoModulesShared.ClearFrontCanvas();
	}
	this.DrawFullCameraAsThumb = function (cameraId, groupId)
	{
		self.setCanvasRenderingState(true);
		disableRenderingStateChangesUntilNextFrame = true;
		return videoModulesShared.DrawFullCameraAsThumb(cameraId, groupId);
	}
	this.DrawThumbAsFullCamera = function (cameraId, groupId)
	{
		self.setCanvasRenderingState(true);
		disableRenderingStateChangesUntilNextFrame = true;
		return videoModulesShared.DrawThumbAsFullCamera(cameraId, groupId);
	}
	this.GetPlayerName = function ()
	{
		return "HTML5";
	}
	this.GetPlayerNameShort = function ()
	{
		return "h5";
	}
	/**
	 * -1: unknown, 0: false, 1: true
	 */
	this.IsUsingHardwareAcceleration = function ()
	{
		return -1;
	}
	this.PreviousFrameIsLastFrame = function ()
	{
		if (jmuxer)
		{
			if (lastFrame)
			{
				jmuxer.feed({
					video: lastFrame.frameData,
					duration: lastFrameDuration
				});
				fedFrameCount++;
				if (fedFrameCount === 1 && currentStreamBitmapInfo)
				{
					// Hack to force the single frame to get rendered.
					jmuxer.feed({
						video: lastFrame.frameData,
						duration: lastFrameDuration
					});
					var startMeta = $.extend({}, lastFrame.meta);
					startMeta.width = currentStreamBitmapInfo.biWidth;
					startMeta.height = currentStreamBitmapInfo.biHeight;
					startMeta.timestamp = startMeta.time;
					frameRendered(startMeta);
				}
			}
			// jmuxer.mediaSource.endOfStream(); // This was causing MEDIA_ERR_SRC_NOT_SUPPORTED when few frames were submitted before ending the stream.
		}
		allFramesAccepted = true;
		CheckStreamEndCondition();
	}
	this.streamInfoCallback = function (bitmapInfoHeader, waveFormatEx)
	{
		if (bitmapInfoHeader)
			currentStreamBitmapInfo = bitmapInfoHeader;
	}
	/**
	 * Enables or disables canvas rendering.
	 * @param {Boolean} enable True to enable <canvas> rendering. False to enable native <video> rendering. If undefined, canvas rendering will be enabled if the zoom level is higher than "fit".
	 */
	this.setCanvasRenderingState = function (enable)
	{
		if (!isActivated)
			return;
		if (disableRenderingStateChangesUntilNextFrame)
			return;
		if (typeof enable === "undefined")
			enable = imageRenderer.zoomHandler.IsZoomedInMoreThanFit();
		if (isRenderingToCanvas !== enable)
		{
			if (enable)
			{
				// Turn on canvas rendering
				// Copy current video frame, if possible.
				if (aFrameWasOnceRendered)
					videoModulesShared.RenderVideoFrame(player);
				$("#videoElement_wrapper").addClass('deactivated'); // Hide <video>				
				videoModulesShared.Get$Canvas().removeClass('deactivated'); // Show <canvas>
			}
			else
			{
				// Turn off canvas rendering
				$("#videoElement_wrapper").removeClass('deactivated'); // Show <video>
				videoModulesShared.Get$Canvas().addClass('deactivated'); // Hide <canvas>
			}
		}
		isRenderingToCanvas = enable;
		self.UpdateNerdStats();
	}
	this.getCanvasRenderingState = function ()
	{
		return isRenderingToCanvas;
	}
	this.UpdateNerdStats = function ()
	{
		nerdStats.UpdateStat("Renderer", isRenderingToCanvas ? "<canvas>" : "Native HTML5 <video>");
	}

	Initialize();
}
function HTML5DelayCompensationHelper(player)
{
	var self = this;
	var averager = new TimedAverage(3000, 10);
	var nextPlaybackRateChangeAllowedAt = 0;
	var aggressionLevel = 3;
	var minSpeed = 1;
	var maxSpeed = 1;
	var tolerance = 1;
	var lastSetRate = 0;
	var setPlaybackRate = function (rate)
	{
		if (lastSetRate !== rate)
		{
			var ex = null;
			try
			{
				player.playbackRate = rate;
			}
			catch (e)
			{
				ex = e;
			}
			if (ex || player.playbackRate !== rate)
			{
				var errMsg = ex ? ex : "no exception was thrown";
				console.log("HTML5 Delay Compensator failed to set playback rate to " + rate, player.playbackRate, errMsg);
				nextPlaybackRateChangeAllowedAt = performance.now() + 10000;
			}
			lastSetRate = rate;
		}
	}
	this.Tick = function (delayedTime)
	{
		if (averager.done)
		{
			UpdateAggressionLevel();
			if (aggressionLevel > 0)
			{
				var now = performance.now();
				if (now >= nextPlaybackRateChangeAllowedAt)
				{
					var avg = averager.Get();
					var adjustedTolerance = tolerance;
					if (avg < 1000)
					{
						if (avg <= 0)
							avg = 1;
						var adjustmentStrength = 1000 / avg;
						adjustedTolerance = adjustmentStrength * tolerance;
					}
					var toleranceOffset = (avg * adjustedTolerance);
					var min = avg - toleranceOffset;
					var max = avg + toleranceOffset;
					var diff;
					if (delayedTime < min)
						diff = Math.max(delayedTime / min, minSpeed);
					else if (delayedTime > max)
						diff = Math.min(delayedTime / max, maxSpeed);
					else
						diff = 1;
					setPlaybackRate(diff);
					nextPlaybackRateChangeAllowedAt = now + 250;
				}
			}
			else
				setPlaybackRate(1);
		}
		else
		{
			averager.Add(delayedTime);
		}
	}
	var UpdateAggressionLevel = function ()
	{
		var value = settings.ui3_html5_delay_compensation;
		var level;
		if (value === HTML5DelayCompensationOptions.Weak)
			level = 1;
		else if (value === HTML5DelayCompensationOptions.Normal)
			level = 2;
		else if (value === HTML5DelayCompensationOptions.Strong)
			level = 3;
		else
			level = 0;

		if (aggressionLevel !== level)
		{
			aggressionLevel = level;

			if (level == 1)
			{
				tolerance = 0.15;
				minSpeed = 0.95;
				maxSpeed = 1.05;
			}
			else if (level == 2)
			{
				tolerance = 0.1;
				minSpeed = 0.75;
				maxSpeed = 1.25;
			}
			else if (level == 3)
			{
				tolerance = 0.05;
				minSpeed = 0.25;
				maxSpeed = 2;
			}
			else
				minSpeed = maxSpeed = tolerance = 1;
		}
	}
	UpdateAggressionLevel();
	setPlaybackRate(1);
}
/**
 * Tries to detect when HTML5 autoplay is being prevented without the courtesy of a "NotAllowedError".
 * This class also circumvents several browser extensions which use non-standard methods to prevent autoplay, some of which are really incompatible with UI3!
 */
function BadAutoplayPreventionDetector()
{
	var self = this;
	var q = new Queue();
	var pauseLimit = 5;
	var timeIntervalMs = 1000;
	var circ1 = 0;
	var circ2 = 0;
	/**
	 * Call this to reset the detector.
	 */
	this.Reset = function ()
	{
		if (q.getLength() > 0)
			q = new Queue();
		if (circ2 < 1)
		{
			// This action circumvents the Chrome extension "Disable HTML5 Autoplay (Reloaded)".
			circ2++;
			if (typeof postMessage === "function")
				postMessage({ msg: 'dh5a:send-msg-to-frames', msgToSend: { msg: 'input-recieved', event: "mousedown", value: true } }, '*');
		}
	};
	/**
	 * Call this when the player gets paused.
	 * @returns {Boolean} true if it appears that the player is being prevented from playing.
	 */
	this.NotifyPause = function ()
	{
		var now = performance.now();
		q.enqueue(now);
		while (!q.isEmpty() && now - q.peek() >= timeIntervalMs)
			q.dequeue();
		return q.getLength() >= pauseLimit;
	};
	/**
	 * Call this to begin media playback.
	 * @param {Object} player the video player instance
	 * @returns {Promise} the promise returned by calling player.play()
	 */
	this.Play = function (player)
	{
		if (circ1 < 2)
		{
			// This action circumvents the Chrome extension "HTML5 Video Autoplay Blocker"
			circ1++;
			var $ele = $("body > .video-blocker-overlay-btn");
			if ($ele.length > 0)
			{
				$ele.click();
				$ele.remove();
				circ1 = 1000;
			}
		}
		if (typeof html5PlayFunc === "function")
			return html5PlayFunc.call(player); // This action circumvents the Chrome extension "Disable HTML5 Autoplay"
		else
			return player.play();
	};
}
function HTML5BetterFrameTiming(video, callback)
{
	var lastTime = null;
	function timeCheck()
	{
		var time = video.currentTime;
		if (lastTime !== time)
		{
			lastTime = time;
			try
			{
				callback(time);
			}
			catch (ex)
			{
				toaster.Error(ex);
			}
		}
		requestAnimationFrame(timeCheck);
	}
	timeCheck();
}
var HTML5VideoBreakDetector = new (function ()
{
	var playerWasReady = false;
	var isWaitingState = false;
	var didPlayAFrame = false;
	var lastFinishedFrameCount = 0;
	var lastFrameRenderedAtTime = 0;
	var lastStallAtTime = -1;
	var stallTimeout = 2000;

	this.Reset = function ()
	{
		playerWasReady = false;
		isWaitingState = false;
		didPlayAFrame = false;
		lastFinishedFrameCount = 0;
		lastFrameRenderedAtTime = performance.now();
		lastStallAtTime = -1;
	}
	this.NotifyWaitingState = function ()
	{
		isWaitingState = true;
	}
	/**
	 * Returns true if it is believed that the HTML5 video player is in a broken state.
	 * @param {Object} player HTML5 video player
	 * @param {Number} acceptedFrameCount Number of frames accepted from the network.
	 * @param {Number} finishedFrameCount Number of frames rendered.
	 * @returns {Boolean} Returns true if it is believed that the HTML5 video player is in a broken state.
	 */
	this.CheckForBreak = function (player, acceptedFrameCount, finishedFrameCount)
	{
		var now = performance.now();
		if (lastFinishedFrameCount !== finishedFrameCount)
		{
			didPlayAFrame = true;
			isWaitingState = false;
			lastFinishedFrameCount = finishedFrameCount;
			lastFrameRenderedAtTime = now;
		}
		if (playerWasReady)
		{
			if (didPlayAFrame && isWaitingState && acceptedFrameCount - finishedFrameCount >= 8 && player.readyState < 3)
			{
				if (lastStallAtTime < 0)
					lastStallAtTime = now;
				if (now - lastFrameRenderedAtTime > stallTimeout && now - lastStallAtTime > stallTimeout)
				{
					if (stallTimeout < 16000)
						stallTimeout += 2000; // Add 2 seconds to stall time each time a stall is detected, so that on badly-behaving systems it won't be as disruptive.
					return true;
				}
			}
			else
				lastStallAtTime = -1;
		}
		else if (player.readyState >= 3)
		{
			playerWasReady = true;
			lastStallAtTime = -1;
		}
		return false;
	}
})();
///////////////////////////////////////////////////////////////
// Non-keyframe Dropper ///////////////////////////////////////
///////////////////////////////////////////////////////////////
/**
 * Utility module that helps UI3's video players drop non-keyframe frames at the start of a stream.
 */
function NonKeyframeDropper()
{
	var hasSeenKeyframe = false;
	this.shouldAccept = function (frame)
	{
		if (hasSeenKeyframe)
			return true;
		else if (frame.isKeyframe())
		{
			hasSeenKeyframe = true;
			return true;
		}
		else
			return false;
	}
	this.Reset = function ()
	{
		hasSeenKeyframe = false;
	}
}
///////////////////////////////////////////////////////////////
// Network Delay Calculator - An Imperfect Science ////////////
///////////////////////////////////////////////////////////////
function NetDelayCalc()
{
	var self = this;

	var frameCounter = 0;
	var baseFrameTime = 0;
	var lastFrameTime = 0;
	var baseRealTime = -1;
	var lastRealTime = -1;
	var firstRealTime = -1;
	var adjustBaseline = true;
	var avgTimestampDiff = new RollingAverage(30);

	this.Reset = function ()
	{
		frameCounter = 0;
		baseFrameTime = 0;
		lastFrameTime = 0;
		baseRealTime = -1;
		lastRealTime = -1;
		firstRealTime = -1;
		adjustBaseline = true;
		avgTimestampDiff = new RollingAverage(30);
	}
	this.Frame = function (frameTime, realTime)
	{
		frameCounter++;
		if (frameTime != 0)
			avgTimestampDiff.Add(frameTime - lastFrameTime);
		lastFrameTime = frameTime;
		lastRealTime = realTime;
		if (baseRealTime == -1)
		{
			baseFrameTime = frameTime;
			baseRealTime = realTime;
			firstRealTime = realTime;
		}
		else if (adjustBaseline)
		{
			// Keep adjusting the baseline over the first 1 second.
			// The timing of the first few frames is a bit unstable sometimes and can result in reporting 
			// of several hundred ms of network lag that doesn't really exist.
			if (frameCounter > 3 && realTime - firstRealTime >= 2000)
			{
				adjustBaseline = false;
			}
			else
			{
				var delay = CalcSimple(lastFrameTime, lastRealTime, baseFrameTime, baseRealTime);
				if (delay > 0)
				{
					baseFrameTime = frameTime;
					baseRealTime = realTime;
				}
			}
		}
	}
	this.Calc = function ()
	{
		if (baseRealTime == -1)
			return 0;
		var realTimePassed = performance.now() - baseRealTime;
		// Blue Iris does not increase frame timestamps at a rate equivalent to real time while encoding a reduced-speed video.
		// I know it is overcompensating wildly, but I'm using playSpeed as a multiplier here to ensure we don't show erroneous network delay messages in the UI.
		// The network would have to be performing exceptionally poorly to show high network delay while playing at a reduced speed.
		if (!videoPlayer.Loading().image.isLive)
		{
			var playSpeed = playbackControls.GetPlaybackSpeed();
			if (playSpeed < 1)
				realTimePassed *= playSpeed;
		}
		var streamTimePassed = lastFrameTime - baseFrameTime;
		var delay = realTimePassed - streamTimePassed;
		var avgTsDiff = avgTimestampDiff.Get();
		delay -= avgTsDiff;
		if (delay < 0)
			delay = 0;
		//console.log("delay " + delay + " = clock " + realTimePassed + " - timestamp " + streamTimePassed + " - interFrame " + avgTsDiff);
		return delay;
	}
	var CalcSimple = function (ft, rt, b_ft, b_rt)
	{
		var realTimePassed = rt - b_rt;
		var streamTimePassed = ft - b_ft;
		return realTimePassed - streamTimePassed;
	}
}
///////////////////////////////////////////////////////////////
// Image Renderer                                            //
// provides rendering and scaling services                   //
///////////////////////////////////////////////////////////////
function CopyImageToCanvas(imgEle, canvas)
{
	if (canvas.width != imgEle.naturalWidth)
		canvas.width = imgEle.naturalWidth;
	if (canvas.height != imgEle.naturalHeight)
		canvas.height = imgEle.naturalHeight;

	var context2d = canvas.getContext("2d");
	context2d.drawImage(imgEle, 0, 0);
}
function CopyVideoFrameToCanvas(videoEle, canvas)
{
	var w = videoEle.videoWidth;
	var h = videoEle.videoHeight;
	if (canvas.width != w)
		canvas.width = w;
	if (canvas.height != h)
		canvas.height = h;

	var context2d = canvas.getContext("2d");
	context2d.drawImage(videoEle, 0, 0, w, h);
}
function ClearCanvas(canvas)
{
	var context2d = canvas.getContext("2d");
	if (context2d != null)
	{
		context2d.clearRect(0, 0, canvas.width, canvas.height);
	}
	else
	{
		var contextGl = canvas.getContext("webgl");
		if (contextGl != null)
			contextGl.clear(contextGl.COLOR_BUFFER_BIT);
	}
}
function ImageRenderer()
{
	var self = this;
	var dpiScalingFactor = BI_GetDevicePixelRatio();
	var zoomHintTimeout = null;
	var zoomHintIsVisible = false;
	var imageIsDragging = false;
	var imageIsLargerThanAvailableSpace = false;
	var mouseX = 0;
	var mouseY = 0;
	var imgDigitalZoomOffsetX = 0;
	var imgDigitalZoomOffsetY = 0;
	var previousImageDraw = {
		x: -1, y: -1, w: -1, h: -1, z: 10
	};
	previousImageDraw.x = -1;
	previousImageDraw.y = -1;
	previousImageDraw.w = -1;
	previousImageDraw.h = -1;
	previousImageDraw.z = 10;

	this.minGroupImageDimension = 240; // Strictly >= 240 or else dynamic group layouts are broken
	this.maxGroupImageDimension = 7680; // Strictly <= 7680 or else dynamic group layouts are broken

	var $layoutbody = $("#layoutbody");
	var $camimg_wrapper = $("#camimg_wrapper");
	var sccc_outerObjs = $('#layoutbody,#camimg_wrapper,#zoomhint');

	this.zoomHandler = zoomHandler_Adjustable;

	this.GetNativeSize = function (ciLoading)
	{
		if (!ciLoading)
			ciLoading = videoPlayer.Loading().image;

		var x;
		var isDynamicResolutionSource = cameraListLoader.isDynamicLayoutEnabled(ciLoading.id);
		if (isDynamicResolutionSource)
		{
			var lockedResolution = groupCfg.GetLockedResolution(ciLoading);
			if (lockedResolution)
				x = lockedResolution; // This dynamic-resolution video source has a preferred size saved.
			else
				x = new ui3Rect($layoutbody.width(), $layoutbody.height()); // Size this dynamic-resolution video according to the viewport
			x.MultiplyBy(100000); // Drastically enlarge so that it will fill the bounding box we apply below.
			// Apply dynamic stream limits
			x.EnforceMaxArea(self.getMaxGroupImageMegapixels() * 1000000);
			x.ApplyBoundingBox(new ui3Rect(self.maxGroupImageDimension, self.maxGroupImageDimension));
			x.ExpandAround(new ui3Rect(self.minGroupImageDimension, self.minGroupImageDimension));
		}
		else
			x = ciLoading.getFullRect(); // Use the video source metadata's native resolution
		return x;
	}
	/**
	 * Returns a ui3Rect defining the dimensions OF JPEG IMAGE to request for a given video source. NOT USABLE FOR H.264 YET
	 * Considers:
	 * * Display dpi / browser zoom level
	 * * Video player zoom level
	 * * UI settings such as jpeg supersampling
	 * * Requirements of the given streaming profile
	 * * Viewport dimensions
	 * * Dynamic group layouts
	 * @param {BICameraData} ciLoading BICameraData to consider for image loading.  If omitted, the currently loading image object is used (videoPlayer.Loading().image).
	 * @param {StreamingProfile} streamingProfile Streaming profile to confine the returned dimensions.  If omitted, the currently selected streaming profile will be used.
	 * @param {Boolean} doNotRemember If true, the dynamicNative properties of the video source will NOT be set.  Pass true if the size being requested will not be used to load video.
	 */
	this.GetSizeToRequest = function (ciLoading, streamingProfile, doNotRemember)
	{
		if (!ciLoading)
			ciLoading = videoPlayer.Loading().image;
		if (!streamingProfile)
			streamingProfile = genericQualityHelper.GetCurrentProfile();

		/** The size we want the video stream to be. */
		var x = self.GetNativeSize(ciLoading);

		if (!streamingProfile.isHQSnapshot && !doNotRemember)
			SetDynamicNativeSize(ciLoading, x.w, x.h);

		var isDynamicResolutionSource = cameraListLoader.isDynamicLayoutEnabled(ciLoading.id);
		if (streamingProfile.vcodec == "jpeg" && !streamingProfile.isHQSnapshot)
		{
			// We can limit this request size if the zoom factor is less than 1
			var zoomFactor = self.zoomHandler.GetZoomFactor(ciLoading);
			if (zoomFactor < 1)
			{
				var ssFactor = parseFloat(settings.ui3_jpegSupersampling);
				if (isNaN(ssFactor) || ssFactor < 0.01 || ssFactor > 2)
					ssFactor = 1;

				var scaleFactor = dpiScalingFactor * ssFactor;
				if (isDynamicResolutionSource)
				{
					var fit = self.zoomHandler.GetFittingZoomFactor(ciLoading);
					if (zoomFactor < fit || self.zoomHandler.zoomsEqual(zoomFactor, fit))
					{
						var viewportRect = new ui3Rect($layoutbody.width(), $layoutbody.height())
							.MultiplyBy(scaleFactor);
						x.ApplyBoundingBox(viewportRect);
					}
				}
				else
					x.MultiplyBy(zoomFactor * scaleFactor);
			}
		}

		// Honor resolution limit of streaming profile.
		var profileBoundingBox = streamingProfile.GetRect();
		if (profileBoundingBox)
		{
			if (profileBoundingBox.AspectRatio() < 1 !== x.AspectRatio() < 1)
				profileBoundingBox.Rotate(); // Profile is different aspect ratio from video stream. Rotate the profile.
			x.ApplyBoundingBox(profileBoundingBox);
		}

		if (isDynamicResolutionSource || ciLoading.isTimeline()) // All timeline video uses dynamic group sizing logic so these minimum dimensions apply.
			x.ExpandAround(new ui3Rect(self.minGroupImageDimension, self.minGroupImageDimension));

		x.Round().MakeDivisibleBy8();

		return x;
	}
	this.SetMousePos = function (x, y)
	{
		mouseX = x;
		mouseY = y;
	}
	this.GetPreviousImageDrawInfo = function ()
	{
		return previousImageDraw;
	}
	this.GetSimulatedCamimgWrapperPosition = function ()
	{
		return { left: previousImageDraw.x, top: previousImageDraw.y };
	}
	this.ImgResized = function (isFromKeyboard)
	{
		imageRenderer.zoomHandler.notifyImageResized();

		dpiScalingFactor = BI_GetDevicePixelRatio();

		var imgAvailableWidth = $layoutbody.width();
		var imgAvailableHeight = $layoutbody.height();

		var zoomFactor = self.zoomHandler.GetZoomFactor();

		// Calculate new size based on zoom levels
		var imgForSizing = videoPlayer.Loaded().image;
		var widthForSizing;
		var heightForSizing;
		var resizableSource = cameraListLoader.isDynamicLayoutEnabled(imgForSizing.id);
		if (resizableSource)
		{
			widthForSizing = imgForSizing.dynamicNativeW;
			heightForSizing = imgForSizing.dynamicNativeH;
			if (!widthForSizing || !heightForSizing)
			{
				widthForSizing = imgForSizing.actualwidth;
				heightForSizing = imgForSizing.actualheight;
			}
		}
		else
		{
			widthForSizing = imgForSizing.fullwidth;
			heightForSizing = imgForSizing.fullheight;
		}
		var imgDrawWidth = Math.max(1, widthForSizing * zoomFactor);
		var imgDrawHeight = Math.max(1, heightForSizing * zoomFactor);
		$camimg_wrapper.css("width", widthForSizing + "px").css("height", heightForSizing + "px");

		imageIsLargerThanAvailableSpace = imgDrawWidth > imgAvailableWidth || imgDrawHeight > imgAvailableHeight;

		if (previousImageDraw.z > -1 && previousImageDraw.z !== zoomFactor)
		{
			// We just experienced a zoom change
			// Find the mouse position percentage relative to the center of the image at its old size
			var imgPos = imageRenderer.GetSimulatedCamimgWrapperPosition();
			var layoutbodyOffset = $layoutbody.offset();
			if (!layoutbodyOffset) // Edge complained about this once
				layoutbodyOffset = { left: 0, top: 0 };
			var xPos = mouseX;
			var yPos = mouseY;
			if (isFromKeyboard)
			{
				xPos = layoutbodyOffset.left + (imgAvailableWidth / 2);
				yPos = layoutbodyOffset.top + (imgAvailableHeight / 2);
			}
			var mouseRelX = -0.5 + (parseFloat((xPos - layoutbodyOffset.left) - imgPos.left) / previousImageDraw.w);
			var mouseRelY = -0.5 + (parseFloat((yPos - layoutbodyOffset.top) - imgPos.top) / previousImageDraw.h);

			// Get the difference in image size
			var imgSizeDiffX = imgDrawWidth - previousImageDraw.w;
			var imgSizeDiffY = imgDrawHeight - previousImageDraw.h;
			// Modify the zoom offsets by % of difference
			imgDigitalZoomOffsetX -= mouseRelX * imgSizeDiffX;
			imgDigitalZoomOffsetY -= mouseRelY * imgSizeDiffY;
		}

		// Enforce digital panning limits
		var maxOffsetX = (imgDrawWidth - imgAvailableWidth) / 2;
		if (maxOffsetX < 0)
			imgDigitalZoomOffsetX = 0;
		else if (imgDigitalZoomOffsetX > maxOffsetX)
			imgDigitalZoomOffsetX = maxOffsetX;
		else if (imgDigitalZoomOffsetX < -maxOffsetX)
			imgDigitalZoomOffsetX = -maxOffsetX;

		var maxOffsetY = (imgDrawHeight - imgAvailableHeight) / 2;
		if (maxOffsetY < 0)
			imgDigitalZoomOffsetY = 0;
		else if (imgDigitalZoomOffsetY > maxOffsetY)
			imgDigitalZoomOffsetY = maxOffsetY;
		else if (imgDigitalZoomOffsetY < -maxOffsetY)
			imgDigitalZoomOffsetY = -maxOffsetY;

		// Calculate new image position
		var proposedX = (((imgAvailableWidth - imgDrawWidth) / 2) + imgDigitalZoomOffsetX);
		var proposedY = (((imgAvailableHeight - imgDrawHeight) / 2) + imgDigitalZoomOffsetY);

		// Store new image position for future calculations
		previousImageDraw.x = proposedX;
		previousImageDraw.y = proposedY;
		previousImageDraw.w = imgDrawWidth;
		previousImageDraw.h = imgDrawHeight;
		previousImageDraw.z = zoomFactor;

		// Css scaling shim:
		proposedX += (widthForSizing * (zoomFactor - 1)) / 2;
		proposedY += (heightForSizing * (zoomFactor - 1)) / 2;

		var player = videoPlayer.GetPlayerObject();
		if (player && player.isMsePlayer)
			player.setCanvasRenderingState();

		var transform = "translate(" + proposedX + "px, " + proposedY + "px)";
		transform += " scale(" + zoomFactor + ")";
		$camimg_wrapper.css("transform", transform);

		BI_CustomEvent.Invoke("ImageResized");
	}
	this.DigitalZoomNow = function (deltaY, isFromKeyboard)
	{
		self.zoomHandler.OffsetZoom(deltaY);
		AfterZoom(isFromKeyboard);
	}
	var AfterZoom = function (isFromKeyboard)
	{
		$("#zoomhint").stop(true, true);
		$("#zoomhint").show();
		zoomHintIsVisible = true;
		$("#zoomhint").html(GetDigitalZoomLabel());
		RepositionZoomHint(isFromKeyboard);
		if (zoomHintTimeout !== null)
			clearTimeout(zoomHintTimeout);
		zoomHintTimeout = setTimeout(function ()
		{
			$("#zoomhint").fadeOut({
				done: function ()
				{
					zoomHintIsVisible = false;
				}
			})
		}, 200);

		self.ImgResized(isFromKeyboard);

		SetCamCellCursor();
	}
	var GetDigitalZoomLabel = function ()
	{
		var fit = self.zoomHandler.GetFittingZoomFactor();
		var zoomFactor = self.zoomHandler.GetZoomFactor();
		var rounded = zoomFactor < 1 ? (Math.round(zoomFactor * 100) / 100) : (Math.round(zoomFactor * 10) / 10);
		if (rounded === 1)
		{
			// Only show "1x" if it is exactly 1x.  Otherwise round down or up.
			if (zoomFactor < 1)
				rounded -= 0.01;
			else if (zoomFactor > 1)
				rounded += 0.1;
		}

		var text = rounded + "x";
		var isOne = self.zoomHandler.zoomsEqual(1, zoomFactor);
		var isFit = self.zoomHandler.zoomsEqual(fit, zoomFactor);
		if (isOne && isFit)
			text += " (Best Fit, Native)";
		else if (isOne)
			text += " (Native)";
		else if (isFit)
			text += " (Best Fit)";
		return text;
	}
	this.DigitalPan = function (dx, dy)
	{
		imgDigitalZoomOffsetX += dx;
		imgDigitalZoomOffsetY += dy;
		self.ImgResized(true);
	}
	var RepositionZoomHint = function (isFromKeyboard)
	{
		var xPos = mouseX;
		var yPos = mouseY;
		if (isFromKeyboard)
		{
			var layoutbodyOffset = $layoutbody.offset();
			xPos = layoutbodyOffset.left + ($layoutbody.outerWidth(true) / 2);
			yPos = layoutbodyOffset.top + ($layoutbody.outerHeight(true) / 2);
		}
		$("#zoomhint").css("left", (xPos - $("#zoomhint").outerWidth(true)) + "px").css("top", (yPos - $("#zoomhint").outerHeight(true)) + "px");
	}
	var SetCamCellCursor = function ()
	{
		if (imageIsLargerThanAvailableSpace)
		{
			if (imageIsDragging)
			{
				sccc_outerObjs.removeClass("grabcursor");
				sccc_outerObjs.addClass("grabbingcursor");
			}
			else
			{
				sccc_outerObjs.removeClass("grabbingcursor");
				sccc_outerObjs.addClass("grabcursor");
			}
		}
		else
		{
			sccc_outerObjs.removeClass("grabcursor");
			sccc_outerObjs.removeClass("grabbingcursor");
		}
	}
	this.CamImgDragStart = function (e)
	{
		mouseX = e.mouseX;
		mouseY = e.mouseY;
		imageIsDragging = true;
		SetCamCellCursor();
	}
	this.CamImgDragMove = function (e, mouseIsDown, dragHasMoved)
	{
		if (mouseIsDown && !dragHasMoved)
			return;

		var requiresImgResize = false;
		if (imageIsDragging && imageIsLargerThanAvailableSpace)
		{
			imgDigitalZoomOffsetX += (e.mouseX - mouseX);
			imgDigitalZoomOffsetY += (e.mouseY - mouseY);
			requiresImgResize = true;
		}

		mouseX = e.mouseX;
		mouseY = e.mouseY;

		if (requiresImgResize)
			self.ImgResized(false);

		if (zoomHintIsVisible)
			RepositionZoomHint(false);
	}
	this.CamImgDragEnd = function (e)
	{
		imageIsDragging = false;
		SetCamCellCursor();

		mouseX = e.mouseX;
		mouseY = e.mouseY;
	}
	$layoutbody.on('wheel', function (e)
	{
		if (playbackControls.MouseInSettingsPanel(e))
			return;
		mouseCoordFixer.fix(e);
		self.SetMousePos(e.mouseX, e.mouseY);
		e.preventDefault();
		var ne = normalizeWheelEvent(e.originalEvent);
		var deltaY = ne.spinY;
		deltaY *= -1; // Invert wheel delta so that wheel up is zoom in by default.
		if (settings.ui3_wheelZoomReverse === "1")
			deltaY *= -1;
		self.DigitalZoomNow(deltaY, false);
	});

	var hammertime;
	var pinchZoomState = { lastScale: 0, startingZoomFactor: 0, active: false };
	var toast;
	function onPinchStart(e)
	{
		if (settings.ui3_browserZoomEnabled !== "1")
		{
			pinchZoomState.active = true;
			pinchZoomState.startingZoomFactor = self.zoomHandler.GetZoomFactor(videoPlayer.Loaded().image);
			e.mouseX = e.center.x;
			e.mouseY = e.center.y;
			self.CamImgDragStart(e);
		}
	}
	function onPinchMove(e)
	{
		if (!pinchZoomState.active)
			return;
		e.mouseX = e.center.x;
		e.mouseY = e.center.y;
		self.CamImgDragMove(e);

		var zoomSpeed = Clamp(parseFloat(settings.ui3_wheelAdjustableSpeed), 200, 2000);
		zoomSpeed /= 400; // Make it a number between 0.05 and 5, where default is 1

		var speedExponent = zoomSpeed;
		var scale = Math.pow(e.scale, speedExponent);

		var szf = pinchZoomState.startingZoomFactor;
		var zf = szf * Math.max(0.001, scale);
		self.zoomHandler.SetZoomFactor(zf);
		AfterZoom(false);
	}
	function onPinchEnd(e)
	{
		if (!pinchZoomState.active)
			return;
		e.mouseX = e.center.x;
		e.mouseY = e.center.y;
		self.CamImgDragEnd(e);
		pinchZoomState.active = false;
	}
	function onSwipe(e)
	{
		if (e.pointerType === "mouse" && settings.ui3_allow_mouse_swipe_gestures !== "1")
			return false;
		if (e.pointerType === "touch" && settings.ui3_allow_touch_swipe_gestures !== "1")
			return false;
		// If the video player is zoomed in at all, the input events are used for video panning so we need to disable swipe actions.
		if (!self.zoomHandler.IsZoomedInMoreThanFit()) 
		{
			if (e.direction === HammerConstants.DIRECTION_LEFT)
			{
				if (settings.ui3_touch_gestures_reverse === "1")
					BI_Hotkey_PreviousCamera();
				else
					BI_Hotkey_NextCamera();
			}
			else if (e.direction === HammerConstants.DIRECTION_RIGHT)
			{
				if (settings.ui3_touch_gestures_reverse === "1")
					BI_Hotkey_NextCamera();
				else
					BI_Hotkey_PreviousCamera();
			}
		}
	}
	var HammerConstants = {
		DIRECTION_NONE: 1,
		DIRECTION_LEFT: 2,
		DIRECTION_RIGHT: 4,
		DIRECTION_UP: 8,
		DIRECTION_DOWN: 16,
		DIRECTION_HORIZONTAL: 6,
		DIRECTION_VERTICAL: 24,
		DIRECTION_ALL: 30
	};
	this.onToggleBrowserZoom = function ()
	{
		if (settings.ui3_browserZoomEnabled === "1")
		{
			if (hammertime)
			{
				ReloadToTakeEffectToast();
				// The following hammer destruction methods do not re-enable native browser zoom over the video player.
				hammertime.off('pinchstart pinchmove pinchend swipe');
				hammertime.get('pinch').set({ enable: false });
				hammertime.stop(true);
				hammertime.destroy();
				hammertime = null;
				imageRenderer.zoomHandler.ZoomToFit();
				resized();
			}
		}
		else
		{
			if (!hammertime)
			{
				DestroyReloadToTakeEffectToast();
				hammertime = new Hammer($layoutbody.get(0));
				hammertime.get('pinch').set({ enable: true });
				hammertime.get('pinch').recognizeWith(hammertime.get('pan')); // Allow pinch to resume if one finger lifts and touches again.
				hammertime.on('pinchstart', onPinchStart);
				hammertime.on('pinchmove', onPinchMove);
				hammertime.on('pinchend', onPinchEnd);
				hammertime.get('swipe').set({ direction: HammerConstants.DIRECTION_HORIZONTAL });
				hammertime.on('swipe', onSwipe);
			}
		}
	}
	/**
	 * Returns the maximum safe value to use as dimensions of a dynamic group image.
	 */
	this.getMaxGroupImageMegapixels = function ()
	{
		var d = parseFloat(settings.ui3_maxDynamicGroupImageMegapixels);
		if (!d || isNaN(d))
			return 2.1;
		else
			return Clamp(d, 0.1, 59); // 59 megapixels is larger than 7680x7680.
	}
}
///////////////////////////////////////////////////////////////
// Digital Zoom ///////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var zoomHandler_Adjustable = new (function ()
{
	var self = this;
	var $layoutbody = $("#layoutbody");
	var absoluteMinZoomFactor = 0.000001;
	var absoluteMinZoomScaler = Math.log2(absoluteMinZoomFactor); // About -20
	var maxZoomScaler = Math.log2(50); // About 5.6
	var _zoomScaler = absoluteMinZoomScaler;
	var wasZoomedToFit = true;
	var defaultZoomStep = maxZoomScaler / 29; // A standard wheel mouse will give 30 distinct zoom levels between 1:1 rendering size and max zoomed-in (zoomFactor 1x to 50x), same as legacy zoom handler.. Some input devices have more or less precision.
	this.OffsetZoom = function (deltaY)
	{
		var zoomSpeed = Clamp(parseFloat(settings.ui3_wheelAdjustableSpeed), 20, 2000);
		zoomSpeed /= 400;
		// zoomSpeed is now a multiplier between 2% and 500%.
		var delta = deltaY * defaultZoomStep * zoomSpeed;
		self.SetZoomScaler(self.GetZoomScaler() + delta);
	}
	/**
	 * Gets the zoom factor, with a range of 0.000001 to 50.
	 * @param {Object} image 
	 */
	this.GetZoomFactor = function (image)
	{
		var zoomFactor = Math.pow(2, self.GetZoomScaler(image));
		return zoomFactor;
	}
	/**
	 * Sets the zoom factor, with a range of 0.000001 to 50.
	 * @param {Number} zoomFactor Number between 0.000001 and 50.
	 */
	this.SetZoomFactor = function (zoomFactor)
	{
		self.SetZoomScaler(Math.log2(zoomFactor));
	}
	this.ZoomToFit = function (image)
	{
		_zoomScaler = self.GetFittingZoomScaler(image);
	}
	this.GetFittingZoomScaler = function (image)
	{
		return Math.log2(self.GetFittingZoomFactor(image));
	}
	this.GetFittingZoomFactor = function (image)
	{
		if (!videoPlayer)
			return 0;
		var oneXSize;
		if (!image)
			image = videoPlayer.Loaded().image;
		if (!image.id)
			return absoluteMinZoomFactor;
		if (cameraListLoader.isDynamicLayoutEnabled(image.id))
			oneXSize = image.getDynamicNativeRect();
		if (!oneXSize || !oneXSize.w || !oneXSize.h)
			oneXSize = imageRenderer.GetNativeSize(image);

		var viewport = new ui3Rect($layoutbody.width(), $layoutbody.height());
		var fitting = oneXSize.Copy().ExpandAround(viewport).ApplyBoundingBox(viewport);
		if (fitting.w > fitting.h)
			return fitting.w / oneXSize.w;
		else
			return fitting.h / oneXSize.h;
	}
	var applyZoomScalerLimits = function (zs, fitZoomScaler)
	{
		var minZoomScaler = fitZoomScaler; //fitZoomScaler may be positive (> 1 zoom factor) or negative (0-1 zoom factor).
		if (settings.ui3_alwaysAllow1xVideoZoom === "1")
			minZoomScaler = Math.min(0, minZoomScaler); // Allow zooming out to 1x even if that is smaller than viewport.
		zs = Math.max(zs, minZoomScaler);
		return Clamp(zs, absoluteMinZoomScaler, maxZoomScaler);
	}
	/**
	 * Sets the zoom scaler, with a range of about -20 to 5.6. Linear increases to zoom scaler over time yield a linear-looking zoom rate.
	 * @param {Number} zs Number with a range of about -20 to 5.6.
	 */
	this.SetZoomScaler = function (zs)
	{
		var fit = self.GetFittingZoomScaler();
		if (isNaN(zs))
			zs = fit;
		// Ensures we always hit "fit" zoom precisely when zooming past it.
		zs = borderGuard(_zoomScaler, zs, fit);
		// Ensures we always hit "1x" zoom precisely when zooming past it.
		zs = borderGuard(_zoomScaler, zs, 0);
		_zoomScaler = applyZoomScalerLimits(zs, fit);
		wasZoomedToFit = self.zoomsEqual(_zoomScaler, fit);
	}
	/**
	 * Gets the current zoom scaler, with a range of about -20 to 5.6. Linear increases to zoom scaler over time yield a linear-looking zoom rate.
	 * @param {Object} image
	 */
	this.GetZoomScaler = function (image)
	{
		var fit = self.GetFittingZoomScaler(image);
		var zs = applyZoomScalerLimits(_zoomScaler, fit);
		if (fit < 0 && zs !== fit && self.zoomsNear(zs, 0))
			return 0;
		if (0 < fit && zs !== 0 && self.zoomsNear(zs, fit))
			return fit;
		return zs;
	}
	var borderGuard = function (oldValue, newValue, border)
	{
		// Don't allow the value to cross the border until it has already been at the border.
		if (oldValue < border && newValue > border)
			return border;
		if (oldValue > border && newValue < border)
			return border;
		if (self.zoomsEqual(newValue, border) && !self.zoomsEqual(oldValue, border))
			return border; // New value is really close to the border. Put it right on the border to avoid future precision errors.
		return newValue;
	}
	this.zoomsEqual = function (a, b)
	{
		return Math.abs(a - b) < 0.0001;
	}
	this.zoomsNear = function (a, b)
	{
		return Math.abs(a - b) < 0.05;
	}
	this.notifyImageResized = function ()
	{
		if (wasZoomedToFit && videoPlayer && videoPlayer.Loaded().image.id)
			self.ZoomToFit(videoPlayer.Loaded().image);
	}
	this.IsZoomedToFit = function ()
	{
		var fit = self.GetFittingZoomScaler();
		return self.zoomsEqual(_zoomScaler, fit);
	}
	this.IsZoomedInMoreThanFit = function ()
	{
		var fit = self.GetFittingZoomScaler();
		return fit < _zoomScaler && !self.zoomsEqual(_zoomScaler, fit);
	}
})();
///////////////////////////////////////////////////////////////
// Camera Name Labels /////////////////////////////////////////
///////////////////////////////////////////////////////////////
function onui3_cameraLabelsChanged()
{
	cameraNameLabels.show();
}
function OnChange_ui3_camera_overlay_icons()
{
	cameraNameLabels.show();
	cameraListLoader.LoadCameraList();
}
function CameraNameLabels()
{
	var self = this;
	var $camimg_wrapper = $("#camimg_wrapper");
	var $camLabels_wrapper = $("#cameraLabelsWrapper");

	BI_CustomEvent.AddListener("ImageResized", onui3_cameraLabelsChanged);
	BI_CustomEvent.AddListener("CameraListLoaded", onui3_cameraLabelsChanged);
	BI_CustomEvent.AddListener("DynamicGroupLayoutLoaded", onui3_cameraLabelsChanged);
	BI_CustomEvent.AddListener("FirstFrameLoaded", onui3_cameraLabelsChanged);

	this.show = function (isHotkeyShow)
	{
		self.hide();
		var loaded = videoPlayer.Loaded();
		if (!loaded.cam || !loaded.image.uniqueId)
			return;

		var show_names = settings.ui3_cameraLabels_enabled === "1";
		var show_overlay_icons = AnyCameraOverlayIconsEnabled();

		var showName = settings.ui3_cameraLabels_text === CameraLabelTextValues.Name;
		var showShortName = settings.ui3_cameraLabels_text === CameraLabelTextValues.ShortName;
		if (settings.ui3_cameraLabels_text === CameraLabelTextValues.Both)
			showName = showShortName = true;
		if (!showName && !showShortName)
			show_names = false;

		show_names = show_names && ((loaded.image.isGroup && settings.ui3_cameraLabels_multiCameras === "1") || (!loaded.image.isGroup && settings.ui3_cameraLabels_singleCameras === "1"));

		if (show_names || show_overlay_icons)
		{
			var nativeRes = cameraListLoader.isDynamicLayoutEnabled(loaded.image.id)
				? loaded.image.getActualRect()
				: loaded.image.getFullRect();
			var scaleX = imageRenderer.GetPreviousImageDrawInfo().w / nativeRes.w;
			var scaleY = imageRenderer.GetPreviousImageDrawInfo().h / nativeRes.h;
			var offsetCamHeight = settings.ui3_cameraLabels_position === CameraLabelPositionValues.Bottom || settings.ui3_cameraLabels_position === CameraLabelPositionValues.Below;
			var offsetNegativeLabelHeight = settings.ui3_cameraLabels_position === CameraLabelPositionValues.Above || settings.ui3_cameraLabels_position === CameraLabelPositionValues.Bottom;

			// Calculate label font size
			var fontSizePt = parseFloat(settings.ui3_cameraLabels_fontSize);

			var zoomAmount = (scaleX + scaleY) / 2; // scaleX and scaleY are probably the same or very close anyway.
			zoomAmount = Clamp(zoomAmount, 0.5, 2); // Font sizing is a little screwy since 2022-03 or earlier. This keeps it from getting too big.
			fontSizePt *= zoomAmount;
			var minScaledFontSize = parseFloat(settings.ui3_cameraLabels_minimumFontSize);
			if (fontSizePt < minScaledFontSize)
				fontSizePt = minScaledFontSize;

			var imgPos = imageRenderer.GetSimulatedCamimgWrapperPosition();
			var cams = cameraListLoader.GetGroupCams(loaded.cam.optionValue);
			var rects = cameraListLoader.GetGroupRects(loaded.cam.optionValue);
			if (!cams || cams.length === 0)
			{
				cams = [loaded.cam.optionValue];
				rects = [[0, 0, loaded.cam.width, loaded.cam.height]];
			}
			var sb = new StringBuilder();
			if (!rects || !cams || rects.length !== cams.length)
				return;
			for (var i = 0; i < cams.length; i++)
			{
				var cam = cameraListLoader.GetCameraWithId(cams[i]);
				if (!cam)
				{
					console.log('Camera label renderer could not find camera "' + cams[i] + '"');
					continue;
				}
				var rect = rects[i];

				// Calculate scaled/adjusted rectangle boundaries
				var adjX = rect[0] * scaleX;
				var adjY = rect[1] * scaleY;
				var adjW = (rect[2] - rect[0]) * scaleX;
				var adjH = (rect[3] - rect[1]) * scaleY;

				if (show_names)
				{
					// Create and style labels.
					sb.Append('<div class="cameraNameLabel" style="');
					sb.Append("width:" + adjW + "px;");

					var bgOpacity = PercentTo01Float(settings.ui3_cameraLabels_backgroundOpacity);
					var textOpacity = PercentTo01Float(settings.ui3_cameraLabels_textOpacity);
					if (settings.ui3_cameraLabels_cameraColor == "1")
					{
						var colorHex = BlueIrisColorToCssColor(cam.color);
						var colorRgba = HexColorToRgbaColor(colorHex, bgOpacity);
						sb.Append("background-color:" + colorRgba + ";");
						colorRgba = HexColorToRgbaColor(GetReadableTextColorHexForBackgroundColorHex(colorHex), textOpacity);
						sb.Append("color:" + colorRgba + ";");
					}
					else
					{
						var bg = HexColorToRgbObj(settings.ui3_cameraLabels_backgroundColor);
						var tx = HexColorToRgbObj(settings.ui3_cameraLabels_textColor);
						sb.Append("background-color:rgba(" + bg.r + "," + bg.g + "," + bg.b + "," + bgOpacity + ");");
						sb.Append("color:rgba(" + tx.r + "," + tx.g + "," + tx.b + "," + textOpacity + ");");
					}
					sb.Append("font-size:" + fontSizePt + "px;");
					sb.Append("left:" + (adjX + imgPos.left) + "px;");

					var yOffset = 0;
					if (offsetCamHeight)
						yOffset += adjH;
					if (offsetNegativeLabelHeight)
						yOffset -= (fontSizePt * 1.333333);
					sb.Append("top:" + (adjY + imgPos.top + yOffset) + "px;");
					sb.Append('">');
					if (showName && showShortName)
						sb.Append(htmlEncode(CleanUpGroupName(cam.optionDisplay) + " (" + cam.optionValue + ")"));
					else if (showName)
						sb.Append(htmlEncode(CleanUpGroupName(cam.optionDisplay)));
					else
						sb.Append(htmlEncode(cam.optionValue));
					sb.Append('</div>');
				}

				// Build icon HTML
				if (show_overlay_icons)
				{
					var icons = GetCameraOverlayIcons(cams[i]);
					if (icons.length > 0)
					{
						var iconYOffset = 0;
						if (show_names && !offsetCamHeight && !offsetNegativeLabelHeight)
							iconYOffset = (fontSizePt * 1.333333);

						sb.Append('<div class="cameraOverlayIcons' + (settings.ui3_icons_extraVisibility === "1" ? " extraVisibility" : "") + '" style="');
						sb.Append("width:" + adjW + "px;");
						sb.Append("left:" + (adjX + imgPos.left) + "px;");
						sb.Append("top:" + (adjY + imgPos.top + iconYOffset) + "px;");
						sb.Append('">');
						for (var n = 0; n < icons.length; n++)
						{
							var icon = icons[n];
							if (!icon.color)
								icon.color = "#FF0000";
							sb.Append('<div class="cameraOverlayIcon" style="color: ' + icon.color + ';">');
							sb.Append('<svg class="icon' + (icon.iconclass ? " " + icon.iconclass : "") + '"><use xlink:href="' + icon.svg + '"></use></svg>');
							sb.Append('</div>');
						}
						sb.Append('</div>');
					}
				}
			}
			$camLabels_wrapper.append(sb.ToString());
		}
	}
	this.hide = function ()
	{
		$camLabels_wrapper.empty();
	}
}
function GetCameraOverlayIcons(cameraId)
{
	var icons = [];
	var cam = cameraListLoader.GetCameraWithId(cameraId);
	if (cam)
	{
		var ts = cam.triggerSource;
		if (settings.ui3_camera_overlay_icon_motion_trigger === "1"
			&& NumberHasFlags(ts, TRIGGER_SOURCE_MOTION))
		{
			icons.push({ id: "motion_trigger", svg: "#svg_mio_run", iconclass: "noflip" });
		}
		if (settings.ui3_camera_overlay_icon_audio_trigger === "1"
			&& NumberHasFlags(ts, TRIGGER_SOURCE_AUDIO))
		{
			icons.push({ id: "audio_trigger", svg: "#svg_mio_volumeUp", iconclass: "noflip" });
		}
		if (settings.ui3_camera_overlay_icon_generic_trigger === "1"
			&& (NumberHasFlags(ts, TRIGGER_SOURCE_ONVIF) || NumberHasFlags(ts, TRIGGER_SOURCE_EXTERNAL) || NumberHasFlags(ts, TRIGGER_SOURCE_DIO) || NumberHasFlags(ts, TRIGGER_SOURCE_GROUP)))
		{
			icons.push({ id: "generic_trigger", svg: "#svg_x5F_Alert1" });
		}
		if (settings.ui3_camera_overlay_icon_paused === "1"
			&& cam.isPaused)
		{
			icons.push({ id: "camera_paused", svg: "#svg_x5F_Pause", color: "rgba(255,128,64,1)" });
		}
		if ((settings.ui3_camera_overlay_icon_new_alerts === "1"
			|| ui3CamSettings.get(cameraId, "overlay_icon_new_alerts") === "1")
			&& cam.newalerts > 0)
		{
			icons.push({ id: "camera_paused", svg: "#svg_x5F_Alert2", color: "rgba(255,255,0,1)" });
		}
		if (settings.ui3_camera_overlay_icon_webcasting_disabled === "1"
			&& !cam.webcast)
		{
			icons.push({ id: "webcasting_disabled", svg: "#svg_x5F_HoldProfile" });
		}
	}
	return icons;
}
function AnyCameraOverlayIconsEnabled()
{
	return AnyCameraTriggerOverlayIconsEnabled()
		|| settings.ui3_camera_overlay_icon_webcasting_disabled === "1"
		|| settings.ui3_camera_overlay_icon_paused === "1"
		|| settings.ui3_camera_overlay_icon_new_alerts === "1"
		|| ui3CamSettings.any(function (cs) { return cs.get("overlay_icon_new_alerts") === "1" && cameraListLoader.GetCameraWithId(cs.getCamId()); });
}
function AnyCameraTriggerOverlayIconsEnabled()
{
	return settings.ui3_camera_overlay_icon_motion_trigger === "1"
		|| settings.ui3_camera_overlay_icon_audio_trigger === "1"
		|| settings.ui3_camera_overlay_icon_generic_trigger === "1";
}
function AnyTimeSensitiveCameraStatusEffectsEnabled()
{
	var isH264 = videoPlayer.CurrentPlayerModuleName() === 'h264';
	return AnyCameraTriggerOverlayIconsEnabled()
		|| (!isH264 && settings.ui3_sound_motion && settings.ui3_sound_motion !== "None")
		|| (!isH264 && settings.ui3_sound_trigger && settings.ui3_sound_trigger !== "None")
		|| (settings.ui3_sound_alert && settings.ui3_sound_alert !== "None");
}
///////////////////////////////////////////////////////////////
// VideoCenter Icons and Video Loading/Buffering Overlay //////
///////////////////////////////////////////////////////////////
var videoOverlayHelper = new (function ()
{
	var self = this;
	var loadingOverlayHidden = true;
	var loadingAnimHidden = true;
	var falseLoadingOverlayHidden = true;
	var overlayIsLessIntense = false;
	var $loadingOverlay = $("#camimg_loading");
	var $loadingAnim = $("#camimg_loading_anim");
	var $falseLoadingOverlay = $("#camimg_false_loading");
	var $tempPlayIcon = $("#camimg_playIcon,#camimg_centerIconBackground");
	var $tempPauseIcon = $("#camimg_pauseIcon,#camimg_centerIconBackground");
	var $temporaryIcons = $("#camimg_playIcon,#camimg_pauseIcon,#camimg_centerIconBackground");

	this.HideLoadingOverlay = function ()
	{
		if (!loadingOverlayHidden)
		{
			loadingOverlayHidden = true;
			$loadingOverlay.addClass('hidden').removeClass('visible');
		}
		self.HideLoadingAnimation();
	}
	this.HideLoadingAnimation = function ()
	{
		if (!loadingAnimHidden)
		{
			loadingAnimHidden = true;
			$loadingAnim.addClass('hidden').removeClass('visible');
		}
	}
	this.ShowLoadingOverlay = function (showAnimation, lessIntenseOverlay)
	{
		if (loadingOverlayHidden)
		{
			loadingOverlayHidden = false;
			$loadingOverlay.removeClass('hidden').addClass('visible');
		}
		if (lessIntenseOverlay && !overlayIsLessIntense)
			$loadingOverlay.addClass("lessIntense");
		else if (!lessIntenseOverlay && overlayIsLessIntense)
			$loadingOverlay.removeClass("lessIntense");
		if (showAnimation)
			self.ShowLoadingAnimation();
		else
			self.HideLoadingAnimation();
	}
	this.ShowLoadingAnimation = function ()
	{
		if (loadingAnimHidden)
		{
			loadingAnimHidden = false;
			$loadingAnim.removeClass('hidden').addClass('visible');
		}
	}
	this.HideFalseLoadingOverlay = function ()
	{
		if (!falseLoadingOverlayHidden)
		{
			falseLoadingOverlayHidden = true;
			$falseLoadingOverlay.addClass('hidden').removeClass('visible');
		}
	}
	this.ShowFalseLoadingOverlay = function ()
	{
		if (falseLoadingOverlayHidden)
		{
			falseLoadingOverlayHidden = false;
			$falseLoadingOverlay.removeClass('hidden').addClass('visible');
		}
	}
	this.ShowTemporaryPlayIcon = function (duration)
	{
		self.HideTemporaryIcons();
		fadeIcons($tempPlayIcon, duration);
	}
	this.ShowTemporaryPauseIcon = function (duration)
	{
		self.HideTemporaryIcons();
		fadeIcons($tempPauseIcon, duration);
	}
	var fadeIcons = function ($icons, duration)
	{
		if (!duration)
			duration = 1000;
		$icons.show().fadeOut(duration);
	}
	this.HideTemporaryIcons = function ()
	{
		$temporaryIcons.stop(true, true);
	}
})();
///////////////////////////////////////////////////////////////
// Corner Status Icons ////////////////////////////////////////
///////////////////////////////////////////////////////////////
function CornerStatusIcons()
{
	var self = this;
	var iconMap = new FasterObjectMap();
	// Icon names should be unique and alphanumeric ([0-9A-Za-z_]) because they are used to build the name of a setting.
	self.iconList = new Array();
	self.iconList.push({
		name: "streamDelay",
		iconHtml: '<svg class="icon noflip"><use xlink:href="#svg_mio_clock"></use></svg>',
		rgb: "255,128,0",
		class: "big",
		title: "This stream is delayed. Click for more details.",
		click: ShowStreamDelayDetails
	});
	self.iconList.push({
		name: "recording",
		iconHtml: '<svg class="icon"><use xlink:href="#svg_x5F_Stoplight"></use></svg>',
		rgb: "255,0,0",
		title: "A camera is recording"
	});
	self.iconList.push({
		name: "trigger",
		iconHtml: '<svg class="icon"><use xlink:href="#svg_x5F_Alert1"></use></svg>',
		rgb: "255,64,64",
		title: "A camera is triggered"
	});
	self.iconList.push({
		name: "motion",
		iconHtml: '<svg class="icon noflip"><use xlink:href="#svg_mio_run"></use></svg>',
		rgb: "120,205,255",
		title: "Motion is detected"
	});
	this.Set = function (iconName, show)
	{
		if (show && self.IsIconEnabled(iconName))
			self.Show(iconName);
		else
			self.Hide(iconName);
	}
	this.Show = function (iconName)
	{
		var icon = iconMap[iconName];
		if (icon && !icon.visible && icon.$ele)
		{
			icon.$ele.show();
			icon.visible = true;
		}
	}
	this.Hide = function (iconName)
	{
		var icon = iconMap[iconName];
		if (icon && icon.visible && icon.$ele)
		{
			icon.$ele.hide();
			icon.visible = false;
		}
	}
	this.ShowAll = function ()
	{
		for (var key in iconMap)
			this.Show(key);
	}
	this.HideAll = function ()
	{
		for (var key in iconMap)
			this.Hide(key);
	}
	this.IsIconEnabled = function (iconName)
	{
		return settings.getItem("ui3_icon_" + iconName) !== "0";
	}
	/** This can be called at any time to recreate icons from iconList, e.g. if new icons were added to the array. */
	this.ReInitialize = function ()
	{
		var $container = $("#cornerStatusIcons");
		$container.empty();
		iconMap = new FasterObjectMap();
		for (var i = 0; i < self.iconList.length; i++)
		{
			var icon = self.iconList[i];
			iconMap[icon.name] = icon;
			icon.$ele = $('<div class="cornerStatusIconWrapper"></div>');
			icon.$ele.attr('iconName', icon.name);
			icon.$ele.attr('title', icon.title);
			icon.$ele.html(icon.iconHtml);
			if (icon.class)
				icon.$ele.addClass(icon.class);
			if (icon.rgb)
			{
				var a = typeof icon.a === "number" ? icon.a : 1;
				icon.$ele.css("color", "rgba(" + icon.rgb + "," + a + ")");
				if (settings.ui3_icons_extraVisibility === "1")
				{
					icon.$ele.css("border-color", "rgba(" + icon.rgb + "," + (a * 0.5) + ")");
					icon.$ele.css("background-color", "rgba(" + icon.rgb + "," + (a * 0.3) + ")");
				}
			}
			if (icon.visible)
			{
				icon.visible = false;
				self.Show(icon.name);
			}
			if (typeof icon.click === "function")
			{
				icon.$ele.on('mousedown touchstart', function (e)
				{
					e.stopPropagation();
					videoPlayer.suppressMouseHelper();
				});
				icon.$ele.on('click', icon.click);
				icon.$ele.addClass('click');
			}
			else
				icon.$ele.addClass('noClick');
			$container.append(icon.$ele);
		}
	}
	this.ReInitialize();
}
function ShowStreamDelayDetails(e)
{
	videoPlayer.ShowDelayWarning();
}
///////////////////////////////////////////////////////////////
// Live Video Pausing /////////////////////////////////////////
///////////////////////////////////////////////////////////////
function LiveVideoPausing()
{
	var self = this;
	var playbackPausedToast = new PersistentToast("streamTimeLimit", "info", false, function ()
	{
		if (videoPlayer)
			videoPlayer.Playback_Play();
	});

	BI_CustomEvent.AddListener("Playback_Pause", function (loading)
	{
		if (loading.isLive && !clipTimeline.timelineDidPauseVideo() && !playbackPausedToast.isShowing())
			self.showToast("Live video is paused. Click here to resume.");
	});
	BI_CustomEvent.AddListener("Playback_Play", function (loading)
	{
		playbackPausedToast.hide();
	});
	BI_CustomEvent.AddListener("OpenVideo", function ()
	{
		playbackPausedToast.hide();
	});

	this.showToast = function (text)
	{
		playbackPausedToast.showText(text);
	}
}
///////////////////////////////////////////////////////////////
// Prevent device from sleeping while video is playing ////////
///////////////////////////////////////////////////////////////
function KeepScreenAlive()
{
	var self = this;
	var noSleep;
	var badAutoplay = new BadAutoplayPreventionDetector();
	var enabled = false;
	try
	{
		noSleep = new NoSleep({ overridePlayFunc: function (player) { return badAutoplay.Play(player); } });
		if (noSleep.noSleepVideo)
		{
			var zIndexTop = parseInt($("#layouttop").css('z-index'));
			$(noSleep.noSleepVideo).css("top", "0px")
				.css("right", "0px")
				.css("width", "1px")
				.css("height", "1px")
				.css("z-index", (zIndexTop + 1).toString())
				.css("opacity", "0.1")
				.css("pointer-events", "none");
		}
		BI_CustomEvent.AddListener("OpenVideo", function (loading)
		{
			self.enable();
		});
		BI_CustomEvent.AddListener("Playback_Pause", function (loading)
		{
			self.disable();
		});
		BI_CustomEvent.AddListener("Playback_Play", function (loading)
		{
			self.enable();
		});
		// During the UI_Loading sequence, a fake document click event is issued.  Skip that and wait for a real user input.
		BI_CustomEvent.AddListener("UI_Loading_End", function ()
		{
			document.addEventListener('click', enableNoSleep, false);
		});
	}
	catch (ex)
	{
		toaster.Error(ex);
	}
	function enableNoSleep()
	{
		document.removeEventListener('click', enableNoSleep, false);
		self.enable(true); // Make absolutely sure the noSleep.enable() method is called here.
	}
	this.enable = function (force)
	{
		if (!enabled || force)
		{
			noSleep.enable();
			enabled = true;
		}
	}
	this.disable = function ()
	{
		if (enabled || self.isEnabled())
		{
			noSleep.disable();
			enabled = false;
		}
	}
	this.isEnabled = function ()
	{
		return noSleep && noSleep.isEnabled;
	}
	this.getNoSleepObject = function ()
	{
		return noSleep;
	}
}
///////////////////////////////////////////////////////////////
// Server-specified Time Limits ///////////////////////////////
///////////////////////////////////////////////////////////////
function ServerTimeLimiter()
{
	var self = this;
	var timeStart = performance.now();
	var updateInterval = null;
	var $sessionLimitClock = $("#sessionLimitClock");
	var $dailyLimitClock = $("#dailyLimitClock");

	BI_CustomEvent.AddListener("Login Success", function (loginResponse)
	{
		timeStart = performance.now();
		if (updateInterval)
			clearInterval(updateInterval);
		if (loginResponse.data.timelimits)
		{
			$("#serverTimeLimits").show();
			updateInterval = setInterval(self.timeLimiterUpdate, 1000);
			self.timeLimiterUpdate();
		}
		else
			$("#serverTimeLimits").hide();
	});

	this.timeLimiterUpdate = function ()
	{
		if (!sessionManager)
			return;
		var loginResponse = sessionManager.GetLastResponse();
		var now = performance.now();
		if (loginResponse && loginResponse.data && loginResponse.data.timelimits)
		{
			var limits = {
				session: toInt(loginResponse.data.sessionlimit),
				day: toInt(loginResponse.data.daylimit),
				dayused: toInt(loginResponse.data.dayused),
				stream: toInt(loginResponse.data.streamlimit),
			};
			if (limits.session > 0)
			{
				if (!$sessionLimitClock.is(":visible"))
					$sessionLimitClock.show();
				var sessionTimeElapsed = now - timeStart;
				var sessionTimeLimit = limits.session * 1000;
				$sessionLimitClock.text("Session Limit: " + msToTime(sessionTimeElapsed) + "/" + msToTime(sessionTimeLimit));
				if (sessionTimeElapsed >= sessionTimeLimit)
					self.serverTimeout("serverSessionLimit=1");
			}
			else
			{
				if ($sessionLimitClock.is(":visible"))
					$sessionLimitClock.hide();
			}
			if (limits.day > 0 && limits.day < 86400)
			{
				if (!$dailyLimitClock.is(":visible"))
					$dailyLimitClock.show();
				var dailyTimeElapsed = limits.dayused * 1000;
				dailyTimeElapsed += (now - timeStart);
				var dailyTimeLimit = limits.day * 1000;
				$dailyLimitClock.text("Daily Limit: " + msToTime(dailyTimeElapsed) + "/" + msToTime(dailyTimeLimit));
				if (dailyTimeElapsed >= dailyTimeLimit)
					self.serverTimeout("serverDailyLimit=1");
			}
			else
			{
				if ($dailyLimitClock.is(":visible"))
					$dailyLimitClock.hide();
			}
			if (videoPlayer && limits.stream > 0)
			{
				var streamTimeElapsed = videoPlayer.GetOffsetFromStartMs();
				var streamTimeLimit = limits.stream * 1000;
				if (streamTimeElapsed >= streamTimeLimit)
				{
					videoPlayer.Playback_Pause();
					liveVideoPausing.showToast("Video has stopped because your user account has a stream time limit of " + msToTime(streamTimeLimit) + ". Click here to resume.");
				}
			}
		}
	}

	this.serverTimeout = function (arg)
	{
		if (!arg)
			arg = "serverSessionLimit=1";
		currentServer.isLoggingOut = true;
		var path = RemoveUrlParams("session");
		if (path.length > location.origin.length)
			path = path.substr(location.origin.length);
		location.href = 'timeout.htm?' + arg + '&path=' + encodeURIComponent(path) + currentServer.GetAPISessionArg("&");
	}

	this.isNearStreamLimit = function (arg)
	{
		if (sessionManager)
		{
			var loginResponse = sessionManager.GetLastResponse();
			if (loginResponse && loginResponse.data && loginResponse.data.timelimits)
			{
				var streamLimit = toInt(loginResponse.data.streamlimit);
				if (videoPlayer && streamLimit > 0)
				{
					var streamTimeElapsed = videoPlayer.GetOffsetFromStartMs();
					var streamTimeLimit = streamLimit * 1000;
					var diff = streamTimeLimit - streamTimeElapsed;
					if (diff <= 10000)
						return true;
				}
			}
		}
		return false;
	}

	var toInt = function (v)
	{
		if (v)
		{
			var n = parseInt(v);
			if (!isNaN(n))
				return n;
		}
		return 0;
	}
}
///////////////////////////////////////////////////////////////
// Sound Effect Player ////////////////////////////////////////
///////////////////////////////////////////////////////////////
function BISoundEffect()
{
	var self = this;
	var audio = null;
	this.Play = function (file, volume)
	{
		if (!volume)
			volume = 0;
		if (file)
		{
			if (file == "None")
			{
				if (audio && !audio.ended)
					audio.pause();
				return;
			}
			var path = currentServer.remoteBaseURL + "sounds/" + file + "?v=" + combined_version + currentServer.GetLocalSessionArg("&");
			if (!audio)
			{
				audio = new Audio(path);
				audio.addEventListener("error", function ()
				{
					if (audio)
						HandleAudioError(audio.error);
				});
			}
			else if (audio.src != path)
			{
				if (!audio.ended)
					audio.pause();
				audio.src = path;
			}
			self.AdjustVolume(volume);
			var playPromise = audio.play();

			if (playPromise && playPromise["catch"])
				playPromise["catch"](function (ex)
				{
					try
					{
						if (ex.message.indexOf('call to pause') > -1)
							return;
						toaster.Error("Audio Play Error: " + htmlEncode(ex.name) + "<br>" + htmlEncode(ex.message), 15000);
					}
					catch (e)
					{
						console.error(e);
					}
				});
		}
	}
	this.AdjustVolume = function (volume)
	{
		if (audio)
			audio.volume = volume / 100;
	}
	var HandleAudioError = function (error)
	{
		try
		{
			var sb = new StringBuilder("<br>");
			sb.Append("Audio Error: ");
			if (error)
			{
				sb.Append("code ");
				sb.Append(htmlEncode(error.code));
				sb.Append(" (");
				sb.Append(GetMediaErrorMessage(error.code));
				sb.AppendLine(")");
				sb.Append(htmlEncode(error.message));
			}
			else
				sb.Append("Unknown error");
			toaster.Warning(sb.ToString(), 10000);
		}
		catch (e)
		{
			console.error(error, e);
		}
	}
}
var biSoundPlayer = new (function ()
{
	var self = this;
	var playerCache = new FasterObjectMap();
	this.PlayEvent = function (event)
	{
		developerLog("PlayEvent " + event)
		var player = playerCache[event];
		if (!player)
			player = playerCache[event] = new BISoundEffect();

		var file = settings.getItem("ui3_sound_" + event);
		player.Play(file, settings.ui3_eventSoundVolume);
	}
	this.PlaySoundFile = function (audioPlayerId, file)
	{
		developerLog('PlaySoundFile("' + audioPlayerId + '", "' + file + '")');
		var player = playerCache["custom_" + audioPlayerId];
		if (!player)
			player = playerCache["custom_" + audioPlayerId] = new BISoundEffect();

		player.Play(file, settings.ui3_eventSoundVolume);
	}
	this.AdjustVolume = function ()
	{
		for (var event in playerCache)
		{
			var player = playerCache[event];
			player.AdjustVolume(settings.ui3_eventSoundVolume);
		}
	}
	this.TestUserInputRequirement = function ()
	{
		var eventSoundPlayerEnabled = settings.ui3_eventSoundVolume > 0 && (settings.ui3_sound_motion !== "None" || settings.ui3_sound_trigger !== "None" || settings.ui3_sound_alert !== "None");
		var videoStatusSoundsEnabled = settings.ui3_uiStatusSounds === "1" || settings.ui3_uiStatusSpeech === "1";
		var mqttSoundsEnabled = settings.ui3_mqttClientEnabled === "1" && settings.ui3_mqttAudioEvents === "1";
		if (eventSoundPlayerEnabled || videoStatusSoundsEnabled || mqttSoundsEnabled)
		{
			try
			{
				// HTML5 audio (sound effect player)
				if (typeof Audio === "function")
				{
					var audio = new Audio();
					audio.play().catch(function (ex)
					{
						if (ex.name === "NotAllowedError")
						{
							var reason = "";
							if (eventSoundPlayerEnabled)
								reason += "event-triggered sound player";
							if (videoStatusSoundsEnabled)
							{
								if (reason)
									reason += " and ";
								reason += "video status sound player";
							}
							if (mqttSoundsEnabled)
							{
								if (reason)
									reason += " and ";
								reason += "MQTT-triggered sound player";
							}
							inputRequiredOverlay.Show(reason);
						}
					});
				}
			}
			catch (ex) { }
		}
	}
	this.PlayEventSounds = function (response, previousResponse)
	{
		try
		{
			if (videoPlayer.Loading().image.isLive)
			{
				var currentCameras = GetCurrentlyVisibleCameras(response.data);
				var previousCameras = GetCurrentlyVisibleCameras(previousResponse ? previousResponse.data : []);

				if (videoPlayer.CurrentPlayerModuleName() !== 'h264')
				{
					if (AnyCameraIs(currentCameras, function (cam) { return cam.isMotion; })
						&& !AnyCameraIs(previousCameras, function (cam) { return cam.isMotion; }))
					{
						self.PlayEvent("motion");
					}

					if (AnyCameraIs(currentCameras, function (cam) { return cam.isTriggered; })
						&& !AnyCameraIs(previousCameras, function (cam) { return cam.isTriggered; }))
					{
						self.PlayEvent("trigger");
					}
				}
				if (AnyCameraIs(currentCameras, function (cam) { return cam.isAlerting; })
					&& !AnyCameraIs(previousCameras, function (cam) { return cam.isAlerting; }))
				{
					self.PlayEvent("alert");
				}
			}
		}
		catch (ex)
		{
			toaster.Error(ex);
		}
	}
	var AnyCameraIs = function (cameras, condition)
	{
		if (cameras)
			for (var i = 0; i < cameras.length; i++)
				if (condition(cameras[i]))
					return true;
		return false;
	}
	var GetCurrentlyVisibleCameras = function (cameraList)
	{
		var cams = [];
		// Get the names of cameras that are currently visible
		var camNames = cameraListLoader.GetGroupCams(videoPlayer.Loading().image.id);
		if (camNames && camNames.length)
		{
			// Get the camera objects from passed-in cameraList.
			var camMap = new FasterObjectMap();
			for (var i = 0; i < cameraList.length; i++)
				camMap[cameraList[i].optionValue] = cameraList[i];

			for (var i = 0; i < camNames.length; i++)
			{
				var cam = camMap[camNames[i]];
				if (cam)
					cams.push(cam);
			}
		}
		else
		{
			for (var i = 0; i < cameraList.length; i++)
			{
				if (iEquals(cameraList[i].optionValue, videoPlayer.Loading().image.id))
				{
					cams.push(cameraList[i]);
					break;
				}
			}
		}
		return cams;
	}
})();
///////////////////////////////////////////////////////////////
// Input Required Overlay /////////////////////////////////////
///////////////////////////////////////////////////////////////
var inputRequiredOverlay = new (function ()
{
	var self = this;
	var $inputOverlay = $('<div class="inputRequiredToPlay"><div>Click anywhere to begin streaming.<br>The <span class="inputRequiredBy">HTML5 player</span> requires user input before playback can begin.</div></div>');
	var $inputRequiredBy = $inputOverlay.find('.inputRequiredBy');
	var listeners = [];

	var isActive = false;
	var isCallingListeners = false;

	var overlayClicked = function ()
	{
		self.Hide();
		isCallingListeners = true;
		for (var i = 0; i < listeners.length; i++)
		{
			try
			{
				listeners[i]();
			}
			catch (ex)
			{
				toaster.Warning(ex);
			}
		}
		isCallingListeners = false;
		listeners = [];
	}

	$inputOverlay.on('click', overlayClicked);

	this.AddListener = function (callbackFn)
	{
		if (isCallingListeners)
			return;
		if (typeof callbackFn === "function")
			listeners.push(callbackFn);
	}
	this.Show = function (name, callbackFn)
	{
		self.Hide();
		self.AddListener(callbackFn);
		$inputRequiredBy.text(name);
		$('body').append($inputOverlay);
		$inputOverlay.on('click', overlayClicked);
		isActive = true;
	}
	this.Hide = function ()
	{
		$inputOverlay.off('click', overlayClicked);
		$inputOverlay.remove();
		isActive = false;
	}
	this.IsActive = function ()
	{
		return isActive;
	}
})();
///////////////////////////////////////////////////////////////
// Clip Overlay Configuration /////////////////////////////////
///////////////////////////////////////////////////////////////
/**
	Provides storage of clip overlay configuration on a per-camera basis.
	Value 0 indicates "UNSET". 1 indicates "OFF". 2 indicates "ON".
 */
function ClipOverlayCfg()
{
	var self = this;
	var cfg = {};
	try
	{
		var json = settings.ui3_clipOverlayCfg;
		if (json)
			cfg = JSON.parse(json);
		if (!cfg)
			cfg = {};
		normalizeKeysToLower(cfg);
	}
	catch (ex)
	{
		toaster.Error(ex);
	}
	var Get = function (camId, type)
	{
		if (camId)
		{
			camId = camId.toLowerCase();
			var camCfg = cfg[camId];
			if (camCfg)
			{
				var val = camCfg[type];
				if (typeof val === "number")
					return val;
			}
		}
		return 0;
	}
	var Set = function (camId, type, val)
	{
		camId = camId.toLowerCase();
		var isTimelinePseudo = camId === "*ui3_timeline_pseudocam";
		var camData = isTimelinePseudo ? null : cameraListLoader.GetCameraWithId(camId);
		if (isTimelinePseudo || (camData && !cameraListLoader.CameraIsGroupOrCycle(camData)))
		{
			if ((type === "t" || type === "m")
				&& typeof val === "number")
			{
				var camCfg = cfg[camId];
				if (!camCfg)
					cfg[camId] = camCfg = {};
				camCfg[type] = val;

				if (val === 0)
					delete camCfg[type];

				var hasAnyProps = false;
				for (var id in camCfg)
				{
					if (Object.prototype.hasOwnProperty.call(camCfg, id))
					{
						hasAnyProps = true;
						break;
					}
				}
				if (!hasAnyProps)
					delete cfg[camId];

				settings.ui3_clipOverlayCfg = JSON.stringify(cfg);
			}
		}
	}
	this.GetTextOverlay = function (camId)
	{
		return Get(camId, "t"); // "t" stores the value for "text/graphic overlay"
	}
	this.GetMotionOverlay = function (camId)
	{
		return Get(camId, "m"); // "m" stores the value for "motion overlay"
	}
	this.SetTextOverlay = function (camId, val)
	{
		return Set(camId, "t", val);
	}
	this.SetMotionOverlay = function (camId, val)
	{
		return Set(camId, "m", val);
	}
	this.GetUrlArgs = function (camId)
	{
		var urlArgs = "";

		var motionoverlay = self.GetMotionOverlay(camId);
		if (motionoverlay === 1)
			urlArgs += "&addmotion=0";
		else if (motionoverlay === 2)
			urlArgs += "&addmotion=1";

		var textoverlay = self.GetTextOverlay(camId);
		if (textoverlay === 1)
			urlArgs += "&addoverlay=0";
		else if (textoverlay === 2)
			urlArgs += "&addoverlay=1";

		return urlArgs;
	}
}
///////////////////////////////////////////////////////////////
// Group Streaming Configuration //////////////////////////////
///////////////////////////////////////////////////////////////
/**
	Provides storage of group configuration on a per-group basis. Also supports group cycles.
	For boolean setting overrides, value 0 indicates "UNSET". 1 indicates "OFF". 2 indicates "ON".
 */
function GroupCfg()
{
	var self = this;
	var cfg = {};
	var keyMap = {
		showCameraNames: "scn",
		showCameraBorders: "scb",
		showHiddenCameras: "shc",
		hideDisabledCameras: "hdc",
		hideInactiveCamerasWithoutVideo: "hicwv",
		lockedResolution: "lr"
	};
	try
	{
		var json = settings.ui3_groupCfg;
		if (json)
			cfg = JSON.parse(json);
		if (!cfg)
			cfg = {};
		// Blue Iris recently changed the "All cameras" group key from "Index" to "index" and said they use case-insensitive matching.
		normalizeKeysToLower(cfg);
	}
	catch (ex)
	{
		toaster.Error(ex);
	}
	this.Get = function (image, key)
	{
		var camId = getImageId(image);
		if (camId)
		{
			var camCfg = cfg[camId];
			if (camCfg)
			{
				if (keyMap[key])
					key = keyMap[key];
				var val = camCfg[key];
				return val;
			}
		}
		return 0;
	}
	this.Set = function (image, key, val)
	{
		var camId = getImageId(image);
		if (camId)
		{
			if (keyMap[key])
				key = keyMap[key];
			var camCfg = cfg[camId];
			if (!camCfg)
				cfg[camId] = camCfg = {};
			camCfg[key] = val;

			if (typeof val === "undefined" || val === null || val === 0)
				delete camCfg[key];

			var hasAnyProps = false;
			for (var id in camCfg)
			{
				if (Object.prototype.hasOwnProperty.call(camCfg, id))
				{
					hasAnyProps = true;
					break;
				}
			}
			if (!hasAnyProps)
				delete cfg[camId];

			settings.ui3_groupCfg = JSON.stringify(cfg);
		}
	}
	this.GetUrlArgs = function (image)
	{
		var flagMask = { flags: 0, mask: 0 };

		SetFlagMask(image, flagMask, 0, "showCameraNames");
		SetFlagMask(image, flagMask, 1, "showCameraBorders");
		SetFlagMask(image, flagMask, 2, "showHiddenCameras");
		SetFlagMask(image, flagMask, 3, "hideDisabledCameras");
		SetFlagMask(image, flagMask, 4, "hideInactiveCamerasWithoutVideo");

		var urlArgs = "";
		if (flagMask.mask > 0)
			urlArgs = "&flags=" + flagMask.flags + "&mask=" + flagMask.mask;
		//if (!image.isGroup && settings.ui3_defaultCameraGroupId)
		//{
		//	// Add a "&group=" parameter so that BI knows which group you were streaming from.  This can affect camera scaling via the "Scale to fill" layout option.
		//	urlArgs += "&group=" + encodeURIComponent(settings.ui3_defaultCameraGroupId);
		//}
		return urlArgs;
	}
	var SetFlagMask = function (image, flagMask, index, key)
	{
		var value = self.Get(image, key);
		if (value === 1 || value === 2)
		{
			flagMask.mask = UI3_BINARY_OR(flagMask.mask, UI3_BINARY_FLAG(index));
			if (value === 2)
				flagMask.flags = UI3_BINARY_OR(flagMask.flags, UI3_BINARY_FLAG(index));
		}
	}
	this.GetResolutionThatWouldBeLockedIn = function (image)
	{
		var w = image.dynamicNativeW;
		var h = image.dynamicNativeH;
		if (w < image.actualwidth || h < image.actualheight)
		{
			w = image.actualwidth;
			h = image.actualheight;
		}
		return w + "x" + h;
	}
	this.LockResolution = function (image)
	{
		self.Set(image, "lockedResolution", self.GetResolutionThatWouldBeLockedIn(image));
	}
	this.UnlockResolution = function (image)
	{
		self.Set(image, "lockedResolution", null);
	}
	/**
	 * Returns the locked resolution for the camera if one is saved for it, otherwise null.
	 * @param {String} camId Camera Short Name
	 */
	this.GetLockedResolution = function (image)
	{
		var lockedResolution = self.Get(image, "lockedResolution");
		if (lockedResolution)
		{
			var parts = lockedResolution.split('x');
			return new ui3Rect(parseInt(parts[0]), parseInt(parts[1]));
		}
		return null;
	}
	this.SetLockedResolution = function (image, width, height)
	{
		self.Set(image, "lockedResolution", width + "x" + height);
		return null;
	}
	var getImageId = function (image)
	{
		if (!image)
			return "";
		var camData = cameraListLoader.GetCameraWithId(image.id);
		if (camData && cameraListLoader.CameraIsGroupOrCycle(camData))
			return image.id.toLowerCase();
		else if (image.isTimeline())
			return "*ui3_timeline_pseudocam";
		else
			return "";
	}
}
function normalizeKeysToLower(obj)
{
	for (var key in obj)
	{
		if (obj.hasOwnProperty(key))
		{
			var lowerKey = key.toLowerCase();
			if (lowerKey !== key)
			{
				obj[lowerKey] = obj[key];
				delete obj[key];
			}
		}
	}
}

///////////////////////////////////////////////////////////////
// Customizable Streaming Profiles ////////////////////////////
///////////////////////////////////////////////////////////////
function StreamingProfileUI()
{
	var self = this;
	var dialog = null;
	var $dlg = $();
	var $content = $();
	var $profileList = $();
	var dragDropHelper;

	this.open = function ()
	{
		CloseDialog();
		$dlg = $('<div class="streamingProfileUiPanel dialogOptionPanel"></div>');
		$content = $('<div class="streamingProfileUiPanelContent"></div>');
		$dlg.append($content);

		$content.append('<div class="dialogOption_item_info">These streaming profiles are unique to your browser. Changing them will not affect anyone else.</div>');

		var $defaultBtn = $('<input type="button" value="Restore missing default profiles" />"');
		$defaultBtn.on('click', function ()
		{
			genericQualityHelper.RestoreDefaultProfiles(false);
			RepopulateProfileList();
		});
		$content.append($('<div class="dialogOption_item_info"></div>').append($defaultBtn));

		var $addBtn = $('<input type="button" value="Create new profile" />"');
		$addBtn.on('click', AddProfile);
		$content.append($('<div class="dialogOption_item_info"></div>').append($addBtn));

		$content.append('<div class="dialogOption_item_info">Click to edit, hold and drag to reorder:</div>');

		$profileList = $('<ol class="profileList"></ol>');
		$content.append($profileList);
		dragDropHelper = new DragAndDropHelper($profileList, UserChangedOrder);

		RepopulateProfileList();

		dialog = $dlg.dialog({ title: "UI3 Streaming Profiles" });
	}
	var RepopulateProfileList = function ()
	{
		$profileList.empty();
		for (var i = 0; i < genericQualityHelper.profiles.length; i++)
		{
			var p = genericQualityHelper.profiles[i];
			var $p = $('<li class="profileListItem"></li>');
			$p.attr('name', p.name);
			$p.append(p.GetNameEle({ warningIconIsButton: false }));
			$p.append($('<div class="profileCodec"></div>').text("(" + p.vcodec + ")"))
			$p.attr('title', p.GetTooltipText());
			$p.on('click', ProfileClicked);
			if (!p.IsCompatible())
				$p.addClass('unsupportedProfile');
			$profileList.append($p);
		}
		dragDropHelper.Rebind();
	}
	var ProfileClicked = function (e)
	{
		var name = this.getAttribute('name');
		new StreamingProfileEditor(genericQualityHelper.GetProfileWithName(name), ProfileEditedCallback);
	}
	var AddProfile = function ()
	{
		var newProfileNumber = 0;
		var newProfile = new StreamingProfile();
		newProfile.name = name;
		var validName = false;
		while (!validName)
		{
			newProfileNumber++;
			newProfile.name = "New Profile " + newProfileNumber;
			validName = true;
			for (var i = 0; i < genericQualityHelper.profiles.length; i++)
				if (genericQualityHelper.profiles[i].name === newProfile.name)
				{
					validName = false;
					break;
				}
		}
		genericQualityHelper.profiles.splice(0, 0, newProfile);
		genericQualityHelper.SaveProfiles();
		RepopulateProfileList();
		$profileList.children().eq(0).click();
	}
	var UserChangedOrder = function (e, ui)
	{
		var sortHelper = {};
		$profileList.children().each(function (idx, ele)
		{
			sortHelper[ele.getAttribute('name')] = idx;
		});
		genericQualityHelper.profiles.sort(function (a, b)
		{
			return sortHelper[a.name] - sortHelper[b.name];
		});
		genericQualityHelper.SaveProfiles();
	}
	var ProfileEditedCallback = function ()
	{
		RepopulateProfileList();
	}
	var CloseDialog = function ()
	{
		if (dragDropHelper)
		{
			dragDropHelper.Destroy();
			dragDropHelper = null;
		}
		if (dialog != null)
		{
			dialog.close();
			dialog = null;
		}
	}
}
function getMaxGOP()
{
	if (!settings.ui3_maxGOP)
		settings.ui3_maxGOP = 1000;
	return Clamp(parseInt(settings.ui3_maxGOP), 300, 99999);
}
function StreamingProfileEditor(srcProfile, profileEditedCallback)
{
	var self = this;
	var p = srcProfile.Clone();
	var dialog = null;
	var $dlg = $();
	var $content = $();

	var Initialize = function ()
	{
		var alreadyOpen = false;
		$('.streamingProfileEditorPanel').each(function (idx, ele)
		{
			if (ele.getAttribute('profileName') === srcProfile.name)
			{
				alreadyOpen = true;
				$(ele).parent().trigger('mousedown');
			}
		});
		if (alreadyOpen)
			return;
		$dlg = $('<div class="streamingProfileEditorPanel dialogOptionPanel"></div>');
		$dlg.attr('profileName', srcProfile.name);
		$content = $('<div class="streamingProfileEditorPanelContent"></div>');

		ReRender();

		$dlg.append($content);
		dialog = $dlg.dialog({
			title: '<span>Profile: ' + srcProfile.GetNameEle({ allowWarningIcon: false }).html() + '</span>'
			, onClosing: DialogClosing
		});
	}
	var ReRender = function ()
	{
		$content.empty();
		var AddEditorField = MakeAddEditorFieldFn("Profile Editor", $content, p);
		AddEditorField("Profile Name", "name", { max: 21 });
		AddEditorField("Abbreviation (0-4 characters)", "abbr", { max: 4 });
		AddEditorField("Abbreviation Color", "aClr", { type: "color" });
		AddEditorField("Video Codec", "vcodec", { type: "select", options: ["jpeg", "h264"], onChange: ReRender });
		if (!p.IsCompatible())
			AddEditorField("UI3 can't play this codec in your current web browser. This profile will not be available.", "vcodec", { type: "errorCommentText" });
		AddEditorField("Base Server Profile", "stream", { type: "select", options: [GetServerProfileString(0), GetServerProfileString(1), GetServerProfileString(2)], onChange: ReRender });
		if (p.vcodec !== "jpeg" && !sessionManager.DoesStreamAllowOverrides(p.stream))
			AddEditorField(GetStreamOverrideWarningSymbolMarkup() + " The chosen Base Server Profile does not allow most encoding parameters to be overridden.  This profile may not operate as expected.  To allow this profile to function fully, choose a different Base Server Profile, or configure the \"Streaming " + p.stream + "\" profile in Blue Iris web server settings to allow UI3 overrides.", "stream", { type: "errorCommentHtml" });
		AddEditorField("Each profile inherits encoding parameters from one of the server's streaming profiles. You may override individual parameters below.", "stream", { type: "comment" });
		AddEditorField("Max Frame Width", "w", { min: 1, max: 99999 });
		AddEditorField("Max Frame Height", "h", { min: 1, max: 99999 });
		AddEditorField("Quality [0-100]", "q", { min: 0, max: 100 });
		if (p.vcodec === "h264")
		{
			AddEditorField("Frame Rate [0-60]", "fps", { min: 0, max: 60 });
			AddEditorField("Limit Bit Rate", "limitBitrate", { type: "select", options: ["inherit", "No Limit", "Yes Limit"] });
			AddEditorField("Max Bit Rate (Kbps) [10-100000]", "kbps", { min: 10, max: 100000 });
			var maxGop = getMaxGOP();
			AddEditorField("Keyframe Interval [1-" + maxGop + "]", "gop", { min: 1, max: maxGop, hint: 'Advanced users may change the Keyframe Interval max limit. Use the developer console to set "settings.ui3_maxGOP = N" where N is between 300 and 99999, then reload UI3. Higher keyframe values may make video streams freeze.' });
			AddEditorField("Preset", "pre", { type: "select", options: ["inherit", "ultrafast", "superfast", "veryfast"] });
			AddEditorField("Profile", "pro", { type: "select", options: ["inherit", "default", "baseline", "main", "extended", "high", "high 10"] });
			AddEditorField("Zero-Frame Latency", "zfl", { type: "select", options: ["inherit", "No", "Yes"] });
			AddEditorField("Full Range Color", "fullRangeColor", { type: "select", options: ["inherit", "No", "Yes"] });
			AddEditorField("Direct-to-wire", "directToWire", { type: "select", options: ["inherit", "No", "Yes"] });
		}
		var $deleteBtn = $('<input type="button" value="Delete This Profile" />');
		$deleteBtn.on('click', DeleteClicked);
		var $cancelBtn = $('<input type="button" style="float:right; margin-right: 10px;" value="Cancel" />');
		$cancelBtn.on('click', CloseDialog);
		var $saveBtn = $('<input type="button" style="float:right;" value="Save" />');
		$saveBtn.on('click', SaveAndClose);
		$content.append($('<div class="dialogOption_item_info"></div>').append($deleteBtn).append($saveBtn).append($cancelBtn));
	}
	var GetServerProfileString = function (i)
	{
		var str = "Streaming " + i;
		var desc = GetTooltipForStreamQuality(i);
		if (desc)
			str += " (" + desc + ")";
		return str;
	}
	var SaveAndClose = function ()
	{
		if (isNullOrWhitespace(p.name))
		{
			SimpleDialog.Text("A profile must have at least one printable character in its name.");
			return;
		}
		p.name = p.name.trim();
		if (srcProfile.name !== p.name)
			for (var i = 0; i < genericQualityHelper.profiles.length; i++)
			{
				if (genericQualityHelper.profiles[i].name === p.name)
				{
					SimpleDialog.Text("A profile with the name '" + p.name + "' already exists.");
					return;
				}
			}
		for (var i = 0; i < genericQualityHelper.profiles.length; i++)
		{
			if (genericQualityHelper.profiles[i].name === srcProfile.name)
			{
				genericQualityHelper.profiles[i] = p;
				if (settings.ui3_streamingQuality === srcProfile.name)
				{
					// Current profile is changing
					genericQualityHelper.QualityChoiceChanged(p.name);
					if (playbackControls.IsVisible())
					{
						playbackControls.FadeOut();
						playbackControls.Show();
					}
				}
				genericQualityHelper.SaveProfiles();
				if (typeof profileEditedCallback === "function")
					profileEditedCallback(p.name);
				CloseDialog();
				toaster.Success("Saved Profile " + p.GetNameEle().html(), 1500);
				return true;
			}
		}
		SimpleDialog.Text("Unable to locate original profile to replace it. Name: '" + srcProfile.name + "'")
	}
	var DialogClosing = function ()
	{
		if (!p.Equals(srcProfile))
		{
			SimpleDialog.ConfirmText("Save changes to this profile?", function ()
			{
				SaveAndClose();
			}, function ()
			{
				CloseDialog();
			});
			return true;
		}
	}
	var DeleteClicked = function ()
	{
		SimpleDialog.ConfirmText("Delete this profile?", function ()
		{
			for (var i = 0; i < genericQualityHelper.profiles.length; i++)
			{
				if (genericQualityHelper.profiles[i].name === srcProfile.name)
				{
					genericQualityHelper.profiles.splice(i, 1);
					genericQualityHelper.SaveProfiles();
					if (typeof profileEditedCallback === "function")
						profileEditedCallback();
					CloseDialog();
					return;
				}
			}
		});
	}
	var CloseDialog = function ()
	{
		if (dialog != null)
		{
			dialog.close(true);
			dialog = null;
		}
	}
	Initialize();
}
function StreamingProfile()
{
	var self = this;
	this.dv = 5; // default version
	this.name = "Unnamed Streaming Profile";
	this.abbr = "";
	this.aClr = "#004882";
	this.vcodec = "h264";
	this.stream = 0;
	// All the remaining options are "optional".  Values of -1 mean to inherit the argument from the server-side stream.
	this.w = -1;
	this.h = -1;
	this.q = -1;
	// Above values apply to H.264 and JPEG.
	// Below values apply only to H.264.
	this.limitBitrate = 0; // 0: Inherit, 1: No, 2: Yes
	this.kbps = -1; // Only if limitBitrate === 2
	this.fps = -1;
	this.gop = -1;
	this.zfl = -1;
	this.pre = -1; // Preset ["inherit", "ultrafast", "superfast", "veryfast"]
	this.pro = -1; // Profile ["inherit", "default", "baseline", "main", "extended", "high", "high 10"]
	this.directToWire = 0; // 0: inherit. 1: disable. 2: enable
	this.fullRangeColor = 0; // 0: inherit. 1: disable. 2: enable

	this.GetNameText = function ()
	{
		return self.name.replace('^', '');
	}
	this.GetNameEle = function (options)
	{
		options = $.extend({
			allowWarningIcon: true,
			warningIconIsButton: true
		}, options);
		var $ele = $('<span></span>');
		if (self.name.indexOf('^') > -1)
		{
			$ele.text(self.GetNameText());
			var $sup = $('<sup></sup>');
			$sup.text(self.abbr);
			var aClr = self.GetAbbrColor();
			$sup.css('margin-left', '3px');
			$sup.css('padding', '0px 2px');
			$sup.css('background-color', "#" + aClr);
			$sup.css('color', "#" + GetReadableTextColorHexForBackgroundColorHex(aClr, "000000", "FFFFFF"));
			$ele.append($sup);
		}
		else
			$ele.text(self.name);
		if (options.allowWarningIcon && genericQualityHelper && sessionManager)
		{
			var profileIndex = genericQualityHelper.GetProfileIndexWithName(self.name);
			if (!sessionManager.CanProfileUseOverrides(profileIndex))
				$ele.prepend(GetStreamOverrideWarningSymbolMarkup(options.warningIconIsButton ? profileIndex : null));
		}
		return $ele;
	}
	/** Returns the 6-digit hex string representing the abbreviation color. */
	this.GetAbbrColor = function ()
	{
		if (self.aClr && self.aClr.length === 6)
			return self.aClr;
		else if (self.aClr && self.aClr.length === 7)
			return self.aClr.substr(1);
		return "004882";
	}
	this.Equals = function (other)
	{
		for (var prop in self)
		{
			if (Object.prototype.hasOwnProperty.call(self, prop))
			{
				var value = self[prop];
				var type = typeof value;
				if ((type === 'string' || type === 'number' || type === 'boolean') && value !== other[prop])
					return false;
			}
		}
		return true;
	}
	this.Clone = function ()
	{
		var newProfile = new StreamingProfile();
		for (var prop in self)
		{
			if (Object.prototype.hasOwnProperty.call(self, prop))
			{
				var value = self[prop];
				var type = typeof value;
				if (type === 'string' || type === 'number' || type === 'boolean')
					newProfile[prop] = value;
			}
		}
		return newProfile;
	}

	this.GetUrlArgs = function (loading)
	{
		var sb = new StringBuilder();
		sb.Append("&stream=").Append(self.stream);

		if (self.q >= 0)
			sb.Append("&q=").Append(self.q);

		var sizeToRequest = imageRenderer.GetSizeToRequest(loading, self);
		sb.Append("&w=").Append(sizeToRequest.w);
		sb.Append("&h=").Append(sizeToRequest.h);

		if (self.vcodec === "h264")
		{
			var kbps = -1; // -1: inherit, 0: no limit, 10-100000: limit
			if (self.limitBitrate === 1)
				kbps = 0; // Sentinel value instructing Blue Iris to use no limit
			else if (self.limitBitrate === 2)
				kbps = Clamp(self.kbps, 10, 100000);
			var max = settings.ui3_streamingProfileBitRateMax;
			if (max)
			{
				max = Clamp(parseInt(max), -1, 100000);
				if (max >= 10 && (max < kbps || kbps === -1 || kbps === 0))
					kbps = max;
			}
			if (kbps === 0 || kbps >= 10)
				sb.Append("&kbps=").Append(kbps);

			if (self.fps >= 0)
				sb.Append("&fps=").Append(self.fps);

			if (self.gop >= 1)
				sb.Append("&gop=").Append(self.gop);

			if (self.zfl > 0)
				sb.Append("&zfl=").Append(self.zfl - 1);

			if (self.pre > 0)
				sb.Append("&preset=").Append(self.pre - 1);

			if (self.pro > 0)
				sb.Append("&profile=").Append(self.pro - 1);

			if (self.directToWire > 0)
				sb.Append("&d2w=").Append(self.directToWire - 1);

			if (self.fullRangeColor > 0)
				sb.Append("&frc=").Append(self.fullRangeColor - 1);
		}
		return sb.ToString();
	}
	this.GetTooltipText = function ()
	{
		var sb = new StringBuilder('\n');

		sb.Append(self.vcodec + ' ');

		if (self.w > 0 && self.h > 0)
			sb.Append(self.w + 'x' + self.h + ' ');
		else if (self.w > 0)
			sb.Append(self.w + 'w ');
		else if (self.h > 0)
			sb.Append(self.h + 'h ');

		if (self.fps >= 0)
			sb.Append('@' + self.fps + 'fps ');

		if (self.q > -1)
			sb.Append('q' + self.q + ' ');

		if (self.limitBitrate === 1)
			sb.Append('no bitrate limit ');
		else if (self.limitBitrate === 2 && self.kbps > -1)
			sb.Append('<' + Clamp(self.kbps, 10, 100000) + ' Kbps ');

		sb.AppendLine().AppendLine();

		var streamDesc = GetTooltipForStreamQuality(self.stream);
		sb.Append('Inherits from Streaming ' + self.stream + (streamDesc ? (' (' + GetTooltipForStreamQuality(self.stream) + ')') : ''));

		return sb.ToString();
	}
	this.IsCompatible = function ()
	{
		return self.vcodec === "jpeg" || (any_h264_playback_supported && self.vcodec === "h264");
	}
	/** Returns a ui3Rect representing the size requirements of this streaming profile.  Null if neither width or height were specified.  If only one of these was specified, the bounding box will be square. */
	this.GetRect = function ()
	{
		if (self.w > 0 && self.h > 0)
			return new ui3Rect(self.w, self.h);
		else if (self.w > 0)
			return new ui3Rect(self.w, self.w);
		else if (self.h > 0)
			return new ui3Rect(self.h, self.h);
		else
			return null;
	}
}
function SetDynamicNativeSize(loading, w, h)
{
	loading.dynamicNativeW = w;
	loading.dynamicNativeH = h;
	var imgLoading = videoPlayer.Loading().image;
	if (imgLoading.id === loading.id)
	{
		imgLoading.dynamicNativeW = w;
		imgLoading.dynamicNativeH = h;
	}
	var imgLoaded = videoPlayer.Loaded().image;
	if (imgLoaded.id === loading.id)
	{
		imgLoaded.dynamicNativeW = w;
		imgLoaded.dynamicNativeH = h;
	}
}
function JpegSnapshotArgs(loadingImg)
{
	var p = new StreamingProfile();
	p.isHQSnapshot = true; // Indicates this is to create isolated snapshots. Special behavior should be exhibited.
	p.name = "Jpeg Snapshot";
	p.vcodec = "jpeg";
	p.abbr = "SS";
	p.aClr = "#000000";
	p.w = 7680;
	p.h = 7680;
	p.q = Clamp(parseInt(settings.ui3_download_snapshot_server_quality), 0, 100);

	return "&decode=1" + p.GetUrlArgs(loadingImg);
}
///////////////////////////////////////////////////////////////
// Generic Quality Helper /////////////////////////////////////
///////////////////////////////////////////////////////////////
function GenericQualityHelper()
{
	var self = this;
	self.profiles = new Array();

	var $layoutbody = $("#layoutbody");

	this.GetCurrentProfile = function ()
	{
		if (!self.profiles || self.profiles.length === 0)
			self.RestoreDefaultProfiles();
		for (var i = 0; i < self.profiles.length; i++)
			if (self.profiles[i].name === settings.ui3_streamingQuality)
			{
				if (!self.profiles[i].IsCompatible())
					continue;
				return self.profiles[i];
			}
		return self.GetAnyCompatibleProfile();
	}
	this.GetCurrentProfileIndex = function ()
	{
		if (!self.profiles || self.profiles.length === 0)
			self.RestoreDefaultProfiles();
		for (var i = 0; i < self.profiles.length; i++)
			if (self.profiles[i].name === settings.ui3_streamingQuality)
			{
				if (!self.profiles[i].IsCompatible())
				{
					toaster.Warning('Streaming Profile "' + settings.ui3_streamingQuality + '\" is not compatible with this browser instance.');
					continue;
				}
				return i;
			}
		toaster.Warning('Streaming Profile "' + settings.ui3_streamingQuality + '" was not found.');
		return -1;
	}
	this.GetAnyCompatibleProfile = function (didRestoreDefaults)
	{
		// Try to find the best profile
		var best = null;
		if (any_h264_playback_supported)
		{
			// Prefer 1080p VBR
			if (!best) best = self.FindBestProfile("h264", function (p)
			{
				if (p.name.startsWith("1080p VBR"))
					return 0;
				return -1;
			});
			// Find one near 1400 Kbps
			if (!best) best = self.FindBestProfile("h264", function (p)
			{
				if (p.limitBitrate === 2 && p.kbps > 0)
					return Math.abs(p.kbps - 1400);
				return -1;
			});
			// Then, one around 1 MP
			if (!best) best = self.FindBestProfile("h264", function (p) { return p.w < 1 || p.h < 1 ? -1 : Math.abs((p.w * p.h) - 1000000); });
			if (!best) best = self.FindBestProfile("h264", function (p) { return p.w < 1 ? -1 : Math.abs(p.w - 1000); });
			if (!best) best = self.FindBestProfile("h264", function (p) { return p.h < 1 ? -1 : Math.abs(p.h - 1000); });
			// Then, one with q near 25
			if (!best) best = self.FindBestProfile("h264", function (p) { return p.q < 0 ? -1 : Math.abs(p.q - 25); });
		}
		// Fall back to the best jpeg profile
		if (!best) best = self.FindBestProfile("jpeg", function (p)
		{
			return (p.w <= 1 && p.h <= 1) || (p.w > 2000 && p.h > 2000) ? 1 : -1;
		});
		// As a last resort, just pick one
		if (!best) best = self.FindBestProfile("any", function (p) { return 1; });
		if (best)
			return best;

		if (didRestoreDefaults)
		{
			toaster.Error("Unable to locate a compatible streaming profile even after restoring default profiles.", 30000);
			return null;
		}
		toaster.Info("Unable to locate a compatible streaming profile. Restoring default profiles.", 5000);
		self.RestoreDefaultProfiles();
		return self.GetAnyCompatibleProfile(true);
	}
	/** Returns the compatible profile with the lowest non-negative output from valuationFn. */
	this.FindBestProfile = function (vcodec, valuationFn)
	{
		var bestProfile = null;
		var valueOfBest = -1;
		for (var i = 0; i < self.profiles.length; i++)
		{
			var p = self.profiles[i];
			if (p.IsCompatible() && (vcodec === "any" || vcodec === p.vcodec))
			{
				var valueOfP = valuationFn(p);
				if (valueOfP >= 0 && (valueOfBest < 0 || valueOfP < valueOfBest))
				{
					bestProfile = p;
					valueOfBest = valueOfP;
				}
			}
		}
		return bestProfile;
	}
	this.QualityChoiceChanged = function (name)
	{
		var p = self.GetProfileWithName(name);
		if (!p || !p.IsCompatible())
		{
			p = self.GetAnyCompatibleProfile();
			NotifyQualitySelectionChanged(p);
			name = p.name;
		}
		for (var i = 0; i < self.profiles.length; i++)
			if (self.profiles[i].name === name)
			{
				settings.ui3_streamingQuality = name;
				dropdownBoxes.setLabelText("streamingQuality", self.profiles[i].GetNameEle().html(), true);
				if (videoPlayer)
					videoPlayer.SelectedQualityChanged();
				break;
			}
		if (playbackControls && playbackControls.IsVisible())
			playbackControls.SetQualityHint();
		SyncStreamingQualityWarningIcon(false);
	}
	var NotifyQualitySelectionChanged = function (p)
	{
		toaster.Info("The active streaming profile has changed to " + p.GetNameEle().html(), 3000);
	}
	this.SetStreamingQualityDropdownBoxItems = function ()
	{
		var arr = new Array();
		for (var i = 0; i < self.profiles.length; i++)
		{
			var p = self.profiles[i];
			if (p.IsCompatible())
				arr.push(new DropdownListItem({ text: p.GetNameEle().html(), uniqueId: p.name, GetTooltip: p.GetTooltipText, isHtml: true }));
		}
		dropdownBoxes.listDefs["streamingQuality"].items = arr;
	}
	this.GetProfileIndexWithName = function (name)
	{
		for (var i = 0; i < self.profiles.length; i++)
			if (self.profiles[i].name === name)
				return i;
		return -1;
	}
	this.GetProfileWithName = function (name)
	{
		for (var i = 0; i < self.profiles.length; i++)
			if (self.profiles[i].name === name)
				return self.profiles[i];
		return null;
	}
	this.GetProfileWithIndex = function (index)
	{
		if (index >= 0 && index < self.profiles.length)
			return self.profiles[index];
		return null;
	}
	this.getSeekPreviewQualityArgs = function (loadingImg)
	{
		var profile = self.GetCurrentProfile();
		var sizeToRequest = imageRenderer.GetSizeToRequest(loadingImg, profile);
		var playerId = profile.vcodec;
		var quality = null;
		if (playerId == "jpeg" && profile.q)
			quality = profile.q;
		if (currentPrimaryTab !== "timeline")
		{
			if (playerId == "h264")
			{
				var bitRateMbps;
				if (profile.kbps)
					bitRateMbps = profile.kbps / 1000;
				else
				{
					var bitRate_Video = bitRateCalc_Video.GetBestGuess() * 8;
					var bitRate_Audio = bitRateCalc_Audio.GetBestGuess() * 8;
					bitRateMbps = (bitRate_Video / 1000000) + (bitRate_Audio / 1000000);
				}

				if (bitRateMbps < 0.1)
				{
					sizeToRequest.ApplyBoundingBox(new ui3Rect(320, 320));
					quality = 20;
				}
				else if (bitRateMbps < 0.3)
				{
					sizeToRequest.ApplyBoundingBox(new ui3Rect(480, 480));
					quality = 20;
				}
				else if (bitRateMbps < 0.5)
				{
					sizeToRequest.ApplyBoundingBox(new ui3Rect(640, 640));
					quality = 25;
				}
				else if (bitRateMbps < 0.75)
				{
					sizeToRequest.ApplyBoundingBox(new ui3Rect(640, 640));
					quality = 40;
				}
				else if (bitRateMbps < 1.5)
				{
					sizeToRequest.ApplyBoundingBox(new ui3Rect(1280, 1280));
					quality = 50;
				}
				else if (bitRateMbps < 4)
				{
					sizeToRequest.ApplyBoundingBox(new ui3Rect(1920, 1920));
					quality = 60;
				}
				else
					quality = 75;
			}
		}
		return "&w=" + sizeToRequest.w + "&h=" + sizeToRequest.h + "&stream=" + profile.stream + (quality === null ? "" : ("&q=" + quality));
	}

	var Create_4320p = function ()
	{
		var p = new StreamingProfile();
		p.name = "4320p^";
		p.abbr = "8K";
		p.aClr = "#8F29AE";
		p.w = 7680;
		p.h = 4320;
		p.q = 50;
		p.limitBitrate = 2;
		p.kbps = 16384;
		p.gop = 1000;
		return p;
	}
	var Create_4320p_VBR = function ()
	{
		var p = new StreamingProfile();
		p.name = "4320p VBR^";
		p.abbr = "V8";
		p.aClr = "#8F29AE";
		p.w = 7680;
		p.h = 4320;
		p.q = 20;
		p.limitBitrate = 2;
		p.kbps = 5000;
		p.gop = 1000;
		p.pre = 2;
		p.zfl = 2;
		return p;
	}
	var Create_2160p_VBR = function ()
	{
		var p = new StreamingProfile();
		p.name = "2160p VBR^";
		p.abbr = "V4";
		p.aClr = "#008248";
		p.w = 3840;
		p.h = 2160;
		p.q = 20;
		p.limitBitrate = 2;
		p.kbps = 3000;
		p.gop = 1000;
		p.pre = 2;
		p.zfl = 2;
		return p;
	}
	var Create_1080p_VBR = function ()
	{
		var p = new StreamingProfile();
		p.name = "1080p VBR^";
		p.abbr = "V2";
		p.aClr = "#004882";
		p.w = 1920;
		p.h = 1080;
		p.q = 20;
		p.limitBitrate = 2;
		p.kbps = 1000;
		p.gop = 1000;
		p.pre = 2;
		p.zfl = 2;
		return p;
	}
	this.GenerateDefaultProfiles = function ()
	{
		var profiles = new Array();
		profiles.push(Create_2160p_VBR());
		profiles.push(Create_1080p_VBR());
		{
			var p = new StreamingProfile();
			p.name = "2160p^";
			p.abbr = "4K";
			p.aClr = "#008248";
			p.w = 3840;
			p.h = 2160;
			p.q = 50;
			p.limitBitrate = 2;
			p.kbps = 8192;
			profiles.push(p);
		}
		{
			var p = new StreamingProfile();
			p.name = "1440p^";
			p.abbr = "4MP";
			p.aClr = "#0048A2";
			p.w = 2560;
			p.h = 1440;
			p.q = 40;
			p.limitBitrate = 2;
			p.kbps = 4096;
			profiles.push(p);
		}
		{
			var p = new StreamingProfile();
			p.name = "1080p^";
			p.abbr = "2MP";
			p.aClr = "#004882";
			p.w = 1920;
			p.h = 1080;
			p.q = 35;
			p.limitBitrate = 2;
			p.kbps = 2048;
			profiles.push(p);
		}
		{
			var p = new StreamingProfile();
			p.name = "720p^";
			p.abbr = "1MP";
			p.aClr = "#003862";
			p.w = 1280;
			p.h = 720;
			p.q = 35;
			p.limitBitrate = 2;
			p.kbps = 1024;
			profiles.push(p);
		}
		{
			var p = new StreamingProfile();
			p.name = "480p";
			p.abbr = "480p";
			p.aClr = "#884400";
			p.w = 856;
			p.h = 480;
			p.q = 30;
			p.limitBitrate = 2;
			p.kbps = 456;
			profiles.push(p);
		}
		{
			var p = new StreamingProfile();
			p.name = "360p";
			p.abbr = "360p";
			p.aClr = "#883000";
			p.w = 640;
			p.h = 360;
			p.q = 30;
			p.limitBitrate = 2;
			p.kbps = 256;
			profiles.push(p);
		}
		{
			var p = new StreamingProfile();
			p.name = "240p";
			p.abbr = "240p";
			p.aClr = "#882000";
			p.w = 427;
			p.h = 240;
			p.q = 30;
			p.limitBitrate = 2;
			p.kbps = 114;
			profiles.push(p);
		}
		{
			var p = new StreamingProfile();
			p.name = "144p";
			p.abbr = "144p";
			p.aClr = "#880000";
			p.w = 256;
			p.h = 144;
			p.q = 30;
			p.limitBitrate = 2;
			p.kbps = 41;
			profiles.push(p);
		}
		{
			var p = new StreamingProfile();
			p.name = "Jpeg HD";
			p.vcodec = "jpeg";
			p.abbr = "HD";
			p.aClr = "#004882";
			p.w = 99999;
			p.h = 99999;
			p.q = 85;
			profiles.push(p);
		}
		{
			var p = new StreamingProfile();
			p.name = "Jpeg SD";
			p.vcodec = "jpeg";
			p.abbr = "SD";
			p.aClr = "#884400";
			p.w = 640;
			p.h = 640;
			p.q = 50;
			profiles.push(p);
		}
		{
			var p = new StreamingProfile();
			p.name = "Jpeg Low";
			p.vcodec = "jpeg";
			p.abbr = "LD";
			p.aClr = "#880000";
			p.w = 320;
			p.h = 320;
			p.q = 20;
			profiles.push(p);
		}
		return profiles;
	}
	var upgradeDefaultProfileData = function (profileData)
	{
		var upgradeMade = false;
		{
			// v1 -> v2
			var upgradeMap = {
				"1440p^": { abbr: "4MP", aClr: "#0048A2" },
				"1080p^": { abbr: "2MP", aClr: "#004882" },
				"720p^": { abbr: "1MP", aClr: "#003862" },
				"480p": { abbr: "480p", aClr: "#884400" },
				"360p": { abbr: "360p", aClr: "#883000" },
				"240p": { abbr: "240p", aClr: "#882000" },
				"144p": { abbr: "144p", aClr: "#880000" }
			};
			for (var i = 0; i < profileData.length; i++)
			{
				if (profileData[i].dv && profileData[i].dv >= 2)
					continue;
				profileData[i].dv = 2;
				var u = upgradeMap[profileData[i].name];
				if (u)
				{
					for (var key in u)
						if (Object.prototype.hasOwnProperty.call(u, key))
							profileData[i][key] = u[key];
					upgradeMade = true;
				}
			}
		}
		{
			// v2 -> v3 (add 1080p VBR and 2160p VBR)
			for (var i = 0; i < profileData.length; i++)
			{
				if (profileData[i].dv && profileData[i].dv >= 3)
					continue;
				profileData[i].dv = 3;
				upgradeMade = true;
			}
			if (upgradeMade)
				profileData.splice(0, 0, Create_2160p_VBR(), Create_1080p_VBR());
		}
		{
			// v3 -> v4 (change preset and ZFL settings for default VBR profiles)
			for (var i = 0; i < profileData.length; i++)
			{
				if (profileData[i].dv && profileData[i].dv >= 4)
					continue;
				profileData[i].dv = 4;
				upgradeMade = true;
				if (profileData[i].name === "2160p VBR^" || profileData[i].name === "1080p VBR^")
				{
					if (profileData[i].pre === 3)
						profileData[i].pre = 2;
					if (profileData[i].zfl <= 0)
						profileData[i].zfl = 2;
				}
			}
		}
		{
			// v4 -> v5 (change abbreviations and colors of default VBR profiles)
			for (var i = 0; i < profileData.length; i++)
			{
				if (profileData[i].dv && profileData[i].dv >= 5)
					continue;
				profileData[i].dv = 5;
				upgradeMade = true;
				if (profileData[i].name === "2160p VBR^")
				{
					if (profileData[i].abbr === "V8")
						profileData[i].abbr = "V4";
					if (profileData[i].aClr === "#00FF00")
						profileData[i].aClr = "#008248";
				}
				else if (profileData[i].name === "1080p VBR^")
				{
					if (profileData[i].aClr === "#00CC88")
						profileData[i].aClr = "#004882";
				}
			}
		}
		// Every time
		{
			var maxGop = getMaxGOP();
			for (var i = 0; i < profileData.length; i++)
			{
				if (profileData[i].gop > maxGop)
				{
					profileData[i].gop = maxGop;
					upgradeMade = true;
				}
			}
		}
		// When adding upgrade steps, be sure to update the dv field declaration to assign the newest version number.
		return upgradeMade;
	}
	this.RestoreDefaultProfiles = function (replaceExisting)
	{
		var defaultProfiles = self.GenerateDefaultProfiles();
		if (self.profiles && self.profiles.length > 0)
		{
			for (var i = 0; i < defaultProfiles.length; i++)
			{
				var foundExisting = false;
				for (var n = 0; n < self.profiles.length; n++)
				{
					if (defaultProfiles[i].name === self.profiles[n].name)
					{
						foundExisting = true;
						if (replaceExisting)
							self.profiles[n] = defaultProfiles[i];
						break;
					}
				}
				if (!foundExisting)
					self.profiles.push(defaultProfiles[i]);
			}
		}
		else
			self.profiles = defaultProfiles;
		if (settings.ui3_didAdd8kProfiles === "1")
		{
			if (!hasProfileWithName("4320p VBR^"))
				self.profiles.push(Create_4320p_VBR());
			if (!hasProfileWithName("4320p^"))
				self.profiles.push(Create_4320p());
		}
		self.SaveProfiles();
	}
	this.LoadProfiles = function ()
	{
		try
		{
			self.profiles = new Array();
			var profileData = JSON.parse(settings.ui3_streamingProfileArray);
			var upgradeMade = upgradeDefaultProfileData(profileData);
			for (var i = 0; i < profileData.length; i++)
				self.profiles.push($.extend(new StreamingProfile(), profileData[i]));
			self.SetStreamingQualityDropdownBoxItems();
			if (upgradeMade)
				self.SaveProfiles();
		}
		catch (ex)
		{
			alert("Your streaming profiles could not be loaded, and will be restored to defaults.");
		}
	}
	var isInSavingProfilesFunc = false;
	this.SaveProfiles = function ()
	{
		try
		{
			settings.ui3_streamingProfileArray = JSON.stringify(self.profiles);

			if (isInSavingProfilesFunc)
				return; // Prevent infinitely looping here in case the default profiles don't have anything compatible.
			try
			{
				isInSavingProfilesFunc = true;
				for (var i = 0; i < self.profiles.length; i++)
					if (self.profiles[i].name === settings.ui3_streamingQuality)
					{
						if (!self.profiles[i].IsCompatible())
							continue;
						return;
					}
				var p = self.GetAnyCompatibleProfile();
				self.QualityChoiceChanged(p.name);
				NotifyQualitySelectionChanged(p);
			}
			finally
			{
				isInSavingProfilesFunc = false;
			}
		}
		finally
		{
			self.SetStreamingQualityDropdownBoxItems();
		}
	}
	var hasProfileWithName = function (name)
	{
		for (var p = 0; p < self.profiles.length; p++)
		{
			if (self.profiles[p].name === name)
				return true;
		}
		return false;
	}
	var onCameraListLoaded = function ()
	{
		BI_CustomEvent.RemoveListener("CameraListLoaded", onCameraListLoaded);
		var cams = cameraListLoader.GetAllStreamObjects();
		for (var i = 0; i < cams.length; i++)
		{
			var cam = cams[i];
			if (cam.width > 3840 || cam.height > 3840)
			{
				// At least one stream exists that is natively larger than 3840px.
				// Add 8K streaming profiles, then exit this function.
				var madeChanges = false;
				var added4320pVBR = hasProfileWithName("4320p VBR^");
				var added4320p = hasProfileWithName("4320p^");
				for (var p = 0; p < self.profiles.length; p++)
				{
					if (!added4320pVBR &&
						(
							self.profiles[p].name === "2160p VBR^"
							|| self.profiles[p].name === "1080p VBR^"
						))
					{
						self.profiles.splice(p, 0, Create_4320p_VBR());
						added4320pVBR = madeChanges = true;
					}
					else if (!added4320p &&
						(
							self.profiles[p].name === "2160p^"
							|| self.profiles[p].name === "1440p^"
							|| self.profiles[p].name === "1080p^"
							|| self.profiles[p].name === "720p^"
						))
					{
						self.profiles.splice(p, 0, Create_4320p());
						added4320p = madeChanges = true;
					}
				}
				if (!added4320p)
				{
					self.profiles.splice(0, 0, Create_4320p());
					added4320p = madeChanges = true;
				}
				if (!added4320pVBR)
				{
					self.profiles.splice(0, 0, Create_4320p());
					added4320pVBR = madeChanges = true;
				}
				if (madeChanges)
				{
					self.SaveProfiles();
				}
				settings.ui3_didAdd8kProfiles = "1";
				console.log("A camera or group with native resolution above 3840px has been detected. 4320p (8K) streaming profiles have been added to UI3.");
				break;
			}
		}
	};
	if (settings.ui3_didAdd8kProfiles !== "1")
		BI_CustomEvent.AddListener("CameraListLoaded", onCameraListLoaded);

	self.LoadProfiles();
	if (!self.profiles || self.profiles.length === 0)
		this.RestoreDefaultProfiles();
	self.QualityChoiceChanged(settings.ui3_streamingQuality);
}
///////////////////////////////////////////////////////////////
// Group Layout Dialog ////////////////////////////////////////
///////////////////////////////////////////////////////////////
var groupLayoutDialog = new GroupLayoutDialog();
function GroupLayoutDialog()
{
	var self = this;
	var dialog = null;
	var $dlg = $();
	var $content = $();
	var $whLbl = $();
	var $layoutWidth = $();
	var $layoutHeight = $();
	var img = null;

	this.Show = function (imgLoaded)
	{
		CloseDialog();
		img = imgLoaded;
		if (!img)
		{
			toaster.Error('GroupLayoutDialog was not given a valid argument');
			return;
		}

		// Create Dialog
		$dlg = $('<div class="groupLayoutUiPanel dialogOptionPanel"></div>');
		$content = $('<div class="groupLayoutUiPanelContent"></div>');
		$dlg.append($content);

		var camName;
		var camData = cameraListLoader.GetCameraWithId(img.id);
		if (camData && cameraListLoader.CameraIsGroupOrCycle(camData))
			camName = '"' + cameraListLoader.GetCameraName(img.id) + '" Group Settings';
		else if (img.isTimeline())
			camName = "Timeline Solo-Camera Settings";
		else
		{
			toaster.Error("Application error. GroupLayoutDialog does not support individual camera settings.");
			return;
		}
		dialog = $dlg.dialog({
			title: camName
			, overlayOpacity: 0.3
			, closeOnOverlayClick: true
		});

		// Load elements into dialog
		if (cameraListLoader.isDynamicLayoutEligible(img.id))
		{
			var lockedResolution = groupCfg.GetLockedResolution(img);
			var collapsible = new CollapsibleSection('grpLayout', "Camera Layout", dialog);
			$content.append(collapsible.$heading);
			$content.append(collapsible.$section);
			if (settings.ui3_dynamicGroupLayout === "0")
				collapsible.$section.append('<div style="padding: 8px; margin-bottom: 10px; border: 2px dotted #FF0000;">This section has no effect while Dynamic Group Layout is disabled in UI Settings &gt; Video Player.</div>');
			collapsible.$section.append(UIFormField({
				inputType: "range"
				, value: parseFloat(settings.ui3_maxDynamicGroupImageMegapixels)
				, minValue: 0.1
				, maxValue: 32
				, step: 0.1
				, unitLabel: " MP"
				, label: 'Dynamic Group Max Resolution'
				, tag: "maxDynRes",
				onChange: function (e, tag, $input)
				{
					settings.ui3_maxDynamicGroupImageMegapixels = $input.val();
					OnChange_ui3_maxDynamicGroupImageMegapixels();
				}
			}));
			collapsible.$section.append('<div class="dialogOption_label"><ul>'
				+ '<li>Can strongly affect server CPU usage.</li>'
				+ '<li>This setting affects all dynamic groups.</li>'
				+ '<li>Stream size may also be limited by the active Streaming Quality profile.</li>');
			collapsible.$section.append(UIFormField({
				inputType: "checkbox"
				, value: !lockedResolution
				, label: "Fit to Viewport"
				, tag: "dynamic",
				onChange: function (tag, checked)
				{
					if (checked)
					{
						groupCfg.UnlockResolution(img);
						videoPlayer.ReopenStreamAtCurrentSeekPosition();
					}
					else
					{
						groupCfg.LockResolution(img);
						$layoutWidth.show();
					}
					ResetResolutionInputVisibility();
				}
			}));
			$whLbl = $('<div class="dialogOption_label">Group Frame Size Target:'
				+ '<div class="settingDesc">(This defines an aspect ratio. The final size depends on "Dynamic Group Max Resolution" and the active streaming profile.)</div></div>');
			$layoutWidth = UIFormField({
				inputType: "number"
				, minValue: imageRenderer.minGroupImageDimension
				, maxValue: imageRenderer.maxGroupImageDimension
				, step: 8
				, value: lockedResolution ? lockedResolution.w : 1920
				, label: "Width"
				, tag: "width",
				onChange: function (e, tag, $input)
				{
					groupCfg.SetLockedResolution(img, $layoutWidth.find('input').val(), $layoutHeight.find('input').val());
					videoPlayer.ReopenStreamAtCurrentSeekPosition();
				}
			});
			$layoutHeight = UIFormField({
				inputType: "number"
				, minValue: imageRenderer.minGroupImageDimension
				, maxValue: imageRenderer.maxGroupImageDimension
				, step: 8
				, value: lockedResolution ? lockedResolution.h : 1080
				, label: "Height"
				, tag: "height",
				onChange: function (e, tag, $input)
				{
					groupCfg.SetLockedResolution(img, $layoutWidth.find('input').val(), $layoutHeight.find('input').val());
					videoPlayer.ReopenStreamAtCurrentSeekPosition();
				}
			});
			collapsible.$section.append($whLbl);
			collapsible.$section.append($layoutWidth);
			collapsible.$section.append($layoutHeight);
			ResetResolutionInputVisibility();
		}
		else
		{
			$whLbl = $();
			$layoutWidth = $();
			$layoutHeight = $();
		}

		if (img.isGroup || img.isTimeline())
		{
			var collapsible = new CollapsibleSection('grpDisp', "Display Options", dialog);
			$content.append(collapsible.$heading);
			$content.append(collapsible.$section);
			collapsible.$section.append(ThreeStateFormField(img, "showCameraNames", "Show camera names"));
			collapsible.$section.append(ThreeStateFormField(img, "showCameraBorders", "Show camera borders"));
			collapsible.$section.append(ThreeStateFormField(img, "showHiddenCameras", "Show hidden cameras"));
			collapsible.$section.append(ThreeStateFormField(img, "hideDisabledCameras", "Hide disabled cameras"));
			collapsible.$section.append(ThreeStateFormField(img, "hideInactiveCamerasWithoutVideo", "Hide inactive cameras without video"));
		}

		if ($content.children().length === 0)
			$content.append('<div style="padding: 10px;">"' + img.id + '" does not have any settings that are configurable in this panel.</div>');

		dialog.contentChanged(true);
	}
	var ThreeStateFormField = function (img, key, label)
	{
		var v = groupCfg.Get(img, key);
		if (!v || v < 0 || v > 2)
			v = 0;

		return UIFormField({
			inputType: "threeState"
			, value: v
			, label: label
			, tag: key,
			onChange: function (e, value, $btn)
			{
				groupCfg.Set(img, key, value);
				videoPlayer.ReopenStreamAtCurrentSeekPosition();
			}
		})
	}
	var ResetResolutionInputVisibility = function ()
	{
		var lockedResolution = groupCfg.GetLockedResolution(img);
		if (lockedResolution)
		{
			$layoutWidth.find('input').val(lockedResolution.w);
			$layoutHeight.find('input').val(lockedResolution.h);
			$whLbl.show();
			$layoutWidth.show();
			$layoutHeight.show();
		}
		else
		{
			$whLbl.hide();
			$layoutWidth.hide();
			$layoutHeight.hide();
		}
	}
	var CloseDialog = function ()
	{
		if (dialog != null)
		{
			dialog.close();
			dialog = null;
		}
	}
}
///////////////////////////////////////////////////////////////
// Video Canvas Context Menu //////////////////////////////////
///////////////////////////////////////////////////////////////
function CanvasContextMenu()
{
	var self = this;
	var lastLiveContextMenuSelectedCamera = null;
	var lastRecordContextMenuSelectedClip = null;
	var lastTimelineContextMenuSelectedCamera = null;

	var onShowLiveContextMenu = function (menu)
	{
		var imgLoaded = videoPlayer.Loaded().image;
		if ((imgLoaded.isGroup && !videoPlayer.Loaded().cam.isFakeGroup) || cameraListLoader.isDynamicLayoutEligible(imgLoaded.id))
			$("#submenu_trigger_groupSettings").closest('.b-m-item,.b-m-ifocus').show();
		else
			$("#submenu_trigger_groupSettings").closest('.b-m-item,.b-m-ifocus').hide();

		var itemsToDisable = ["cameraname"];
		if (lastLiveContextMenuSelectedCamera == null || !cameraListLoader.CameraIsAlone(lastLiveContextMenuSelectedCamera))
		{
			itemsToDisable = itemsToDisable.concat(["trigger", "record", "snapshot", "maximize", "restart", "properties"]);
			menu.applyrule(
				{
					name: "disable_camera_buttons",
					disable: true,
					items: itemsToDisable
				});
		}
		else
		{
			if (lastLiveContextMenuSelectedCamera.isFakeGroup)
				itemsToDisable.push("maximize");
			menu.applyrule(
				{
					name: "disable_cameraname",
					disable: true,
					items: itemsToDisable
				});
		}
	}
	var onTriggerLiveContextMenu = function (e)
	{
		if (!videoPlayer.Loading().image.isLive || !videoPlayer.Loaded().image.isLive)
			return false;

		mouseCoordFixer.fix(e);

		videoPlayer.suppressMouseHelper();
		videoOverlayHelper.HideFalseLoadingOverlay();

		var downloadButton = $("#cmroot_liveview_downloadbutton_findme").closest(".b-m-item");
		if (downloadButton.parent().attr("id") == "cmroot_liveview_downloadlink")
			downloadButton.parent().attr("href", videoPlayer.GetLastSnapshotUrl());
		else
			downloadButton.wrap('<a id="cmroot_liveview_downloadlink" style="display:block" href="'
				+ videoPlayer.GetLastSnapshotUrl()
				+ '" onclick="saveSnapshot(&quot;#cmroot_liveview_downloadlink&quot;)" target="_blank"></a>');
		$("#cmroot_liveview_downloadlink").attr("download", "temp.jpg");

		var homeGroupObj = null;
		var camData = videoPlayer.GetCameraUnderMousePointer(e);
		if (camData == null)
			camData = homeGroupObj = videoPlayer.GetCurrentHomeGroupObj();
		lastLiveContextMenuSelectedCamera = camData;
		if (camData != null)
		{
			LoadDynamicManualRecordingButtonState(camData);
			var camName = CleanUpGroupName(camData.optionDisplay);
			$("#contextMenuCameraName").text(camName);
			$("#contextMenuCameraName").closest("div.b-m-item,div.b-m-idisable").attr("title", "The buttons below are specific to the camera: " + camName);
			var $maximize = $("#contextMenuMaximize");
			var isMaxAlready = (iEquals(camData.optionValue, videoPlayer.Loaded().image.id) && homeGroupObj == null);
			$maximize.text(isMaxAlready ? "Back to Group" : "Maximize");
			$maximize.parent().prev().find("use").attr("xlink:href", isMaxAlready ? "#svg_mio_FullscreenExit" : "#svg_mio_Fullscreen");
		}

		return true;
	}
	var onLiveContextMenuAction = function ()
	{
		switch (this.data.alias)
		{
			case "maximize":
				if (!cameraListLoader.CameraIsAlone(lastLiveContextMenuSelectedCamera))
					toaster.Warning("Function is unavailable.");
				else
					videoPlayer.ImgClick_Camera(lastLiveContextMenuSelectedCamera);
				break;
			case "trigger":
				if (!cameraListLoader.CameraIsAlone(lastLiveContextMenuSelectedCamera))
					toaster.Warning("You cannot trigger cameras that are part of an auto-cycle.");
				else
					TriggerCamera(lastLiveContextMenuSelectedCamera.optionValue);
				break;
			case "record":
				if (!cameraListLoader.CameraIsAlone(lastLiveContextMenuSelectedCamera))
					toaster.Warning("You cannot toggle recording of cameras that are part of an auto-cycle.");
				else
					ManualRecordCamera(lastLiveContextMenuSelectedCamera.optionValue, $("#manRecBtnLabel").attr("start"));
				break;
			case "snapshot":
				if (!cameraListLoader.CameraIsAlone(lastLiveContextMenuSelectedCamera))
					toaster.Warning("You cannot save a snapshot of cameras that are part of an auto-cycle.");
				else
					SaveSnapshotInBlueIris(lastLiveContextMenuSelectedCamera.optionValue);
				break;
			case "restart":
				if (!cameraListLoader.CameraIsAlone(lastLiveContextMenuSelectedCamera))
					toaster.Warning("You cannot restart cameras that are part of an auto-cycle.");
				else
					ResetCamera(lastLiveContextMenuSelectedCamera.optionValue);
				break;
			case "properties":
				if (!cameraListLoader.CameraIsAlone(lastLiveContextMenuSelectedCamera))
					toaster.Warning("You cannot view properties of cameras that are part of an auto-cycle.");
				else
					new CameraProperties(lastLiveContextMenuSelectedCamera.optionValue);
				break;
			case "opennewtab":
				window.open(videoPlayer.GetLastSnapshotUrl());
				break;
			case "copyimageaddress":
				var relUrl = videoPlayer.GetLastSnapshotUrl();
				if (!relUrl.startsWith("/"))
					relUrl = "/" + relUrl;
				clipboardHelper.CopyText(location.origin + relUrl);
				break;
			case "saveas":
				return true;
			case "statsfornerds":
				nerdStats.Open();
				break;
			case "group_settings_edit":
				groupLayoutDialog.Show(videoPlayer.Loaded().image);
				break;
			default:
				toaster.Error(this.data.alias + " is not implemented!");
				break;
		}
	}
	var onCancelLiveContextMenu = function ()
	{
	}
	var optionLive =
	{
		alias: "cmroot_live", width: 200, items:
			[
				{ text: "Open image in new tab", icon: "#svg_mio_Tab", iconClass: "noflip", alias: "opennewtab", action: onLiveContextMenuAction }
				, { text: '<div id="cmroot_liveview_downloadbutton_findme" style="display:none"></div>Save image to disk', icon: "#svg_x5F_Snapshot", alias: "saveas", action: onLiveContextMenuAction }
				, { text: "Copy image address", icon: "#svg_mio_copy", iconClass: "noflip", alias: "copyimageaddress", action: onLiveContextMenuAction }
				, { type: "splitLine" }
				, { text: "<span id=\"submenu_trigger_groupSettings\">Group Settings</span>", icon: "#svg_mio_apps", iconClass: "noflip", alias: "group_settings_edit", action: onLiveContextMenuAction }
				, { text: "<span id=\"contextMenuCameraName\">Camera Name</span>", icon: "", alias: "cameraname" }
				, { type: "splitLine" }
				, { text: "<span id=\"contextMenuMaximize\">Maximize</span>", icon: "#svg_mio_Fullscreen", iconClass: "noflip", alias: "maximize", action: onLiveContextMenuAction }
				, { type: "splitLine" }
				, { text: "Trigger Now", icon: "#svg_x5F_Alert1", iconClass: "iconBlue", alias: "trigger", action: onLiveContextMenuAction }
				, { text: "<span id=\"manRecBtnLabel\">Toggle Recording</span>", icon: "#svg_x5F_Stoplight", iconClass: "iconBlue", alias: "record", tooltip: "Toggle Manual Recording", action: onLiveContextMenuAction }
				, { text: "Snapshot in Blue Iris", icon: "#svg_x5F_Snapshot", iconClass: "iconBlue", alias: "snapshot", tooltip: "Blue Iris will record a snapshot", action: onLiveContextMenuAction }
				, { text: "Restart Camera", icon: "#svg_x5F_Restart", iconClass: "iconBlue", alias: "restart", action: onLiveContextMenuAction }
				, { type: "splitLine" }
				, { text: "Stats for nerds", icon: "#svg_x5F_Info", alias: "statsfornerds", action: onLiveContextMenuAction }
				, { type: "splitLine" }
				, { text: "Properties", icon: "#svg_x5F_Viewdetails", alias: "properties", action: onLiveContextMenuAction }
			]
		, onContextMenu: onTriggerLiveContextMenu
		, onCancelContextMenu: onCancelLiveContextMenu
		, onShow: onShowLiveContextMenu
		, clickType: GetPreferredContextMenuTrigger()
	};
	$("#layoutbody").contextmenu(optionLive);

	var onShowRecordContextMenu = function (menu)
	{
		var disable_items = ["clipname"];
		var enable_items = ["opennewtab", "saveas", "copyimageaddress", "convertexport", "set_start_frame", "set_end_frame"
			, "submenu_motionoverlays"
			, "motionoverlays_nopreference"
			, "motionoverlays_off"
			, "motionoverlays_on"
			, "submenu_textoverlays"
			, "textoverlays_nopreference"
			, "textoverlays_off"
			, "textoverlays_on"
			, "closeclip", "statsfornerds", "properties"];
		var clipData = lastRecordContextMenuSelectedClip;
		if (sessionManager.HasPermission_DownloadClip(clipData))
			enable_items.push("downloadclip");
		else
			disable_items.push("downloadclip");
		menu.applyrule({ name: "disable_items", disable: true, items: disable_items });
		menu.applyrule({ name: "enable_items", disable: false, items: enable_items });
	}
	var onTriggerRecordContextMenu = function (e)
	{
		if (videoPlayer.Loading().image.isLive || videoPlayer.Loading().image.isTimeline())
			return false;

		videoPlayer.suppressMouseHelper();
		videoOverlayHelper.HideFalseLoadingOverlay();
		videoOverlayHelper.HideTemporaryIcons();

		var clipData = lastRecordContextMenuSelectedClip = clipLoader.GetClipFromId(videoPlayer.Loading().image.uniqueId);

		var downloadButton = $("#cmroot_recordview_downloadbutton_findme").closest(".b-m-item");
		if (downloadButton.parent().attr("id") == "cmroot_recordview_downloadlink")
			downloadButton.parent().attr("href", videoPlayer.GetLastSnapshotUrl());
		else
			downloadButton.wrap('<a id="cmroot_recordview_downloadlink" style="display:block" href="'
				+ videoPlayer.GetLastSnapshotUrl()
				+ '" onclick="saveSnapshot(&quot;#cmroot_recordview_downloadlink&quot;)" target="_blank"></a>');
		$("#cmroot_recordview_downloadlink").attr("download", "temp.jpg");

		var $dlBtnLabel = $("#cmroot_recordview_downloadclipbutton");
		var $dlBtn = $dlBtnLabel.closest(".b-m-item");
		if ($dlBtn.parent().attr("id") != "cmroot_recordview_downloadcliplink")
			$dlBtn.wrap('<a id="cmroot_recordview_downloadcliplink" style="display:block" href="" target="_blank"></a>');
		var $dlLink = $("#cmroot_recordview_downloadcliplink");
		if (sessionManager.HasPermission_DownloadClip(clipData))
		{
			$dlBtnLabel.text(clipLoader.GetClipDownloadText(clipData));
			var clipInfo = clipLoader.GetDownloadClipInfo(clipData);
			$dlLink.attr("href", clipInfo.href).attr("download", clipInfo.download);
		}
		else
		{
			$dlBtnLabel.text("(download unavailable)");
			$dlLink.removeAttr("href", "javascript:void(0)").removeAttr("download");
		}

		var name = clipLoader.GetClipDisplayName(clipData);
		$("#contextMenuClipName").text(name).closest(".b-m-item,.b-m-idisable").attr("title", name);

		ThreeStateMenuItem.Refresh("motionoverlays", clipOverlayCfg.GetMotionOverlay(clipData.camera));
		ThreeStateMenuItem.Refresh("textoverlays", clipOverlayCfg.GetTextOverlay(clipData.camera));

		return true;
	}
	var onRecordContextMenuAction = function ()
	{
		switch (this.data.alias)
		{
			case "properties":
				if (lastRecordContextMenuSelectedClip != null)
					clipProperties.open(lastRecordContextMenuSelectedClip.recId);
				break;
			case "opennewtab":
				videoPlayer.Playback_Pause();
				window.open(videoPlayer.GetLastSnapshotUrl());
				break;
			case "saveas":
				return true;
			case "downloadclip":
				return true;
			case "convertexport":
			case "set_start_frame":
			case "set_end_frame":
				if (lastRecordContextMenuSelectedClip)
				{
					var unexportableReason = clipLoader.GetUnexportableReason(lastRecordContextMenuSelectedClip);
					if (lastRecordContextMenuSelectedClip.isSnapshot && unexportableReason) // Classic UI3 AVI export still works with non-BVR video files, though API export doesn't.
						toaster.Info(unexportableReason, 15000);
					else
						exportControls.Enable(lastRecordContextMenuSelectedClip.recId);
				}
				if (this.data.alias === "set_start_frame")
					exportControls.SetStartTime(videoPlayer.GetClipPlaybackPositionPercent());
				else if (this.data.alias === "set_end_frame")
					exportControls.SetEndTime(videoPlayer.GetClipPlaybackPositionPercent());
				break;
			case "closeclip":
				clipLoader.CloseCurrentClip();
				return;
			case "statsfornerds":
				nerdStats.Open();
				return;
			case "copyimageaddress":
				var relUrl = videoPlayer.GetLastSnapshotUrl();
				if (!relUrl.startsWith("/"))
					relUrl = "/" + relUrl;
				clipboardHelper.CopyText(location.origin + relUrl);
				break;
			case "motionoverlays_nopreference":
				if (lastRecordContextMenuSelectedClip)
				{
					clipOverlayCfg.SetMotionOverlay(lastRecordContextMenuSelectedClip.camera, 0);
					videoPlayer.ReopenStreamAtCurrentSeekPosition();
				}
				break;
			case "motionoverlays_off":
				if (lastRecordContextMenuSelectedClip)
				{
					clipOverlayCfg.SetMotionOverlay(lastRecordContextMenuSelectedClip.camera, 1);
					videoPlayer.ReopenStreamAtCurrentSeekPosition();
				}
				break;
			case "motionoverlays_on":
				if (lastRecordContextMenuSelectedClip)
				{
					clipOverlayCfg.SetMotionOverlay(lastRecordContextMenuSelectedClip.camera, 2);
					videoPlayer.ReopenStreamAtCurrentSeekPosition();
				}
				break;
			case "textoverlays_nopreference":
				if (lastRecordContextMenuSelectedClip)
				{
					clipOverlayCfg.SetTextOverlay(lastRecordContextMenuSelectedClip.camera, 0);
					videoPlayer.ReopenStreamAtCurrentSeekPosition();
				}
				break;
			case "textoverlays_off":
				if (lastRecordContextMenuSelectedClip)
				{
					clipOverlayCfg.SetTextOverlay(lastRecordContextMenuSelectedClip.camera, 1);
					videoPlayer.ReopenStreamAtCurrentSeekPosition();
				}
				break;
			case "textoverlays_on":
				if (lastRecordContextMenuSelectedClip)
				{
					clipOverlayCfg.SetTextOverlay(lastRecordContextMenuSelectedClip.camera, 2);
					videoPlayer.ReopenStreamAtCurrentSeekPosition();
				}
				break;
			default:
				toaster.Error(this.data.alias + " is not implemented!");
				break;
		}
	}
	// { type: "skip" }
	var optionRecord =
	{
		alias: "cmroot_record", width: 200, items:
			[
				{ text: "Open image in new tab", icon: "#svg_mio_Tab", iconClass: "noflip", alias: "opennewtab", action: onRecordContextMenuAction }
				, { text: '<div id="cmroot_recordview_downloadbutton_findme" style="display:none"></div>Save image to disk', icon: "#svg_x5F_Snapshot", alias: "saveas", action: onRecordContextMenuAction }
				, { text: '<span id="cmroot_recordview_downloadclipbutton">Download clip</span>', icon: "#svg_x5F_Download", alias: "downloadclip", action: onRecordContextMenuAction }
				, { text: "Copy image address", icon: "#svg_mio_copy", iconClass: "noflip", alias: "copyimageaddress", action: onRecordContextMenuAction }
				, { type: "splitLine" }
				, { text: "<span id=\"contextMenuClipName\">Clip Name</span>", icon: "", alias: "clipname" }
				, { type: "splitLine" }
				, { text: 'Convert/export', icon: "#svg_mio_launch", iconClass: "noflip", alias: "convertexport", action: onRecordContextMenuAction }
				, { text: "Set start frame", icon: "#svg_mio_download", iconClass: "noflip rotate90 setStartFrame", alias: "set_start_frame", action: onRecordContextMenuAction }
				, { text: "Set end frame", icon: "#svg_mio_download", iconClass: "noflip rotate270 setEndFrame", alias: "set_end_frame", action: onRecordContextMenuAction }
				, { type: "splitLine" }
				, ThreeStateMenuItem.Create("motionoverlays", "Motion overlays", onRecordContextMenuAction)
				, ThreeStateMenuItem.Create("textoverlays", "Text/graphic overlays", onRecordContextMenuAction)
				, { type: "splitLine" }
				, { text: "Close Clip", icon: "#svg_x5F_Error", alias: "closeclip", action: onRecordContextMenuAction }
				, { type: "splitLine" }
				, { text: "Stats for nerds", icon: "#svg_x5F_Info", alias: "statsfornerds", action: onRecordContextMenuAction }
				, { type: "splitLine" }
				, { text: "Properties", icon: "#svg_x5F_Viewdetails", alias: "properties", action: onRecordContextMenuAction }
			]
		, onContextMenu: onTriggerRecordContextMenu
		, onShow: onShowRecordContextMenu
		, clickType: GetPreferredContextMenuTrigger()
	};
	$("#layoutbody").contextmenu(optionRecord);

	var onShowTimelineContextMenu = function (menu)
	{
		// 2022-03-11 - I'm letting the user configure group settings, such as display of labels, for solo-camera timeline views. It is hacky but it works.
		var imgLoaded = videoPlayer.Loaded().image;
		if (cameraListLoader.GetGroupCamera(imgLoaded.id))
			$("#submenu_trigger_timelineGroupSettings").text('Group Settings');
		else
			$("#submenu_trigger_timelineGroupSettings").text('Solo-Camera Settings');

		var itemsToDisable = ["cameraname"];
		if (lastTimelineContextMenuSelectedCamera == null || !cameraListLoader.CameraIsAlone(lastTimelineContextMenuSelectedCamera))
		{
			itemsToDisable = itemsToDisable.concat(["maximize", "properties"]);
			menu.applyrule(
				{
					name: "disable_camera_buttons",
					disable: true,
					items: itemsToDisable
				});
		}
		else
		{
			if (lastTimelineContextMenuSelectedCamera.isFakeGroup)
				itemsToDisable.push("maximize");
			menu.applyrule(
				{
					name: "disable_cameraname",
					disable: true,
					items: itemsToDisable
				});
		}
	}
	var onTriggerTimelineContextMenu = function (e)
	{
		if (!videoPlayer.Loading().image.isTimeline() || !videoPlayer.Loaded().image.isTimeline())
			return false;

		mouseCoordFixer.fix(e);

		videoPlayer.suppressMouseHelper();
		videoOverlayHelper.HideFalseLoadingOverlay();

		var downloadButton = $("#cmroot_timelineview_downloadbutton_findme").closest(".b-m-item");
		if (downloadButton.parent().attr("id") == "cmroot_timelineview_downloadlink")
			downloadButton.parent().attr("href", videoPlayer.GetLastSnapshotUrl());
		else
			downloadButton.wrap('<a id="cmroot_timelineview_downloadlink" style="display:block" href="'
				+ videoPlayer.GetLastSnapshotUrl()
				+ '" onclick="saveSnapshot(&quot;#cmroot_timelineview_downloadlink&quot;)" target="_blank"></a>');
		$("#cmroot_timelineview_downloadlink").attr("download", "temp.jpg");

		var homeGroupObj = null;
		var camData = videoPlayer.GetCameraUnderMousePointer(e);
		if (camData == null)
			camData = homeGroupObj = videoPlayer.GetCurrentHomeGroupObj();
		lastTimelineContextMenuSelectedCamera = camData;
		if (camData != null)
		{
			LoadDynamicManualRecordingButtonState(camData);
			var camName = CleanUpGroupName(camData.optionDisplay);
			$("#contextMenuTimelineCameraName").text(camName);
			$("#contextMenuTimelineCameraName").closest("div.b-m-item,div.b-m-idisable").attr("title", "The buttons below are specific to the camera: " + camName);
			var $maximize = $("#contextMenuTimelineMaximize");
			var isMaxAlready = (iEquals(camData.optionValue, videoPlayer.Loaded().image.id) && homeGroupObj == null);
			$maximize.text(isMaxAlready ? "Back to Group" : "Maximize");
			$maximize.parent().prev().find("use").attr("xlink:href", isMaxAlready ? "#svg_mio_FullscreenExit" : "#svg_mio_Fullscreen");
		}

		ThreeStateMenuItem.Refresh("timeline_motionoverlays", clipOverlayCfg.GetMotionOverlay("*ui3_timeline_pseudocam"));
		ThreeStateMenuItem.Refresh("timeline_textoverlays", clipOverlayCfg.GetTextOverlay("*ui3_timeline_pseudocam"));

		return true;
	}
	var onTimelineContextMenuAction = function ()
	{
		switch (this.data.alias)
		{
			case "maximize":
				if (!cameraListLoader.CameraIsAlone(lastTimelineContextMenuSelectedCamera))
					toaster.Warning("Function is unavailable.");
				else
					videoPlayer.ImgClick_Camera(lastTimelineContextMenuSelectedCamera);
				break;
			case "properties":
				if (!cameraListLoader.CameraIsAlone(lastTimelineContextMenuSelectedCamera))
					toaster.Warning("You cannot view properties of cameras that are part of an auto-cycle.");
				else
					new CameraProperties(lastTimelineContextMenuSelectedCamera.optionValue);
				break;
			case "opennewtab":
				window.open(videoPlayer.GetLastSnapshotUrl());
				break;
			case "copyimageaddress":
				var relUrl = videoPlayer.GetLastSnapshotUrl();
				if (!relUrl.startsWith("/"))
					relUrl = "/" + relUrl;
				clipboardHelper.CopyText(location.origin + relUrl);
				break;
			case "saveas":
				return true;
			case "statsfornerds":
				nerdStats.Open();
				break;
			case "group_settings_edit":
				groupLayoutDialog.Show(videoPlayer.Loaded().image);
				break;
			case "golive":
				videoPlayer.goLive();
				break;
			case "timeline_motionoverlays_nopreference":
				clipOverlayCfg.SetMotionOverlay("*ui3_timeline_pseudocam", 0);
				videoPlayer.RefreshVideoStream();
				break;
			case "timeline_motionoverlays_off":
				clipOverlayCfg.SetMotionOverlay("*ui3_timeline_pseudocam", 1);
				videoPlayer.RefreshVideoStream();
				break;
			case "timeline_motionoverlays_on":
				clipOverlayCfg.SetMotionOverlay("*ui3_timeline_pseudocam", 2);
				videoPlayer.RefreshVideoStream();
				break;
			case "timeline_textoverlays_nopreference":
				clipOverlayCfg.SetTextOverlay("*ui3_timeline_pseudocam", 0);
				videoPlayer.RefreshVideoStream();
				break;
			case "timeline_textoverlays_off":
				clipOverlayCfg.SetTextOverlay("*ui3_timeline_pseudocam", 1);
				videoPlayer.RefreshVideoStream();
				break;
			case "timeline_textoverlays_on":
				clipOverlayCfg.SetTextOverlay("*ui3_timeline_pseudocam", 2);
				videoPlayer.RefreshVideoStream();
				break;
			default:
				toaster.Error(this.data.alias + " is not implemented!");
				break;
		}
	}
	var onCancelTimelineContextMenu = function ()
	{
	}
	var optionTimeline =
	{
		alias: "cmroot_timelinecanvas", width: 200, items:
			[
				{ text: "Open image in new tab", icon: "#svg_mio_Tab", iconClass: "noflip", alias: "opennewtab", action: onTimelineContextMenuAction }
				, { text: '<div id="cmroot_timelineview_downloadbutton_findme" style="display:none"></div>Save image to disk', icon: "#svg_x5F_Snapshot", alias: "saveas", action: onTimelineContextMenuAction }
				, { text: "Copy image address", icon: "#svg_mio_copy", iconClass: "noflip", alias: "copyimageaddress", action: onTimelineContextMenuAction }
				, { text: "Go Live", icon: "#svg_mio_clock", iconClass: "noflip clockRotate", alias: "golive", action: onTimelineContextMenuAction }
				, { type: "splitLine" }
				, { text: "<span id=\"submenu_trigger_timelineGroupSettings\">Group Settings</span>", icon: "#svg_mio_apps", iconClass: "noflip", alias: "group_settings_edit", action: onTimelineContextMenuAction }
				, ThreeStateMenuItem.Create("timeline_motionoverlays", "Motion overlays", onTimelineContextMenuAction)
				, ThreeStateMenuItem.Create("timeline_textoverlays", "Text/graphic overlays", onTimelineContextMenuAction)
				, { type: "splitLine" }
				, { text: "<span id=\"contextMenuTimelineCameraName\">Camera Name</span>", icon: "", alias: "cameraname" }
				, { type: "splitLine" }
				, { text: "<span id=\"contextMenuTimelineMaximize\">Maximize</span>", icon: "#svg_mio_Fullscreen", iconClass: "noflip", alias: "maximize", action: onTimelineContextMenuAction }
				, { type: "splitLine" }
				, { text: "Stats for nerds", icon: "#svg_x5F_Info", alias: "statsfornerds", action: onTimelineContextMenuAction }
				, { type: "splitLine" }
				, { text: "Properties", icon: "#svg_x5F_Viewdetails", alias: "properties", action: onTimelineContextMenuAction }
			]
		, onContextMenu: onTriggerTimelineContextMenu
		, onCancelContextMenu: onCancelTimelineContextMenu
		, onShow: onShowTimelineContextMenu
		, clickType: GetPreferredContextMenuTrigger()
	};
	$("#layoutbody").contextmenu(optionTimeline);
}
function OpenGroupSettings()
{
	groupLayoutDialog.Show(videoPlayer.Loaded().image);
}
var ThreeStateMenuItem = new (function ()
{
	this.Create = function (id, nameHtml, action)
	{
		return {
			text: "<span id=\"submenu_trigger_" + id + "\">" + nameHtml + "</span>", icon: "#svg_mio_cbUnchecked", iconClass: "noflip", alias: "submenu_" + id,
			type: "group",
			items: [
				{ text: "<span id=\"" + id + "_nopreference\" title=\"Value is inherited from server\">No preference</span>&nbsp;", icon: "#svg_mio_cbUnchecked", iconClass: "noflip", alias: id + "_nopreference", action: action },
				{ text: "<span id=\"" + id + "_off\">Force OFF</span>", icon: "#svg_mio_cbMinus", iconClass: "noflip", alias: id + "_off", action: action },
				{ text: "<span id=\"" + id + "_on\">Force ON</span>", icon: "#svg_mio_cbPlus", iconClass: "noflip", alias: id + "_on", action: action }
			]
		}
	};
	this.Refresh = function (id, value)
	{
		getIconWrapper("submenu_trigger_" + id).find("use").attr("href", getIconId(value));
		setIconClass(id + "_nopreference", value === 0);
		setIconClass(id + "_off", value === 1);
		setIconClass(id + "_on", value === 2);
	};

	function getIconWrapper(spanId)
	{
		return $("#" + spanId).parent().siblings(".b-m-icon");
	}
	function getIconId(val)
	{
		if (val === 1)
			return "#svg_mio_cbMinus";
		if (val === 2)
			return "#svg_mio_cbPlus";
		return "#svg_mio_cbUnchecked";
	}
	function setIconClass(spanId, enabled)
	{
		if (enabled)
			getIconWrapper(spanId).removeClass("iconGray");
		else
			getIconWrapper(spanId).addClass("iconGray");
	}
	this.SetVisible = function (id, visible)
	{
		if (visible)
			$("#submenu_trigger_" + id).closest('.b-m-item,.b-m-ifocus').show();
		else
			$("#submenu_trigger_" + id).closest('.b-m-item,.b-m-ifocus').hide();
	}
})();
///////////////////////////////////////////////////////////////
// Calendar Context Menu //////////////////////////////////////
///////////////////////////////////////////////////////////////
function CalendarContextMenu()
{
	var self = this;

	var onContextMenuAction = function ()
	{
		switch (this.data.alias)
		{
			case "select":
				dateFilter.OpenDatePicker($("#dateRange").get(0));
				break;
			case "today":
				dateFilter.SelectToday();
				break;
			case "clear":
				dateFilter.Clear();
				break;
			default:
				toaster.Error(this.data.alias + " is not implemented!");
				break;
		}
	}
	var menuOptions =
	{
		alias: "cmroot_calendar", width: 200, items:
			[
				{ text: "Filter by Date Range", icon: "", alias: "select", action: onContextMenuAction }
				, { text: "Today Only", icon: "", alias: "today", action: onContextMenuAction }
				, { text: "Clear Filter", icon: "", alias: "clear", action: onContextMenuAction }

			]
		, clickType: GetPreferredContextMenuTrigger()
	};
	$("#dateRange").contextmenu(menuOptions);
}
///////////////////////////////////////////////////////////////
// Open Alert List Button Context Menu ////////////////////////
///////////////////////////////////////////////////////////////
function OpenAlertListButtonContextMenu()
{
	var self = this;

	var onContextMenuAction = function ()
	{
		switch (this.data.alias)
		{
			case "open":
				$("#open_alerts_btn").click();
				break;
			case "clear":
				resetNewAlertCounters();
				break;
			default:
				toaster.Error(this.data.alias + " is not implemented!");
				break;
		}
	}
	var menuOptions =
	{
		alias: "cmroot_open_alert_list_button", width: 160, items:
			[
				{ text: "Open Alert List", icon: "#svg_x5F_Alert1", alias: "open", action: onContextMenuAction }
				, { text: "Clear Counters", icon: "#svg_mio_Trash", iconClass: "noflip", alias: "clear", action: onContextMenuAction }
			]
		, clickType: GetPreferredContextMenuTrigger()
	};
	$("#open_alerts_btn").contextmenu(menuOptions);
}
///////////////////////////////////////////////////////////////
// Clip list Context Menu /////////////////////////////////////
///////////////////////////////////////////////////////////////
function ClipListContextMenu()
{
	var self = this;
	var allSelectedClipIDs = [];
	var flagEnable = false;
	var protectEnable = false;
	var aiConfirm = false;
	var addDeleteItem = settings.ui3_allow_clip_deletion !== "0";

	var onShowMenu = function (menu)
	{
		var itemsToEnable = ["flag", "protect", "larger_thumbnails", "mouseover_thumbnails", "convertexport"];
		var itemsToDisable = [];

		if (addDeleteItem)
			itemsToEnable.push("delete");
		var singleClipItems = itemsToEnable;
		if (allSelectedClipIDs.length > 1)
			singleClipItems = itemsToDisable;
		singleClipItems.push("properties");
		singleClipItems.push("copyurl");
		singleClipItems.push("editmemo");

		var hasClipsSelected = false;
		var clipData;
		for (var i = 0; i < allSelectedClipIDs.length; i++)
		{
			clipData = clipLoader.GetClipFromId(allSelectedClipIDs[i]);
			if (clipData.isClip)
			{
				hasClipsSelected = true;
				break;
			}
		}
		if (!hasClipsSelected)
			itemsToEnable.push("aiconfirm");

		if (allSelectedClipIDs.length !== 1 || sessionManager.HasPermission_DownloadClip(clipData))
			itemsToEnable.push("download");
		else
			itemsToDisable.push("download");


		menu.applyrule({ name: "disable_items", disable: true, items: itemsToDisable });
		menu.applyrule({ name: "enable_items", disable: false, items: itemsToEnable });

	}
	var onTriggerContextMenu = function (e)
	{
		var downloadClipButton = $("#cm_cliplist_download").closest(".b-m-item");
		if (downloadClipButton.parent().attr("id") != "cmroot_cliplist_downloadcliplink")
			downloadClipButton.wrap('<a id="cmroot_cliplist_downloadcliplink" style="display:block" href="javascript:void(0)" target="_blank"></a>');
		var $dl_link = $("#cmroot_cliplist_downloadcliplink");
		$dl_link.removeAttr("href").removeAttr("download");

		var recId = e.currentTarget.id.substr(1);
		if (!clipLoader.IsClipSelected(recId))
		{
			clipLoader.UnselectAllClips();
			clipLoader.SelectClipIdNoOpen(recId);
		}

		allSelectedClipIDs = clipLoader.GetAllSelected();

		flagEnable = false; // Turn all off, but if one is already off, then turn all on.
		protectEnable = false;
		aiConfirm = false;
		for (var i = 0; i < allSelectedClipIDs.length; i++)
		{
			var clipData = clipLoader.GetClipFromId(allSelectedClipIDs[i]);
			if (clipData)
			{
				if (!NumberHasFlags(clipData.flags, BIDBFLAG.FLAGGED))
					flagEnable = true;
				if (!NumberHasFlags(clipData.flags, BIDBFLAG.PROTECTED))
					protectEnable = true;
				if (!NumberHasFlags(clipData.flags, BIDBFLAG.AI_CONFIRMED))
					aiConfirm = true;
			}
		}

		if (allSelectedClipIDs.length == 1)
		{
			var clipData = clipLoader.GetClipFromId(allSelectedClipIDs[0]);

			$("#cm_cliplist_flag").text(flagEnable ? "Flag" : "Unflag");
			$("#cm_cliplist_protect").text(protectEnable ? "Protect" : "Unprotect");
			$("#cm_cliplist_aiconfirm").text(aiConfirm ? "Mark as AI-confirmed" : "Unmark as AI-confirmed");
			if (sessionManager.HasPermission_DownloadClip(clipData))
			{
				$("#cm_cliplist_download").text(clipLoader.GetClipDownloadText(clipData));
				var clipInfo = clipLoader.GetDownloadClipInfo(clipData);
				$dl_link.attr("href", clipInfo.href);
				if (clipInfo.download)
					$dl_link.attr("download", clipInfo.download);
			}
			else
				$("#cm_cliplist_download").text("(download unavailable)");
			$("#cm_cliplist_delete").text("Delete");
			$("#cm_cliplist_copyurl").text("Copy " + (clipData.isClip ? "clip" : "alert") + " URL");
		}
		else if (allSelectedClipIDs.length > 1)
		{
			var label = " " + allSelectedClipIDs.length + " " + (DbViewIsAlerts(settings.ui3_current_dbView) ? "alerts" : "clips");
			$("#cm_cliplist_flag").text((flagEnable ? "Flag" : "Unflag") + label);
			$("#cm_cliplist_protect").text((protectEnable ? "Protect" : "Unprotect") + label);
			$("#cm_cliplist_aiconfirm").text((aiConfirm ? "Mark as AI-confirmed" : "Unmark as AI-confirmed") + label);
			$("#cm_cliplist_download").text("Download " + allSelectedClipIDs.length + " clips");
			$("#cm_cliplist_delete").text("Delete" + label);
		}

		if (getLargerClipThumbnails())
			$("#cm_cliplist_larger_thumbnails").text("Shrink Thumbnails");
		else
			$("#cm_cliplist_larger_thumbnails").text("Enlarge Thumbnails");

		if (getMouseoverClipThumbnails())
			$("#cm_cliplist_mouseover_thumbnails").text("Disable Mouseover Thumbs");
		else
			$("#cm_cliplist_mouseover_thumbnails").text("Enable Mouseover Thumbs");
		return true;
	}
	var onContextMenuAction = function ()
	{
		switch (this.data.alias)
		{
			case "flag":
				var whatAction = (flagEnable ? "flag" : "unflag");
				var whichKind = (DbViewIsAlerts(settings.ui3_current_dbView) ? "alert" : "clip") + (allSelectedClipIDs.length == 1 ? "" : "s");
				if (allSelectedClipIDs.length <= 12)
					clipLoader.Multi_Flag(allSelectedClipIDs, flagEnable);
				else
					AskYesNo("Confirm " + whatAction + " of " + allSelectedClipIDs.length + " " + whichKind + "?", function ()
					{
						clipLoader.Multi_Flag(allSelectedClipIDs, flagEnable);
					});
				break;
			case "protect":
				var whatAction = (protectEnable ? "protect" : "unprotect");
				var whichKind = (DbViewIsAlerts(settings.ui3_current_dbView) ? "alert" : "clip") + (allSelectedClipIDs.length == 1 ? "" : "s");
				if (allSelectedClipIDs.length <= 12)
					clipLoader.Multi_Protect(allSelectedClipIDs, protectEnable);
				else
					AskYesNo("Confirm " + whatAction + " of " + allSelectedClipIDs.length + " " + whichKind + "?", function ()
					{
						clipLoader.Multi_Protect(allSelectedClipIDs, protectEnable);
					});
				break;
			case "aiconfirm":
				var whatAction = (aiConfirm ? "Mark AI-confirmed" : "Unmark AI-confirmed");
				var whichKind = (DbViewIsAlerts(settings.ui3_current_dbView) ? "alert" : "clip") + (allSelectedClipIDs.length == 1 ? "" : "s");
				if (allSelectedClipIDs.length <= 12)
					clipLoader.Multi_AiConfirm(allSelectedClipIDs, aiConfirm);
				else
					AskYesNo("Confirm " + whatAction + " of " + allSelectedClipIDs.length + " " + whichKind + "?", function ()
					{
						clipLoader.Multi_AiConfirm(allSelectedClipIDs, aiConfirm);
					});
				break;
			case "download":
				if (allSelectedClipIDs.length == 1)
					return true;
				else
					clipDownloadDialog.open(allSelectedClipIDs);
				break;
			case "delete":
				var whichKind = (DbViewIsAlerts(settings.ui3_current_dbView) ? "alert" : "clip") + (allSelectedClipIDs.length == 1 ? "" : "s");
				var deleter = function ()
				{
					clipLoader.Multi_Delete(allSelectedClipIDs);
				};
				if (settings.ui3_askForDelete === "All" ||
					settings.ui3_askForDelete === "Multiple" && allSelectedClipIDs.length > 1)
				{
					AskYesNo("Confirm deletion of " + allSelectedClipIDs.length + " " + whichKind + "?", deleter);
				}
				else
				{
					deleter();
				}
				break;
			case "copyurl":
				if (allSelectedClipIDs.length === 1)
				{
					var clipData = clipLoader.GetClipFromId(allSelectedClipIDs[0]);
					var search = new URLSearchParams();
					search.set("rec", clipData.recId);
					search = "?" + search.toString();
					var url = location.origin + location.pathname + search;
					clipboardHelper.CopyText(url);
				}
				break;
			case "larger_thumbnails":
				toggleLargerClipThumbnails();
				break;
			case "mouseover_thumbnails":
				toggleMouseoverClipThumbnails();
				break;
			case "editmemo":
				var clipData = clipLoader.GetClipFromId(allSelectedClipIDs[0]);
				AskUserForUpdatedMemo(clipData);
				break;
			case "convertexport":
				if (allSelectedClipIDs.length >= 1)
				{
					if (allSelectedClipIDs.length === 1)
					{
						var clipData = clipLoader.GetClipFromId(allSelectedClipIDs[0]);
						var unexportableReason = clipLoader.GetUnexportableReason(clipData);
						if (clipData.isSnapshot && unexportableReason) // Classic UI3 AVI export still works with non-BVR video files, though API export doesn't.
							toaster.Info(unexportableReason, 15000);
						else
						{
							var $ele = $("#c" + clipData.recId);
							if ($ele.length > 0)
								clipLoader.OpenClip($ele.get(0), clipData.recId, true);
							exportControls.Enable(videoPlayer.Loading().image.uniqueId);
						}
					}
					else
					{
						clipExportPanel.Open(allSelectedClipIDs);
					}
				}
				else
					toaster.Warning("No " + (DbViewIsAlerts(settings.ui3_current_dbView) ? "alert" : "clip") + " is selected.");
				break;
			case "properties":
				if (allSelectedClipIDs.length >= 1)
					clipProperties.open(allSelectedClipIDs[0]);
				else
					toaster.Warning("No " + (DbViewIsAlerts(settings.ui3_current_dbView) ? "alert" : "clip") + " is selected.");
				break;
			default:
				toaster.Error(this.data.alias + " is not implemented!");
				break;
		}
	}
	// You can use { type: "skip" } as a context menu item, and that item will not be rendered
	var menuOptions =
	{

		alias: "cmroot_cliplist", width: 200, items:
			[
				{ text: '<span id="cm_cliplist_flag">Flag</span>', icon: "#svg_x5F_Flag", iconClass: "", alias: "flag", action: onContextMenuAction }
				, { text: '<span id="cm_cliplist_protect">Protect</span>', icon: "#svg_mio_lock", iconClass: "noflip", alias: "protect", action: onContextMenuAction }
				, { text: '<span id="cm_cliplist_aiconfirm">(un)Mark as AI-confirmed</span>', icon: "#svg_mio_cbChecked", iconClass: "noflip", alias: "aiconfirm", action: onContextMenuAction }
				, { text: '<span id="cm_cliplist_download">Download clip</span>', icon: "#svg_x5F_Download", alias: "download", action: onContextMenuAction }
				, (addDeleteItem
					? { text: '<span id="cm_cliplist_delete">Delete</span>', icon: "#svg_mio_Trash", iconClass: "noflip", alias: "delete", action: onContextMenuAction }
					: { type: "skip" })
				, { text: '<span id="cm_cliplist_copyurl">Copy clip URL</span>', icon: "#svg_mio_copy", alias: "copyurl", action: onContextMenuAction }
				, { type: "splitLine" }
				, { text: '<span id="cm_cliplist_larger_thumbnails">Enlarge Thumbnails</span>', icon: "#svg_mio_imageLarger", iconClass: "noflip", alias: "larger_thumbnails", action: onContextMenuAction }
				, { text: '<span id="cm_cliplist_mouseover_thumbnails">Enlarge Thumbnails</span>', icon: "#svg_mio_popout", iconClass: "noflip rotate270", alias: "mouseover_thumbnails", action: onContextMenuAction }
				, { type: "splitLine" }
				, { text: "Edit Memo", icon: "#svg_mio_edit", iconClass: "noflip", alias: "editmemo", action: onContextMenuAction }
				, { type: "splitLine" }
				, { text: "Convert/export", icon: "#svg_mio_launch", iconClass: "noflip", alias: "convertexport", action: onContextMenuAction }
				, { type: "splitLine" }
				, { text: "Properties", icon: "#svg_x5F_Viewdetails", alias: "properties", action: onContextMenuAction }

			]
		, clickType: GetPreferredContextMenuTrigger()
		, onContextMenu: onTriggerContextMenu
		, onShow: onShowMenu
	};
	this.AttachContextMenu = function ($ele)
	{
		$ele.contextmenu(menuOptions);
	}
}
function getLargerClipThumbnails()
{
	return settings.ui3_cliplist_larger_thumbnails == "1";
}
function toggleLargerClipThumbnails()
{
	settings.ui3_cliplist_larger_thumbnails = getLargerClipThumbnails() ? "0" : "1";
	resized();
}
function getMouseoverClipThumbnails()
{
	return settings.ui3_cliplist_mouseover_thumbnails == "1";
}
function toggleMouseoverClipThumbnails()
{
	settings.ui3_cliplist_mouseover_thumbnails = getMouseoverClipThumbnails() ? "0" : "1";
}
///////////////////////////////////////////////////////////////
// Generic Enable/Disable Item Context Menu ///////////////////
///////////////////////////////////////////////////////////////
function GetUi3FeatureEnabled(uniqueSettingsId)
{
	return settings.getItem("ui3_feature_enabled_" + uniqueSettingsId) == "1";
}
function SetUi3FeatureEnabled(uniqueSettingsId, enabled)
{
	return settings.setItem("ui3_feature_enabled_" + uniqueSettingsId, enabled ? "1" : "0");
}
function ContextMenu_EnableDisableItem(selector, uniqueSettingsId, itemName, onToggle, extraMenuButtons, shouldDisableToggler, labels)
{
	var self = this;
	var onShowContextMenu = function (menu)
	{
		var itemsToDisable = [];
		var itemsToEnable = [];
		if (shouldDisableToggler && shouldDisableToggler())
			itemsToDisable.push("toggle");
		else
			itemsToEnable.push("toggle");
		if (extraMenuButtons)
			for (var i = 0; i < extraMenuButtons.length; i++)
				if (extraMenuButtons[i].shouldDisable && extraMenuButtons[i].shouldDisable())
					itemsToDisable.push(uniqueSettingsId + '_extra_alias_' + i);
				else
					itemsToEnable.push(uniqueSettingsId + '_extra_alias_' + i);
		menu.applyrule({ name: "enable_items_" + uniqueSettingsId, disable: false, items: itemsToEnable });
		menu.applyrule({ name: "disable_items_" + uniqueSettingsId, disable: true, items: itemsToDisable });
	};
	var onTriggerContextMenu = function (e)
	{
		// Set text for Enable/Disable button
		var label = $("#cmToggleLabel_" + uniqueSettingsId);
		if (GetUi3FeatureEnabled(uniqueSettingsId))
			label.html(labels[1]);
		else
			label.html(labels[0]);
		// Set text for Extra buttons.
		if (extraMenuButtons)
			for (var i = 0; i < extraMenuButtons.length; i++)
				$("#" + uniqueSettingsId + "_extra_" + i).html(extraMenuButtons[i].getName(e.currentTarget));
		return true;
	};
	var onContextMenuAction = function (ele)
	{
		switch (this.data.alias)
		{
			case "toggle":
				var enabled = !GetUi3FeatureEnabled(uniqueSettingsId);
				SetUi3FeatureEnabled(uniqueSettingsId, enabled);
				if (onToggle)
					onToggle(enabled);
				break;
			default:
				if (extraMenuButtons && this.data.alias.startsWith(uniqueSettingsId + '_extra_alias_'))
				{
					var i = parseInt(this.data.alias.substr((uniqueSettingsId + '_extra_alias_').length));
					if (!isNaN(i) && i >= 0 && i < extraMenuButtons.length)
						extraMenuButtons[i].action(ele);
				}
				else
					toaster.Error(this.data.alias + " is not implemented!");
				break;
		}
	};
	var menuItemArray = [{ text: '<span id="cmToggleLabel_' + uniqueSettingsId + '">' + labels[2] + '</span> ' + itemName + "&nbsp;", icon: "", alias: "toggle", action: onContextMenuAction }];
	if (extraMenuButtons)
		for (var i = 0; i < extraMenuButtons.length; i++)
		{
			var btnDef = extraMenuButtons[i];
			menuItemArray.push({ text: '<span id="' + uniqueSettingsId + '_extra_' + i + '">Extra ' + i + '</span>', icon: "", alias: uniqueSettingsId + '_extra_alias_' + i, action: onContextMenuAction });
		}
	var menuOptions =
	{
		alias: "cmroot_" + uniqueSettingsId
		, width: "auto"
		, items: menuItemArray
		, onContextMenu: onTriggerContextMenu
		, onShow: onShowContextMenu
		, clickType: GetPreferredContextMenuTrigger()
	};
	$(selector).contextmenu(menuOptions);
	if (onToggle)
		onToggle(GetUi3FeatureEnabled(uniqueSettingsId));
}
///////////////////////////////////////////////////////////////
// Get Clip Stats /////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var clipStatsLoader = new ClipStatsLoader();
function ClipStatsLoader()
{
	var self = this;
	var cache = {};
	var maxCacheAge = 10000;
	var queuedLoad = null;
	var activeLoad = null;
	/**
	 * Gets clipstats for the specified clip and sends the results to the onSuccess method.  If cached results are available (regardless of age), onSuccess will be called before this method returns.  If there is no cached value, or if the cached value is beyond the max age and "preferCached" is false, fresh data may be requested asynchronously and onSuccess may be called again later.  This method can be provided alert IDs as well, but it is preferable to provide clip IDs as these will be hit more often in the cache.
	 * @param {string} clipId Clip ID or Alert ID. If given an Alert ID, the server will find its clip.
	 * @param {Function} onSuccess Callback which is called if/when a clip's stats are available. May be called 0, 1, or 2 times.
	 * @param {boolean} preferCached If true and a cached value is available (regardless of age), no server API call will be made.
	 * @param {Function} onFinished Callback which is called when any response is received from the server. Guaranteed to be called one time, unless this function is called many times rapidly, in which case the request queueing system may drop some requests.
	 */
	this.LoadClipStats = function (clipId, onSuccess, preferCached, onFinished)
	{
		if (!clipId)
		{
			if (typeof onFinished === "function")
				onFinished(null);
			return;
		}
		var cachedValue = cache[clipId];
		if (cachedValue)
		{
			if (typeof onSuccess === "function")
				onSuccess(cachedValue.getStats());
			if (preferCached || cachedValue.getAgeMs() < maxCacheAge)
			{
				if (typeof onFinished === "function")
					onFinished(cachedValue.getStats());
				return;
			}
		}
		GetFresh(clipId, onSuccess, onFinished);
	}
	var GetFresh = function (clipId, onSuccess, onFinished)
	{
		if (activeLoad)
		{
			activeLoad.canceled = true; // Prevent onSuccess from being raised for previous requests.
			queuedLoad = { clipId: clipId, onSuccess: onSuccess, onFinished: onFinished };
		}
		else
		{
			activeLoad = { clipId: clipId, onSuccess: onSuccess, onFinished: onFinished, canceled: false };
			GetClipStats(clipId, function (stats)
			{
				cache[clipId] = new CachedClipStats(stats);
				if (activeLoad && !activeLoad.canceled && typeof onSuccess === "function")
					onSuccess(stats, clipId);
				if (typeof onFinished === "function")
					onFinished(stats);
				activeLoad = null;
				processQueuedLoad();
			}, function (clipId, msg)
			{
				if (typeof onFinished === "function")
					onFinished(null, msg);
				else
					toaster.Error(msg);
				activeLoad = null;
				processQueuedLoad();
			});
		}
	}
	var processQueuedLoad = function ()
	{
		if (queuedLoad)
		{
			GetFresh(queuedLoad.clipId, queuedLoad.onSuccess, queuedLoad.onFinished);
			queuedLoad = null;
		}
	}
	var GetClipStats = function (clipId, onSuccess, onFail)
	{
		ExecJSON({ cmd: "clipstats", path: clipId }, function (response)
		{
			if (typeof response.result == "undefined")
			{
				if (onFail)
					onFail(clipId, "Unexpected response when getting clip stats from server. This alert may have an inaccurate duration.");
			}
			else if (response.result == "fail")
			{
				if (onFail)
					onFail(clipId, "Fail response when getting clip stats from server. This alert may have an inaccurate duration.");
			}
			else
			{
				if (onSuccess)
					onSuccess(response.data, clipId);
			}
		}, function (jqXHR, textStatus, errorThrown)
		{
			if (onFail)
				onFail(clipId, "Error response when getting clip stats from server: " + jqXHR.status + " " + jqXHR.statusText + "<br>This alert may have an inaccurate duration.");
		});
	}
}
function CachedClipStats(stats)
{
	var created = performance.now();
	this.getStats = function ()
	{
		return stats;
	}
	this.getAgeMs = function ()
	{
		return performance.now() - created;
	}
}
///////////////////////////////////////////////////////////////
// Get / Set Camera Config ////////////////////////////////////
///////////////////////////////////////////////////////////////
function CameraConfig()
{
	var self = this;
	this.get = function (camId, successCallbackFunc, failCallbackFunc)
	{
		ExecJSON({ cmd: "camconfig", camera: camId }, function (response)
		{
			if (typeof response.result == "undefined")
			{
				toaster.Error("Unexpected response when getting camera configuration from server.");
				if (failCallbackFunc)
					failCallbackFunc(camId, false);
				return;
			}
			if (response.result == "fail")
			{
				if (failCallbackFunc)
					failCallbackFunc(camId, true);
				return;
			}
			if (successCallbackFunc)
				successCallbackFunc(response, camId);
		}, function (jqXHR, textStatus, errorThrown)
		{
			if (failCallbackFunc)
				failCallbackFunc(camId, false);
		});
	}
	this.set = function (camId, key, value, successCallbackFunc, failCallbackFunc)
	{
		var args = { cmd: "camconfig", camera: camId };
		if (key == "manrec")
			args.manrec = value;
		else if (key == "reset")
			args.reset = value;
		else if (key == "reboot")
			args.reboot = value;
		else if (key == "enable")
			args.enable = value;
		else if (key == "pause")
			args.pause = value;
		else if (key == "motion")
			args.motion = value;
		else if (key == "schedule")
			args.schedule = value;
		else if (key == "ptzcycle")
			args.ptzcycle = value;
		else if (key == "ptzevents")
			args.ptzevents = value;
		else if (key == "alerts")
			args.alerts = value;
		else if (key == "record")
			args.record = value;
		else if (key == "push")
			args.push = value;
		else if (key == "output")
			args.output = value;
		else if (key.startsWith("setmotion."))
		{
			args.setmotion = {};
			if (key == "setmotion.audio_trigger")
				args.setmotion.audio_trigger = value;
			else if (key == "setmotion.audio_sense")
				args.setmotion.audio_sense = value;
			else if (key == "setmotion.usemask")
				args.setmotion.usemask = value;
			else if (key == "setmotion.sense")
				args.setmotion.sense = value;
			else if (key == "setmotion.contrast")
				args.setmotion.contrast = value;
			else if (key == "setmotion.showmotion")
				args.setmotion.showmotion = value;
			else if (key == "setmotion.shadows")
				args.setmotion.shadows = value;
			else if (key == "setmotion.luminance")
				args.setmotion.luminance = value;
			else if (key == "setmotion.objects")
				args.setmotion.objects = value;
			else if (key == "setmotion.maketime")
				args.setmotion.maketime = value;
			else if (key == "setmotion.breaktime")
				args.setmotion.breaktime = value;
			else
			{
				toaster.Error('Unknown camera configuration key: ' + htmlEncode(key), 3000);
				return;
			}
		}
		else if (key.startsWith("setpost."))
		{
			args.setpost = {};
			if (key == "setpost.timed")
				args.setpost.timed = value;
			else if (key == "setpost.timed_interval")
				args.setpost.timed_interval = value;
			else
			{
				toaster.Error('Unknown camera configuration key: ' + htmlEncode(key), 3000);
				return;
			}
		}
		else
		{
			toaster.Error('Unknown camera configuration key: ' + htmlEncode(key), 3000);
			return;
		}
		ExecJSON(args, function (response)
		{
			if (typeof response.result == "undefined")
			{
				toaster.Error("Unexpected response when setting camera configuration on server.");
				return;
			}
			if (response.result == "fail")
			{
				openLoginDialog(function () { self.set(camId, key, value, successCallbackFunc, failCallbackFunc); });
				return;
			}
			console.log('CameraConfig Set ("' + htmlEncode(camId) + '", "' + htmlEncode(key) + '", "' + htmlEncode(value) + '")');
			if (successCallbackFunc)
				successCallbackFunc(response, camId, key, value);
		}, function (jqXHR, textStatus, errorThrown)
		{
			if (failCallbackFunc)
				failCallbackFunc(camId, key, value);
			else
				toaster.Error("Failed to set camera configuration! (" + htmlEncode(key) + ")<br>" + jqXHR.ErrorMessageHtml, 8000);
		});
	}
}
///////////////////////////////////////////////////////////////
// Camera List Dialog /////////////////////////////////////////
///////////////////////////////////////////////////////////////
function CameraListDialog()
{
	var self = this;
	var modal_cameralistdialog = null;
	var timeBetweenCameraListThumbUpdates = 1000 * 60 * 60 * 24; // 1 day
	var loadedOnce = false;
	this.open = function ()
	{
		CloseCameraListDialog();
		modal_cameralistdialog = $('<div id="cameralistdialog">'
			+ '<div id="cameralistcontent" class="cameralistcontent"></div>'
			+ '</div>'
		).dialog({
			title: "Camera List"
			, onClosing: DialogClosing
			, onRefresh: function () { self.refresh(); }
		});

		BI_CustomEvent.AddListener("CameraListLoaded", CameraListLoaded);

		self.refresh();
	}
	this.refresh = function ()
	{
		if (modal_cameralistdialog)
		{
			modal_cameralistdialog.setLoadingState(true);
			cameraListLoader.LoadCameraList();
		}
	}
	var CameraListLoaded = function ()
	{
		var $cameralistcontent = $("#cameralistcontent");
		if ($cameralistcontent.length == 0 || modal_cameralistdialog == null)
			return;
		modal_cameralistdialog.setLoadingState(false);
		$cameralistcontent.empty();
		var lastCameraListResponse = cameraListLoader.GetLastResponse();
		if (!lastCameraListResponse || !lastCameraListResponse.data || lastCameraListResponse.data.length == 0)
		{
			$cameralistcontent.html("The camera list is empty! Please try reloading the page.");
			return;
		}
		// Add camera boxes
		for (var i = 0; i < lastCameraListResponse.data.length; i++)
		{
			var cam = lastCameraListResponse.data[i];
			if (!cameraListLoader.CameraIsGroupOrCycle(cam))
			{
				$cameralistcontent.append('<div class="camlist_item">'
					+ GetCameraListLabel(cam)
					+ '</div>');
			}
		}
		// Add bit rate totals, MP/s, etc.
		var totalMainBps = 0;
		var totalSubBps = 0;
		var totalMpps = 0;
		var totalMainMpps = 0;
		var totalSubMpps = 0;
		var totalSavingsFromSubStreamsMpps = 0;
		for (var i = 0; i < lastCameraListResponse.data.length; i++)
		{
			var cam = lastCameraListResponse.data[i];
			if (!cameraListLoader.CameraIsGroupOrCycle(cam) && cam.isEnabled && cam.isOnline && !cam.isNoSignal)
			{
				totalMainBps += parseInt(cam.BPS);
				var mainMpps = (parseInt(cam.width) * parseInt(cam.height) * parseFloat(cam.FPS)) / 1000000;
				var subMpps = 0;
				totalMainMpps += mainMpps;
				if (cam.BPS2 && cam.width2 && cam.height2)
				{
					totalSubBps += parseInt(cam.BPS2);
					subMpps = (parseInt(cam.width2) * parseInt(cam.height2) * parseFloat(cam.FPS2)) / 1000000;
				}
				if (subMpps)
				{
					totalSubMpps += subMpps;
					totalMpps += subMpps;
					totalSavingsFromSubStreamsMpps += mainMpps;
				}
				else
					totalMpps += mainMpps;
			}
		}
		$cameralistcontent.append(''
			+ '<div class="camlist_item_center" style="user-select: all;">'
			+ '<div style="text-align: left; display: inline-block;">'
			+ '<div class="camlist_item_heading">'
			+ 'Total Bit Rate - bits'
			+ '</div>'
			+ '<div class="camlist_item_indent">'
			+ formatBitsPerSecond((totalMainBps + totalSubBps) * 8) + " (Main: "
			+ formatBitsPerSecond(totalMainBps * 8) + ', Sub: ' + formatBitsPerSecond(totalSubBps * 8) + ")"
			+ '</div>'
			+ '<div class="camlist_item_heading">'
			+ 'Total Bit Rate - bytes'
			+ '</div>'
			+ '<div class="camlist_item_indent">'
			+ formatBytes2(totalMainBps + totalSubBps, 1) + "/s (Main: "
			+ formatBytes2(totalMainBps, 1) + '/s, Sub: ' + formatBytes2(totalSubBps, 1) + "/s)"
			+ '</div>'
			+ '<div class="camlist_item_heading">'
			+ 'Megapixels Per Second'
			+ '</div>'
			+ '<div class="camlist_item_indent">'
			+ 'Current workload: ' + totalMpps.toFixedNoE(1) + " MP/s"
			+ '<br>'
			+ 'All main streams: ' + totalMainMpps.toFixedNoE(1) + " MP/s"
			+ '<br>'
			+ 'All sub streams: ' + totalSubMpps.toFixedNoE(1) + " MP/s"
			+ '<br>'
			+ 'Sub streams are reducing the workload by: ' + totalSavingsFromSubStreamsMpps.toFixedNoE(1) + " MP/s"
			+ '</div>'
			+ '</div>'
			+ '</div>'
			+ '<div class="camlist_item_center">'
			+ '<div class="camlist_item_heading">'
			+ '<a href="javascript:UIHelp.LearnMore(\'Camera List Totals\')">(learn more)</a>'
			+ '</div>'
			+ '</div>');
		// Finish up
		$cameralistcontent.append('<div><br></div>'
			+ '<div class="camlist_item_center"><input type="button" class="simpleTextButton btnTransparent" onclick="resetNewAlertCounters()" value="reset new alert counters" title="Resets the new alert counters for all cameras" /></div>'
			+ '<div class="camlist_item_center"><input type="button" class="simpleTextButton btnTransparent" onclick="cameraListDialog.UpdateCameraThumbnails(true)" value="force refresh thumbnails" title="Thumbnails otherwise update only once per day" /></div>'
			+ '<div class="camlist_item_center"><input type="button" class="simpleTextButton btnTransparent" onclick="cameraListDialog.ShowRawCameraList()" value="view raw data" /></div>'
			+ '');
		self.UpdateCameraThumbnails();
		modal_cameralistdialog.contentChanged(!loadedOnce);
		loadedOnce = true;
	}
	var DialogClosing = function ()
	{
		BI_CustomEvent.RemoveListener("CameraListLoaded", CameraListLoaded);
		loadedOnce = false;
		modal_cameralistdialog = null;
	}
	var CloseCameraListDialog = function ()
	{
		if (modal_cameralistdialog != null)
			modal_cameralistdialog.close();
	}
	this.ShowRawCameraList = function ()
	{
		$('<div class="cameralistcontent selectable"></div>').append(ArrayToHtmlTable(cameraListLoader.GetLastResponse().data)).dialog({ title: "Raw Camera List" });
	}
	var GetCameraListLabel = function (cam)
	{
		var labelText = cam.optionDisplay + " (" + cam.optionValue + ")";
		var colorHex = BlueIrisColorToCssColor(cam.color);
		var nameColorHex = GetReadableTextColorHexForBackgroundColorHex(colorHex);

		var floatingBadges = '';
		if (cam.isPaused)
			floatingBadges += '<div class="icon16" style="color:#FFFF00;" title="paused"><svg class="icon"><use xlink:href="#svg_x5F_Stoplight"></use></svg></div>';
		if (cam.isRecording)
			floatingBadges += '<div class="icon16" style="color:#FF0000;" title="recording"><svg class="icon"><use xlink:href="#svg_x5F_Stoplight"></use></svg></div>';
		if (cam.isAlerting)
			floatingBadges += '<div class="icon16" style="color:#FF0000;" title="alerting"><svg class="icon"><use xlink:href="#svg_x5F_Alert1"></use></svg></div>';
		if (cam.isEnabled && (!cam.isOnline || cam.isNoSignal))
			floatingBadges += '<div class="icon16" style="color:#FF0000;" title="offline / no signal"><svg class="icon"><use xlink:href="#svg_x5F_Warning"></use></svg></div>';
		if (!cam.webcast)
			floatingBadges += '<div class="icon16" style="color:#FF0000;" title="webcasting disabled"><svg class="icon"><use xlink:href="#svg_x5F_HoldProfile"></use></svg></div>';
		if (cam.newalerts > 0)
			floatingBadges += '<div class="newAlerts" title="' + htmlAttributeEncode(cam.newalerts) + ' new alert' + (cam.newAlerts === 1 ? '' : 's') + '" style="color:#FF0000;"><div class="icon16"><svg class="icon"><use xlink:href="#svg_x5F_Alert1"></use></svg></div>' + htmlEncode(cam.newalerts) + '</div>';
		if (!cam.isEnabled)
			floatingBadges += '<div class="icon16" style="color:#FF0000;" title="disabled"><svg class="icon"><use xlink:href="#svg_x5F_Logout"></use></svg></div>';
		if (cam.hidden)
			floatingBadges += '<div class="icon16" style="color:#FF8000;" title="hidden"><svg class="icon noflip"><use xlink:href="#svg_mio_hide_image"></use></svg></div>';
		if (floatingBadges != '')
			floatingBadges = '<div class="floatingBadges">' + floatingBadges + '</div>';

		return '<div class="camlist_thumbbox" onclick="cameraListDialog.camListThumbClick(\'' + cam.optionValue + '\')" style="background-color: #' + colorHex + ';">'
			+ '<div class="camlist_thumb">'
			+ '<div class="camlist_thumb_aligner"></div>'
			+ '<div class="camlist_thumb_helper"><img src="" alt="" class="camlist_thumb_img" camid="' + cam.optionValue + '" isEnabled="' + (cam.isEnabled && cam.webcast ? '1' : '0') + '" aspectratio="' + (cam.width / cam.height) + '" />'
			+ '<span style="display:none;">No Image</span></div></div>'
			+ '<div class="camlist_label" style="background-color: #' + colorHex + '; color: #' + nameColorHex + ';">' + floatingBadges + htmlEncode(labelText) + '</div>'
			+ '</div>';
	}
	this.camListThumbClick = function (camId)
	{
		new CameraProperties(camId);
	}
	this.UpdateCameraThumbnails = function (overrideImgDate)
	{
		$("#cameralistcontent").find("img.camlist_thumb_img").each(function (idx, ele)
		{
			var $ele = $(ele);
			var camId = $ele.attr("camId");
			var settingsKey = "ui3_camlistthumb_" + camId;
			var imgData = settings.getItem(settingsKey);
			if (imgData != null && imgData.length > 0)
			{
				$ele.attr("src", imgData);
				$ele.css("display", "block");
				$ele.parent().parent().find(".camlist_thumb_aligner").css("height", "120px");
			}
			else
			{
				$ele.next('span').show();
			}
			if ($ele.attr('isEnabled') == '1')
			{
				var imgDate = parseInt(settings.getItem(settingsKey + "_date"));
				if (!imgDate)
					imgDate = 0;
				if (imgDate + timeBetweenCameraListThumbUpdates < new Date().getTime() || overrideImgDate)
				{
					var sizeArg = "&w=160";
					if (parseFloat($ele.attr("aspectratio")) < (160 / 120))
						sizeArg = "&h=120";
					var tmpImgSrc = currentServer.remoteBaseURL + "image/" + camId + '?time=' + new Date().getTime() + sizeArg + "&q=50" + currentServer.GetAPISessionArg("&", true);
					PersistImageFromUrl(settingsKey, tmpImgSrc, function (imgAsDataURL)
					{
						settings.setItem(settingsKey + "_date", new Date().getTime())
						$ele.next('span').hide();
						$ele.attr("src", imgAsDataURL);
						$ele.css("display", "block");
						$ele.parent().parent().find(".camlist_thumb_aligner").css("height", "120px");
					}
						, function (message)
						{
							settings.setItem(settingsKey + "_date", new Date().getTime())
						});
				}
			}
		});
	}
}
function resetNewAlertCounters()
{
	cameraListLoader.clearNewAlertsCounterOnNextLoad = true;
	cameraListLoader.LoadCameraList(function ()
	{
		statusLoader.LoadStatus();
	});
}
///////////////////////////////////////////////////////////////
// Camera Properties Dialog ///////////////////////////////////
///////////////////////////////////////////////////////////////
function CameraProperties(camId)
{
	var self = this;
	var modal_cameraPropDialog = null;
	var loadedOnce = false;
	var devTypes = { 0: "Screen capture", 2: "USB/Firewire/Analog", 4: "Network IP Camera", 5: "Broadcast from client app" };
	var $dlg = $('<div id="campropdialog" class="campropdialog"></div>');
	var $camprop = $('<div class="campropcontent dialogOptionPanel"><div style="text-align: center">Loading...</div></div>');
	$dlg.append($camprop);

	var $infoSection = $();
	var $btnPause = $();
	var $btnManrec = $();
	var $btnDisable = $();
	var initialize = function ()
	{
		modal_cameraPropDialog = $dlg.dialog({
			title: "Camera Properties"
			, overlayOpacity: 0.3
			, closeOnOverlayClick: true
			, onClosing: function ()
			{
				BI_CustomEvent.RemoveListener("CameraListLoaded", CameraListLoadedCb);
				modal_cameraPropDialog = null;
				cameraListDialog.refresh();
			}
			, onRefresh: function () { self.refresh(); }
		});
		BI_CustomEvent.AddListener("CameraListLoaded", CameraListLoadedCb);

		self.refresh();
	}
	this.refresh = function ()
	{
		if (modal_cameraPropDialog)
		{
			modal_cameraPropDialog.setLoadingState(true);

			cameraConfig.get(camId,
				function (response)
				{
					if (modal_cameraPropDialog == null)
						return;
					modal_cameraPropDialog.setLoadingState(false);

					/* Example Response
					{
					  "result": "success",
					  "session": "...",
					  "data": {
						"pause": 0,
						"push": false,
						"motion": true,
						"schedule": false,
						"ptzcycle": false,
						"ptzevents": false,
						"alerts": 0,
						"output": false,
						"setmotion": {
						  "audio_trigger": false,
						  "audio_sense": 10000,
						  "usemask": true,
						  "sense": 8650,
						  "contrast": 67,
						  "showmotion": 0,
						  "shadows": true,
						  "luminance": false,
						  "objects": true,
						  "maketime": 16,
						  "breaktime": 70
						},
						"record": 2
					  }
					}
					*/
					try
					{
						AppendInformationSection();
						AppendUI3CamSettingsSection();

						var cam = cameraListLoader.GetCameraWithId(camId);

						var collapsible = new CollapsibleSection('gs', "General Settings", modal_cameraPropDialog);
						$camprop.append(collapsible.$heading);
						var $generalSection = collapsible.$section;
						$generalSection.append(GetCamPropCheckbox("webcast|" + camId, "Webcasting Enabled", cam.webcast, camPropAdminCommandOnOffBtnClick));
						$generalSection.append(GetCamPropCheckbox("hide|" + camId, "Hidden", cam.hidden, camPropAdminCommandOnOffBtnClick));
						$generalSection.append(GetCamPropCheckbox("schedule|" + camId, "Override Global Schedule", response.data.schedule, camPropOnOffBtnClick));
						$generalSection.append(GetCamPropCheckbox("ptzcycle|" + camId, "PTZ auto-cycle", response.data.ptzcycle, camPropOnOffBtnClick));
						$generalSection.append(GetCamPropCheckbox("ptzevents|" + camId, "PTZ event schedule", response.data.ptzevents, camPropOnOffBtnClick));
						$generalSection.append(GetCamPropCheckbox("output|" + camId, "DIO output 1", response.data.output, camPropOnOffBtnClick));
						$generalSection.append(GetCamPropCheckbox("push|" + camId, "Mobile App Push", response.data.push, camPropOnOffBtnClick));
						var $selectRecord = GetSelectRow("Record:", "record",
							GetHtmlOptionElementMarkup("-1", "Only manually", response.data.record.toString())
							+ GetHtmlOptionElementMarkup("0", "When triggered", response.data.record.toString())
							+ GetHtmlOptionElementMarkup("1", "When alerted", response.data.record.toString())
							+ GetHtmlOptionElementMarkup("2", "Continuous", response.data.record.toString())
							+ GetHtmlOptionElementMarkup("3", "Periodic, each", response.data.record.toString())
							+ GetHtmlOptionElementMarkup("4", "Triggered + periodic", response.data.record.toString())
							+ GetHtmlOptionElementMarkup("5", "Continuous sub + Alerts", response.data.record.toString())
							+ GetHtmlOptionElementMarkup("6", "Continuous sub + Triggered", response.data.record.toString()));
						$generalSection.append($selectRecord);
						var $selectAlerts = GetSelectRow("Alerts:", "alerts",
							GetHtmlOptionElementMarkup("-1", "Never", response.data.alerts.toString())
							+ GetHtmlOptionElementMarkup("0", "This camera is triggered", response.data.alerts.toString())
							+ GetHtmlOptionElementMarkup("1", "Any camera in group is triggered", response.data.alerts.toString())
							+ GetHtmlOptionElementMarkup("2", "Any camera is triggered", response.data.alerts.toString()));
						$generalSection.append($selectAlerts);
						$camprop.append($generalSection);

						var collapsible = new CollapsibleSection('mt', "Motion/Trigger", modal_cameraPropDialog);
						$camprop.append(collapsible.$heading);
						var $motionSection = collapsible.$section;
						$motionSection.append(GetCamPropCheckbox("motion|" + camId, "Motion sensor", response.data.motion, camPropOnOffBtnClick));
						$motionSection.append(GetRangeSlider("setmotion.sense|" + camId, "Min. object size: "
							, response.data.setmotion.sense, 1000, 11000, 50, true, motionSenseScalingMethod
							, camPropSliderChanged));
						$motionSection.append(GetRangeSlider("setmotion.contrast|" + camId, "Min. contrast: "
							, response.data.setmotion.contrast, 12, 84, 1, false, null
							, camPropSliderChanged));
						$motionSection.append(GetRangeSlider("setmotion.maketime|" + camId, "Make time: "
							, response.data.setmotion.maketime, 0, 100, 1, false, timeScalingMethod
							, camPropSliderChanged));
						$motionSection.append(GetRangeSlider("setmotion.breaktime|" + camId, "Break time: "
							, response.data.setmotion.breaktime, 0, 9000, 10, false, timeScalingMethod
							, camPropSliderChanged));
						$motionSection.append(GetCamPropCheckbox("setmotion.objects|" + camId, "Object detection", response.data.setmotion.objects, camPropOnOffBtnClick));
						$motionSection.append(GetCamPropCheckbox("setmotion.usemask|" + camId, "Mask/hotspot", response.data.setmotion.usemask, camPropOnOffBtnClick));
						$motionSection.append(GetCamPropCheckbox("setmotion.luminance|" + camId, "Black &amp; white", response.data.setmotion.luminance, camPropOnOffBtnClick));
						$motionSection.append(GetCamPropCheckbox("setmotion.shadows|" + camId, "Cancel shadows", response.data.setmotion.shadows, camPropOnOffBtnClick));
						$motionSection.append(GetCamPropCheckbox("setmotion.audio_trigger|" + camId, "Audio trigger enabled", response.data.setmotion.audio_trigger, camPropOnOffBtnClick));
						$motionSection.append(GetRangeSlider("setmotion.audio_sense|" + camId, "Audio Sensitivity: "
							, response.data.setmotion.audio_sense, 0, 32000, 320, false, percentScalingMethod
							, camPropSliderChanged));
						var $selectHighlight = GetSelectRow("Highlight:", "setmotion.showmotion",
							GetHtmlOptionElementMarkup("0", "No", response.data.setmotion.showmotion.toString())
							+ GetHtmlOptionElementMarkup("1", "Motion", response.data.setmotion.showmotion.toString())
							+ GetHtmlOptionElementMarkup("2", "Objects", response.data.setmotion.showmotion.toString())
							+ GetHtmlOptionElementMarkup("3", "Motion + Objects", response.data.setmotion.showmotion.toString()));
						$motionSection.append($selectHighlight);
						$camprop.append($motionSection);

						var collapsible = new CollapsibleSection('jp', "Jpeg Posting", modal_cameraPropDialog);
						$camprop.append(collapsible.$heading);
						var $postSection = collapsible.$section;
						$postSection.append('<div class="dialogOption_item dialogOption_item_info">Due to limited Blue Iris API functionality, this section offers very limited configuration from Blue Iris\'s <b>Camera Properties &gt; Post</b> tab.</div>');
						$postSection.append(GetCamPropCheckbox("setpost.timed|" + camId, "Queue an image update ...", response.data.setpost.timed, camPropOnOffBtnClick));
						$postSection.append(GetNumberInput("setpost.timed_interval|" + camId, "... each (seconds): ", response.data.setpost.timed_interval, 1, 99999));
						$camprop.append($postSection);

						var collapsible = new CollapsibleSection('mro', "Manual Recording Options", modal_cameraPropDialog);
						$camprop.append(collapsible.$heading);
						var $manrecSection = collapsible.$section;
						var $btnSet1 = $('<div class="dialogOption_item dialogOption_item_center"></div>');
						$btnSet1.append(GetCameraPropertyButton("Trigger", "trigger", "largeBtnYellow", camId, "Trigger the camera, typically causing a new Alert item to be created."));
						$btnSet1.append(GetCameraPropertyButton("Snapshot", "snapshot", "largeBtnBlue", camId, "Save a snapshot within Blue Iris."));
						$btnSet1.append("<br/>");
						$btnSet1.append($btnManrec = GetCameraPropertyButton("Toggle Recording", "manrec", "largeBtnRed", camId, "Toggle manual recording mode on or off."));
						$manrecSection.append($btnSet1);
						$camprop.append($manrecSection);

						var collapsible = new CollapsibleSection('mgmt', "Camera Management", modal_cameraPropDialog);
						$camprop.append(collapsible.$heading);
						var $mgmtSection = collapsible.$section;
						var $btnSet2 = $('<div class="dialogOption_item dialogOption_item_center"></div>');
						$btnSet2.append($btnPause = GetCameraPropertyButton("Pause", "pause", "largeBtnYellow", camId, "Open a menu of Pause options. Pausing a camera is equivalent to setting the Shield icon red, but for one camera only."));
						$btnSet2.append($btnDisable = GetCameraPropertyButton("Disable", "disable", "largeBtnRed", camId, "Disable this camera instance in Blue Iris."));

						$btnSet2.append("<br/>");

						$btnSet2.append(GetCameraPropertyButton("Soft Restart", "reset", "largeBtnBlue", camId, "Restart this camera instance in Blue Iris."));
						$btnSet2.append(GetCameraPropertyButton("Hard Reboot", "reboot", "largeBtnRed", camId, "Send a hard-reboot command to the physical camera. Not guaranteed to work with all cameras."));

						$mgmtSection.append($btnSet2);
						$camprop.append($mgmtSection);

						if (cam)
						{
							SetCameraPropertyManualRecordButtonState(cam.isRecording);
							SetCameraPropertyEnableButtonState(cam.isEnabled);
						}
					}
					catch (ex)
					{
						toaster.Error(ex);
					}
					if (developerMode)
						$camprop.append('<div class="dialogOption_item dialogOption_item_center"><input type="button" class="simpleTextButton btnTransparent" onclick="Camera_OpenRaw(&quot;' + camId + '&quot;)" value="view raw data" /></div>');

					modal_cameraPropDialog.contentChanged(!loadedOnce);
					loadedOnce = true;
					CameraListLoaded(response.data);
				}
				, function (camId, adminRequired)
				{
					if (adminRequired)
					{
						modal_cameraPropDialog.setLoadingState(false);

						AppendInformationSection();
						AppendUI3CamSettingsSection();

						var $adminSection = $('<div style="margin: 12px; border: 1px solid currentColor; padding: 8px;"></div>');
						var $adminLoginBtn = $('<a role="button">Upgrade to Administrator</a>');
						$adminLoginBtn.on('click', function ()
						{
							openLoginDialog(function ()
							{
								self.refresh();
							});
						});
						$adminSection.append($adminLoginBtn);
						$adminSection.append(' for more options.');
						$camprop.append($adminSection);
					}
					else
						modal_cameraPropDialog.close();
				});
		}
	}
	var AppendInformationSection = function ()
	{
		if ($camprop.length == 0)
			return;
		$camprop.empty();

		var cam = cameraListLoader.GetCameraWithId(camId);
		if (cam)
		{
			var collapsible = new CollapsibleSection("info", "Information", modal_cameraPropDialog);
			$camprop.append(collapsible.$heading);
			$infoSection = collapsible.$section;
			UpdateInformationSection(cam);
			$camprop.append($infoSection);
		}
	}
	var AppendUI3CamSettingsSection = function ()
	{
		if ($camprop.length == 0)
			return;

		var cam = cameraListLoader.GetCameraWithId(camId);
		if (cam)
		{
			var collapsible = new CollapsibleSection('gs', "UI3 Settings", modal_cameraPropDialog);
			$camprop.append(collapsible.$heading);
			var $ui3Section = collapsible.$section;
			var camSettings = ui3CamSettings.getCamSettings(camId);
			for (var i = 0; i < ui3CamSettingsDefaults.length; i++)
			{
				var s = ui3CamSettingsDefaults[i];
				if (s.inputType === "checkbox")
				{
					$ui3Section.append(GetCamPropCheckbox(s.key, s.label, camSettings.get(s.key) === "1", camSettings.onChangeCheckbox));
				}
				else
				{
					console.log('inputType "' + s.inputType + '" is not supported in ui3CamSettingsDefaults.');
				}
			}
			$camprop.append($ui3Section);
		}
	}
	var UpdateInformationSection = function (cam)
	{
		$infoSection.empty();
		$infoSection.append(GetInfo("ID", cam.optionValue));
		$infoSection.append(GetInfo("Name", CleanUpGroupName(cam.optionDisplay)));
		if (cam.type !== 4)
		{
			var devType = devTypes[cam.type];
			if (!devType)
				devType = "Unknown (" + cam.type + ")";
			$infoSection.append(GetInfo("Device Type", devType));
		}
		var statusArr = [];
		if (cam.isEnabled)
		{
			statusArr.push("Enabled");
			if (cam.isOnline)
				statusArr.push("Online");
			else
				statusArr.push("Offline");
		}
		else
			statusArr.push("Disabled");
		if (cam.hidden)
			statusArr.push("Hidden");
		$infoSection.append(GetInfo("Status", statusArr.join(", ")));
		if (!cam.webcast)
			$infoSection.append(GetInfo("Webcasting", "Disabled"));
		$infoSection.append(GetInfo("Video", cam.width + "x" + cam.height + (cam.width2 || cam.height2 ? (" (sub: " + cam.width2 + "x" + cam.height2 + ")") : "")));
		$infoSection.append(GetInfo("Main stream", ((cam.width * cam.height) / 1000000).toFixed(1) + "MP, " + cam.FPS.toFixed(2) + " fps, " + formatBitsPerSecond(cam.BPS * 8), cam.width + "x" + cam.height));
		if (cam.width2 || cam.height2 || cam.FPS2 || cam.BPS2)
			$infoSection.append(GetInfo("Sub stream", ((cam.width2 * cam.height2) / 1000000).toFixed(1) + "MP, " + cam.FPS2.toFixed(2) + " fps, " + formatBitsPerSecond(cam.BPS2 * 8), cam.width2 + "x" + cam.height2));
		$infoSection.append(GetInfo("Audio", cam.audio ? "Yes" : "No"));
		$infoSection.append(GetInfo("Profile", cam.profile));
		$infoSection.append(GetInfo("Clips", cam.nClips));
		$infoSection.append(GetInfo("Alerts", cam.nAlerts));
		$infoSection.append(GetInfo("Triggers", cam.nTriggers));
		$infoSection.append(GetInfo("No Signal", cam.nNoSignal));
		var lastAlert = "None";
		if (cam.alertutc && cam.alertutc > 0)
		{
			var diff = Date.now() - (parseInt(cam.alertutc) * 1000);
			if (diff >= 0)
			{
				lastAlert = MsToDHMS(diff) + " ago";
			}
		}
		$infoSection.append(GetInfo("Last Alert", lastAlert));
		if (cam.ip)
		{
			var url = 'http://' + cam.ip;
			$infoSection.append('<div class="dialogOption_item dialogOption_item_info" title="This link only works if the IP address responds to HTTP requests on port 80, and the IP address is accessible on your current network.">Web Interface: <a href="' + url + '" target="_blank">'
				+ url
				+ '</a></div>');
		}
		$infoSection.append('<div class="dialogOption_item dialogOption_item_info"><a title="Opens a live H.264 stream in an efficient, cross-platform player. This method delays the stream by several seconds." href="javascript:hlsPlayer.OpenDialog(\'' + JavaScriptStringEncode(camId) + '\')">'
			+ '<svg class="icon noflip"><use xlink:href="#svg_mio_ViewStream"></use></svg>'
			+ ' Open HTTP Live Stream (HLS)</a></div>');
	}
	var CameraListLoadedCb = function ()
	{
		CameraListLoaded();
	}
	var CameraListLoaded = function (cam)
	{
		if (!cam)
		{
			cam = cameraListLoader.GetCameraWithId(camId);
			if (cam)
				UpdateInformationSection(cam);
		}
		if (!cam)
			return;
		if (cam.pause == 0)
			$btnPause.val("Pause")
		else if (cam.pause < 0)
			$btnPause.val("Paused (no limit)");
		else
			$btnPause.val("Paused (" + msToTime(cam.pause * 1000) + ")");
	}
	var GetInfo = function (label, value, tooltip)
	{
		var $info = $('<div class="dialogOption_item dialogOption_item_info"></div>');
		$info.text(label + ": " + value);
		if (tooltip)
			$info.attr("title", tooltip);
		return $info;
	}
	var GetCamPropCheckbox = function (tag, label, checked, onChange)
	{
		var $parent = $('<div class="dialogOption_item dialogOption_item_cb"></div>');
		$parent.append(GetCustomCheckbox(tag, label, checked, onChange));
		return $parent;
	}
	var GetRangeSlider = function (tag, label, value, min, max, step, invert, scalingMethod, onChange)
	{
		if (invert)
			value = (max - value) + min;

		if (!scalingMethod)
			scalingMethod = function (v) { return v; };

		var $parent = $('<div class="dialogOption_item dialogOption_item_range"></div>');
		$parent.append('<span>' + label + '</span>');

		var $valLabel = $('<span></span>');
		$valLabel.text(scalingMethod(value, min, max));
		$parent.append($valLabel);

		var $range = $('<input type="range" min="' + min + '" max="' + max + '" step="' + step + '" />');
		$range.val(value);
		$parent.append($range);

		var changeTimeout = null;
		var inputCb = function () { $valLabel.text(scalingMethod($range.val(), min, max)); };
		$range.on('input', inputCb); // Raised on every drag
		$range.on('change', function ()
		{
			inputCb();
			// Some browsers, particularly old versions, will raise the 'change' event like the 'input' event
			if (onChange)
			{
				var v = parseInt($range.val());
				if (invert)
					v = (max - v) + min;
				clearTimeout(changeTimeout);
				changeTimeout = setTimeout(function ()
				{
					onChange(tag, v);
				}, 500);
			}
		});
		return $parent;
	}
	var GetNumberInput = function (tag, label, value, min, max)
	{
		var $parent = $('<div class="dialogOption_item dialogOption_item_info"></div>');

		var $input = $('<input type="number" min="' + min + '" max="' + max + '" />');
		$input.val(value);
		$parent.append($input);

		var changeTimeout = null;
		$input.on('change', function ()
		{
			var v = parseInt($input.val());
			v = Clamp(v, min, max);
			clearTimeout(changeTimeout);
			changeTimeout = setTimeout(function ()
			{
				camPropNumberChanged(tag, v);
			}, 500);
		});

		$parent.append('<div class="dialogOption_label">' + label + '</div>');
		return $parent;
	}
	var percentScalingMethod = function (value, min, max)
	{
		value -= min;
		var range = max - min;
		if (range == 0)
			value = 0;
		else
			value = parseInt(Math.round((value / range) * 100));
		return value + "%";
	}
	var timeScalingMethod = function (value, min, max)
	{
		return value / 10 + " sec";
	}
	var motionSenseScalingMethod = function (value, min, max)
	{
		return parseInt(value / 10);
	}
	var GetCameraPropertyButton = function (text, buttonId, colorClass, camId, tooltip)
	{
		var $btn = $('<input type="button" class="largeTextButton ' + colorClass + '" value="' + text + '" />');
		if (tooltip)
			$btn.attr('title', tooltip);
		$btn.click(function ()
		{
			camPropButtonClick(camId, buttonId);
		});
		return $btn;
	}
	var camPropOnOffBtnClick = function (mysetting, buttonStateIsOn)
	{
		var parts = mysetting.split('|');
		var settingName = parts[0];
		var camId = parts[1];
		cameraConfig.set(camId, settingName, buttonStateIsOn);
	}
	var camPropAdminCommandOnOffBtnClick = function (mysetting, buttonStateIsOn)
	{
		var parts = mysetting.split('|');
		var key = parts[0];
		var camId = parts[1];
		var args;
		var restartCameraAfter = false;
		if (key === "webcast")
		{
			args = "webcast=" + (buttonStateIsOn ? "1" : "0");
			restartCameraAfter = true;
		}
		else if (key === "hide")
		{
			args = "hide=" + (buttonStateIsOn ? "1" : "0");
			restartCameraAfter = true;
		}
		else
		{
			toaster.Error('Unknown admin command key: ' + htmlEncode(key), 3000);
			return;
		}
		ExecAdminCall(camId, args,
			function (response)
			{
				if (restartCameraAfter)
					ResetCamera(camId);
				cameraListLoader.LoadCameraList();
				if (key === "webcast" && !buttonStateIsOn && iEquals(videoPlayer.Loading().cam.optionValue, camId))
					videoPlayer.LoadFirstAvailableCameraGroup();
			},
			function (jqXHR, textStatus, errorThrown)
			{
				if (jqXHR && jqXHR.status == 403)
					openLoginDialog(function () { camPropAdminCommandOnOffBtnClick(mysetting, buttonStateIsOn); });
				else
					toaster.Error("Failed to set camera configuration! (" + htmlEncode(key) + ")<br>" + jqXHR.ErrorMessageHtml, 8000);
			});
	}
	var camPropSliderChanged = function (tag, value)
	{
		var parts = tag.split('|');
		var settingName = parts[0];
		var camId = parts[1];
		cameraConfig.set(camId, settingName, value);
	}
	var camPropNumberChanged = camPropSliderChanged;
	var GetSelectRow = function (label, settingKey, options)
	{
		var $row = $('<div class="dialogOption_item dialogOption_item_ddl"></div>');
		var $select = $('<select></select>');
		$select.on('change', function ()
		{
			var selectedValue = parseInt($select.val());
			cameraConfig.set(camId, settingKey, selectedValue);
		});
		$select.append(options);
		$row.append($select);
		$row.append(GetDialogOptionLabel(label));
		return $row;
	}
	var camPropButtonClick = function (camId, button)
	{
		switch (button)
		{
			case "trigger":
				TriggerCamera(camId);
				break;
			case "snapshot":
				SaveSnapshotInBlueIris(camId);
				break;
			case "manrec":
				ManualRecordCamera(camId, $btnManrec.attr("start"), SetCameraPropertyManualRecordButtonState);
				break;
			case "reset":
				ResetCamera(camId);
				break;
			case "reboot":
				RebootCamera(camId);
				break;
			case "disable":
				cameraConfig.set(camId, "enable", $btnDisable.attr("enabled") != "1"
					, function ()
					{
						SetCameraPropertyEnableButtonState($btnDisable.attr("enabled") != "1");
					});
				break;
			case "pause":
				new CameraPauseDialog(camId);
				break;
			default:
				toaster.Error(button + " not implemented in this UI version");
				break;
		}
	}
	var SetCameraPropertyManualRecordButtonState = function (is_recording)
	{
		if (is_recording)
		{
			$btnManrec.val("Stop Recording");
			$btnManrec.attr("start", "0");
		}
		else
		{
			$btnManrec.val("Start Recording");
			$btnManrec.attr("start", "1");
		}
	}
	var SetCameraPropertyEnableButtonState = function (is_enabled)
	{
		if (is_enabled)
		{
			$btnDisable.val("Disable");
			$btnDisable.attr("enabled", "1");
			$btnDisable.removeClass("largeBtnGreen");
			$btnDisable.addClass("largeBtnRed");
		}
		else
		{
			$btnDisable.val("Enable");
			$btnDisable.attr("enabled", "0");
			$btnDisable.removeClass("largeBtnRed");
			$btnDisable.addClass("largeBtnGreen");
		}
	}

	initialize();
}
function Camera_OpenRaw(camId)
{
	cameraConfig.get(camId, function (response)
	{
		var cam = cameraListLoader.GetCameraWithId(camId);
		objectVisualizer.open({ data: cam, config: response.data }, cam.optionDisplay + " Properties (Raw)");
	}, function ()
	{
		toaster.Warning("Unable to load camera properties for " + camId);
	});
}
function UI3CamSettings()
{
	var self = this;

	var defaultSettingsMap = new FasterObjectMap();
	for (var i = 0; i < ui3CamSettingsDefaults.length; i++)
	{
		var s = ui3CamSettingsDefaults[i];
		defaultSettingsMap[s.key] = s;
	}

	var json = settings.ui3_cam_settings_map;
	var map;
	if (json)
	{
		try
		{
			map = JSON.parse(json);
		}
		catch (ex)
		{
			toaster.Error(ex);
		}
	}
	if (!map)
		map = {};
	normalizeKeysToLower(map);
	var settingsObjectMap = new FasterObjectMap();
	this.getCamSettings = function (camId)
	{
		var camIdNormalized = camId.toLowerCase();
		var camSettings = settingsObjectMap[camIdNormalized];
		if (!camSettings)
			settingsObjectMap[camIdNormalized] = camSettings = new UI3PerCamSettings(camId, map, self);
		return camSettings;
	}
	this.get = function (camId, key)
	{
		return self.getCamSettings(camId).get(key);
	}
	this.set = function (camId, key, value)
	{
		self.getCamSettings(camId).set(key, value);
	}
	this.getDefaultSetting = function (key)
	{
		return defaultSettingsMap[key];
	}
	/**
	 * Returns true if any of the camera settings objects stored within cause a [predicate] function to return true.
	 * @param {Function} predicate A function which is called with each camera's settings object.  If the predicate returns true, the [any] function returns true.
	 */
	this.any = function (predicate)
	{
		for (var camId in map)
		{
			if (map.hasOwnProperty(camId))
			{
				var camSettings = self.getCamSettings(camId);
				if (predicate(camSettings))
					return true;
			}
		}
		return false;
	}
}
function UI3PerCamSettings(camId, map, ui3CamSettings)
{
	var camIdNormalized = camId.toLowerCase();
	var self = this;

	this.getCamId = function ()
	{
		return camId;
	}
	this.get = function (key)
	{
		var camSettings = map[camIdNormalized];
		if (camSettings)
		{
			var existingValue = camSettings[key];
			if (typeof existingValue !== "undefined")
				return existingValue;
		}
		return self.getDefaultValue(key);
	}
	this.set = function (key, value)
	{
		var camSettings = map[camIdNormalized];
		if (!camSettings)
			map[camIdNormalized] = camSettings = {};
		if (camSettings[key] !== value)
		{
			camSettings[key] = value;
			var json = JSON.stringify(map);
			settings.ui3_cam_settings_map = json;
		}
	}
	this.getDefaultValue = function (key)
	{
		var s = ui3CamSettings.getDefaultSetting(key);
		if (s)
			return s.value;
		return undefined;
	}
	this.onChangeCheckbox = function (key, value)
	{
		self.set(key, value ? "1" : "0");
		CallOnChangeCallback(ui3CamSettings.getDefaultSetting(key));
	}
	var CallOnChangeCallback = function (s)
	{
		if (s && typeof s.onChange == "function")
		{
			try
			{
				s.onChange(self.get(s.key));
			}
			catch (ex)
			{
				toaster.Error(ex);
			}
		}
	}
}
///////////////////////////////////////////////////////////////
// Clip Properties Dialog /////////////////////////////////////
///////////////////////////////////////////////////////////////
function ClipProperties()
{
	var self = this;
	this.open = function (recId)
	{
		var dialog = null;
		var clipData = clipLoader.GetClipFromId(recId);

		var camName = cameraListLoader.GetCameraName(clipData.camera);

		var $dlg = $('<div class="campropdialog"></div>');
		var $camprop = $('<div class="campropcontent selectable"></div>');
		$dlg.append($camprop);

		try
		{
			var $thumb = $('<img class="clipPropertiesThumb" src="" alt="clip thumbnail"></img>');
			var thumbPath = GetThumbnailPath(clipData.recId, true);
			$thumb.attr('src', thumbPath);
			$thumb.css("border-color", "#" + clipData.colorHex);
			$camprop.append($thumb);
			$thumb.on('load', function ()
			{
				if (dialog)
					dialog.contentChanged(true, true);
			});

			$camprop.append(GetInfo("Date", GetDateStr(clipData.displayDate)));
			if (clipData.isClip)
				$camprop.append(GetInfo("Real Time", clipData.roughLength).attr("title", "Real Time: Length of real time this clip covers.\nMay be significantly longer than Play Time if created from multiple alerts."));
			$camprop.append(GetInfo("Play Time", msToTime(clipData.msec, true), true));
			if (clipData.isClip)
				$camprop.append(GetInfo("Size", clipData.fileSize));
			else
				$camprop.append(GetInfo("Zones", new AlertZonesMask(clipData.rawData.zones).toString()));

			$camprop.append(GetInfo("Resolution", clipData.res));

			if (clipData.memo)
				$camprop.append(GetInfo("Memo", clipData.memo));

			if (clipData.plate)
				$camprop.append(GetInfo("License Plate", clipData.plate));

			$camprop.append(clipIcons.getIconHtmlForClipProperties(clipData));

			$camprop.append(GetInfoEleValue("File Type", clipData.fileExtType));
			var clipInfo = clipLoader.GetDownloadClipInfo(clipData);
			if (sessionManager.HasPermission_DownloadClip(clipData))
			{
				var $link = $('<a href="javascript:void(0)">Click here to download the clip.</a>');
				$link.attr("href", clipInfo.href);
				if (clipInfo.download)
				{
					$link.text(clipInfo.download);
					$link.attr("download", clipInfo.download);
				}
				$camprop.append(GetInfoEleValue("Download " + clipData.fileExtType, $link));
				if (clipData.fileExtType === "BVR")
					$camprop.append('<div class="dialogOption_item clipprop_item_info">&nbsp; (BVR files are only playable in Blue Iris.)</div>');
			}

			if (clipInfo.originalFileHref)
			{
				// This happens if the object is an alert that has fileSize, which typically indicates a hi-res Jpeg is available.
				// Opening an alert causes UI3 to populate its fileSize field with data from the clip, so this isn't perfect.
				var $link2 = $('<a href="javascript:void(0)"></a>');
				$link2.attr("href", clipInfo.originalFileHref);
				$link2.text(clipInfo.originalFileName);
				$link2.attr("download", clipInfo.originalFileName);
				$camprop.append(GetInfoEleValue("Download Image", $link2));
			}

			if (!clipData.isSnapshot)
			{
				var $exportBtn = $('<a href="javascript:void(0)">Export a section of the clip.</a>');
				$exportBtn.on('click', function ()
				{
					videoPlayer.LoadClip(clipData);
					exportControls.Enable(videoPlayer.Loading().image.uniqueId);
					dialog.close();
				});
				$camprop.append(GetInfoEleValue("Convert/export", $exportBtn));
			}

			$camprop.append(GetInfo("File Name", clipData.rawData.file));

			if (developerMode)
			{
				$camprop.append(GetInfo("Flags", InsertSpacesInBinary(dec2bin(clipData.flags), 32)));
			}
		}
		catch (ex)
		{
			toaster.Error(ex);
		}
		if (developerMode)
			$camprop.append('<div class="dialogOption_item dialogOption_item_center"><input type="button" class="simpleTextButton btnTransparent" onclick="ClipProperties_OpenRaw(&quot;' + recId + '&quot;)" value="view raw data" /></div>');

		dialog = $dlg.dialog({
			title: htmlEncode(camName) + ' ' + (clipData.isClip ? "Clip" : "Alert") + ' Properties'
			, overlayOpacity: 0.3
			, closeOnOverlayClick: true
		});
	}
	var GetInfo = function (label, value, isHtml)
	{
		var $info = $('<div class="dialogOption_item clipprop_item_info"></div>');
		if (isHtml)
			$info.html(label + ": " + value);
		else
			$info.text(label + ": " + value);
		return $info;
	}
	var GetInfoEleValue = function (label, ele)
	{
		var $info = $('<div class="dialogOption_item clipprop_item_info"></div>');
		$info.text(label + ": ").append(ele);
		return $info;
	}
}
function ClipProperties_OpenRaw(recId)
{
	var clipData = clipLoader.GetClipFromId(recId);
	objectVisualizer.open(clipData, "Clip Properties (raw)");
}
///////////////////////////////////////////////////////////////
// Clip Download Dialog ///////////////////////////////////////
///////////////////////////////////////////////////////////////
function ClipDownloadDialog()
{
	var self = this;
	this.open = function (allSelectedClipIDs)
	{
		var $dlg = $('<div class="campropdialog"></div>');
		var $camprop = $('<div class="campropcontent"></div>');
		$dlg.append($camprop);

		$camprop.append('<div class="dialogOption_item clipprop_item_info">Click each link to download the desired clips.</div>');
		$camprop.append('<div class="dialogOption_item clipprop_item_info">Each link will disappear after it is clicked, so you can\'t accidentally download duplicates.</div>');
		var numNotLinked = 0;
		for (var i = 0; i < allSelectedClipIDs.length; i++)
		{
			var clipData = clipLoader.GetClipFromId(allSelectedClipIDs[i]);
			if (sessionManager.HasPermission_DownloadClip(clipData))
			{
				$camprop.append(GetLink(clipData));
			}
			else
				numNotLinked++;
		}
		if (numNotLinked > 0)
			$camprop.append('<div class="dialogOption_item clipprop_item_info">' + numNotLinked + ' selected clip' + (numNotLinked === 1 ? ' is' : 's are') + ' not available to download because your session has insufficient permission.</div>');

		$dlg.dialog({ title: "Download Multiple Clips" });
	}
	var GetLink = function (clipData)
	{
		var clipInfo = clipLoader.GetDownloadClipInfo(clipData);
		var $link = $('<a href=""></a>');
		$link.attr("href", clipInfo.href);
		if (clipInfo.download)
		{
			$link.text(clipInfo.download);
			$link.attr("download", clipInfo.download);
		}
		else
			$link.text("Click Here");
		$link.click(function ()
		{
			$link.remove();
			return true;
		});
		return $('<div class="dialogOption_item clipprop_item_info"></div>').append($link);
	}
}
///////////////////////////////////////////////////////////////
// Clip Export (API + Local) Configuration Panel //////////////
///////////////////////////////////////////////////////////////
/**
 * A panel providing clip export options.  Overlaps the clip list in the side bar.
 */
function ClipExportPanel()
{
	var self = this;

	var exportOptions;

	var state = { recIdArray: [], fileSizeBytes: 0, onPanelClosing: null };
	var isOpen = false;

	var $content = $('<div class="clipExportPanel dialogOptionPanel"></div>');
	var $root = $('#layoutleftExportScrollable');
	var $status = null;
	var classic_ui3_idx = -1;
	var limitedFormatOptions = false;

	function Initialize()
	{
		$root.append($content);
	}

	/**
	 * Opens the panel, hiding the clip list.
	 * @param {Array} recIdArray Array of recId.
	 * @param {Function} onPanelClosing Callback function which is called when the panel closes.
	 */
	this.Open = function (recIdArray, onPanelClosing)
	{
		state.recIdArray = recIdArray;
		state.onPanelClosing = onPanelClosing;
		state.fileSizeBytes = 0;

		isOpen = true;

		exportOptions = {
			format: parseInt(settings.ui3_clip_export_format),
			profile: parseInt(settings.ui3_clip_export_profile),
			substream: settings.ui3_clip_export_substream === "1",
			audio: settings.ui3_clip_export_withAudio === "1",
			reencode: settings.ui3_clip_export_reencode === "1",
			overlay: settings.ui3_clip_export_overlay === "1",
			timelapse: settings.ui3_clip_export_timelapse === "1",
			timelapseMultiplier: parseFloat(settings.ui3_clip_export_timelapseMultiplier),
			timelapseFps: parseFloat(settings.ui3_clip_export_timelapseFps)
		};

		ReRender();

		$("#layoutleftRecordings").hide();
		$("#layoutleftExport").show();
	}

	/**
	 * Closes the panel, showing the clip list.
	 */
	this.Close = function ()
	{
		$("#layoutleftRecordings").show();
		self.Abort();
	}

	/**
	 * Closes the panel but does not show the clip list.
	 */
	this.Abort = function ()
	{
		$("#layoutleftExport").hide();
		isOpen = false;
		if (typeof state.onPanelClosing === "function")
			state.onPanelClosing(exportOptions);
	}

	this.IsOpen = function ()
	{
		return isOpen;
	}

	var ReRender = function ()
	{
		$content.empty();
		var $closeBtn = $('<div class="panel_close" title="Cancel export">'
			+ '<div class="panel_close_icon"><svg viewbox="0 0 12 12">'
			+ '<path stroke-width="1.4" d="M 1,1 L 11,11 M 1,11 L 11,1" />'
			+ '</svg></div></div>');
		$closeBtn.on('click', self.Close);
		$content.append($closeBtn);
		var headingStart = '<span class="hideInSizeSmall">Convert/export</span><span class="showInSizeSmall">Export</span>';
		$content.append('<div class="leftBarHeading">' + headingStart + ' ' + state.recIdArray.length + ' clip' + (state.recIdArray.length === 1 ? '' : 's') + '</div>');

		$status = null;
		if (state.recIdArray.length === 1)
		{
			$status = $('<div class="dialogOption_item clipprop_item_info"></div>')
			$content.append($status);
		}

		var AddEditorField = MakeAddEditorFieldFn("Convert/export", $content, exportOptions, { compact: true });

		var formatOptions = ["AVI", "MP4 (H.264, H.265, MPEG4 only)", "Windows Media"];

		if (state.recIdArray.length === 1)
		{
			// There is only one clip, so we can expose UI3 AVI format if the browser supports it.
			var clipData = clipLoader.GetClipFromId(state.recIdArray[0]);
			var unexportableReason = clipLoader.GetUnexportableReason(clipData);
			if (unexportableReason)
			{
				// This clip is not exportable by any means other than UI3 AVI format.
				limitedFormatOptions = true;
				formatOptions = [];
				if (!exporting_clips_to_avi_supported)
				{
					/// UI3 AVI format is not supported!
					toaster.Info(unexportableReason, 15000);
					self.Close();
					return;
				}
			}
			// Add legacy export option if available, otherwise make sure it is not the default choice
			if (exporting_clips_to_avi_supported)
			{
				classic_ui3_idx = formatOptions.length;
				formatOptions.push("UI3 AVI (in-browser)");
			}
			if (exportOptions.format >= formatOptions.length)
				exportOptions.format = 1;
			if (exportOptions.format >= formatOptions.length)
				exportOptions.format = 0;
		}

		AddEditorField("Output format", "format", { type: "select", options: formatOptions, onChange: ReRender });
		if (exportOptions.format != classic_ui3_idx)
			AddEditorField("Encoder profile", "profile", { type: "select", options: ["export 0", "export 1", "export 2", "export 3"] });
		AddEditorField("Use sub stream if available", "substream", { type: "boolean", onChange: ReRender });
		AddEditorField("Include audio track", "audio", { type: "boolean", onChange: ReRender });
		if (exportOptions.format != classic_ui3_idx)
		{
			AddEditorField("Re-encode video to H.264", "reencode", { type: "boolean", onChange: ReRender });
			AddEditorField("Add the camera's current text and graphic overlay", "overlay", { type: "boolean", disabled: !exportOptions.reencode });
			AddEditorField("Time-lapse", "timelapse", { type: "boolean", onChange: ReRender, disabled: !exportOptions.reencode || exportOptions.audio });
			if (exportOptions.timelapse)
			{
				AddEditorField("Timelapse multiplier", "timelapseMultiplier", { min: 1, max: 86400, disabled: !exportOptions.reencode || exportOptions.audio || !exportOptions.timelapse });
				AddEditorField("Timelapse max output fps", "timelapseFps", { min: 1, max: 120, disabled: !exportOptions.reencode || exportOptions.audio || !exportOptions.timelapse });
			}
		}
		var $okBtn = $('<input type="button" value="Begin Export" class="exportControlsExportBtn" />');
		$okBtn.on('click', Ok_Click);
		$content.append($('<div class="dialogOption_item_info" style="text-align: center;"></div>').append($okBtn));
		var $cancelBtn = $('<input type="button" value="Cancel" class="exportControlsCancelBtn" />');
		$cancelBtn.on('click', self.Close);
		$content.append($('<div class="dialogOption_item_info" style="text-align: center;"></div>').append($cancelBtn));
	}

	var Ok_Click = function ()
	{
		if (!limitedFormatOptions)
			settings.ui3_clip_export_format = exportOptions.format;
		settings.ui3_clip_export_profile = exportOptions.profile;
		settings.ui3_clip_export_substream = exportOptions.substream ? "1" : "0";
		settings.ui3_clip_export_withAudio = exportOptions.audio ? "1" : "0";
		settings.ui3_clip_export_reencode = exportOptions.reencode ? "1" : "0";
		settings.ui3_clip_export_overlay = exportOptions.overlay ? "1" : "0";
		settings.ui3_clip_export_timelapse = exportOptions.timelapse ? "1" : "0";
		settings.ui3_clip_export_timelapseMultiplier = exportOptions.timelapseMultiplier;
		settings.ui3_clip_export_timelapseFps = exportOptions.timelapseFps;

		// Validate start and end times
		if (state.recIdArray.length === 1)
		{
			var durationMs = exportOptions.endTimeMs - exportOptions.startTimeMs;
			if (durationMs === 0)
			{
				// Both markers are in exactly the same spot.
				// Adjust end time offset 10 seconds forward.
				exportOptions.endTimeMs = Clamp(exportOptions.endTimeMs + 10000, 0, fileDuration);
				exportOptions.startTimeMs = Clamp(exportOptions.endTimeMs - 10000, 0, fileDuration);
			}
			else if (durationMs < 0)
			{
				// End marker is before Start marker.  Swap them.
				var tmp = exportOptions.startTimeMs;
				exportOptions.startTimeMs = exportOptions.endTimeMs;
				exportOptions.endTimeMs = tmp;
			}
		}

		// Time to export!
		if (state.recIdArray.length === 1 && exportOptions.format === classic_ui3_idx)
		{
			// Use classic in-browser export method
			var clipData = clipLoader.GetClipFromId(state.recIdArray[0]);
			var fileDuration = Math.max(videoPlayer.Loading().image.msec, 2);
			if (!state.fileSizeBytes)
				state.fileSizeBytes = getBytesFromBISizeStr(clipData.fileSize);
			var durationMs = exportOptions.endTimeMs - exportOptions.startTimeMs;
			var percentOfClip = durationMs / fileDuration;
			var estimatedSize = percentOfClip * state.fileSizeBytes;
			var proceedFunc = function ()
			{
				new ClientsideClipExportDialog(clipData, exportOptions.startTimeMs, exportOptions.endTimeMs, exportOptions.audio);

				self.Close();
			}
			if (estimatedSize >= 950000000)
			{
				// 1 GB is the supposed limit for AVI files produced by UI3 at this time.
				SimpleDialog.ConfirmText("Your selection size is very large, approximately " + formatBytes2(estimatedSize, 1) + ", and the export will probably fail.  Do you wish to try anyway?", proceedFunc);
			}
			else if (estimatedSize >= 450000000)
			{
				// 500-600 MB is the supposed limit for Blobs / Data URIs in some browsers.
				SimpleDialog.ConfirmText("Your selection size is very large, approximately " + formatBytes2(estimatedSize, 1) + ", and the export may fail.  Do you wish to try anyway?", proceedFunc);
			}
			else
				proceedFunc();
			return;
		}

		self.Close();

		clipLoader.Multi_Export(state.recIdArray, exportOptions, exportAPIStatusDialog.show);
	}

	this.UpdateRangeSelection = function (percentStart, percentEnd)
	{
		if (!isOpen)
			return;
		if (state.recIdArray.length === 1)
		{
			var clipData = clipLoader.GetClipFromId(state.recIdArray[0]);
			if (!clipData)
				return;

			var fileDuration = Math.max(videoPlayer.Loading().image.msec, 2);
			if (!state.fileSizeBytes) // fileSize gets changed/lost in clipData when automatically refreshing the alert list.
				state.fileSizeBytes = getBytesFromBISizeStr(clipData.fileSize);

			var percentOfClip = Math.abs(percentEnd - percentStart);
			var durationMs = percentOfClip * fileDuration;
			var estimatedSize = percentOfClip * state.fileSizeBytes;

			exportOptions.startTimeMs = percentStart * fileDuration;
			exportOptions.endTimeMs = percentEnd * fileDuration;

			$status.text(msToTime(durationMs) + ' (' + formatBytes2(estimatedSize, 1) + ')');
		}
	}

	Initialize();
}
///////////////////////////////////////////////////////////////
// Export API Status Dialog ///////////////////////////////////
///////////////////////////////////////////////////////////////
function ExportAPIStatusDialog()
{
	var self = this;

	var isActive = false;
	var dialog = null;
	var $body = null;
	var $progressBar = null;
	var $activeItem = null;
	var $itemsQueued = null;
	var $finished = null;
	var $allDone = null;
	var updateTimeout = null;
	var items = [];

	this.show = function (multi_operation_options)
	{
		stop();

		items = [];
		if (multi_operation_options && multi_operation_options.history)
			for (var i = 0; i < multi_operation_options.history.length; i++)
				items.push(multi_operation_options.history[i]);

		isActive = true;

		update();
	}
	var update = function ()
	{
		clearTimeout(updateTimeout);
		if (!isActive)
			return;
		ExecJSON({ cmd: "export", summary: true }
			, function (response)
			{
				if (!isActive)
					return;
				if (response.result === "success")
				{
					if (response.data)
					{
						if (!dialog)
						{
							$body = $('<div class="exportStatus">'
								+ '<div class="multi_operation_status_wrapper"><div class="multi_operation_status_bar"></div></div>'
								+ '<div class="active_item"></div>'
								+ '<div><span class="items_queued"></span></div>'
								+ '</div>');

							$progressBar = $body.find(".multi_operation_status_bar");
							$activeItem = $body.find(".active_item");
							$itemsQueued = $body.find(".items_queued");

							var $fullDialogLink = $('<a role="button" tabindex="0">Open Convert/Export Queue</a>');
							$fullDialogLink.on('click', exportListDialog.open);
							$body.append($('<div class="fullDialogLink"></div>').append($fullDialogLink));

							var $cbDownloadAutomatically = $('<input type="checkbox" />');
							$cbDownloadAutomatically.on('change', function ()
							{
								settings.ui3_download_exports_automatically = $cbDownloadAutomatically.is(':checked') ? "1" : "0";
							});
							if (settings.ui3_download_exports_automatically === "1")
								$cbDownloadAutomatically.attr("checked", "checked");

							var $lblAroundCb = $('<label></label>');
							$lblAroundCb.append($cbDownloadAutomatically);
							$lblAroundCb.append('<span>Download Exports Automatically</span>');
							$body.append($('<div class="downloadAutomaticallyOption"></div>').append($lblAroundCb));

							$finished = $('<div class="items_done"></div>');
							$body.append($finished);

							$allDone = $('<div class="exportStatus_allDone" style="display: none;">Finished!</div>');
							$body.append($allDone);

							dialog = $body.dialog({
								title: "Export Status"
								, onClosing: DialogClosing
							});
						}

						var queued = parseInt(response.data.queued);
						var activeArr = response.data.active;

						var unfinished = queued + activeArr.length;
						while (unfinished >= 0 && items.length > unfinished)
						{
							var last = items[0];
							items.splice(0, 1);
							AddDownloadLink(last);
						}

						if (queued === 0 && (!activeArr || !activeArr.length))
						{
							$progressBar.parent().hide();
							$activeItem.hide();
							$itemsQueued.hide();
							$allDone.show();
						}
						else
						{
							$progressBar.parent().show();
							$activeItem.show();
							$itemsQueued.show();
							$allDone.hide();

							var progressPercent = 0;
							var fileName = "";
							if (activeArr && activeArr.length > 0)
							{
								progressPercent = Clamp(parseFloat(activeArr[0].progress), 0, 100);
								fileName = GetFilenameFromPath(activeArr[0].uri);
							}

							$progressBar.css("width", progressPercent + "%");
							$activeItem.text(fileName);
							if (queued > 0)
								$itemsQueued.text(queued + " job" + (queued == 1 ? "" : "s") + " queued");
							else
								$itemsQueued.text("");
						}
						updateTimeout = setTimeout(update, 2000);
					}
					else
						error("Export status response was missing the data field.");
				}
				else
				{
					console.error(response);
					if (response.result === "fail" && response.status)
						error(response.status);
					else if (response.result === "fail" && response.data && response.data.reason)
						error(response.data.reason);
					else
						error("An unspecified error occurred updating export status.");
				}
			}
			, function (jqXHR, textStatus, errorThrown)
			{
				if (!isActive)
					return;
				error(jqXHR.ErrorMessageHtml);
			});
	}
	var error = function (errMsgHtml)
	{
		stop();
		toaster.Error(errMsgHtml, 15000);
	}
	var AddDownloadLink = function (item)
	{
		if (item && item.uri)
		{
			var exported_clip_url = currentServer.remoteBaseURL + 'clips/' + item.uri + '?dl=1' + currentServer.GetAPISessionArg("&");
			if (settings.ui3_download_exports_automatically === "1")
			{
				$body.append('<iframe width="1" height="1" frameborder="0" src="' + htmlAttributeEncode(exported_clip_url) + '" style="display:none"></iframe>');
			}
			else
			{
				var $link = $('<a href="' + htmlAttributeEncode(exported_clip_url) + '" download="' + htmlAttributeEncode(item.uri) + '">' + htmlEncode(GetFilenameFromPath(item.uri)) + '</a>');
				$link.on('click', function ()
				{
					setTimeout(function ()
					{
						$link.parent().remove();
					}, 0);
				});
				$finished.append($('<div></div>').append($link));
			}
		}
	}
	this.notifyDeletingItem = function (path)
	{
		for (var i = 0; i < items.length; i++)
		{
			if (items[i].path === path)
			{
				items.splice(i, 1);
				return;
			}
		}
	}
	var DialogClosing = function ()
	{
		isActive = false;
		clearTimeout(updateTimeout);
		dialog = null;
		$progressBar = null;
		$activeItem = null;
		$itemsQueued = null;
		$finished = null;
	}
	var stop = function ()
	{
		if (dialog)
			dialog.close();
	}
}
///////////////////////////////////////////////////////////////
// Clientside Clip Export Dialog //////////////////////////////
///////////////////////////////////////////////////////////////
function ExportListDialog()
{
	var self = this;

	var dialog = null;
	var $body = null;
	var $content = null;
	var itemMap = new FasterObjectMap();
	var loadedOnce = false;
	var refreshTimeout = null;
	var asyncThumbnailDownloader = null;

	this.open = function ()
	{
		CloseDialog();

		var $dlg = $('<div id="convertexportlistdialog"></div>');
		$content = $('<div id="convertexportlistcontent"></div>');
		$content.append('<div class="heading">Finished exports are accessible in <a href="javascript:clipLoader.LoadView(\'new.clipboard\')">Clips &gt; Clipboard</a>.<br></div>');
		$content.append('<div class="heading queuedCancelNotice">Click any "Queued" item below to cancel it.</div>');
		$body = $('<div></div>');
		$content.append($body);
		$dlg.append($content);

		dialog = $dlg.dialog({
			title: "Convert/Export Queue"
			, onClosing: DialogClosing
			, onRefresh: function () { refresh(); }
		});

		asyncThumbnailDownloader = new AsyncClipThumbnailDownloader();

		refresh();
	}
	this.notifyDeletingItem = function (pathDeleting)
	{
		var queuedItemCount = 0;
		for (var path in itemMap)
		{
			var item = itemMap[path];
			if (pathDeleting === path)
			{
				item.jqEle.remove();
				delete itemMap[path];
			}
			else if (item.status === 'queued')
				queuedItemCount++;
		}

		if (queuedItemCount > 0)
			$content.addClass("hasItemsRemaining");
		else
			$content.removeClass("hasItemsRemaining");
	}
	var refresh = function ()
	{
		if (!dialog)
			return;
		clearTimeout(refreshTimeout);
		ExecJSON({ cmd: "export" }
			, function (response)
			{
				if (response.result === "success")
				{
					if (response.data && (response.data.length === 0 || response.data.length > 0))
						ExportListLoaded(response.data);
					else
						toaster.Warning("Data missing in Convert/Export Queue response.");
					refreshTimeout = setTimeout(refresh, 4000);
				}
			}
			, function (jqXHR)
			{
				refreshTimeout = setTimeout(refresh, 10000);
			});
	}
	var ExportListLoaded = function (itemArray)
	{
		if (!dialog)
			return;
		var seenItems = new FasterObjectMap();
		var queuedItemCount = 0;
		for (var i = itemArray.length - 1; i > -1; i--)
		{
			var newItem = itemArray[i];
			if (newItem.status === "queued")
				queuedItemCount++;
			seenItems[newItem.path] = newItem;
			var oldItem = itemMap[newItem.path];
			if (oldItem)
			{
				if (oldItem.status !== newItem.status
					|| oldItem.progress !== newItem.progress
					|| oldItem.msec !== newItem.msec
					|| oldItem.utc !== newItem.utc
					|| oldItem.uri !== newItem.uri)
				{
					// Item data has changed.  Replace GUI element.
					var $newBox = GetExportItemBox(newItem);
					newItem.jqEle = $newBox;
					itemMap[newItem.path] = newItem;
					oldItem.jqEle.replaceWith($newBox);
				}
			}
			else
			{
				// Item is new. Add GUI element.
				var $newBox = GetExportItemBox(newItem);
				newItem.jqEle = $newBox;
				itemMap[newItem.path] = newItem;
				$body.prepend($newBox);
			}
		}

		// Remove items that are no longer in the payload from the server.
		for (var path in itemMap)
		{
			if (!seenItems[path])
			{
				var oldItem = itemMap[path];
				oldItem.jqEle.remove();
				delete itemMap[path];
			}
		}

		$body.find("img.thumb").each(function (idx, ele)
		{
			asyncThumbnailDownloader.Visible(ele, ele.getAttribute('path'));
		});

		if (queuedItemCount > 0)
			$content.addClass("hasItemsRemaining");
		else
			$content.removeClass("hasItemsRemaining");

		dialog.contentChanged(!loadedOnce);
		loadedOnce = true;
	}
	var GetExportItemBox = function (item)
	{
		var loadingImg = "ui3/LoadingImage.png" + currentServer.GetLocalSessionArg("?");
		var thumbStyle = item.status === "done" ? '' : ' style="opacity: 0.5;"';
		var thumb = '<div class="camlist_thumb">'
			+ '<div class="camlist_thumb_aligner"></div>'
			+ '<div class="camlist_thumb_helper">'
			+ '<img src="' + loadingImg + '" alt="thumbnail" class="thumb" path="' + item.path + '"' + thumbStyle + ' />'
			+ '</div>'
			+ '</div>';

		var startDate = new Date(parseInt(item.utc) + GetServerTimeOffset());
		var tsHtml = '<div class="timestamp">' + GetDateDisplayStr(startDate) + '<br>' + GetTimeStr(startDate) + '</div>';
		var link = '<div>' + thumb + '<div class="camlist_label">' + tsHtml + htmlEncode(GetFilenameFromPath(item.uri)) + '</div></div>';
		var noLinkOverlay = '';
		var onClick = null;
		var clipsize = item.filesize ? ('<div class="clipdur clipsize">' + htmlEncode(item.filesize) + '</div>') : '';
		var clipdur = item.msec ? ('<div class="clipdur">' + msToTime(parseInt(item.msec)) + '</div>') : '';

		var addClasses = [];
		var labelUpper = item.status;
		var labelLower = null;
		var spinnerHtml = '<div style="width:50px;height:50px;margin: 35px 55px" class="spinOverlay spin1s">'
			+ '<svg class="icon noflip stroke"><use xlink:href="#svg_stroke_loading_circle"></use></svg>'
			+ '</div>';
		if (item.status === "queued")
		{
			labelUpper = "Queued";
			onClick = function ()
			{
				DeleteItemFromConvertExportQueue_WithConfirmation(item.path);
			};
			addClasses.push("queued");
		}
		else if (item.status === "active")
		{
			labelUpper = "Exporting";
			labelLower = parseInt(item.progress) + "%";
			addClasses.push("active");
		}
		else if (item.status === "error")
		{
			// This may not be able to appear anymore because Blue Iris does not show "done" status anymore.
			labelUpper = "Error<br><br>Click for Details";
			onClick = function ()
			{
				SimpleDialog.Text('This clip failed to export due to an error:\\n\\n' + item.error)
			};
			spinnerHtml = '';
			addClasses.push("error");
		}
		labelUpper = '<div class="noLinkOverlay">' + labelUpper + '</div>';
		if (labelLower)
			labelLower = '<div class="noLinkOverlay lower">' + labelLower + '</div>';

		noLinkOverlay = spinnerHtml + labelUpper + labelLower;

		var $newBox = $('<div class="exportlist_item camlist_thumbbox">'
			+ link
			+ clipsize
			+ clipdur
			+ noLinkOverlay
			+ '</div>');
		if (onClick)
		{
			$newBox.on('click', onClick);
			$newBox.addClass("linked");
		}
		for (var i = 0; i < addClasses.length; i++)
		{
			$newBox.addClass(addClasses[i]);
		}
		return $newBox;
	}
	var DialogClosing = function ()
	{
		clearTimeout(refreshTimeout);
		if (asyncThumbnailDownloader)
			asyncThumbnailDownloader.Stop();
		asyncThumbnailDownloader = null;
		loadedOnce = false;
		dialog = null;
		$body = null;
		itemMap = {};
	}
	var CloseDialog = function ()
	{
		if (dialog)
			dialog.close();
	}
}
function DeleteItemFromConvertExportQueue_WithConfirmation(path, onDeleteCallback)
{
	SimpleDialog.ConfirmText("Are you sure you want to cancel the selected Convert/Export item?", function ()
	{
		DeleteItemFromConvertExportQueue(path, onDeleteCallback);
	});
}
function DeleteItemFromConvertExportQueue(path, onDeleteCallback)
{
	var args = { cmd: "export", path: path, delete: true };

	var failCallback = function (msg)
	{
		toaster.Error("Export delete command failed: " + msg, 15000);
		if (typeof onFailure === "function")
			onFailure(msg);
	};

	exportAPIStatusDialog.notifyDeletingItem(path);
	exportListDialog.notifyDeletingItem(path);

	ExecJSON(args, function (response)
	{
		if (response.result === "success")
		{
			if (typeof onDeleteCallback === "function")
				onDeleteCallback();
		}
		else
		{
			console.log("export delete command failed:", response);
			if (response.result === "fail" && response.status)
				failCallback(response.status);
			else
				failCallback("No reason was given for the failure.");
		}
	}
		, function (jqXHR, textStatus, errorThrown)
		{
			console.log("export delete command failed:", jqXHR.ErrorMessageHtml);
			failCallback(jqXHR.ErrorMessageHtml);
		});
}
///////////////////////////////////////////////////////////////
// Clientside Clip Export Dialog //////////////////////////////
///////////////////////////////////////////////////////////////
/** This dialog controls the actual export operation and lacks a normal close button. */
function ClientsideClipExportDialog(clipData, startTimeMs, endTimeMs, includeAudio)
{
	var self = this;
	var durationMs = endTimeMs - startTimeMs;
	var userHasDownloadedAVI = false;

	var fileTypeInfo = clipLoader.GetClipFileTypeInfo(clipData);
	var fastExport = fileTypeInfo.isBVR && fileTypeInfo.isH264;

	var $dlg = $('<div class="activeExportDialog"></div>');
	var $content = $('<div class="campropcontent"></div>');
	$dlg.append($content);

	var $exportTypeRow = $('<div class="dialogOption_item clipprop_item_info">Export Type: </div>');
	var $exportType = $('<span></span>');
	$exportTypeRow.append($exportType);
	$exportTypeRow.append('<a href="javascript:UIHelp.LearnMore(\'Export Types\')">(learn more)</a>');
	$content.append($exportTypeRow);

	var $linkLabel = $('<div class="dialogOption_item clipprop_item_info">Your AVI file is being generated.</div>');
	$content.append($linkLabel);

	var $status = $('<div class="dialogOption_item clipprop_item_info">Starting export...</div>');
	$content.append($status);

	var $closeBtn = $('<input type="button" value="Cancel" style="display:block;margin:40px auto 0px auto;" iscancel="1" />');
	$content.append($closeBtn);

	var updateExportType = function ()
	{
		if (fastExport)
			$exportType.text("Native ");
		else
			$exportType.text("Slow Transcode ");
	}
	updateExportType();

	var progressUpdate = function (state, message)
	{
		$status.text(message);
	}
	var exportComplete = function (dataUri, finishedSuccessfully, firstFrameTimeUTC)
	{
		if (dataUri)
		{
			$status.after(GetLink(dataUri, firstFrameTimeUTC));
			$status.remove();
			if (finishedSuccessfully)
				$linkLabel.text("Click the link below to save!");
			else
				$linkLabel.text("The export did not complete, but we got some video data.  Click the link below to save it!");
		}
		else
		{
			$linkLabel.text("Error!");
			userHasDownloadedAVI = true;
		}

		$closeBtn.val("Close");
		$closeBtn.attr('iscancel', '0');
	}

	var GetLink = function (dataUri, firstFrameTimeUTC)
	{
		var $link = $('<a href=""></a>');
		$link.attr("href", dataUri);
		var camName = cameraListLoader.GetCameraName(clipData.camera);
		var date = firstFrameTimeUTC ? GetPaddedDateStr(new Date(firstFrameTimeUTC)) : GetPaddedDateStr(clipData.displayDate);
		var fileName = camName + " " + FormatFileName(date) + ".avi";
		$link.text(fileName);
		$link.attr("download", fileName);
		$link.on('click', function ()
		{
			userHasDownloadedAVI = true;
			return true;
		});
		return $('<div class="dialogOption_item clipprop_item_info"></div>').append($link);
	}

	var dialog = $dlg.dialog({
		title: "Export in Progress"
		, includeCloseButton: false
		, overlayOpacity: 0.5
		, onClosing: function ()
		{
			if (exportStreamer)
				exportStreamer.Dispose();
		}
	});
	$closeBtn.on('click', function ()
	{
		if ($closeBtn.attr('iscancel') == '1')
		{
			SimpleDialog.ConfirmText("Are you sure you wish to cancel this export?", function ()
			{
				dialog.close();
			});
		}
		else if (!userHasDownloadedAVI)
		{
			SimpleDialog.ConfirmHtml("You have not yet saved the exported AVI.<br>If you close this dialog now, the exported AVI file will be lost.<br><br>Are you sure you wish to close?", function ()
			{
				dialog.close();
			});
		}
		else
			dialog.close();
	});

	var exportStreamer = new ClipExportStreamer(clipData.path, startTimeMs, durationMs, !fastExport, includeAudio, progressUpdate, exportComplete, enableRecordingOffsetWorkaround);
}
///////////////////////////////////////////////////////////////
// Clientside Clip Export Streaming ///////////////////////////
///////////////////////////////////////////////////////////////
var ui3ClipIsExporting = false; // This flag helps the H.264 player module not end the fetch stream if the browser tab visibility changes.
var enableRecordingOffsetWorkaround = true;
function ClipExportStreamer(path, startTimeMs, durationMs, useTranscodeMethod, includeAudio, progressUpdate, exportCompleteCb, recordingOffsetWorkaround)
{
	var self = this;
	var aviEncoder = null;
	var dataUri = null;
	var totalVideoFrames = 0;
	var totalExportedTimeMs = 0;
	var firstFrameTimeUTC = 0;

	this.Dispose = function ()
	{
		ui3ClipIsExporting = false;
		if (dataUri)
		{
			setTimeout(function ()
			{
				URL.revokeObjectURL(dataUri);
			}, 1000);
		}
		aviEncoder = null;
		exportCompleteCb = null;
		if (safeFetch.IsActive())
		{
			safeFetch.CloseStream();
			console.log("Closed stream");
		}
	}
	var headerCallback = function (headers)
	{
	}
	var acceptFrame = function (frame, streams)
	{
		if (!exportCompleteCb)
			return;
		if (!aviEncoder)
		{
			toaster.Error("Streaming protocol error: Stream metadata was not received by ClipExportStreamer before the first frame!");
			return;
		}
		if (frame.isVideo)
		{
			aviEncoder.AddVideoFrame(frame.frameData, frame.isKeyframe());
			totalVideoFrames++;
			totalExportedTimeMs = frame.time;
			if (firstFrameTimeUTC === 0)
				firstFrameTimeUTC = frame.utc;
			if (frame.time >= durationMs)
			{
				HandleAviReady(true, -1);
				safeFetch.CloseStream();
			}
			else
			{
				var percent = Math.round((frame.time / durationMs) * 100);
				progressUpdate(2, "Export progress: " + percent + "%");
			}
		}
		else if (frame.isAudio)
			aviEncoder.AddAudioFrame(frame.frameData, frame.isKeyframe());
	}
	var acceptStatusBlock = function (status)
	{
	}
	var streamInfoCallback = function (bitmapInfoHeader, waveFormatEx)
	{
		if (!exportCompleteCb)
			return;
		aviEncoder = new AVIEncoder("H264", bitmapInfoHeader, waveFormatEx ? "ulaw" : null, waveFormatEx);
		progressUpdate(1, "Export progress: 0%");
	}
	var StreamEnded = function (message, wasJpeg, wasAppTriggered, videoFinishedStreaming, responseError, isSessionLoss)
	{
		if (!exportCompleteCb)
			return;
		if (videoFinishedStreaming)
			HandleAviReady(true, 0);
		else
		{
			if (aviEncoder && totalVideoFrames > 0)
			{
				// At least one frame was received before the failure.  Provide the AVI but make it known that we didn't get all we expected.
				HandleAviReady(false, -1);
			}
			else
			{
				console.error("Export Failed: " + message, responseError);
				if (responseError)
					HandleExportFailure("Export failed because the fetch video response was \"" + responseError + "\"");
				else
					HandleExportFailure("Export failed because the data stream ended prematurely!");
				exportCompleteCb = null;
			}
		}
	}
	var HandleAviReady = function (finishedSuccessfully, frameCountOffset)
	{
		if (exportCompleteCb)
		{
			if (finishedSuccessfully)
				progressUpdate(3, "Export progress: 100%");
			if (aviEncoder)
			{
				var fps;
				if (totalVideoFrames <= 0)
					HandleExportFailure("Export failed because no video frames were received.");
				else if (totalVideoFrames == 1 || totalExportedTimeMs <= 0)
					fps = 1;
				else
				{
					// frameCountOffset accounts for the fact that sometimes our totalExportedTimeMs value will not include the duration of the last frame.  In theory this results in a more accurate FPS calculation.
					fps = ((totalVideoFrames + frameCountOffset) / totalExportedTimeMs) * 1000;
				}
				exportCompleteCb(Uint8ArrayToDataURI(aviEncoder.FinishAndGetUint8Array(fps)), finishedSuccessfully, firstFrameTimeUTC);
			}
			else
				HandleExportFailure("Export failed because no stream metadata was received.");
			exportCompleteCb = null;
		}
	}
	var HandleExportFailure = function (reason)
	{
		progressUpdate(3, reason);
		toaster.Error(reason, 30000);
		if (exportCompleteCb)
			exportCompleteCb();
	}
	// Begin the clip export.

	if (typeof exportCompleteCb !== "function")
	{
		toaster.Error("API Error: no exportCompleteCb callback was provided to ClipExportStreamer");
		return;
	}

	ui3ClipIsExporting = true;
	videoPlayer.Playback_Pause();

	var beginRecording = function ()
	{
		var recordArg = useTranscodeMethod ? "" : "&record=1";
		var audioArg = "&audio=" + (includeAudio ? "1" : "0");
		var videoUrl = currentServer.remoteBaseURL + "file/clips/" + path + currentServer.GetAPISessionArg("?", true) + recordArg + audioArg + "&speed=100&stream=0&extend=2&time=" + startTimeMs;
		safeFetch.OpenStream(videoUrl, headerCallback, acceptFrame, acceptStatusBlock, streamInfoCallback, StreamEnded, {});
	}
	if (recordingOffsetWorkaround)
		DoExportRecordingOffsetWorkaround(beginRecording, path, startTimeMs);
	else
		beginRecording();
}
/**
 * As of BI 4.7.4.4, seeking with "time" does not work if record=1, so this method performs a low-cost seek without the record argument and then the playback object will already be at the correct position, or close enough.
 */
function DoExportRecordingOffsetWorkaround(callbackMethod, path, startTimeMs)
{
	var anyCallback = function ()
	{
		if (callbackMethod)
		{
			safeFetch.CloseStream();
			callbackMethod();
			callbackMethod = null;
		}
	}
	var videoUrl = currentServer.remoteBaseURL + "file/clips/" + path + currentServer.GetAPISessionArg("?", true) + "&speed=0&audio=0&stream=0&extend=2&w=160&q=10&time=" + startTimeMs;
	safeFetch.OpenStream(videoUrl, anyCallback, anyCallback, anyCallback, anyCallback, anyCallback, {});
}
///////////////////////////////////////////////////////////////
// Camera Pause Dialog ////////////////////////////////////////
///////////////////////////////////////////////////////////////
function CameraPauseDialog(camId)
{
	var self = this;
	var $status = $();
	var initialize = function ()
	{
		var camData = cameraListLoader.GetCameraWithId(camId);
		var $dlg = $('<div class="campausedialog"></div>');
		var $camprop = $('<div class="campropcontent"></div>');
		$dlg.append($camprop);

		$status = $('<div class="dialogOption_item clipprop_item_info"></div>');
		$camprop.append($status);
		$camprop.append(GetButton(camId, "Off (unpause)", 0));
		$camprop.append(GetButton(camId, "Add 30 seconds", 1));
		$camprop.append(GetButton(camId, "Add 5 minutes", 2));
		$camprop.append(GetButton(camId, "Add 30 minutes", 3));
		$camprop.append(GetButton(camId, "Add 1 hour", 4));
		$camprop.append(GetButton(camId, "Add 2 hours", 5));
		$camprop.append(GetButton(camId, "Add 3 hours", 6));
		$camprop.append(GetButton(camId, "Add 5 hours", 7));
		$camprop.append(GetButton(camId, "Add 10 hours", 8));
		$camprop.append(GetButton(camId, "Add 24 hours", 9));
		$camprop.append(GetButton(camId, "Indefinitely", -1));

		CameraListLoaded();
		BI_CustomEvent.AddListener("CameraListLoaded", CameraListLoadedCb);

		$dlg.dialog({
			title: "Pause " + camData.optionDisplay
			, overlayOpacity: 0.3
			, onClosing: function ()
			{
				BI_CustomEvent.RemoveListener("CameraListLoaded", CameraListLoadedCb);
			}
		});

	}
	var GetButton = function (camId, label, pauseValue)
	{
		var $row = $('<div class="dialogOption_item clipprop_item_info"></div>');
		var $btn = $('<input type="button" class="smallBtnYellow" value="' + label + '" />');
		$btn.click(function () { DoPause(camId, pauseValue); });
		$row.append($btn);
		return $row;
	}
	var DoPause = function (camId, pauseValue)
	{
		if (!sessionManager.IsAdministratorSession(camId))
			openLoginDialog(function () { DoPause(camId, pauseValue); });
		else
			cameraConfig.set(camId, "pause", pauseValue, function (response)
			{
				CameraListLoaded(response.data);
			});
	}
	var CameraListLoadedCb = function ()
	{
		CameraListLoaded();
	}
	var CameraListLoaded = function (cam)
	{
		if (!cam)
			cam = cameraListLoader.GetCameraWithId(camId);
		if (!cam)
			return;
		if (cam.pause == 0)
			$status.text("Not paused")
		else if (cam.pause < 0)
			$status.text("Paused indefinitely");
		else
			$status.text("Paused for next " + msToTime(cam.pause * 1000));
	}

	initialize();
}
///////////////////////////////////////////////////////////////
// Object/JSON Visualize //////////////////////////////////////
///////////////////////////////////////////////////////////////
var objectVisualizer = new (function ObjectVisualizer()
{
	var self = this;
	var isLoaded = false;
	var isLoading = false;

	this.open = function (obj, title)
	{
		if (!isLoaded)
		{
			if (isLoading)
				setTimeout(function () { self.open(obj, title); }, 500);
			else
			{
				isLoading = true;
				$('<style type="text/css">@import url("ui3/libs-src/jsonview/jsonview.min.css?v=' + combined_version + currentServer.GetLocalSessionArg("&") + '")</style>').appendTo("head");
				$.getScript("ui3/libs-src/jsonview/jsonview.min.js?v=" + combined_version + currentServer.GetLocalSessionArg("&"))
					.done(function ()
					{
						isLoaded = true;
						self.open(obj, title);
					})
					.fail(function (jqXHR, settings, exception)
					{
						isLoaded = isLoading = false;
						toaster.Error("Unable to load jsonview library.<br>" + jqXHR.ErrorMessageHtml, 5000);
					});
			}
			return;
		}
		var $root = $('<div class="ObjectVisualizer"></div>');
		var $viewer = $('<div class="selectable" style="word-wrap: break-word; border:1px solid #000000; background-color: #FFFFFF; color: #000000; margin: 10px; padding: 10px;"></div>');
		$root.append($viewer);
		if (obj)
		{
			if (typeof obj == "object")
				$viewer.JSONView(obj);
			else
				$viewer.find(".selectable").text(obj);
		}
		else
			$viewer.find(".selectable").text("null");
		if (!title)
			title = "Object Visualizer";
		$root.dialog({ title: title });
	}
})();
///////////////////////////////////////////////////////////////
// Soft-Reset Camera //////////////////////////////////////////
///////////////////////////////////////////////////////////////
function ResetCamera(camId)
{
	var camName = cameraListLoader.GetCameraName(camId);
	cameraConfig.set(camId, "reset", true, function (response)
	{
		toaster.Success("Camera " + camName + " is soft-restarting");
	}, function ()
	{
		toaster.Error("Camera " + camName + " could not be soft-restarted");
	});
}
///////////////////////////////////////////////////////////////
// Hard-Reboot Camera /////////////////////////////////////////
///////////////////////////////////////////////////////////////
function RebootCamera(camId)
{
	var camName = cameraListLoader.GetCameraName(camId);
	cameraConfig.set(camId, "reboot", true, function (response)
	{
		toaster.Success("Camera " + camName + " hard-reboot command sent");
	}, function ()
	{
		toaster.Error("Camera " + camName + " hard-reboot command could not be sent");
	});
}
///////////////////////////////////////////////////////////////
// Manual Recording Start / Stop //////////////////////////////
///////////////////////////////////////////////////////////////
function ManualRecordCamera(camId, start, successCallback)
{
	if (start == "1")
		start = true;
	else if (start == "0")
		start = false;
	else
	{
		start = false;
		var camData = cameraListLoader.GetCameraWithId(camId);
		if (camData != null)
			start = !camData.isRecording;
	}
	cameraConfig.set(camId, "manrec", start, function ()
	{
		setTimeout(function ()
		{
			cameraListLoader.LoadCameraList(function (camList)
			{
				var camData = cameraListLoader.GetCameraWithId(camId);
				if (camData != null)
				{
					toaster.Info(camData.optionDisplay + " " + (camData.isRecording ? '<span style="font-weight: bold;color:Red; background-color: #000000;">IS RECORDING</span>' : '<span style="font-weight: bold;color:Green; background-color: #000000;">IS NOT RECORDING</span>'));
					if (successCallback)
						successCallback(camData.isRecording);
				}
			});
		}, 250);
	}, function ()
	{
		toaster.Error("Failed to toggle manual recording for " + camId);
	});
}
function LoadDynamicManualRecordingButtonState(camData)
{
	$("#manRecBtnLabel").text("Toggle Recording");
	$("#manRecBtnLabel").removeAttr("start");

	if (cameraListLoader.CameraIsAlone(camData))
	{
		UpdateManRecButtonState(camData.optionValue);
		cameraListLoader.LoadCameraList(function (camList)
		{
			UpdateManRecButtonState(camData.optionValue);
		});
	}
}
function UpdateManRecButtonState(camId)
{
	var camData = cameraListLoader.GetCameraWithId(camId);
	if (camData != null)
	{
		if (camData.isRecording)
		{
			$("#manRecBtnLabel").text("Stop Recording");
			$("#manRecBtnLabel").attr("start", "0");
			return true;
		}
		else
		{
			$("#manRecBtnLabel").text("Start Recording");
			$("#manRecBtnLabel").attr("start", "1");
			return false;
		}
	}
}
///////////////////////////////////////////////////////////////
// Trigger Camera /////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function TriggerCamera(camId)
{
	ExecJSON({ cmd: "trigger", camera: camId }, function (response)
	{
		if (typeof response.result != "undefined" && response.result == "fail")
		{
			openLoginDialog(function () { TriggerCamera(camId); });
			return;
		}
		if (response.result == "success")
			toaster.Success("Triggered camera " + camId);
		else
			toaster.Error("Failed to trigger camera " + camId);
	}, function ()
	{
		toaster.Error("Failed to contact Blue Iris server to trigger camera " + camId);
	});
}
///////////////////////////////////////////////////////////////
// Change Clip Flags State ////////////////////////////////////
///////////////////////////////////////////////////////////////
function UpdateClipFlags(path, flags, mask, cbSuccess, cbFailure)
{
	if (typeof mask === "function")
		toaster.Error("The UpdateClipFlags API has changed. 3rd argument is now mask.");
	ExecJSON({ cmd: "update", path: path, flags: flags, mask: mask }, function (response)
	{
		if (typeof response.result != "undefined" && response.result == "fail")
		{
			if (typeof cbFailure == "function")
				cbFailure();
			else
				toaster.Warning("Failed to update clip properties");
			openLoginDialog(function () { UpdateClipFlags(path, flags, mask, cbSuccess, cbFailure); });
			return;
		}
		else
		{
			if (typeof cbSuccess == "function")
				cbSuccess();
			else
				toaster.Success("Clip properties updated");
		}
	}, function ()
	{
		toaster.Warning("Failed to update clip properties because of a connection failure");
		if (typeof cbFailure == "function")
			cbFailure();
	});
}
///////////////////////////////////////////////////////////////
// Change Clip/Alert Memo /////////////////////////////////////
///////////////////////////////////////////////////////////////
function AskUserForUpdatedMemo(clipData)
{
	var $input = $('<input type="text" />');
	var memo = clipData.memo;
	if (!memo)
		memo = "";
	$input.val(memo);
	var $question = $('<div style="margin:7px 3px 20px 3px;text-align:center;">Memo text:<br><br></div>');
	$question.append($input);
	AskYesNo($question, function ()
	{
		var newMemo = $input.val();
		ChangeMemo(clipData.alertPath, newMemo, function ()
		{
			var newClipData = JSON.parse(JSON.stringify(clipData));
			newClipData.memo = newMemo;
			clipLoader.UpdateExistingClipData(clipData, newClipData);
			toaster.Success("Memo changed");
		});
	}, null, toaster.Error, "Save", "Cancel", "Edit Memo");
}
function ChangeMemo(path, memo, cbSuccess, cbFailure)
{
	ExecJSON({ cmd: "update", path: path, memo: memo }, function (response)
	{
		if (typeof response.result != "undefined" && response.result == "fail")
		{
			if (typeof cbFailure == "function")
				cbFailure();
			else
				toaster.Warning("Failed to change memo");
			openLoginDialog(function () { ChangeMemo(path, memo, cbSuccess, cbFailure); });
			return;
		}
		else
		{
			if (typeof cbSuccess == "function")
				cbSuccess();
			else
				toaster.Success("Memo changed");
		}
	}, function ()
	{
		toaster.Warning("Failed to change memo because of a connection failure");
		if (typeof cbFailure == "function")
			cbFailure();
	});
}
///////////////////////////////////////////////////////////////
// Delete Alert/Clip //////////////////////////////////////////
///////////////////////////////////////////////////////////////
function DeleteAlert(path, isClip, cbSuccess, cbFailure)
{
	var clipOrAlert = isClip ? "clip" : "alert";
	ExecJSON({ cmd: "del" + clipOrAlert, path: path }, function (response)
	{
		if (typeof response.result != "undefined" && response.result == "fail")
		{
			var isAdmin = cameraListLoader.hasCameraAdminPrivilege() || sessionManager.IsAdministratorSession();
			var msg = "Failed to delete " + clipOrAlert + ".<br/>";
			if (response.data && response.data.reason)
				msg += htmlEncode(response.data.reason);
			else
				msg += (isAdmin ? ("The " + clipOrAlert + " may be still recording.") : ("You need administrator permission to delete " + clipOrAlert + "s."));
			if (typeof cbFailure == "function")
				cbFailure(msg);
			else
				toaster.Warning(msg, 10000);
			if (!isAdmin)
				openLoginDialog(function () { DeleteAlert(path, isClip, cbSuccess, cbFailure); });
			return;
		}
		else
		{
			if (typeof cbSuccess == "function")
				cbSuccess();
			else
				toaster.Success(clipOrAlert + " deleted");
		}
	}, function ()
	{
		var msg = 'Unable to contact Blue Iris server.';
		if (typeof cbFailure == "function")
			cbFailure(msg);
		else
			toaster.Error(msg, 3000);
	});
}
///////////////////////////////////////////////////////////////
// Custom Checkboxes //////////////////////////////////////////
///////////////////////////////////////////////////////////////
var customCheckboxId = 0;
function GetCustomCheckbox(tag, label, checked, onChange, disabled)
{
	var myId = customCheckboxId++;
	var $wrapper = $('<div class="customCheckboxWrapper"></div>');
	var $cb = $('<input id="ccb_' + myId + '" type="checkbox" class="sliderCb" ' + (checked ? 'checked="checked" ' : '') + '/>');
	if (disabled)
	{
		$cb.attr("disabled", "disabled");
		$wrapper.addClass("disabled");
	}
	else
		$cb.on('change', function () { onChange(tag, $(this).is(":checked")); });
	$wrapper.append($cb);
	$wrapper.append('<label for="ccb_' + myId + '"><span class="ui"></span>' + label + '<div class="customCheckboxSpacer"></div></label>');
	return $wrapper;
}
///////////////////////////////////////////////////////////////
// Server Control Dialog //////////////////////////////////////
///////////////////////////////////////////////////////////////
function ServerControl()
{
	var self = this;
	var modal_servercontroldialog = null;
	this.open = function ()
	{
		CloseSysConfigDialog();
		modal_servercontroldialog = $('<div id="sysconfigdialog" class="dialogOptionPanel"><div id="sysconfigcontent"></div></div>')
			.dialog({
				title: "Server Control"
				, overlayOpacity: 0.3
				, closeOnOverlayClick: true
				, onClosing: function () { modal_servercontroldialog = null; }
			});
		var $sysconfig = $("#sysconfigcontent");
		if ($sysconfig.length == 0)
			return;
		$sysconfig.html('<div style="text-align: center">Loading...</div>');
		ExecJSON({ cmd: "sysconfig" }, function (response)
		{
			if (typeof response.result == "undefined")
			{
				CloseSysConfigDialog();
				toaster.Error("Unexpected response when requesting system configuration from server.");
				return;
			}
			if (response.result == "fail")
			{
				CloseSysConfigDialog();
				openLoginDialog(self.open);
				return;
			}
			var $sysconfig = $("#sysconfigcontent");
			if ($sysconfig.length == 0)
				return;
			$sysconfig.empty();
			AddInstallUpdateButton($sysconfig);
			$sysconfig.append(GetCustomCheckbox('archive', "Clip Web Archival (FTP)", response.data.archive, SetSysConfig));
			$sysconfig.append(GetCustomCheckbox('schedule', "Global Schedule", response.data.schedule, SetSysConfig));
			$sysconfig.append(UIFormField({
				inputType: "number",
				value: response.data.manrecsec,
				label: "Manual recording limit (seconds)",
				tag: "manrecsec",
				onChange: function (e, tag, $input)
				{
					SetSysConfig(tag, $input.val());
				}
			}));
			AddRebootServerButton($sysconfig);

			if (modal_servercontroldialog !== null)
				modal_servercontroldialog.contentChanged(true);
		}, function ()
		{
			toaster.Error('Unable to contact Blue Iris server.', 3000);
			CloseSysConfigDialog();
		});
	}
	var CloseSysConfigDialog = function ()
	{
		if (modal_servercontroldialog != null)
			modal_servercontroldialog.close();
	}
	var SetSysConfig = function (key, value)
	{
		var args = { cmd: "sysconfig" };
		if (key == "archive")
			args.archive = value;
		else if (key == "schedule")
			args.schedule = value;
		else if (key == "manrecsec")
			args.manrecsec = parseInt(value);
		else
		{
			toaster.Error('Unknown system configuration key: ' + htmlEncode(key), 3000);
			return;
		}
		ExecJSON(args, function (response)
		{
			if (typeof response.result == "undefined")
			{
				toaster.Error("Unexpected response when attempting to set system configuration on server.");
				return;
			}
			if (response.result == "fail")
			{
				openLoginDialog(function () { SetSysConfig(key, value); });
				return;
			}
			toaster.Success('Set configuration field "' + htmlEncode(key) + '" = "' + htmlEncode(value) + '"');
		}, function ()
		{
			toaster.Error('Unable to contact Blue Iris server to set ' + htmlEncode(key) + ' value.', 3000);
		});
	}
	var AddRebootServerButton = function ($sysconfig)
	{
		var $row = $('<div class="dialogOption_item dialogOption_item_info"></div>');
		var $input = $('<input type="button" value="Reboot" />');
		$input.on('click', function ()
		{
			SimpleDialog.ConfirmText("This function will cause the computer running Blue Iris to be restarted.\n\nDo you wish to proceed?\n\n(confirmation 1/2)", function ()
			{
				SimpleDialog.ConfirmHtml("If the remote computer fails to reboot for any reason, you may be unable to access the system.  Please remember that Windows Updates may slow down or interfere with the reboot procedure.<br><br>Click <b>Yes</b> to send the restart command now.<br><br>(confirmation 2/2)", function ()
				{
					console.log("Sending REBOOT command to Blue Iris");

					ExecJSON({ cmd: "status", reboot: true }, function (response)
					{
						console.log("REBOOT command was sent successfully");
						SimpleDialog.Text("The server was instructed to reboot.\n\n"
							+ "Blue Iris should stop responding shortly.\n\n"
							+ "Windows may take longer than usual to reboot if there were any updates ready to install.");
						toaster.Success("The server was instructed to reboot.", 60000);
					}, function (jqXHR, textStatus, errorThrown)
					{
						toaster.Error("An error occurred. The server may not have received the reboot command.<br>" + jqXHR.ErrorMessageHtml);
					});
				});
			});
		});
		$row.append($input);
		$row.append(GetDialogOptionLabel("Reboot Server Computer"));
		$sysconfig.append($row);
	}
	var AddInstallUpdateButton = function ($sysconfig)
	{
		if (sessionManager.UpdateAvailable() && sessionManager.HasPermission_InstallUpdate())
		{
			var sessionResponse = sessionManager.GetLastResponse();
			var version = sessionResponse.data.newversion;
			var $row = $('<div class="dialogOption_item dialogOption_item_info"></div>');
			var $input = $('<input type="button" value="Update" />');
			$input.on('click', function ()
			{
				SimpleDialog.ConfirmText("This function will cause Blue Iris to download and install version " + version + ".\n\nIt is recommended to have remote desktop access available in case the update fails and Blue Iris becomes unreachable.\n\nDo you wish to proceed?"
					, function ()
					{
						toaster.Warning("Update Starting.  Blue Iris should restart soon.", 60000);
						CloseSysConfigDialog();
						statusLoader.InstallUpdate(version);
					}
					, function ()
					{
						toaster.Info("Update Canceled");
					}
					, { yesText: "Begin Update", noText: "Cancel" });
			});
			$row.append($input);
			$row.append(GetDialogOptionLabel("Install Update " + version));
			$sysconfig.append($row);

			$row = $('<div class="dialogOption_item dialogOption_item_info"></div>');
			$row.append(GetDialogOptionLabel('<a href="javascript:uiSettingsPanel.open(\'Update Available\')">Configure "Update Available Notice"</a>'));
			$sysconfig.append($row);
		}
	}
}
///////////////////////////////////////////////////////////////
// List Dialog ////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function ListDialog(options_arg)
{
	var self = this;
	var dialog = null;
	var loadedOnce = false;
	var $content;

	var listSettings = $.extend({
		title: "Unnamed List Dialog"
		, json_command: ""
		, headers: []
		, get_row: function (data) { return ""; }
	}, options_arg);

	this.open = function ()
	{
		CloseListDialog();
		var $dlg = $('<div class="listDialog"></div>');
		$content = $('<div class="listDialogContent"><div style="text-align: center; margin-top: 20px;">Loading...</div></div>');
		$dlg.append($content);
		dialog = $dlg.dialog({
			title: listSettings.title
			, onRefresh: function () { refreshListDialog(); }
			, onClosing: function ()
			{
				dialog = null;
				loadedOnce = false;
			}
		});
		refreshListDialog();
	}
	var refreshListDialog = function ()
	{
		dialog.setLoadingState(true);
		ExecJSON({ cmd: listSettings.json_command }, function (response)
		{
			if (dialog == null)
				return;
			dialog.setLoadingState(false);
			if (typeof response.result == "undefined")
			{
				CloseListDialog();
				toaster.Error("Unexpected response when requesting " + listSettings.title + " from server.");
				return;
			}
			if (response.result == "fail")
			{
				CloseListDialog();
				openLoginDialog(self.open);
				return;
			}
			if (!$content || $content.length == 0)
				return;
			var sb = [];
			sb.push('<table><thead><tr>');
			for (var i = 0; i < listSettings.headers.length; i++)
			{
				sb.push('<th>');
				sb.push(listSettings.headers[i]);
				sb.push('</th>');
			}
			sb.push('</tr></thead><tbody></tbody></table>');
			$content.html(sb.join(""));
			var $tbody = $content.find("tbody");
			if (response.data)
			{
				for (var i = 0; i < response.data.length; i++)
					$tbody.append(listSettings.get_row(response.data[i]));
			}
			else
				$tbody.append('<tr><td colspan="' + listSettings.headers.length + '" style="text-align: center; padding: 16px 0px;">This list is empty.</td></tr>');
			dialog.contentChanged(!loadedOnce);
			loadedOnce = true;
		}, function ()
		{
			toaster.Error('Unable to contact Blue Iris server.', 3000);
			CloseListDialog();
		});
	}
	var CloseListDialog = function ()
	{
		if (dialog != null)
			dialog.close();
	}
}
function GetLevelImageMarkup(level)
{
	if (level == 0)
		return GetSysLogIcon("#svg_x5F_Info", "#2748CC");
	if (level == 1)
		return GetSysLogIcon("#svg_mio_warning", "#FFFF00");
	if (level == 2)
		return GetSysLogIcon("#svg_x5F_Error", "#DF1751");
	if (level == 3)
		return GetSysLogIcon("#svg_x5F_Alert1", "#FF6000");
	if (level == 4)
		return GetSysLogIcon("#svg_x5F_OK", "#63C35B");
	if (level == 5)
		return GetSysLogIcon("#svg_mio_help", "#FFFF00");
	if (level == 6)
		return GetSysLogIcon("#svg_x5F_Stoplight", "#2748CC");
	if (level == 10)
		return GetSysLogIcon("#svg_x5F_User", "#FFFFFF");
	return '<span title="Log level ' + level + ' is unknown">' + level + '</span>';
}
function GetSysLogIcon(iconId, color)
{
	var classes = ["icon"];
	if (iconId.indexOf("_x5F_") < 0)
		classes.push("noflip");
	return '<div class="logicon" style="color: ' + color + '"><svg class="' + classes.join(' ') + '"><use xlink:href="' + iconId + '"></use></svg></div>';
}
///////////////////////////////////////////////////////////////
// System Log /////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var systemLog = new ListDialog({
	title: "System Log"
	, json_command: "log"
	, headers: ["", "#", "Time", "Object", "Message"]
	, get_row: function (data)
	{
		var date = GetServerDate(new Date(data.date * 1000));
		var dateStr = GetDateStr(date);
		var level = GetLevelImageMarkup(data.level);
		var count = typeof data.count == "undefined" ? "" : parseInt(data.count);
		return '<tr><td class="levelcolumn">' + level + '</td><td class="centercolumn" style="font-weight: bold;">' + count + '</td><td>' + dateStr + '</td><td style="font-weight: bold;">' + htmlEncode(data.obj) + '</td><td>' + htmlEncode(data.msg) + '</td></tr>';
	}
});
///////////////////////////////////////////////////////////////
// User List //////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var userList = new ListDialog({
	title: "User List"
	, json_command: "users"
	, headers: ["Online", "#", "Last Connected", "User", "Object", "Message"]
	, get_row: function (data)
	{
		var date = GetServerDate(new Date(data.date * 1000));
		var dateStr = data.date == 0 ? "never" : GetDateStr(date);
		var level = GetLevelImageMarkup(data.level);
		var count = typeof data.count == "undefined" ? "" : parseInt(data.count);
		return '<tr>'
			+ '<td>' + (data.isOnline ? "Online" : "") + '</td>'
			+ '<td class="centercolumn" style="font-weight: bold;">' + count + '</td>'
			+ '<td>' + dateStr + '</td>'
			+ '<td>' + htmlEncode(data.obj) + '</td>'
			+ '<td style="font-weight: bold;">' + htmlEncode(data.object) + '</td>'
			+ '<td>' + htmlEncode(data.msg) + '</td>'
			+ '</tr>';
	}
});
///////////////////////////////////////////////////////////////
// Devices List ///////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var deviceList = new ListDialog({
	title: "Device List"
	, json_command: "devices"
	, headers: ["#", "Last Connected", "Name", "Type", "Inside", "Push"]
	, get_row: function (data)
	{
		var date = GetServerDate(new Date(data.date * 1000));
		var dateStr = data.date == 0 ? "never" : GetDateStr(date);
		var level = GetLevelImageMarkup(data.level);
		var count = typeof data.count == "undefined" ? "" : parseInt(data.count);
		return '<tr>'
			+ '<td class="centercolumn" style="font-weight: bold;">' + count + '</td>'
			+ '<td>' + dateStr + '</td>'
			+ '<td title="ID: ' + htmlEncode(data.id) + '">' + data.name + '</td>'
			+ '<td>' + data.type + '</td>'
			+ '<td>' + data.inside + '</td>'
			+ '<td>' + (data.push == 0 ? "" : "Enabled") + '</td>'
			+ '</tr>';
	}
});
///////////////////////////////////////////////////////////////
// Save Snapshot in Blue Iris /////////////////////////////////
///////////////////////////////////////////////////////////////
function SaveSnapshotInBlueIris(camId)
{
	if (currentServer.isLoggingOut)
		return;
	$.ajax(currentServer.remoteBaseURL + "cam/" + camId + "/pos=100" + currentServer.GetAPISessionArg("?", true))
		.done(function (response)
		{
			if (response.indexOf(">Ok<") != -1)
				toaster.Success("Blue Iris saved a snapshot for camera " + camId);
			else
				toaster.Error("Blue Iris did not save a snapshot for camera " + camId);
		})
		.fail(function (jqXHR, textStatus, errorThrown)
		{
			if (jqXHR && jqXHR.status == 403)
				openLoginDialog(function () { SaveSnapshotInBlueIris(camId); });
			else
				toaster.Error("Blue Iris did not save a snapshot for camera " + camId);
		});
}
///////////////////////////////////////////////////////////////
// About Dialog ///////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var aboutDialog = null;
function openAboutDialog()
{
	closeAboutDialog();
	aboutDialog = $("#aboutDialog").dialog({ title: "About UI3" });
}
function closeAboutDialog()
{
	if (aboutDialog != null)
	{
		aboutDialog.close();
		aboutDialog = null;
	}
}
///////////////////////////////////////////////////////////////
// Login Dialog ///////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var loginModal = null;
var adminLoginCallbackSuccess = null;
function openLoginDialog(callbackSuccess)
{
	closeLoginDialog();
	if (settings.bi_rememberMe == "1")
	{
		$('#loginDialog input[type="text"][varname="user"]').val(Base64.decode(settings.bi_username));
		$('#loginDialog input[type="password"][varname="pass"]').val(Base64.decode(settings.bi_password));
		$("#cbRememberMe").prop("checked", true);
	}
	else
		$("#cbRememberMe").prop("checked", false);
	adminLoginCallbackSuccess = callbackSuccess;
	loginModal = $("#loginDialog").dialog(
		{
			overlayOpacity: 0.3
			, closeOnOverlayClick: true
			, title: "Upgrade Session"
			, onClosing: function ()
			{
				adminLoginCallbackSuccess = null;
			}
		});
}
function closeLoginDialog()
{
	adminLoginCallbackSuccess = null;
	if (loginModal != null)
	{
		loginModal.close();
		loginModal = null;
	}
}
///////////////////////////////////////////////////////////////
// Audio Decoder: mu-law //////////////////////////////////////
///////////////////////////////////////////////////////////////
var muLawDecoder = new MuLawDecoder();
function MuLawDecoder()
{
	var self = this;
	var decHelper = [-32124, -31100, -30076, -29052, -28028, -27004, -25980, -24956,
	-23932, -22908, -21884, -20860, -19836, -18812, -17788, -16764,
	-15996, -15484, -14972, -14460, -13948, -13436, -12924, -12412,
	-11900, -11388, -10876, -10364, -9852, -9340, -8828, -8316,
	-7932, -7676, -7420, -7164, -6908, -6652, -6396, -6140,
	-5884, -5628, -5372, -5116, -4860, -4604, -4348, -4092,
	-3900, -3772, -3644, -3516, -3388, -3260, -3132, -3004,
	-2876, -2748, -2620, -2492, -2364, -2236, -2108, -1980,
	-1884, -1820, -1756, -1692, -1628, -1564, -1500, -1436,
	-1372, -1308, -1244, -1180, -1116, -1052, -988, -924,
	-876, -844, -812, -780, -748, -716, -684, -652,
	-620, -588, -556, -524, -492, -460, -428, -396,
	-372, -356, -340, -324, -308, -292, -276, -260,
	-244, -228, -212, -196, -180, -164, -148, -132,
	-120, -112, -104, -96, -88, -80, -72, -64,
	-56, -48, -40, -32, -24, -16, -8, -1,
		32124, 31100, 30076, 29052, 28028, 27004, 25980, 24956,
		23932, 22908, 21884, 20860, 19836, 18812, 17788, 16764,
		15996, 15484, 14972, 14460, 13948, 13436, 12924, 12412,
		11900, 11388, 10876, 10364, 9852, 9340, 8828, 8316,
		7932, 7676, 7420, 7164, 6908, 6652, 6396, 6140,
		5884, 5628, 5372, 5116, 4860, 4604, 4348, 4092,
		3900, 3772, 3644, 3516, 3388, 3260, 3132, 3004,
		2876, 2748, 2620, 2492, 2364, 2236, 2108, 1980,
		1884, 1820, 1756, 1692, 1628, 1564, 1500, 1436,
		1372, 1308, 1244, 1180, 1116, 1052, 988, 924,
		876, 844, 812, 780, 748, 716, 684, 652,
		620, 588, 556, 524, 492, 460, 428, 396,
		372, 356, 340, 324, 308, 292, 276, 260,
		244, 228, 212, 196, 180, 164, 148, 132,
		120, 112, 104, 96, 88, 80, 72, 64,
		56, 48, 40, 32, 24, 16, 8, 0
	];
	this.DecodeUint8ArrayToInt16Array = function (encoded)
	{
		var decoded = new Int16Array(encoded.length);
		for (var i = 0; i < encoded.length; i++)
			decoded[i] = decHelper[encoded[i]];
		return decoded;
	}
	this.DecodeUint8ArrayToFloat32Array = function (encoded)
	{
		var decoded = new Float32Array(encoded.length);
		for (var i = 0; i < encoded.length; i++)
			decoded[i] = decHelper[encoded[i]] / 32768;
		return decoded;
	}
}
///////////////////////////////////////////////////////////////
// Audio Filter (silences crackle at frame boundaries) ////////
// Not recommended because not all audio waveforms are ////////
// centered on zero.                                   ////////
///////////////////////////////////////////////////////////////
function AudioEdgeFilter(buffer)
{
	var tmp = new Float32Array(1);

	buffer.copyFromChannel(tmp, 0, 0);

	var wasPositive = (tmp[0] > 0);

	for (var i = 0; i < buffer.length; i += 1)
	{
		buffer.copyFromChannel(tmp, 0, i);

		if ((wasPositive && tmp[0] < 0) || (!wasPositive && tmp[0] > 0))
			break;

		tmp[0] = 0;
		buffer.copyToChannel(tmp, 0, i);
	}

	buffer.copyFromChannel(tmp, 0, buffer.length - 1);

	wasPositive = (tmp[0] > 0);

	for (var i = buffer.length - 1; i > 0; i -= 1)
	{
		buffer.copyFromChannel(tmp, 0, i);

		if ((wasPositive && tmp[0] < 0) || (!wasPositive && tmp[0] > 0))
			break;

		tmp[0] = 0;
		buffer.copyToChannel(tmp, 0, i);
	}

	return buffer;
}
function AudioEdgeFilterRaw(audio32)
{
	var wasPositive = (audio32[0] > 0);

	for (var i = 0; i < audio32.length; i += 1)
	{
		if ((wasPositive && audio32[i] < 0) || (!wasPositive && audio32[i] > 0))
			break;

		audio32[i] = 0;
	}

	wasPositive = (audio32[audio32.length - 1] > 0);

	for (var i = audio32.length - 1; i > 0; i -= 1)
	{
		if ((wasPositive && audio32[i] < 0) || (!wasPositive && audio32[i] > 0))
			break;

		audio32[i] = 0;
	}

	return audio32;
}
///////////////////////////////////////////////////////////////
// Audio Playback /////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var debug_doEdgeFilter = false;
function PcmAudioPlayer()
{
	var self = this;
	var supported = audio_playback_supported;
	var AudioContext;
	if (supported)
		AudioContext = window.AudioContext || window.webkitAudioContext;
	else
		AudioContext = FakeAudioContext_Dummy;


	var context;
	var volumeController;
	var currentVolume = -1; // 0 to 1
	var nextTime = 0; // This is the playback time in seconds at which we run out (or ran out) of audio.
	var audioStopTimeout = null;
	var suppressAudioVolumeSave = false;
	var suspended = true;
	var pendingBufferQueue = new Queue();
	//context.onstatechange = function ()
	//{
	//	switch (context.state)
	//	{
	//		case "suspended":
	//			break;
	//		case "running":
	//			break;
	//		case "closed":
	//			volumeIconHelper.setColorIdle();
	//			break;
	//	}
	//};
	var decoderState = { lastReceivedAudioIndex: -1, nextPlayAudioIndex: 0, buffers: [], startTime: -1 };
	this.DecodeAndPlayAudioData = function (audioData, sampleRate, setAudioCodecString)
	{
		if (!supported)
			return;
		if (sampleRate !== context.sampleRate)
			NewContext(sampleRate);

		// detect decoder stall
		if (decoderState.nextPlayAudioIndex <= 1 && decoderState.lastReceivedAudioIndex > 20 && decoderState.startTime > -1 && performance.now() - decoderState.startTime > 5000)
		{
			console.log("FLAC decoder stall detected.", decoderState);
			DoAudioDecodingFallback();
			return;
		}

		if (decoderState.startTime === -1)
			decoderState.startTime = performance.now();
		decoderState.lastReceivedAudioIndex++;
		var myIndex = decoderState.lastReceivedAudioIndex;
		context.decodeAudioData(audioData.buffer, function (audioBuffer)
		{
			setAudioCodecString("flac " + audioBuffer.numberOfChannels + "ch " + sampleRate + "hz");
			decoderState.buffers.push({ buffer: audioBuffer, index: myIndex });
			PlayDecodedAudio(setAudioCodecString);
		}, function ()
		{
			console.log("Audio decode FAIL", arguments);
			setAudioCodecString("flac (cannot decode)");
			DoAudioDecodingFallback();
		});
	}
	var PlayDecodedAudio = function ()
	{
		// Plays the decoded audio buffers in the correct order.
		for (var i = 0; i < decoderState.buffers.length; i++)
		{
			if (decoderState.buffers[i].index === decoderState.nextPlayAudioIndex)
			{
				decoderState.nextPlayAudioIndex++;
				var audioBuffer = decoderState.buffers[i].buffer;
				decoderState.buffers.splice(i, 1);
				var channels = [];
				for (var i = 0; i < audioBuffer.numberOfChannels; i++)
					channels.push(audioBuffer.getChannelData(i));
				self.AcceptBuffer(channels, audioBuffer.sampleRate);
				PlayDecodedAudio(); // Recursively call in case the next buffer was already added out of order.
				return;
			}
		}
	}
	/**
	 * Queues a Float32Array of raw audio data (range -1.0 to 1.0) for playback.
	 * @param {Array} audio32 Array of audio channels.  Each channel is a Float32Array of raw audio data (range -1.0 to 1.0)
	 * @param {Number} sampleRate Sample rate (hz)
	 */
	this.AcceptBuffer = function (audio32, sampleRate)
	{
		if (!supported)
			return;
		if (sampleRate !== context.sampleRate)
			NewContext(sampleRate);
		if (suspended)
		{
			suspended = false;
			context.resume();
		}
		if (debug_doEdgeFilter)
			AudioEdgeFilterRaw(audio32[0]);

		var buffer = context.createBuffer(audio32.length, audio32[0].length, sampleRate);
		for (var i = 0; i < audio32.length; i++)
			buffer.copyToChannel(audio32[i], i);

		var bufferSource = context.createBufferSource();
		bufferSource.buffer = buffer;
		bufferSource.connect(volumeController);
		volumeController.connect(context.destination);

		var currentTime = context.currentTime;
		if (nextTime == 0)
			nextTime = currentTime + 0.2; // Add the initial audio delay in seconds.

		var duration = bufferSource.buffer.duration;
		var offset = currentTime - nextTime;
		var maxDelayMs = Clamp(parseInt(settings.ui3_audio_buffer_ms) / 1000, 0, 5000);
		if (offset > 0)
		{
			// This frame is late. Play it immediately.
			nextTime = currentTime;
			//console.log("Audio frame is LATE by", offset);
			offset = 0;
		}
		else if (offset < -1 * maxDelayMs)
		{
			CheckUserInputRequirement();
			// We have received so many frames that we are queued at least 700ms ahead. Drop this frame.
			if (managedUserInputRequirement)
				console.log("Audio buffer is overfull at " + currentTime.toFixed(6) + " with " + Math.abs(offset.toFixed(6)) + " seconds queued. Dropping audio frame to keep delay from growing too high.");
			return;
		}
		pendingBufferQueue.enqueue(bufferSource);
		bufferSource.onended = DequeueBufferSource;
		volumeIconHelper.setEnabled(true);
		volumeIconHelper.setColorPlaying();

		bufferSource.start(nextTime);
		//bufferSource.stop(nextTime + duration);
		nextTime += duration;

		if (ui3AudioVisualizer)
			ui3AudioVisualizer.AcceptBuffer(audio32, sampleRate, currentTime, nextTime, duration);
	}
	var DequeueBufferSource = function ()
	{
		pendingBufferQueue.dequeue();
		if (pendingBufferQueue.isEmpty() && !videoPlayer.Playback_IsPaused())
			volumeIconHelper.setColorLoading();
	}
	this.GetBufferedMs = function ()
	{
		if (!supported)
			return 0;
		var buffered = nextTime - context.currentTime;
		if (buffered < 0)
			return 0;
		return buffered * 1000;
	}
	this.GetCurrentTime = function ()
	{
		if (!supported)
			return 0;
		return context.currentTime;
	}
	this.SuppressAudioVolumeSave = function ()
	{
		return suppressAudioVolumeSave;
	}
	this.SetAudioVolumeFromSettings = function ()
	{
		if (!supported)
			return;
		var effectiveVolume = settings.ui3_audioMute == "1" ? 0 : parseFloat(settings.ui3_audioVolume);
		suppressAudioVolumeSave = true;
		setTimeout(function () { suppressAudioVolumeSave = false; }, 0);
		volumeSlider.setPosition(effectiveVolume);
	}
	this.SetVolume = function (newVolume)
	{
		if (!supported)
			return;
		clearMuteStopTimeout();
		currentVolume = newVolume;
		newVolume = Clamp(newVolume, 0, 1);
		volumeController.gain.value = newVolume * newVolume; // Don't use setValueAtTime method because it has issues (UI3-v17 + Chrome 66 was affected)
		volumeIconHelper.setIconForVolume(newVolume);
		if (newVolume == 0)
			audioStopTimeout = setTimeout(toggleAudioPlayback, 1000);
		else
			toggleAudioPlayback();
		if (mqttClient)
			mqttClient.volumeChanged();
	}
	this.GetVolume = function ()
	{
		if (!supported)
			return 0;
		return Clamp(Math.sqrt(volumeController.gain.value), 0, 1);
	}
	var clearMuteStopTimeout = function ()
	{
		if (audioStopTimeout != null)
		{
			clearTimeout(audioStopTimeout);
			audioStopTimeout = null;
		}
	}
	var toggleAudioPlayback = function ()
	{
		if (!supported)
			return;
		clearMuteStopTimeout();
		if (videoPlayer)
			videoPlayer.AudioToggleNotify(self.AudioEnabled());
	}
	var startedUserInputRequirement = false;
	var managedUserInputRequirement = false;
	var userInputRequirementEvents = ['keydown', 'click', 'mousedown'];
	var CheckUserInputRequirement = function ()
	{
		if (!startedUserInputRequirement && context.currentTime === 0 && !suspended && context.state === "suspended")
		{
			startedUserInputRequirement = true;
			if (settings.ui3_web_audio_autoplay_warning === "1")
				inputRequiredOverlay.Show("audio player", HandleUserInputRequirement);
			for (var i = 0; i < userInputRequirementEvents.length; i++)
				document.addEventListener(userInputRequirementEvents[i], HandleUserInputRequirement);
			volumeIconHelper.setColorError();
		}
	}
	var HandleUserInputRequirement = function (e)
	{
		managedUserInputRequirement = true;
		for (var i = 0; i < userInputRequirementEvents.length; i++)
			document.removeEventListener(userInputRequirementEvents[i], HandleUserInputRequirement);
		self.Reset();
	}
	this.AudioEnabled = function ()
	{
		return self.GetVolume() > 0;
	}
	this.Reset = function ()
	{
		if (!supported)
			return;
		if (!suspended)
		{
			suspended = true;
			context.suspend();
			nextTime = 0;
		}
		while (!pendingBufferQueue.isEmpty())
		{
			var buffer = pendingBufferQueue.dequeue();
			buffer.onended = function () { }
			buffer.stop();
		}
	}
	var NewContext = function (sampleRate)
	{
		if (context)
		{
			context.suspend();
			if (typeof context.close === "function")
			{
				try
				{
					context.close();
				}
				catch (ex)
				{
					toaster.Error(ex);
				}
			}
		}
		// We must specify the correct sample rate during AudioContext construction, 
		// or else FLAC will be resampled by the decoder in such a way that it 
		// introduces a static pop after every audio buffer.
		if (sampleRate)
			context = new AudioContext({ sampleRate: sampleRate });
		else
			context = new AudioContext();
		context.suspend();
		volumeController = context.createGain();
		if (currentVolume >= 0)
			self.SetVolume(currentVolume);
		suspended = true;
		if (ui3AudioVisualizer)
			ui3AudioVisualizer.Reset();
	}
	NewContext();
}
/** This object provides a fake implementation to prevent script errors when a real implementation is unavailable. */
function FakeAudioContext_Dummy()
{
	this.isFakeAudioContext = true;
	this.createGain = function () { }
	this.onstatechange = null;
	this.createBuffer = function () { }
	this.createBufferSource = function () { }
	this.destination = null;
	this.currentTime = 0;
	this.suspend = function () { }
	this.resume = function () { }
	this.close = function () { }
}
function CameraAudioMuteToggle()
{
	settings.ui3_audioMute = (settings.ui3_audioMute == "1" ? "0" : "1");
	if (settings.ui3_audioMute === "0" && parseFloat(settings.ui3_audioVolume) === 0)
		settings.ui3_audioVolume = 1;
	if (pcmPlayer)
		pcmPlayer.SetAudioVolumeFromSettings();
}
function DoAudioDecodingFallback()
{
	var fallbackCodec = GetAudioCodecOptions()[0];
	if (settings.ui3_audio_codec !== fallbackCodec)
	{
		toaster.Warning('"' + settings.ui3_audio_codec + '" audio decoder failed. Changing audio codec setting to "' + fallbackCodec + '".', 10000);
		settings.ui3_audio_codec = fallbackCodec;
		OnChange_ui3_audio_codec();
	}
}
///////////////////////////////////////////////////////////////
// Volume Icon Helper /////////////////////////////////////////
///////////////////////////////////////////////////////////////
var volumeIconHelper = new (function ()
{
	var self = this;
	var isEnabled = false;
	var iconName = "off";

	this.setColorError = function () { setColorClass("error"); }
	this.setColorLoading = function () { setColorClass("loading"); }
	this.setColorPlaying = function () { setColorClass("playing"); }
	this.setColorIdle = function () { setColorClass(""); }
	var setColorClass = function (c)
	{
		$("#volumeBar").removeClass("error loading playing");
		if (c)
			$("#volumeBar").addClass(c);
	}

	this.setEnabled = function (enabled)
	{
		var changed = (isEnabled && !enabled) || (!isEnabled && enabled);
		isEnabled = enabled;
		if (enabled)
			$("#volumeBar").attr("title", "");
		else
			$("#volumeBar").attr("title", "Audio is not available from the current stream");

		if (changed)
			ApplyIcon();
	}
	this.setIconForVolume = function (volume)
	{
		if (volume > 0.5)
			self.setIcon("up");
		else if (volume > 0)
			self.setIcon("down");
		else
			self.setIcon("mute");
	}
	this.setIcon = function (newIconName)
	{
		if (newIconName != "up" && newIconName != "down" && newIconName != "mute" && newIconName != "off")
			newIconName = "mute";
		if (iconName != newIconName)
		{
			iconName = newIconName;
			ApplyIcon();
		}
	}
	var ApplyIcon = function ()
	{
		var $icon = $("#pcVolume").removeClass("up down mute off");
		if (isEnabled)
			$icon.addClass(iconName);
		else
			$icon.addClass("off");
	}
	ApplyIcon();
})();
///////////////////////////////////////////////////////////////
// Save Snapshot Button ///////////////////////////////////////
///////////////////////////////////////////////////////////////
function saveSnapshot(btnSelector)
{
	if (typeof btnSelector == "undefined")
		btnSelector = "#save_snapshot_btn";
	var camName = cameraListLoader.GetCameraName(videoPlayer.Loading().image.id);
	var date = GetPaddedDateStr(new Date(videoPlayer.lastFrameUtc + GetServerTimeOffset()), true);
	date = FormatFileName(date);
	var fileName = camName + " " + date + ".jpg";
	$(btnSelector).attr("href", videoPlayer.GetLastSnapshotUrl());
	if (settings.ui3_download_snapshot_method === "Local (JPEG)" || settings.ui3_download_snapshot_method === "Local (PNG)")
	{
		var playerEle = videoPlayer.GetPlayerElement();
		if (playerEle)
		{
			if (playerEle.tagName === "VIDEO" || (playerEle.tagName === "CANVAS" && videoPlayer.CurrentPlayerModuleName() === "jpeg"))
			{
				var contentType = "image/jpeg";
				if (settings.ui3_download_snapshot_method === "Local (PNG)")
				{
					contentType = "image/png";
					fileName = camName + " " + date + ".png";
				}
				$(btnSelector).attr("href", GetSnapshotDataUri(playerEle, contentType));
			}
		}
	}
	$(btnSelector).attr("download", fileName);
	setTimeout(function ()
	{
		$(btnSelector).attr("download", "temp.jpg");
		$(btnSelector).attr("href", "javascript:void(0)");
	}, 0);
}
///////////////////////////////////////////////////////////////
// HLS H264 Streaming with Clappr /////////////////////////////
///////////////////////////////////////////////////////////////
function HLSPlayer()
{
	var self = this;
	var initStarted = false; // True if script loading has begun.
	var initFinished = false; // True if script loading has succeeded or failed.
	var initSucceeded = false; // True if script loading has succeeded.
	var dialog = null;
	var container = null;
	var playerObj = null;
	var hlsPlayerLastCamId = "";
	var Initialize = function (camId)
	{
		if (initStarted)
			return;
		$(window).resize(resizeHlsPlayer);
		initStarted = true;
		$.getScript("clappr/clappr.min.js?v=" + combined_version + currentServer.GetLocalSessionArg("&"))
			.done(function (script, textStatus)
			{
				initFinished = true;
				initSucceeded = true;
				BeginHlsPlayback(camId);
			})
			.fail(function (jqXHR, settings, exception)
			{
				initFinished = true;
				self.CloseDialog();
				toaster.Error("Failed to load HLS player script.<br>" + jqXHR.ErrorMessageHtml);
			});
	}
	this.OpenDialog = function (camId)
	{
		hlsPlayerLastCamId = camId;
		container = $('<div style="overflow: hidden;padding:0px;"></div>');
		dialog = container.dialog(
			{
				title: "HTTP Live Stream (HLS) - " + htmlEncode(cameraListLoader.GetCameraName(camId))
				, overlayOpacity: 0.3
				, closeOnOverlayClick: true
				, onClosing: function ()
				{
					container = null;
					dialog = null;
					if (playerObj != null)
						playerObj.stop();
					playerObj = null;
					videoPlayer.RefreshVideoStream();
				}
			});
		videoPlayer.DeactivatePlayer();
		if (!initFinished)
		{
			container.append('<div style="width:50px;height:50px;margin: 20px auto" class="spin1s">'
				+ '<svg class="icon noflip stroke"><use xlink:href="#svg_stroke_loading_circle"></use></svg>'
				+ '</div>');
			Initialize(camId);
		}
		else
		{
			if (initSucceeded)
				BeginHlsPlayback(camId);
		}
	}
	this.CloseDialog = function ()
	{
		if (dialog != null)
			if (dialog.close())
				dialog = null;
	}
	var BeginHlsPlayback = function (camId)
	{
		if (container != null)
		{
			container.empty();
			container.append('<div id="hlsPlayer"></div>');

			var src = currentServer.remoteBaseURL + "h264/" + camId + "/temp.m3u8" + currentServer.GetAPISessionArg("?", true);
			playerObj = new Clappr.Player({ source: src, parentId: "#hlsPlayer", autoPlay: false, disableVideoTagContextMenu: true, allowUserInteraction: true, actualLiveTime: true, hlsMinimumDvrSize: 1 });
			playerObj.on('playererror', onHlsError);
			playerObj.on('fullscreen', function ()
			{
				setTimeout(resizeHlsPlayer, 0); setTimeout(resizeHlsPlayer, 100);
			});
			playerObj.play();
			resizeHlsPlayer();

			registerHlsContextMenu($("#hlsPlayer"));
			registerHlsContextMenu($("#hlsPlayer video"));

			dialog.contentChanged(true);
		}
	}
	var onHlsError = function (obj)
	{
		var description = "Unknown";
		try
		{
			var code = obj.raw.response.code;
			if (code === 503)
				description = "Unable to load stream with this camera name.";
			else if (code === 403)
				description = "Session Lost";
			else
				description = obj.description;
		}
		catch (ex)
		{
		}
		toaster.Error("Video player reports error: " + description);
	}
	this.IsOpen = function ()
	{
		return dialog != null;
	}
	var resizeHlsPlayer = function ()
	{
		if (container != null && dialog != null)
		{
			var playerSizeObj = container.find('[data-player]');
			playerSizeObj.css('width', dialog.$dialog.width());
			playerSizeObj.css('height', dialog.$dialog.height());
		}
	}
	// Context Menu
	var onHlsContextMenuAction = function ()
	{
		switch (this.data.alias)
		{
			case "newtab":
				self.CloseDialog();
				var sessionArg = currentServer.GetAPISessionArg("&");
				window.open("livestream.htm?cam=" + encodeURIComponent(hlsPlayerLastCamId) + sessionArg);
				break;
			default:
				toaster.Error(this.data.alias + " is not implemented!");
				break;
		}
	}
	var optionHls =
	{
		alias: "cmroot_hls", width: 200, items:
			[
				{ text: "Open stream in New Tab", icon: "", alias: "newtab", action: onHlsContextMenuAction }
			]
		, clickType: GetPreferredContextMenuTrigger()
	};

	var registerHlsContextMenu = function ($ele)
	{
		$ele.contextmenu(optionHls);
	};
}
///////////////////////////////////////////////////////////////
// Live Stream in Dialog Window ///////////////////////////////
///////////////////////////////////////////////////////////////
//function LiveStreamDialogWindow(camId)
//{
//	var self = this;
//	var dialog = null;
//	var streamer = null;
//	var playerModule = null;

//	function Initialize()
//	{
//		if (!any_h264_playback_supported)
//		{
//			toaster.Error("Unable to open a Live Stream Dialog Window because no H.264 player is supported.");
//			return;
//		}

//		streamer = new SynchronousStreamFetcher();

//		container = $('<div style="overflow: hidden;padding:0px;"></div>');

//		if (any_h264_playback_supported)
//		{
//			playerModule = new FetchH264VideoModule();
//		}

//		dialog = container.dialog(
//			{
//				title: htmlEncode(cameraListLoader.GetCameraName(camId))
//				, onClosing: DialogClosing
//			});

//		else
//		{
//			if (initSucceeded)
//				BeginHlsPlayback(camId);
//		}
//	}
//	function DialogClosing()
//	{
//		streamer.CloseStream();
//		streamer = null;

//		container = null;
//		dialog = null;
//	}

//	this.CloseDialog = function ()
//	{
//		if (dialog != null)
//			if (dialog.close())
//				dialog = null;
//	}
//	this.IsOpen = function ()
//	{
//		return !!dialog;
//	}

//	Initialize();
//}
///////////////////////////////////////////////////////////////
// MediaSession (OS-provided media controls) //////////////////
///////////////////////////////////////////////////////////////
function MediaSessionController()
{
	var self = this;
	var lastSetState = null;

	var supportsMediaSession = false;
	this.supportsMediaSession = function ()
	{
		return supportsMediaSession;
	}

	try
	{
		supportsMediaSession = navigator.mediaSession;
	}
	catch (ex)
	{
		console.error(ex);
	}

	this.setMediaMetadata = function (title)
	{
		if (supportsMediaSession)
		{
			try
			{
				navigator.mediaSession.metadata = new MediaMetadata({
					title: title,
					album: document.title
				});
			}
			catch (ex)
			{
				console.error(ex);
				supportsMediaSession = false;
			}
		}
	}

	this.setMediaState = function ()
	{
		if (supportsMediaSession)
		{
			var isPlaying = true;
			var duration = 86400;
			var position = 86400;
			var playbackRate = 1.0;
			if (!videoPlayer.Loading().image.isLive && !videoPlayer.Loading().image.isTimeline())
			{
				var isPlaying = !videoPlayer.Playback_IsPaused();
				duration = Clamp(videoPlayer.Loading().image.msec - 1, 0, Infinity);
				position = Clamp(videoPlayer.GetClipPlaybackPositionMs(), 0, duration);
				playbackRate = playbackControls.GetPlaybackSpeed();
				if (playbackRate === 0)
				{
					playbackRate = 0.0001;
					isPlaying = false;
				}
			}

			var stateDict = { duration: duration, playbackRate: playbackRate, position: position };
			if (lastSetState == null
				|| lastSetState.duration !== stateDict.duration
				|| lastSetState.playbackRate !== stateDict.playbackRate
				|| lastSetState.position !== stateDict.position) 
			{
				try
				{
					navigator.mediaSession.setPositionState(stateDict);
				}
				catch (ex)
				{
					console.error(ex);
					supportsMediaSession = false;
					return;
				}
				lastSetState = stateDict;
			}

			var playbackState = isPlaying ? "playing" : "paused"
			try
			{
				if (navigator.mediaSession.playbackState !== playbackState)
				{
					navigator.mediaSession.playbackState = playbackState;
				}
			}
			catch (ex)
			{
				console.error(ex);
				supportsMediaSession = false;
				return;
			}
		}
	}

	if (supportsMediaSession)
	{
		try
		{
			navigator.mediaSession.setActionHandler('play', function ()
			{
				if (videoPlayer.Loading().image.isLive)
					videoPlayer.LoadHomeGroup();
				else if (!videoPlayer.Loading().image.isTimeline())
					videoPlayer.Playback_Play();
			});
			navigator.mediaSession.setActionHandler('pause', function ()
			{
				if (videoPlayer.Loading().image.isLive)
					videoPlayer.LoadHomeGroup();
				else if (!videoPlayer.Loading().image.isTimeline())
					videoPlayer.Playback_Pause();
			});
			navigator.mediaSession.setActionHandler('stop', function ()
			{
				if (videoPlayer.Loading().image.isLive)
					videoPlayer.goLive();
				else if (!videoPlayer.Loading().image.isTimeline())
					clipLoader.CloseCurrentClip();
			});
		}
		catch (ex)
		{
			console.error(ex);
		}

		try
		{
			navigator.mediaSession.setActionHandler('seekbackward', function (details)
			{
				if (!videoPlayer.Loading().image.isLive && !videoPlayer.Loading().image.isTimeline())
				{
					if (details.seekOffset && details.seekOffset > 0)
						videoPlayer.SeekByMs(-1000 * details.seekOffset);
					else
						videoPlayer.SeekByMs(-1000 * GetSkipAmount());
				}
			});
			navigator.mediaSession.setActionHandler('seekforward', function (details)
			{
				if (!videoPlayer.Loading().image.isLive && !videoPlayer.Loading().image.isTimeline())
				{
					if (details.seekOffset && details.seekOffset > 0)
						videoPlayer.SeekByMs(1000 * details.seekOffset);
					else
						videoPlayer.SeekByMs(1000 * GetSkipAmount());
				}
			});
			navigator.mediaSession.setActionHandler('seekto', function (details)
			{
				if (!videoPlayer.Loading().image.isLive && !videoPlayer.Loading().image.isTimeline())
				{
					if (details.seekTime || details.seekTime === 0)
					{
						var msLength = currentlyLoadingImage.msec - 1;
						if (msLength <= 0)
							return;
						var newPos = (details.seekTime * 1000) / msLength;
						newPos = Clamp(newPos, 0, 1);
						var play = !details.fastSeek;
						videoPlayer.SeekToPercent(newPos, play);
					}
				}
			});
		}
		catch (ex)
		{
			console.error(ex);
		}

		try
		{
			navigator.mediaSession.setActionHandler('previoustrack', function ()
			{
				if (videoPlayer.Loading().image.isLive && currentPrimaryTab !== "timeline")
					BI_Hotkey_PreviousCamera();
				else
					videoPlayer.Playback_PreviousClip();
			});

			navigator.mediaSession.setActionHandler('nexttrack', function ()
			{
				if (videoPlayer.Loading().image.isLive)
					BI_Hotkey_NextCamera();
				else if (!videoPlayer.Loading().image.isTimeline())
					videoPlayer.Playback_NextClip();
			});
		}
		catch (ex)
		{
			console.error(ex);
		}
	}
}
///////////////////////////////////////////////////////////////
// Picture-in-Picture /////////////////////////////////////////
///////////////////////////////////////////////////////////////
function OnChange_ui3_show_picture_in_picture_button()
{
	pictureInPictureController.updatePictureInPictureButtonState();
}
function PictureInPictureController()
{
	var self = this;
	var pipIsSupported = false;
	try
	{
		pipIsSupported = document.pictureInPictureEnabled && currentH264Player === H264PlayerOptions.HTML5;
	}
	catch (ex)
	{
		console.error(ex);
	}

	function Initialize()
	{
		$("#clipPictureInPictureButton").on("click", function ()
		{
			self.togglePictureInPicture();
		});
		self.updatePictureInPictureButtonState();
	}
	function CurrentPlayerSupportsPip()
	{
		return videoPlayer.CurrentPlayerModuleName() !== "none" && videoPlayer.GetPlayerObject() && videoPlayer.GetPlayerObject().isMsePlayer;
	}
	this.updatePictureInPictureButtonState = function ()
	{
		var playerSupportsPip = CurrentPlayerSupportsPip();
		if (settings.ui3_show_picture_in_picture_button === "1" && pipIsSupported && playerSupportsPip)
			$("#clipPictureInPictureButton").removeClass("pictureInPictureButtonHidden");
		else
			$("#clipPictureInPictureButton").addClass("pictureInPictureButtonHidden");
		if (!playerSupportsPip)
			this.disablePictureInPicture();
	}
	this.isPictureInPictureSupported = function ()
	{
		return pipIsSupported;
	}
	this.isPictureInPictureEnabled = function ()
	{
		try
		{
			return pipIsSupported && !!document.pictureInPictureElement;
		}
		catch (ex)
		{
			console.log(ex);
			return false;
		}
	}
	this.enablePictureInPicture = function ()
	{
		try
		{
			if (pipIsSupported && CurrentPlayerSupportsPip())
				videoPlayer.GetPlayerElement().requestPictureInPicture();
		}
		catch (ex)
		{
			toaster.Error(ex);
		}
	}
	this.disablePictureInPicture = function ()
	{
		try
		{
			if (pipIsSupported && document.pictureInPictureElement)
				document.exitPictureInPicture();
		}
		catch (ex)
		{
			toaster.Error(ex);
		}
	}
	this.togglePictureInPicture = function ()
	{
		if (self.isPictureInPictureEnabled())
			self.disablePictureInPicture();
		else
			self.enablePictureInPicture();
	}
	Initialize();
}
///////////////////////////////////////////////////////////////
// Maximized Mode /////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function MaximizedModeController()
{
	var self = this;
	$("#clipMaximizeButton,#clipExitMaximizeButton")
		.on("click", function () { self.toggleMaximize(); })
		.on("mousedown touchstart", function (e)
		{
			// Prevents the button click from causing camera maximize actions.
			// Do not use touchEvents.Gate(e) here, otherwise events sneak through on touchscreens.
			// stopPropagation prevents the event from reaching videoPlayer.
			e.stopPropagation();
			// And [suppressMouseHelper] clears the state in case the event got there before we stopped propagation.
			videoPlayer.suppressMouseHelper();
		});
	this.updateMaximizeButtonState = function ()
	{
		if (settings.ui3_is_maximized === "1" || settings.ui3_show_maximize_button === "1" || fullScreenModeController.isFullScreen())
		{
			if (settings.ui3_is_maximized === "1")
			{
				$("#clipMaximizeButton").addClass('maximizeButtonHidden');
				$("#clipExitMaximizeButton").removeClass('maximizeButtonHidden');
			}
			else
			{
				$("#clipMaximizeButton").removeClass('maximizeButtonHidden');
				$("#clipExitMaximizeButton").addClass('maximizeButtonHidden');
			}
		}
		else
		{
			$("#clipMaximizeButton").addClass('maximizeButtonHidden');
			$("#clipExitMaximizeButton").addClass('maximizeButtonHidden');
		}
		if (loadingHelper.DidLoadingFinish())
			resized();
	};
	this.toggleMaximize = function ()
	{
		if (settings.ui3_is_maximized === "1")
			settings.ui3_is_maximized = "0";
		else
			settings.ui3_is_maximized = "1";
		this.loadMaximizeState();
	};
	this.loadMaximizeState = function ()
	{
		if (settings.ui3_is_maximized === "1")
			$("#layoutleft,#layouttop").hide();
		else
			$("#layoutleft,#layouttop").show();
		this.updateMaximizeButtonState();
		clipLoader && clipLoader.RedrawClipList();
		BI_CustomEvent.Invoke("MaximizeChanged", settings.ui3_is_maximized === "1");
	}
	this.EnableMaximizedMode = function ()
	{
		if (settings.ui3_is_maximized !== "1")
			this.toggleMaximize();
	};
	this.DisableMaximizedMode = function ()
	{
		if (settings.ui3_is_maximized === "1")
			this.toggleMaximize();
	};

	this.loadMaximizeState();
}
///////////////////////////////////////////////////////////////
// FullScreen Mode ////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function FullScreenModeController()
{
	var self = this;
	var isFullScreen_cached = false;
	$(document).on("webkitfullscreenchange mozfullscreenchange fullscreenchange MSFullscreenChange", function (event)
	{
		if (maximizedModeController)
		{
			if (settings.ui3_fullscreen_videoonly == "1")
			{
				if (self.isFullScreen())
					maximizedModeController.EnableMaximizedMode();
				else
					maximizedModeController.DisableMaximizedMode();
			}
			maximizedModeController.updateMaximizeButtonState();
		}
		self.updateFullScreenButtonState();
	});
	$("#clipFullscreenButton,#clipExitFullscreenButton")
		.on("click", function () { self.toggleFullScreen(); })
		.on("mousedown touchstart", function (e)
		{
			// Prevents the button click from causing camera maximize actions.
			// Do not use touchEvents.Gate(e) here, otherwise events sneak through on touchscreens.
			// stopPropagation prevents the event from reaching videoPlayer.
			e.stopPropagation();
			// And [suppressMouseHelper] clears the state in case the event got there before we stopped propagation.
			videoPlayer.suppressMouseHelper();
		});
	this.updateFullScreenButtonState = function ()
	{
		if (self.isFullScreen())
		{
			$("#clipFullscreenButton").addClass('fullscreenButtonHidden');
			$("#clipExitFullscreenButton").removeClass('fullscreenButtonHidden');
		}
		else
		{
			$("#clipFullscreenButton").removeClass('fullscreenButtonHidden');
			$("#clipExitFullscreenButton").addClass('fullscreenButtonHidden');
		}
		if (loadingHelper.DidLoadingFinish())
			resized();
	}
	this.toggleFullScreen = function ()
	{
		if (fullscreen_supported)
		{
			if (!self.isFullScreen())
				requestFullScreen();
			else
				exitFullScreen();
			clipLoader.RedrawClipList();
		}
		else
		{
			BI_Hotkey_MaximizeVideoArea();
		}
	}
	this.isFullScreen = function ()
	{
		isFullScreen_cached = (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) ? true : false;
		return isFullScreen_cached;
	}
	var requestFullScreen = function ()
	{
		if (document.documentElement.requestFullscreen)
			document.documentElement.requestFullscreen();
		else if (document.documentElement.msRequestFullscreen)
			document.documentElement.msRequestFullscreen();
		else if (document.documentElement.mozRequestFullScreen)
			document.documentElement.mozRequestFullScreen();
		else if (document.documentElement.webkitRequestFullscreen)
			document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
	}
	var exitFullScreen = function ()
	{
		if (document.exitFullscreen)
			document.exitFullscreen();
		else if (document.msExitFullscreen)
			document.msExitFullscreen();
		else if (document.mozCancelFullScreen)
			document.mozCancelFullScreen();
		else if (document.webkitExitFullscreen)
			document.webkitExitFullscreen();
	}
}
//////////////////////////////////////////////////////////////////////
// Ajax History //////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
function AjaxHistoryManager()
{
	// This class manages the back and forward buttons in a custom way.
	var self = this;
	var buttonOverride;
	var allowExitUI3 = false;

	var BackButtonPressed = function ()
	{
		if (allowExitUI3)
		{
			allowExitUI3 = false;
			return false;
		}
		var loading = videoPlayer.Loading();
		if (loading.image.isTimeline())
		{
			if (!cameraListLoader.CameraIsGroupOrCycle(loading.cam))
				videoPlayer.LoadHomeGroup();
			else
				videoPlayer.goLive();
		}
		else if (!loading.image.isLive)
			clipLoader.CloseCurrentClip();
		else if (!loading.image.isGroup)
			videoPlayer.LoadHomeGroup();
		else
			return false;
		return true;
	}
	if (html5HistoryPushEnabled)
		buttonOverride = new HistoryButtonOverride(BackButtonPressed);

	/**
	 * Undoes and deletes the history button override script.
	 */
	this.Destroy = function ()
	{
		if (buttonOverride)
		{
			buttonOverride.Destroy();
			buttonOverride = null;
		}
	}
	/**
	 * Navigates back in the browser history, bypassing custom back button handling.  This will exit UI3 if there is anything else in the history stack to navigate to.
	 */
	this.NavigateBack = function ()
	{
		allowExitUI3 = true;
		try
		{
			tabVisibleStopwatch.Set(5000);
			settings.bi_lastunload = Date.now();
			console.log('UI3 is navigating back. Automatic login will be suppressed for the next 5 seconds.');
			history.back();
		}
		catch (ex)
		{
			toaster.Error(ex);
		}
	}
}
//////////////////////////////////////////////////////////////////////
// Update Current URL ////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
function GetCleanUrlSearchParams()
{
	var search = new URLSearchParams(location.search);
	search.delete("tab");
	search.delete("t");
	search.delete("clipview");
	search.delete("v");
	search.delete("clipsearch");
	search.delete("cs");
	search.delete("datestart");
	search.delete("ds");
	search.delete("dateend");
	search.delete("de");
	search.delete("group");
	search.delete("g");
	search.delete("cam");
	search.delete("c");
	search.delete("maximize");
	search.delete("m");
	search.delete("rec");
	search.delete("r");
	search.delete("timeline");
	search.delete("tl");
	search.delete("streamingprofile");
	search.delete("p");
	search.delete("timeout");
	search.delete("to");
	search.delete("pause");
	return search;
}
function UpdateCurrentURL()
{
	if (!html5HistorySupported || !loadingHelper.DidLoadingFinish())
		return location.href;
	var search = GetCleanUrlSearchParams();

	search.set("t", currentPrimaryTab);

	var cli = videoPlayer.Loading().image;
	if (cli.isTimeline())
	{
		search.set("timeline", clipTimeline.getCurrentTime());
		search.delete("t");
		if (videoPlayer.Playback_IsPaused())
			search.set("pause", "1");
	}
	else if (!cli.isLive)
	{
		var clipData = clipLoader.GetClipFromId(cli.uniqueId);
		if (clipData)
		{
			var val = clipData.recId;
			var offset = videoPlayer.GetClipPlaybackPositionMs();
			if (offset > 0)
				val += "-" + offset;
			search.set("rec", val);
			search.delete("t");
			if (videoPlayer.Playback_IsPaused())
				search.set("pause", "1");
		}
	}

	if (currentPrimaryTab === "clips")
	{
		if (dateFilter.BeginDate)
			search.set("ds", dateSecondsToYMD(dateFilter.BeginDate))
		if (dateFilter.EndDate && dateFilter.BeginDate !== dateFilter.EndDate - 86400)
			search.set("de", dateSecondsToYMD(dateFilter.EndDate - 86400))
		if (clipFilterSearch.getQuery())
			search.set("v", settings.ui3_current_dbView);
		if (clipFilterSearch.getQuery())
			search.set("cs", clipFilterSearch.getQuery());
	}

	search.set(cli.isGroup ? "group" : "cam", cli.id);

	search = search.toString();
	if (search.length)
		search = "?" + search;

	var newUrl = location.origin + location.pathname + search + location.hash;
	if (location.href !== newUrl)
	{
		try
		{
			history.replaceState(history.state, "", newUrl);
		}
		catch (ex)
		{
			console.error(ex);
		}
	}
	return newUrl;
}
BindEventsPassive(document, "mouseleave", UpdateCurrentURL);
/**
 * Returns the URL with the specified URL parameters removed. First argument is the string containing URL parameters. All following arguments must be URL parameter names. If the URL contains a question mark, it will still exist in the return value.
 * @param {String} url URL.
 */
function RemoveUrlParameters(url)
{
	var root = "";
	var search = url;
	var idxQmark = search.indexOf("?");
	if (idxQmark > -1)
	{
		root = search.substr(0, idxQmark + 1);
		search = search.substr(idxQmark + 1);
	}
	search = new URLSearchParams(search);
	for (var i = 1; i < arguments.length; i++)
	{
		search.delete(arguments[i]);
	}
	return root + search.toString();
}
/**
 * Returns "?" if the given string does not have one in it already, otherwise returns "&".
 * @param {String} url URL.
 */
function GetUrlParameterSeparator(url)
{
	return url.indexOf("?") > -1 ? "&" : "?";
}
//////////////////////////////////////////////////////////////////////
// Hotkeys ///////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
function BI_Hotkey_MaximizeVideoArea()
{
	maximizedModeController.toggleMaximize();
}
function BI_Hotkey_FullScreen()
{
	fullScreenModeController.toggleFullScreen();
}
function BI_Hotkey_Load_Tab_Live()
{
	$('.topbar_tab[name="live"]').click();
}
function BI_Hotkey_Load_Tab_Clips()
{
	$('.topbar_tab[name="clips"]').click();
}
function BI_Hotkey_Load_Tab_Timeline()
{
	$('.topbar_tab[name="timeline"]').click();
}
function BI_Hotkey_Toggle_Camera_Labels()
{
	settings.ui3_cameraLabels_enabled = settings.ui3_cameraLabels_enabled === "1" ? "0" : "1";
	cameraNameLabels.show();
}
function BI_Hotkey_DownloadFrame()
{
	$("#save_snapshot_btn").get(0).click();
}
function BI_Hotkey_ToggleMute()
{
	CameraAudioMuteToggle();
}
function BI_Hotkey_NextCamera()
{
	LoadNextOrPreviousCamera(1);
}
function BI_Hotkey_PreviousCamera()
{
	LoadNextOrPreviousCamera(-1);
}
function LoadNextOrPreviousCamera(offset)
{
	if (offset == 0)
		return;
	// Not supported during timeline playback, simply because the default hotkey for next/previous camera is shared with next/previous frame, and I can only choose one to work for timeline playback
	var loading = videoPlayer.Loading();
	if (!loading.image.isLive || cameraListLoader.CameraIsCycle(loading.cam))
		return;
	var groupCamera = videoPlayer.GetCurrentHomeGroupObj();
	var idxCurrentMaximizedCamera = -1;
	var cams = cameraListLoader.GetGroupCams(groupCamera.optionValue);
	if (!cams)
	{
		toaster.Error('Can not load next or previous camera because group "' + groupCamera.optionDisplay + '" has invalid layout metadata.');
		return;
	}

	for (var i = 0; i < cams.length; i++)
	{
		if (iEquals(cams[i], loading.cam.optionValue))
		{
			idxCurrentMaximizedCamera = i;
			break;
		}
	}

	if (idxCurrentMaximizedCamera === -1)
	{
		if (offset < 0)
			idxCurrentMaximizedCamera = cams.length;
	}

	var iterations = 1000;
	while (iterations-- > 0)
	{
		idxCurrentMaximizedCamera += offset;
		if (idxCurrentMaximizedCamera < 0 || idxCurrentMaximizedCamera >= cams.length)
		{
			videoPlayer.ImgClick_Camera(groupCamera);
			break;
		}
		var newCameraId = cams[idxCurrentMaximizedCamera];
		var newCamera = cameraListLoader.GetCameraWithId(newCameraId);
		videoPlayer.ImgClick_Camera(newCamera);
		if (iEquals(videoPlayer.Loading().cam.optionValue, newCameraId))
			break;
	}
}
function BI_Hotkey_NextGroup()
{
	LoadNextOrPreviousGroup(1);
}
function BI_Hotkey_PreviousGroup()
{
	LoadNextOrPreviousGroup(-1);
}
function LoadNextOrPreviousGroup(offset)
{
	var loading = videoPlayer.Loading();
	if (!loading.image.isLive && !loading.image.isTimeline())
		return;
	var groupCamera = videoPlayer.GetCurrentHomeGroupObj();
	var groupList = cameraListLoader.GetGroupAndCycleList();
	var idxCurrentGroup = -1;
	for (var i = 0; i < groupList.length; i++)
	{
		if (groupList[i] == groupCamera)
		{
			idxCurrentGroup = i;
			break;
		}
	}
	var idxDesiredGroup;
	var safeOffset = (idxCurrentGroup + offset) % groupList.length;
	if (safeOffset < 0)
		idxDesiredGroup = groupList.length + safeOffset;
	else
		idxDesiredGroup = safeOffset;

	videoPlayer.SelectCameraGroup(groupList[idxDesiredGroup].optionValue);
}
function BI_Hotkey_PlayPause()
{
	if (videoPlayer.Playback_IsPaused())
		videoOverlayHelper.ShowTemporaryPlayIcon();
	else
		videoOverlayHelper.ShowTemporaryPauseIcon();
	videoPlayer.Playback_PlayPause();
}
function BI_Hotkey_Delete()
{
	clipLoader.DeleteCurrentClip();
}
function BI_Hotkey_ToggleReverse()
{
	if (!videoPlayer.Loading().image.isLive)
		playbackControls.ToggleReverse();
}
function BI_Hotkey_NextClip()
{
	if (!videoPlayer.Loading().image.isLive)
	{
		if (settings.ui3_clip_navigation_direction === "Oldest First")
			videoPlayer.Playback_NextClip();
		else
			videoPlayer.Playback_PreviousClip();
	}
}
function BI_Hotkey_PreviousClip()
{
	if (!videoPlayer.Loading().image.isLive)
	{
		if (settings.ui3_clip_navigation_direction === "Oldest First")
			videoPlayer.Playback_PreviousClip();
		else
			videoPlayer.Playback_NextClip();
	}
	else if (currentPrimaryTab === "timeline")
		videoPlayer.Playback_PreviousClip();
}
function BI_Hotkey_SkipAhead()
{
	if (!videoPlayer.Loading().image.isLive)
		videoPlayer.SeekByMs(1000 * GetSkipAmount());
}
function BI_Hotkey_SkipBack()
{
	if (!videoPlayer.Loading().image.isLive)
		videoPlayer.SeekByMs(-1000 * GetSkipAmount());
	else if (currentPrimaryTab === "timeline")
		clipTimeline.loadNewestAllowableTime();
}
function GetSkipAmount()
{
	return Clamp(parseFloat(settings.ui3_skipAmount), 0.01, 9999);
}
function BI_Hotkey_SkipAhead1Frame()
{
	if (!videoPlayer.Loading().image.isLive)
		videoPlayer.SeekByMs(videoPlayer.GetExpectedFrameIntervalOfCurrentCamera(), false);
}
function BI_Hotkey_SkipBack1Frame()
{
	if (!videoPlayer.Loading().image.isLive)
		videoPlayer.SeekByMs(-1 * videoPlayer.GetExpectedFrameIntervalOfCurrentCamera(), false);
	else if (currentPrimaryTab === "timeline")
		clipTimeline.loadNewestAllowableTime();
}
function BI_Hotkey_PlaybackFaster()
{
	if (!videoPlayer.Loading().image.isLive)
		playbackControls.ChangePlaySpeed(1);
}
function BI_Hotkey_PlaybackSlower()
{
	if (!videoPlayer.Loading().image.isLive)
		playbackControls.ChangePlaySpeed(-1);
}
function BI_Hotkey_CloseClip()
{
	if (suppress_Hotkey_CloseClip)
		return;
	if (videoPlayer.Loading().image.isTimeline())
	{
		if (cameraListLoader.CameraIsGroupOrCycle(videoPlayer.Loading().cam))
			videoPlayer.goLive();
	}
	else if (!videoPlayer.Loading().image.isLive)
	{
		clipLoader.CloseCurrentClip();
		// Prevent this same hotkey event from closing the current camera, too.
		clearTimeout(suppress_Hotkey_CloseCamera);
		suppress_Hotkey_CloseCamera = setTimeout(function () { suppress_Hotkey_CloseCamera = null; }, 0);
	}
}
var suppress_Hotkey_CloseClip = null;
var suppress_Hotkey_CloseCamera = null;
function BI_Hotkey_CloseCamera()
{
	if (suppress_Hotkey_CloseCamera)
		return;
	var loading = videoPlayer.Loading();
	if ((loading.image.isLive || videoPlayer.Loading().image.isTimeline()) && !cameraListLoader.CameraIsGroupOrCycle(videoPlayer.Loading().cam))
	{
		videoPlayer.ImgClick_Camera(loading.cam);
		if (videoPlayer.Loading().image.isTimeline())
		{
			clearTimeout(suppress_Hotkey_CloseClip);
			suppress_Hotkey_CloseClip = setTimeout(function () { suppress_Hotkey_CloseClip = null; }, 0);
		}
	}
}
function BI_Hotkey_DigitalZoomIn()
{
	imageRenderer.DigitalZoomNow(1, true);
}
function BI_Hotkey_DigitalZoomOut()
{
	imageRenderer.DigitalZoomNow(-1, true);
}
function BI_Hotkey_DigitalPanUp()
{
	hotkeys.digitalPanUp_isActive = true;
	hotkeys.StartDigitalPanning();
}
function BI_Hotkey_DigitalPanDown()
{
	hotkeys.digitalPanDown_isActive = true;
	hotkeys.StartDigitalPanning();
}
function BI_Hotkey_DigitalPanLeft()
{
	hotkeys.digitalPanLeft_isActive = true;
	hotkeys.StartDigitalPanning();
}
function BI_Hotkey_DigitalPanRight()
{
	hotkeys.digitalPanRight_isActive = true;
	hotkeys.StartDigitalPanning();
}
function BI_Hotkey_DigitalPanUp_Up()
{
	hotkeys.digitalPanUp_isActive = false;
}
function BI_Hotkey_DigitalPanDown_Up()
{
	hotkeys.digitalPanDown_isActive = false;
}
function BI_Hotkey_DigitalPanLeft_Up()
{
	hotkeys.digitalPanLeft_isActive = false;
}
function BI_Hotkey_DigitalPanRight_Up()
{
	hotkeys.digitalPanRight_isActive = false;
}
function CreateBIPtzState()
{
	return { up: 0, down: 0, left: 0, right: 0, zin: 0, zout: 0, ffar: 0, fnear: 0, previousCamera: false, nextCamera: false, restartCamera: false };
}
function BI_Hotkey_PtzUp() { ptzButtons.vue().hotkeyState.up = 1; }
function BI_Hotkey_PtzUp_Up() { ptzButtons.vue().hotkeyState.up = 0; }
function BI_Hotkey_PtzDown() { ptzButtons.vue().hotkeyState.down = 1; }
function BI_Hotkey_PtzDown_Up() { ptzButtons.vue().hotkeyState.down = 0; }
function BI_Hotkey_PtzLeft() { ptzButtons.vue().hotkeyState.left = 1; }
function BI_Hotkey_PtzLeft_Up() { ptzButtons.vue().hotkeyState.left = 0; }
function BI_Hotkey_PtzRight() { ptzButtons.vue().hotkeyState.right = 1; }
function BI_Hotkey_PtzRight_Up() { ptzButtons.vue().hotkeyState.right = 0; }
function BI_Hotkey_PtzIn() { ptzButtons.vue().hotkeyState.zin = 1; }
function BI_Hotkey_PtzIn_Up() { ptzButtons.vue().hotkeyState.zin = 0; }
function BI_Hotkey_PtzOut() { ptzButtons.vue().hotkeyState.zout = 1; }
function BI_Hotkey_PtzOut_Up() { ptzButtons.vue().hotkeyState.zout = 0; }
function BI_Hotkey_PtzFocusFar() { ptzButtons.vue().hotkeyState.ffar = 1; }
function BI_Hotkey_PtzFocusFar_Up() { ptzButtons.vue().hotkeyState.ffar = 0; }
function BI_Hotkey_PtzFocusNear() { ptzButtons.vue().hotkeyState.fnear = 1; }
function BI_Hotkey_PtzFocusNear_Up() { ptzButtons.vue().hotkeyState.fnear = 0; }
function BI_Hotkey_PtzPreset(presetNum)
{
	var loading = videoPlayer.Loading();
	if (loading.image.ptz && loading.image.isLive)
		ptzButtons.vue().enqueuePtzAction(loading.image.id, 100 + parseInt(presetNum));
}
function BI_Hotkeys()
{
	var self = this;
	var charCodeToKeyNameMap;

	var currentlyDownKeys = {};
	$(document).keydown(function (e)
	{
		var charCode = e.which;
		if (charCode === 116 || (e.ctrlKey && charCode === 82)) // F5 or (ctrl+R)
			UpdateCurrentURL();
		if (!charCode
			|| $("body").children(".dialog_overlay").length !== 0
			|| $("body").children(".dialog_wrapper").children(".streamingProfileEditorPanel").length !== 0
			|| $("#clipFilterSearch").is(':focus'))
			return;
		if (e.ctrlKey)
			relativePTZ.setToggleButtonState(true);
		var hotkeysBeingRepeated = currentlyDownKeys[charCode];
		if (hotkeysBeingRepeated)
		{
			for (var i = 0; i < hotkeysBeingRepeated.length; i++)
			{
				var s = hotkeysBeingRepeated[i];
				if (s.allowRepeatKey)
				{
					var val = settings.getItem(s.key);
					if (!val)
						continue;
					var parts = val.split("|");
					if (parts.length >= 4)
					{
						if ((e.ctrlKey ? "1" : "0") == parts[0]
							&& (e.altKey ? "1" : "0") == parts[1]
							&& (e.shiftKey ? "1" : "0") == parts[2]
							&& (charCode == parts[3]))
						{
							s.actionDown();
						}
					}
				}
			}
			return false;
		}
		var isRepeatKey = currentlyDownKeys[charCode];
		currentlyDownKeys[charCode] = [];
		var retVal = true;
		for (var i = 0; i < defaultSettings.length; i++)
		{
			var s = defaultSettings[i];
			if (s.hotkey)
			{
				if (typeof s.actionDown == "function")
				{
					var val = settings.getItem(s.key);
					if (!val)
						continue;
					var parts = val.split("|");
					if (parts.length >= 4)
					{
						if ((e.ctrlKey ? "1" : "0") == parts[0]
							&& (e.altKey ? "1" : "0") == parts[1]
							&& (e.shiftKey ? "1" : "0") == parts[2]
							&& (charCode == parts[3]))
						{
							currentlyDownKeys[charCode].push(s);
							s.actionDown();
							retVal = false;
						}
					}
				}
			}
		}
		if (!retVal)
			return retVal;
	});
	$(document).keyup(function (e)
	{
		relativePTZ.setToggleButtonState();
		var charCode = e.which;
		if (!charCode)
			return;
		var hotkeysBeingReleased = currentlyDownKeys[charCode];
		currentlyDownKeys[charCode] = false;
		var retVal = true;
		if (hotkeysBeingReleased)
		{
			for (var i = 0; i < hotkeysBeingReleased.length; i++)
			{
				var s = hotkeysBeingReleased[i];
				if (typeof s.actionUp == "function")
				{
					s.actionUp();
					retVal = false;
				}
			}
		}
		if (!retVal)
			return retVal;
	});

	var lastDigitalPanAction = 0;
	var isPanning = false;
	this.digitalPanUp_isActive = false;
	this.digitalPanDown_isActive = false;
	this.digitalPanLeft_isActive = false;
	this.digitalPanRight_isActive = false;

	this.StartDigitalPanning = function ()
	{
		if (isPanning)
			return;
		isPanning = true;
		DoDigitalPan();
	}
	var DoDigitalPan = function ()
	{
		var dx = 0;
		var dy = 0;
		var timeNow = new Date().getTime();
		var timePassed = lastDigitalPanAction == 0 ? 16 : Math.min(1000, timeNow - lastDigitalPanAction);
		// Pan speed will increase with a larger browser window.
		var panSpeed = (timePassed / 1000) * (($(window).width() + $(window).height()) / 2);
		if (self.digitalPanUp_isActive)
			dy += panSpeed;
		if (self.digitalPanDown_isActive)
			dy -= panSpeed;
		if (self.digitalPanLeft_isActive)
			dx += panSpeed;
		if (self.digitalPanRight_isActive)
			dx -= panSpeed;
		if (dx == 0 && dy == 0
			&& !self.digitalPanUp_isActive
			&& !self.digitalPaDown_isActive
			&& !self.digitalPanLeft_isActive
			&& !self.digitalPanRight_isActive)
		{
			EndDigitalPanning();
			return;
		}
		imageRenderer.DigitalPan(dx, dy);
		requestAnimationFrame(DoDigitalPan);
	}
	var EndDigitalPanning = function ()
	{
		isPanning = false;
		lastDigitalPanAction = 0;
	}

	this.getKeyName = function (charCode)
	{
		charCode = parseInt(charCode);
		var name = charCodeToKeyNameMap[charCode];
		if (typeof name == "undefined")
			name = String.fromCharCode(charCode);
		return name;
	}
	var buildKeyMap = function ()
	{
		var m = {};
		m[8] = "backspace";
		m[9] = "tab";
		m[13] = "enter";
		m[16] = "";
		m[17] = "";
		m[18] = "";
		m[19] = "pause/break";
		m[20] = "caps lock";
		m[27] = "escape";
		m[32] = "space";
		m[33] = "page up";
		m[34] = "page down";
		m[35] = "end";
		m[36] = "home";
		m[37] = "left arrow";
		m[38] = "up arrow";
		m[39] = "right arrow";
		m[40] = "down arrow";
		m[45] = "insert";
		m[46] = "delete";
		m[91] = "left window";
		m[92] = "right window";
		m[93] = "select key";
		m[96] = "numpad 0";
		m[97] = "numpad 1";
		m[98] = "numpad 2";
		m[99] = "numpad 3";
		m[100] = "numpad 4";
		m[101] = "numpad 5";
		m[102] = "numpad 6";
		m[103] = "numpad 7";
		m[104] = "numpad 8";
		m[105] = "numpad 9";
		m[106] = "multiply";
		m[107] = "add";
		m[109] = "subtract";
		m[110] = "decimal point";
		m[111] = "divide";
		m[112] = "F1";
		m[113] = "F2";
		m[114] = "F3";
		m[115] = "F4";
		m[116] = "F5";
		m[117] = "F6";
		m[118] = "F7";
		m[119] = "F8";
		m[120] = "F9";
		m[121] = "F10";
		m[122] = "F11";
		m[123] = "F12";
		m[144] = "num lock";
		m[145] = "scroll lock";
		m[176] = "Media Next";
		m[177] = "Media Previous";
		m[178] = "Media Stop";
		m[179] = "Media Play/Pause";
		m[186] = "semicolon (;)";
		m[187] = "=";
		m[188] = "comma (,)";
		m[189] = "hyphen (-)";
		m[190] = "period (.)";
		m[191] = "/";
		m[192] = "tilde (~`)";
		m[219] = "[";
		m[220] = "\\";
		m[221] = "]";
		m[222] = "apostrophe (')";
		return m;
	}
	charCodeToKeyNameMap = buildKeyMap();
}
///////////////////////////////////////////////////////////////
// On-screen Toast Messages ///////////////////////////////////
///////////////////////////////////////////////////////////////
function Toaster()
{
	if (toastr)
		toastr.options = {
			"closeButton": false,
			"debug": false,
			"positionClass": "toast-bottom-right",
			"onclick": null,
			"showDuration": "300",
			"hideDuration": "1000",
			"timeOut": "3000",
			"extendedTimeOut": "10000",
			"showEasing": "swing",
			"hideEasing": "linear",
			"showMethod": "fadeIn",
			"hideMethod": "fadeOut",
			"target": "#toast-wrapper"
		}
	var showToastInternal = function (type, message, showTime, closeButton, onClick, extendedTimeOut)
	{
		if (typeof message === "object" && typeof message.message === "string" && typeof message.stack === "string")
		{
			console.error(type + " toast", message);
			message = htmlEncode(message.message + ": " + message.stack);
		}
		else if (typeof message === "object" && typeof message.name === "string" && typeof message.message === "string" && typeof message.code === "number")
		{
			message = message.name + " (code " + message.code + "): " + message.message, message;
			console.error(type + " toast", message);
			message = htmlEncode(message);
		}
		else
		{
			if (type === "error")
				console.error(type + " toast: ", message);
			else
				console.log(type + " toast: ", message);
		}
		var overrideOptions = {};

		if (showTime)
			overrideOptions.timeOut = showTime;

		if (closeButton)
		{
			overrideOptions.closeButton = true;
			overrideOptions.tapToDismiss = false;
			overrideOptions.extendedTimeOut = 60000;
		}

		if (typeof extendedTimeOut === "number")
			overrideOptions.extendedTimeOut = extendedTimeOut;

		if (typeof onClick == "function")
			overrideOptions.onclick = onClick;

		var myToast = toastr[type](message, null, overrideOptions);

		return myToast;
	}
	this.Success = function (message, showTime, closeButton, onClick, extendedTimeOut)
	{
		return showToastInternal('success', message, showTime, closeButton, onClick, extendedTimeOut);
	}
	this.Info = function (message, showTime, closeButton, onClick, extendedTimeOut)
	{
		return showToastInternal('info', message, showTime, closeButton, onClick, extendedTimeOut);
	}
	this.Warning = function (message, showTime, closeButton, onClick, extendedTimeOut)
	{
		return showToastInternal('warning', message, showTime, closeButton, onClick, extendedTimeOut);
	}
	this.Error = function (message, showTime, closeButton, onClick, extendedTimeOut)
	{
		return showToastInternal('error', message, showTime, closeButton, onClick, extendedTimeOut);
	}
	this.Show = function (type, message, showTime, closeButton, onClick, extendedTimeOut)
	{
		return showToastInternal(type, message, showTime, closeButton, onClick, extendedTimeOut);
	}
	this.ErrorResponse = function (responseObject)
	{
		var msg;
		if (responseObject)
		{
			var json = JSON.stringify(responseObject);
			console.log("toaster.ErrorResponse", json);
			if (responseObject.data && responseObject.data.reason)
				msg = responseObject.data.reason;
			else if (responseObject.result === "fail")
				msg = "JSON API response failed without a reason being given. " + json;
			else
				msg = "JSON API response failed for an unknown reason. " + json;
		}
		else
		{
			console.log("toaster.ErrorResponse(null)");
			msg = "JSON API response object was null.";
		}
		try
		{
			var err = new Error();
			msg += " \n" + err.stack;
		}
		catch (ex) { }
		return showToastInternal('error', msg, 10000);
	}
}
function showSuccessToast(message, showTime, closeButton)
{
	return toaster.Success(message, showTime, closeButton);
}
function showInfoToast(message, showTime, closeButton)
{
	return toaster.Info(message, showTime, closeButton);
}
function showWarningToast(message, showTime, closeButton)
{
	return toaster.Warning(message, showTime, closeButton);
}
function showErrorToast(message, showTime, closeButton)
{
	return toaster.Error(message, showTime, closeButton);
}
///////////////////////////////////////////////////////////////
// /admin API Calls ///////////////////////////////////////////
///////////////////////////////////////////////////////////////
function ExecAdminCall(camId, args, callbackSuccess, callbackFail)
{
	$.ajax(currentServer.remoteBaseURL + "admin?camera=" + camId + "&" + args + currentServer.GetAPISessionArg("&", true))
		.done(function (response)
		{
			if (typeof callbackSuccess === "function")
				callbackSuccess(response);
		})
		.fail(function (jqXHR, textStatus, errorThrown)
		{
			if (typeof callbackFail === "function")
				callbackFail(jqXHR, textStatus, errorThrown);
		});
}
///////////////////////////////////////////////////////////////
// JSON ///////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var execJsonCounter = 0;
var appPathFallback = false;
function ExecJSON(args, callbackSuccess, callbackFail, synchronous)
{
	if (currentServer.isLoggingOut && args.cmd !== "logout")
		return;
	var isLogin = args.cmd == "login";
	if (typeof args.session == "undefined" && !isLogin)
		args.session = sessionManager.GetAPISession();
	var eventArgs = { id: execJsonCounter++, args: args };
	BI_CustomEvent.Invoke("ExecJSON_Start", eventArgs);
	var reqUrl = currentServer.remoteBaseURL + "json" + "?_" + encodeURIComponent(args.cmd);
	$.ajax({
		type: 'POST',
		url: reqUrl,
		contentType: "text/plain",
		data: JSON.stringify(args),
		dataType: "json",
		async: !synchronous,
		success: function (data)
		{
			eventArgs.data = data;
			BI_CustomEvent.Invoke("ExecJSON_Success", eventArgs);
			if (callbackSuccess)
				callbackSuccess(data);
		},
		error: function (jqXHR, textStatus, errorThrown)
		{
			if (jqXHR && jqXHR.status === 404)
			{
				if (currentServer.remoteBaseURL === appPath && appPath !== "" && !appPathFallback)
				{
					appPathFallback = true;
					toaster.Warning('JSON API unreachable at "' + reqUrl + '". This is may be the result of using a reverse-proxy server incorrectly. <a href="https://github.com/bp2008/ui3/wiki/Using-UI3-with-a-reverse-proxy-server" target="_blank">Learn More</a>', 30000);
					currentServer.remoteBaseURL = ""; // First fallback
					ExecJSON(args, callbackSuccess, callbackFail, synchronous);
					return;
				}
				else if (currentServer.remoteBaseURL === "" && appPath !== "/")
				{
					currentServer.remoteBaseURL = "/"; // Second fallback
					ExecJSON(args, callbackSuccess, callbackFail, synchronous);
					return;
				}
			}
			if (!jqXHR)
				jqXHR = { status: 0, statusText: "No jqXHR object was created" };
			jqXHR.OriginalURL = reqUrl;
			if (jqXHR.status === 0)
				jqXHR.ErrorMessageHtml = "No connection to server.";
			else
				jqXHR.ErrorMessageHtml = 'Response: ' + jqXHR.status + ' ' + jqXHR.statusText + '<br>Status: ' + textStatus + '<br>Error: ' + errorThrown + '<br>URL: ' + reqUrl;
			console.error('Response: ' + jqXHR.status + ' ' + jqXHR.statusText + '\nStatus: ' + textStatus + '\nError: ' + errorThrown + '\nURL: ' + reqUrl);
			BI_CustomEvent.Invoke("ExecJSON_Fail", eventArgs);
			if (callbackFail)
				callbackFail(jqXHR, textStatus, errorThrown);
		}
	});
}
function ExecJSONPromise(args)
{
	return new Promise(function (resolve, reject)
	{
		ExecJSON(args
			, function (response)
			{
				resolve(response);
			}
			, function (jqXHR, textStatus, errorThrown)
			{
				reject(jqXHR.ErrorMessageHtml);
			});
	});
}
function IsGroupableConnectionError(jqXHR)
{
	return !!jqXHR && (jqXHR.status === 0 || jqXHR.status === 503);
}
var connectionLostNotice = { toast: null, time: null, interval: null };
function HandleGroupableConnectionError(jqXHR)
{
	if (!jqXHR || IsGroupableConnectionError(jqXHR))
	{
		if (connectionLostNotice.toast == null)
		{
			connectionLostNotice.time = performance.now();
			connectionLostNotice.toast = toaster.Error('<div id="connectionErrorToast">Server is unavailable (<span class="time"></span>)</div>', 99999999, false, null, 99999999);
			connectionLostNotice.interval = setInterval(UpdateConnectionLostTime, 500);
			UpdateConnectionLostTime();
		}
		return true;
	}
	return false;
}
function UpdateConnectionLostTime()
{
	$("#connectionErrorToast .time").text(msToTime(performance.now() - connectionLostNotice.time));
}
function EndConnectionErrors()
{
	if (connectionLostNotice.interval !== null)
	{
		clearInterval(connectionLostNotice.interval);
		connectionLostNotice.interval = null;
	}
	if (connectionLostNotice.toast !== null)
	{
		connectionLostNotice.toast.remove();
		connectionLostNotice.toast = null;
		videoPlayer.ReopenStreamAtCurrentSeekPosition();
		clipLoader.reloadIfInFailedState();
	}
}
function AddOrUpdateErrorToast(toast, elementId, html)
{
	if (!toast)
		toast = toaster.Error('<div id="' + elementId + '"></div>', 99999999, false, null, 99999999);
	$("#" + elementId).html(html);
	return toast;
}
function AddOrUpdateWarningToast(toast, elementId, html)
{
	if (!toast)
		toast = toaster.Warning('<div id="' + elementId + '"></div>', 99999999, false, null, 99999999);
	$("#" + elementId).html(html);
	return toast;
}
///////////////////////////////////////////////////////////////
// Persistent Toast ///////////////////////////////////////////
///////////////////////////////////////////////////////////////
function PersistentToast(elementId, type, closeButton, onClose)
{
	var self = this;
	var toast = null;
	this.showText = function (text)
	{
		show();
		$("#" + elementId).text(text);
	}
	this.showHtml = function (html)
	{
		show();
		$("#" + elementId).html(html);
	}
	var show = function ()
	{
		if (!toast)
		{
			var fn = toaster.Error;
			if (type.toUpperCase() === "WARNING")
				fn = toaster.Warning;
			else if (type.toUpperCase() === "INFO")
				fn = toaster.Info;
			else if (type.toUpperCase() === "SUCCESS")
				fn = toaster.Success;
			toast = fn('<div id="' + elementId + '"></div>', 99999999, closeButton, function ()
			{
				toast = null;
				if (typeof onClose === "function")
					onClose(self);
			}, 99999999);
		}
	}
	this.hide = function ()
	{
		if (toast)
		{
			toast.remove();
			toast = null;
		}
	}
	this.isShowing = function ()
	{
		return !!toast;
	}
}
///////////////////////////////////////////////////////////////
// Frame rate counter /////////////////////////////////////////
///////////////////////////////////////////////////////////////
var fpsCounter = new FPSCounter1();
function FPSCounter1()
{
	// Counts the exact number of frames that arrived within the last 1000 ms.
	var queue = new Queue();
	this.getFPS = function (lastFrameLoadingTime)
	{
		var now = performance.now();
		// Trim times older than 1 second
		while (!queue.isEmpty() && now - queue.peek() >= 1000)
			queue.dequeue();
		queue.enqueue(now);
		return queue.getLength();
	};
	this.peekFPS = function ()
	{
		var now = performance.now();
		// Trim times older than 1 second
		while (!queue.isEmpty() && now - queue.peek() >= 1000)
			queue.dequeue();
		return queue.getLength();
	}
}
function FPSCounter2()
{
	// Calculates frame rate based on the average loading time of the last 10 frames.
	var MAXSAMPLES = 10;
	var tickindex = 0;
	var ticksum = 0;
	var ticklist = [];
	for (var i = 0; i < MAXSAMPLES; i++)
		ticklist.push(0);
	var CalcAverageTick = function (newtick)
	{
		if (newtick !== null)
		{
			ticksum -= ticklist[tickindex];  /* subtract value falling off */
			ticksum += newtick;              /* add new value */
			ticklist[tickindex] = newtick;   /* save new value so it can be subtracted later */
			if (++tickindex == MAXSAMPLES)   /* inc buffer index */
				tickindex = 0;
		}
		/* return average */
		return (ticksum / MAXSAMPLES);
	};
	this.getFPS = function (newtick)
	{
		return (1000 / CalcAverageTick(newtick)).toFloat(1);
	};
	this.peekFPS = function ()
	{
		console.log("peekFPS is not implemented properly in FPSCounter2");
		return (1000 / (ticksum / MAXSAMPLES)).toFloat(1);
	}
}
///////////////////////////////////////////////////////////////
// Bit rate calculator ////////////////////////////////////////
///////////////////////////////////////////////////////////////
var bitRateCalc_Video = new BitRateCalculator();
var bitRateCalc_Audio = new BitRateCalculator();
function BitRateCalculator()
{
	var self = this;
	var queue = new Queue();
	this.averageOverMs = 1000;
	var sum = 0;
	var best = 0;
	this.AddDataPoint = function (bytes)
	{
		cleanup();
		sum += bytes;
		queue.enqueue(new BitRateDataPoint(bytes));
		if (sum > best)
			best += ((sum - best) * 0.1);
		else if (sum < best)
			best += ((sum - best) * 0.01);
	}
	this.GetBPS = function ()
	{
		cleanup();
		return sum / (self.averageOverMs / 1000);
	}
	this.GetBestGuess = function ()
	{
		return best / (self.averageOverMs / 1000);
	}
	var cleanup = function ()
	{
		var now = performance.now();
		while (!queue.isEmpty() && now - queue.peek().time > self.averageOverMs)
			sum -= queue.dequeue().bytes;
	}
}
function BitRateDataPoint(bytes)
{
	this.bytes = bytes;
	this.time = performance.now();
}
///////////////////////////////////////////////////////////////
// Efficient Rolling Average Calculator ///////////////////////
///////////////////////////////////////////////////////////////
/** Calculates rolling averages. */
function RollingAverage(MAXSAMPLES)
{
	if (!MAXSAMPLES)
		MAXSAMPLES = 10;
	var tickindex = 0;
	var ticksum = 0;
	var numTicks = 0;
	var ticklist = [];
	for (var i = 0; i < MAXSAMPLES; i++)
		ticklist.push(0);
	this.Add = function (newValue)
	{
		if (newValue !== null)
		{
			ticksum -= ticklist[tickindex];  // subtract value falling off
			ticksum += newValue;              // add new value
			ticklist[tickindex] = newValue;   // save new value so it can be subtracted later
			if (++tickindex == MAXSAMPLES)   // inc buffer index
				tickindex = 0;
			if (numTicks < MAXSAMPLES)
				numTicks++;
		}
	}
	this.Get = function ()
	{
		if (numTicks == 0)
			return 0;
		return (ticksum / numTicks);
	}
}
/////////////////////////////////////////////////////////////
// Efficient Timed Average Calculator ///////////////////////
/////////////////////////////////////////////////////////////
/**
 * Calculates the average of values provided for a limited time. The timer starts upon the first Add operation. The Add method becomes a no-op when the timer reaches time time limit and [minRecords] or more items have been added.
 * @param {Number} maxMs Time limit.
 * @param {Number} minRecords Minimum number of records to keep.
 */
function TimedAverage(maxMs, minRecords)
{
	var self = this;
	var itemCount = 0;
	var sum = 0;
	var endTime = -1;
	this.done = false;
	this.Add = function (newValue)
	{
		if (!self.done && newValue !== null)
		{
			if (endTime == -1)
				endTime = performance.now() + maxMs;
			if (performance.now() < endTime || itemCount < minRecords)
			{
				sum += newValue;
				itemCount++;
				return true;
			}
			self.done = true;
			return false;
		}
	}
	this.Get = function ()
	{
		if (itemCount == 0)
			return 0;
		return (sum / itemCount);
	}
}
///////////////////////////////////////////////////////////////
// Failure Limiter ////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function FailLimiter(maxFailsInTimePeriod, timePeriodMs)
{
	var self = this;
	var queue = new Queue();
	var sum = 0;

	this.Fail = function ()
	{
		queue.enqueue(performance.now());
		return self.IsLimiting();
	}
	this.IsLimiting = function ()
	{
		cleanup();
		return queue.getLength() > maxFailsInTimePeriod;
	}

	var cleanup = function ()
	{
		var now = performance.now();
		while (!queue.isEmpty() && now - queue.peek() > timePeriodMs)
			queue.dequeue();
	}
}
///////////////////////////////////////////////////////////////
// Custom Events //////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var BI_CustomEvent =
{
	customEventRegistry: new Object(),
	AddListener: function (eventName, eventHandler)
	{
		if (typeof this.customEventRegistry[eventName] == "undefined")
			this.customEventRegistry[eventName] = new Array();
		this.customEventRegistry[eventName].push(eventHandler);
		return function () { BI_CustomEvent.RemoveListener(eventName, eventHandler); }
	},
	RemoveListener: function (eventName, eventHandler)
	{
		if (typeof this.customEventRegistry[eventName] == "undefined")
			return;
		var handlers = this.customEventRegistry[eventName];
		var idx = handlers.indexOf(eventHandler);
		if (idx > -1)
		{
			var handler = handlers[idx];
			if (handler.isExecutingEventHandlerNow)
				handler.removeEventHandlerWhenFinished = true;
			else
				handlers.splice(idx, 1);
		}
	},
	Invoke: function (eventName, args)
	{
		if (typeof this.customEventRegistry[eventName] != "undefined")
			for (var i = 0; i < this.customEventRegistry[eventName].length; i++)
				try
				{
					var handler = this.customEventRegistry[eventName][i];
					handler.isExecutingEventHandlerNow = true;
					handler(args);
					handler.isExecutingEventHandlerNow = false;
					if (handler.removeEventHandlerWhenFinished)
					{
						this.customEventRegistry[eventName].splice(i, 1);
						i--;
					}
				}
				catch (ex)
				{
					toaster.Error(ex);
				}
	}
};
///////////////////////////////////////////////////////////////
// Session Timeout ////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function SessionTimeout()
{
	var self = this;
	var idleTimer = null;
	var timerStarted = performance.now();

	var idleLogoff = function ()
	{
		if (getTimeoutMs() > 0)
		{
			currentServer.isLoggingOut = true;
			var path = RemoveUrlParams("session");
			if (path.length > location.origin.length)
				path = path.substr(location.origin.length);
			location.href = 'timeout.htm?path=' + encodeURIComponent(path) + currentServer.GetAPISessionArg("&");
		}
	}

	var resetTimer = function ()
	{
		if (idleTimer != null)
			clearTimeout(idleTimer);
		if (getTimeoutMs() > 0)
		{
			timerStarted = performance.now();
			idleTimer = setTimeout(idleLogoff, getTimeoutMs());
		}
	}

	var getTimeoutMs = function ()
	{
		var ms = parseFloat(settings.ui3_timeout) * 60 * 1000;
		if (ms > 0 && ms < 30000)
			return 30000;
		return ms;
	}
	/** Returns the number of milliseconds until idle timeout occurs, or the string "Idle timeout is not enabled". */
	this.GetMsUntilTimeout = function ()
	{
		if (getTimeoutMs() > 0)
		{
			var waited = performance.now() - timerStarted;
			return getTimeoutMs() - waited;
		}
		return "Idle timeout is not enabled";
	}

	$(document.body).bind('mousemove keydown click', resetTimer);
	resetTimer();
}
///////////////////////////////////////////////////////////////
// Loading Helper /////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function LoadingHelper()
{
	var self = this;
	var loadingFinished = false;
	var loadingFinishedAtServerTime = 0;
	var things =
		[
			// name, selector, isLoaded
			["window", "#loadingWebContent", false]
			, ["cameraList", "#loadingCameraList", false]
			, ["status", "#loadingServerStatus", false]
			, ["login", "#loadingLogin", false]
			, ["svg", "#loadingSVG", false]
			, ["h264", "#loadingH264", false]
			, ["startupClip", "#loadingStartupClip", false]
			, ["timeline", "#loadingTimeline", false]
		];

	this.SetLoadedStatus = function (name)
	{
		var thing = GetThing(name);
		if (thing[2])
			return;
		thing[2] = true;
		var loadingStatusObj = $(thing[1]);
		if (loadingStatusObj.length > 0)
		{
			loadingStatusObj.html("OK");
			loadingStatusObj.css("color", "#00CC00");
		}
		FinishLoadingIfConditionsMet();
	}
	this.SetErrorStatus = function (name, errorMessage, reloadTimeoutMs)
	{
		var thing = GetThing(name);
		var loadingStatusObj = $(thing[1]);
		if (loadingStatusObj.length > 0)
		{
			loadingStatusObj.html("FAIL");
			loadingStatusObj.css("color", "#CC0000");
		}

		if (reloadTimeoutMs === true)
			reloadTimeoutMs = 3000;
		else if (typeof reloadTimeoutMs === undefined || reloadTimeoutMs === false || reloadTimeoutMs < 0)
			reloadTimeoutMs = -1;

		var eventArg = { reloadTimeoutMs: reloadTimeoutMs, showErrorToast: true };
		BI_CustomEvent.Invoke("UI_Loading_Failed", eventArg);

		if (typeof errorMessage === "undefined" || !errorMessage)
			errorMessage = "UI3 failed to load.";
		if (!errorMessage.endsWith("."))
			errorMessage += ".";
		if (eventArg.reloadTimeoutMs >= 0)
		{
			errorMessage += "  Reloading momentarily...";
			setTimeout(ReloadInterface, eventArg.reloadTimeoutMs);
		}
		if (eventArg.showErrorToast)
			toaster.Error(errorMessage, 600000);
	}
	var GetThing = function (name)
	{
		for (var i = 0; i < things.length; i++)
			if (things[i][0] === name)
				return things[i];
		return null;
	}
	var FinishLoadingIfConditionsMet = function ()
	{
		if (loadingFinished)
			return;
		for (var i = 0; i < things.length; i++)
			if (!things[i][2])
				return;
		if (inputRequiredOverlay.IsActive())
		{
			inputRequiredOverlay.AddListener(FinishLoadingIfConditionsMet);
			return;
		}
		ajaxHistoryManager = new AjaxHistoryManager();
		loadingFinished = true;
		loadingFinishedAtServerTime = GetUtcNow();
		$("#loadingmsgwrapper").remove();
		$("body").removeClass("uiIsLoading");
		resized();
		videoPlayer.Initialize();
		ShowIEWarning();
		BI_CustomEvent.RemoveListener("UI_Settings_Closing", uiSettingsClosingHandler);
		BI_CustomEvent.Invoke("FinishedLoading");
	}
	this.DidLoadingFinish = function ()
	{
		return loadingFinished;
	}
	this.GetLoadingFinishedTime = function ()
	{
		return loadingFinishedAtServerTime;
	}
	function uiSettingsClosingHandler()
	{
		$("#loadingmsgwrapper").css("z-index", 99999);
		$("body").addClass("uiIsLoading");
	}
	var loadingStallTimeout = setTimeout(function ()
	{
		BI_CustomEvent.AddListener("UI_Settings_Closing", uiSettingsClosingHandler);
		var $btn = $('<div class="loadinglabel" style="text-align:center"><a href="javascript:void(0)" style="color:#8DF;padding:2px 0px">Open UI Settings</a></div>');
		$btn.find("a").on("click", function ()
		{
			$("#loadingmsgwrapper").css("z-index", 999);
			$("body").removeClass("uiIsLoading");
			uiSettingsPanel.open();
		});
		$("#loadingmsgwrapper .loadingmsgcontent").append($btn);
	}, 3000);

	$(window).load(function ()
	{
		self.SetLoadedStatus("window");
	});
}
var ieWarningToast = null;
function ShowIEWarning()
{
	if (BrowserIsIE() && settings.ui3_disableIEWarning !== "1")
	{
		ieWarningToast = toaster.Info('<div>UI3 works poorly in Internet Explorer.<br><br>For a better experience, try one of these browsers: <br><br>'
			+ '<a target="_blank" href="https://www.google.com/chrome"><div class="browserIcon"><svg class="icon noflip"><use xlink:href="#svg_chrome"></use></svg></div>Google Chrome</a>'
			+ '<br>'
			+ '<a target="_blank" href="https://www.microsoft.com/edge/"><div class="browserIcon"><svg class="icon noflip"><use xlink:href="#edge_logo"></use></svg></div>Edge (Chromium-based)</a>'
			+ '<br>'
			+ '<br>'
			+ '<input type="button" value="Ignore once" onclick="IgnoreIEWarning()" />'
			+ '<br>'
			+ '<br>'
			+ '<input type="button" value="Do not show again" onclick="DisableIEWarning()" />'
			+ '</div>', 60000, true);
	}
}
function IgnoreIEWarning()
{
	if (ieWarningToast)
		ieWarningToast.remove();
}
function DisableIEWarning()
{
	settings.ui3_disableIEWarning = "1";
	IgnoreIEWarning();
}
///////////////////////////////////////////////////////////////
// Logging ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
if (!console)
	window.console = {};
if (typeof console.log !== "function")
	console.log = function () { };
if (typeof console.error !== "function")
	console.error = function () { };
///////////////////////////////////////////////////////////////
// Object To Html Table ///////////////////////////////////////
///////////////////////////////////////////////////////////////
function ArrayToHtmlTable(a)
{
	var $table = $("<table></table>");
	var $thead = $("<thead></thead>");
	var $theadrow = $("<tr></tr>");
	var $tbody = $("<tbody></tbody>");
	$thead.append($theadrow);
	$table.append($thead);
	$table.append($tbody);
	var columnSpec = new Object();
	var columnIdx = 0;
	for (var i = 0; i < a.length; i++)
	{
		for (var key in a[i])
		{
			if (Object.prototype.hasOwnProperty.call(a[i], key))
			{
				if (typeof columnSpec[key] == "undefined")
				{
					$theadrow.append($("<th></th>").text(key));
					columnSpec[key] = columnIdx++;
				}
			}
		}
	}
	for (var i = 0; i < a.length; i++)
	{
		var newRow = new Object();
		for (var key in a[i])
		{
			if (Object.prototype.hasOwnProperty.call(a[i], key))
			{
				var value = a[i][key];
				var idx = columnSpec[key];
				newRow[idx] = value;
			}
		}
		var $row = $("<tr></tr>");
		for (var n = 0; n < columnIdx; n++)
		{
			if (typeof newRow[n] == "undefined")
				$row.append("<td></td>");
			else
				$row.append($("<td></td>").text(newRow[n]));
		}
		$tbody.append($row);
	}
	return $table;
}
///////////////////////////////////////////////////////////////
// Save Images to Local Storage ///////////////////////////////
///////////////////////////////////////////////////////////////
function ImageToDataUrl(imgEle, contentType)
{
	if (!contentType)
		contentType = "image/jpeg";
	var imgCanvas = document.createElement("canvas");

	// Make sure canvas is as big as the picture
	imgCanvas.width = imgEle.naturalWidth;
	imgCanvas.height = imgEle.naturalHeight;

	// Draw image into canvas element
	var imgContext = imgCanvas.getContext("2d");
	imgContext.drawImage(imgEle, 0, 0, imgEle.naturalWidth, imgEle.naturalHeight);

	return imgCanvas.toDataURL(contentType);
}
/**
 * Creates a jpeg data URI from the specified video, image, or canvas element.
 * @param {any} ele video or canvas element
 */
function GetSnapshotDataUri(ele, contentType)
{
	if (!contentType)
		contentType = "image/jpeg";
	if (ele.tagName === "IMAGE")
		return ImageToDataUrl(ele, contentType);
	var imgCanvas;
	if (ele.tagName === "CANVAS")
		imgCanvas = ele;
	else if (ele.tagName === "VIDEO")
	{
		imgCanvas = document.createElement("canvas");
		imgCanvas.width = ele.videoWidth;
		imgCanvas.height = ele.videoHeight;
		var imgContext = imgCanvas.getContext("2d");
		imgContext.drawImage(ele, 0, 0, ele.videoWidth, ele.videoHeight);
	}
	return imgCanvas.toDataURL(contentType);
}
function PersistImageFromUrl(settingsKey, url, onSuccess, onFail)
{
	if (!isCanvasSupported())
	{
		if (onFail)
			onFail("Browser does not support the Canvas element.");
		return;
	}
	var tries = 0;
	var tmpImg = document.createElement("img");
	tmpImg.crossOrigin = "Anonymous";
	var $tmpImg = $(tmpImg);
	$tmpImg.load(function ()
	{
		if (!this.complete || typeof this.naturalWidth == "undefined" || this.naturalWidth == 0)
		{
			// Failed
			if (tries++ < 2)
				$tmpImg.attr("src", url);
			else
			{
				$tmpImg.remove();
				if (onFail)
					onFail("Image was invalid.");
			}
		}
		else
		{

			// Get canvas contents as a data URL
			var imgAsDataURL = ImageToDataUrl(tmpImg);

			$tmpImg.remove();

			// Save image into settings
			try
			{
				settings.setItem(settingsKey, imgAsDataURL);
			}
			catch (e)
			{
				// either the settings object does not exist or it is full
				if (onFail)
					onFail("Local Storage may be full!");
				return;
			}

			if (onSuccess)
				onSuccess(imgAsDataURL);
		}
	});
	$tmpImg.error(function ()
	{
		if (tries++ < 2)
			$tmpImg.attr("src", url);
		else
		{
			$tmpImg.remove();
			if (onFail)
				onFail("Unable to load image from server.");
		}
	});
	$tmpImg.attr("src", url);
}
///////////////////////////////////////////////////////////////
// Load jpeg images with HTTP headers /////////////////////////
///////////////////////////////////////////////////////////////
/**
 * Loads the specified resource as a Data URI and provides access to the response headers.
 * Returns a promise that resolves with { dataUri: "...", headers: { key: value } }
 * Most rejections will include an argument that has status and statusText fields.
 * @param {String} url URL of any resource that can be downloaded and converted into a Data URI.
 */
function DownloadToDataUri(url)
{
	return new Promise(function (resolve, reject)
	{
		// Handles most browsers with a fallback for IE9
		var hasUint8Array = !!window.Uint8Array;
		if (!window.Uint8Array && !window.VBArray)
		{
			reject({ status: 0, statusText: "Unsupported web browser" });
			return;
		}
		var xhr = new XMLHttpRequest();
		xhr.open("GET", url, true);
		if (hasUint8Array)
			xhr.responseType = "arraybuffer";
		xhr.onload = function ()
		{
			if (xhr.status >= 200 && xhr.status < 300)
			{
				var arr;
				var dataUri;
				//var start = performance.now();
				if (hasUint8Array)
				{
					arr = new Uint8Array(xhr.response);
					var imgData = new Blob([arr], { type: "application/octet-binary" });
					dataUri = URL.createObjectURL(imgData);
				}
				else
				{
					arr = xhr.responseBody.toArray();
					dataUri = "data:image/jpg;base64," + base64Array(arr);
				}
				//var end = performance.now();
				//console.log(arr.length + " bytes to base64 took " + (end - start).toFixed(1) + "ms");
				var headerStr = xhr.getAllResponseHeaders();
				var headerArr = headerStr.trim().split(/[\r\n]+/);
				var headerMap = {};
				for (var i = 0; i < headerArr.length; i++)
				{
					var parts = headerArr[i].split(': ');
					var header = parts.shift().toLowerCase();
					var value = parts.join(': ');
					headerMap[header] = value;
				}
				resolve({ dataUri: dataUri, headers: headerMap, imageSizeBytes: arr.length });
			}
			else
				reject({ status: xhr.status, statusText: xhr.statusText });
		};
		xhr.onerror = function ()
		{
			var failure = { status: xhr.status, statusText: xhr.statusText };
			if (failure.status === 0 && !failure.statusText)
				failure.statusText = "Connection timed out";
			reject(failure);
		};
		xhr.send();
	});
}
/**
 * Loads the image described by the specified Uri. Also accepts a headers object which will be passed through to the resolve or reject handlers of the promise.
 * Returns a promise that resolves or rejects with the argument { image: HTMLImageElement, headers: headers }
 * @param {String} url Image Uri
 * @param {Object} headers Optional object containing HTTP headers to deliver along with the final image.
 * @param {Number} imageSizeBytes Size of the image, in bytes. Omit if unknown.
 */
function LoadImagePromise(url, headers, imageSizeBytes)
{
	return new Promise(function (resolve, reject)
	{
		var image = new Image();
		image.setAttribute("crossOrigin", "Anonymous");
		image.onload = function ()
		{
			if (url.substr(0, 5) === "blob:")
				URL.revokeObjectURL(url);
			if (image.complete && image.naturalWidth && image.naturalHeight)
				resolve({ image: image, headers: headers, imageSizeBytes: imageSizeBytes });
			else
				reject({ image: image, headers: headers, imageSizeBytes: imageSizeBytes });
		};
		image.onerror = function ()
		{
			if (url.substr(0, 5) === "blob:")
				URL.revokeObjectURL(url);
			reject({ image: image, headers: headers, imageSizeBytes: imageSizeBytes });
		};
		image.src = url;
	});
}
///////////////////////////////////////////////////////////////
// Fetch /video/ h.264 streaming //////////////////////////////
///////////////////////////////////////////////////////////////
function SynchronousStreamFetcher()
{
	// This object makes sure only one fetch connection is open at a time, to keep from overloading Blue Iris.
	// And to (slightly) reduce the risk of this bug:
	// (as of 2016/2017) Opening fetch objects too rapidly results in some connections getting stuck in "pending" 
	// state and access to the server is blocked until the page is refreshed.  This is a Chrome bug, because when I 
	// proxied all connections through fiddler, the "pending" connection never even made it out of Chrome.
	//
	// I'm tentatively declaring this bug SQUASHED since requiring that the first chunk of data be read from the 
	// fetch stream before it can be canceled.
	var self = this;
	var streamer;
	var queuedRequest = null;
	var stopTimeout = null;
	var streamEndedCbForActiveFetch = null;
	this.OpenStream = function (url, headerCallback, frameCallback, statusBlockCallback, streamInfoCallback, streamEnded, options)
	{
		developerLog("safeFetch.OpenStream", url);
		queuedRequest = { url: url, headerCallback: headerCallback, frameCallback: frameCallback, statusBlockCallback: statusBlockCallback, streamInfoCallback: streamInfoCallback, streamEnded: streamEnded, options: options, activated: false };
		if (streamer)
		{
			// A fetch stream is currently active.  Try to stop it.
			streamer.StopStreaming();
			if (stopTimeout == null)
				stopTimeout = setTimeout(StopTimedOut, 15000);
		}
		else
			OpenStreamNow();
	}
	this.CloseStream = function ()
	{
		// Disable any queued request, because the caller is expecting to not receive any frames after calling CloseStream
		if (queuedRequest)
			queuedRequest.activated = true;
		if (streamer)
			streamer.StopStreaming();
	}
	this.IsActive = function ()
	{
		return streamer ? true : false;
	}
	var OpenStreamNow = function ()
	{
		if (queuedRequest.activated)
			return;
		if (stopTimeout != null)
		{
			clearTimeout(stopTimeout);
			stopTimeout = null;
		}
		queuedRequest.activated = true;
		streamEndedCbForActiveFetch = queuedRequest.streamEnded;
		streamer = new FetchVideoH264Streamer(queuedRequest.url, queuedRequest.headerCallback, queuedRequest.frameCallback, queuedRequest.statusBlockCallback, queuedRequest.streamInfoCallback, StreamEndedWrapper, queuedRequest.options);
	}
	var StreamEndedWrapper = function (message, wasJpeg, wasAppTriggered, videoFinishedStreaming, responseError, isSessionLoss)
	{
		if (stopTimeout != null)
		{
			clearTimeout(stopTimeout);
			stopTimeout = null;
		}
		streamer = null;
		if (streamEndedCbForActiveFetch)
			streamEndedCbForActiveFetch(message, wasJpeg, wasAppTriggered, videoFinishedStreaming, responseError, isSessionLoss);
		OpenStreamNow();
	}
	var StopTimedOut = function ()
	{
		stopTimeout = null;
		toaster.Error('Video streaming connection stuck open! You should reload the page.', 600000, true);
	}
}
var safeFetch = new SynchronousStreamFetcher();
function FetchVideoH264Streamer(url, headerCallback, frameCallback, statusBlockCallback, streamInfoCallback, streamEnded, options)
{
	var self = this;
	var UINT32_MAX = 4294967296;
	var cancel_streaming = false;
	var stopCalledByApp = false;
	var reader = null;

	// Since at any point we may not have received enough data to finish parsing, we will keep track of parsing progress via a state integer.
	// State 0: Waiting for first 6 bytes of stream header to be available:
	//		DWORD 'blue'
	//		BYTE streams ... 1 for video only, 2 for both audio and video
	//		BYTE size of header total
	// State 1: Waiting for entire header to be available, length determined by 6th byte read in state 0
	// State 2: Waiting for first 5 bytes of block header to be available.
	//		DWORD 'Blue'
	//		BYTE type ... 0 = video, 1 = audio, 2 = status
	// State 3: Waiting for entire block header to be available, length determined by its type.
	// State 4: Waiting for entire audio or video frame data chunk to be available.
	var state = 0;
	var myStream = new GhettoStream();
	var availableStreams = 0; // 1 for video only, 2 for audio and video
	var streamHeaderSize = 0;
	var blockType = -1;
	var baseVideoFrameTime = -1;
	var lastVideoFrameTime = -1;
	var currentVideoFrame = { pos: 0, time: 0, rawtime: 0, utc: 0, size: 0 };
	var currentAudioFrame = { size: 0 };
	var statusBlockSize = 0;
	var bitmapHeader = null;
	var audioHeader = null;
	var abort_controller = null;
	var responseError = null;

	options = $.extend({
		timestampScale: 1
	}, options);

	this.StopStreaming = function ()
	{
		stopCalledByApp = true;
		stopStreaming_Internal();
	}
	var stopStreaming_Internal = function ()
	{
		cancel_streaming = true;
		// Aborting the AbortController must happen first, or else some versions of MS Edge leave the stream open in the background.
		if (abort_controller)
		{
			abort_controller.abort();
			abort_controller = null;
		}
		if (reader)
		{
			myStream = new GhettoStream(); // This is mostly just to release any data stored in the old stream.
			var cancelPromise = reader.cancel("Streaming canceled");
			if (cancelPromise && cancelPromise["catch"])
				cancelPromise["catch"](function (e)
				{
					if (DOMException && DOMException.ABORT_ERR && e && e.code === DOMException.ABORT_ERR)
					{
						// Expected result. Don't spam console.
					}
					else if (DOMException && DOMException.INVALID_STATE_ERR && e && e.code === DOMException.INVALID_STATE_ERR)
					{
						// Expected result in MS Edge.
					}
					else
						console.error(e);
				});
			reader = null;
		}
	}
	var Start = function ()
	{
		var startTime = performance.now();

		var fetchArgs = { credentials: "same-origin" };
		if (typeof AbortController == "function")
		{
			// FF 57+, Edge 16+ (in theory)
			// Broken in Edge 17.x and 18.x (connection stays open)
			// Unknown when it will be fixed
			abort_controller = new AbortController();
			fetchArgs.signal = abort_controller.signal;
		}
		fetch(url, fetchArgs).then(function (res)
		{
			try
			{
				if (res.status === 0)
				{
					responseError = res.status + " " + res.statusText;
					HandleGroupableConnectionError();
					CallStreamEnded("Server unreachable");
				}
				else if (res.status === 403)
				{
					responseError = res.status + " " + res.statusText;
					CallStreamEnded("Your session has been lost.", undefined, undefined, true);
				}
				//else if (res.redirected || (res.status && res.status.toString().startsWith("3")))
				//{
				//	// This will be problematic if the server redirects the video request for any other reason than session loss.
				//	if (res.redirected)
				//		responseError = "0 fetch redirected";
				//	else
				//		responseError = res.status + " " + res.statusText;
				//	var contentType = res.headers.get("Content-Type");
				//	var isSessionLoss = typeof contentType !== "string" || !contentType.startsWith("video");
				//	CallStreamEnded("Your session has been lost.", undefined, undefined, isSessionLoss);
				//}
				else if (res.status === 503)
				{
					responseError = res.status + " " + res.statusText;
					HandleGroupableConnectionError();
					CallStreamEnded("Server responded saying service is unavailable");
				}
				else
				{
					try
					{
						headerCallback(res.headers);
					}
					catch (e)
					{
						toaster.Error(e);
					}

					if (res.headers.get("Content-Type") == "image/jpeg")
					{
						var blobPromise = res.blob();
						blobPromise.then(function (jpegBlob)
						{
							try
							{
								if (!currentServer.isUsingRemoteServer && parseInt(res.headers.get("Content-Length")) != jpegBlob.size)
								{
									// Apparently we aren't allowed to read the Content-Length header if this is a remote server.
									CallStreamEnded("fetch graceful exit (jpeg incomplete)", true, true);
									return;
								}
								var jpegObjectURL = URL.createObjectURL(jpegBlob);
								try
								{
									CallFrameCallback({ startTime: startTime, jpeg: jpegObjectURL, isVideo: true }, 1);
								}
								catch (e)
								{
									toaster.Error(e);
								}
								CallStreamEnded("fetch graceful exit (jpeg)", true, true);
							}
							catch (e)
							{
								toaster.Error(e);
							}
						}
						)["catch"](function (e)
						{
							CallStreamEnded(e);
						});
						return blobPromise;
					}
					else
					{
						if (!res.ok)
							responseError = res.status + " " + res.statusText;
						// Do NOT return before the first reader.read() or the fetch can be left in a bad state!
						reader = res.body.getReader();
						return pump(reader);
					}
				}
			}
			catch (e)
			{
				toaster.Error(e);
			}
		})["catch"](function (e)
		{
			try
			{
				CallStreamEnded(e);
			}
			catch (e)
			{
				toaster.Error(e);
			}
		});
	}
	function CallStreamEnded(message, naturalEndOfStream, wasJpeg, isSessionLoss)
	{
		if (typeof streamEnded === "function")
		{
			try
			{
				streamEnded(message, wasJpeg, stopCalledByApp, naturalEndOfStream, responseError, isSessionLoss);
			}
			catch (e)
			{
				if (typeof message == "object" && typeof message.stack == "string")
					message = message.stack;
				var e2 = e;
				if (typeof e2 == "object" && typeof e2.stack == "string")
					e2 = e2.stack;
				toaster.Error("An unhandled error occurred while handling the end-of-stream event: " + htmlEncode(e2) + "<br>The stream ended because: " + htmlEncode(message));
			}
		}
		streamEnded = null;
	}
	function CallFrameCallback()
	{
		try
		{
			frameCallback.apply(this, arguments);
		}
		catch (e)
		{
			toaster.Error(e);
		}
	}
	function protocolError(error)
	{
		stopStreaming_Internal();
		toaster.Error("Protocol Error: " + error);
		CallStreamEnded("/video/ Protocol Error: " + error);
	}

	function pump()
	{
		// Do NOT return before the first reader.read() or the fetch can be left in a bad state!
		// Except if reader is null of course.
		if (reader == null)
			return;
		reader.read().then(function (result)
		{
			try
			{
				if (result.done)
				{
					CallStreamEnded("fetch graceful exit (type 1)");
					return;
				}
				else if (cancel_streaming)
				{
					stopStreaming_Internal();
					CallStreamEnded("fetch graceful exit (type 2)");
					return;
				}

				myStream.Write(result.value);

				while (myStream) // was "while (true)" but eslint doesn't like that.
				{
					if (cancel_streaming)
					{
						stopStreaming_Internal();
						CallStreamEnded("fetch graceful exit (type 3)");
						return;
					}
					if (state == 0) // Read Stream Header Start
					{
						var buf = myStream.Read(6);
						if (buf == null)
							return pump();

						// First 4 bytes are supposed to be ASCII "blue"
						if (buf[0] != 98 || buf[1] != 108 || buf[2] != 117 || buf[3] != 101)
							return protocolError("stream did not start with \"blue\"");

						availableStreams = buf[4];
						if (availableStreams != 1 && availableStreams != 2)
							return protocolError("availableStreams (" + availableStreams + ") was supposed to be 1 (video) or 2 (audio+video)");

						streamHeaderSize = buf[5];

						state = 1;
					}
					else if (state == 1) // Read Stream Header Remainder
					{
						var buf = myStream.Read(streamHeaderSize);
						if (buf == null)
							return pump();

						// Read BITMAPINFOHEADER structure
						var offsetWrapper = { offset: 0 };
						var bitmapHeaderSize = ReadUInt32LE(buf, offsetWrapper);
						offsetWrapper.offset -= 4; // Reverse the previous read so it will be included in the object.
						if (bitmapHeaderSize > 0)
							bitmapHeader = new BITMAPINFOHEADER(ReadSubArray(buf, offsetWrapper, bitmapHeaderSize));

						if (offsetWrapper.offset < streamHeaderSize)
						{
							// Audio stream was provided.
							// Assuming the remainder of the header is WAVEFORMATEX structure
							audioHeader = new WAVEFORMATEX(ReadSubArray(buf, offsetWrapper, streamHeaderSize - offsetWrapper.offset));
						}

						try
						{
							streamInfoCallback(bitmapHeader, audioHeader);
						}
						catch (e)
						{
							toaster.Error(e);
						}

						state = 2;
					}
					else if (state == 2) // Read Block Header Start
					{
						var buf = myStream.Read(5);
						if (buf == null)
							return pump();

						// First 4 bytes are supposed to be ASCII "Blue"
						if (buf[0] != 66 || buf[1] != 108 || buf[2] != 117 || buf[3] != 101)
							return protocolError("block did not start with \"Blue\"");

						blockType = buf[4];

						state = 3;
					}
					else if (state == 3) // Read Block Header Remainder
					{
						if (blockType == 0) // Video
						{
							var buf = myStream.Read(18); // 2 + 4 + 8 + 4
							if (buf == null)
								return pump();
							var offsetWrapper = { offset: 0 };
							currentVideoFrame.pos = ReadUInt16(buf, offsetWrapper);
							currentVideoFrame.rawtime = ReadUInt32(buf, offsetWrapper); // Position of the frame relative to the start of the clip
							currentVideoFrame.time = currentVideoFrame.rawtime; // After below computation, this will be the playback clock timestamp at which to render the frame.
							currentVideoFrame.utc = ReadUInt64LE(buf, offsetWrapper);
							currentVideoFrame.size = ReadUInt32(buf, offsetWrapper);

							{
								// As of Sept 2020, frame times no longer always start from 0.

								if (baseVideoFrameTime === -1)
									baseVideoFrameTime = currentVideoFrame.time;

								if (lastVideoFrameTime != -1)
								{
									// If time jumped backwards more than one billion milliseconds, assume the UINT32 overflowed to 0.
									if (lastVideoFrameTime - 1000000000 > currentVideoFrame.time)
										baseVideoFrameTime -= UINT32_MAX;
									// If time jumped forward more than one billion milliseconds, assume the UINT32 overflowed to UINT32_MAX.
									if (lastVideoFrameTime + 1000000000 < currentVideoFrame.time)
										baseVideoFrameTime += UINT32_MAX;
								}
								lastVideoFrameTime = currentVideoFrame.time;

								currentVideoFrame.time -= baseVideoFrameTime;
								if (options.timestampScale !== 0)
									currentVideoFrame.time = Math.round(currentVideoFrame.time / options.timestampScale);
								currentVideoFrame.time = Math.abs(currentVideoFrame.time);
							}


							if (currentVideoFrame.size > 10000000)
								return protocolError("Video frame size of " + currentVideoFrame.size + " was rejected.");

							state = 4;
						}
						else if (blockType == 1) // Audio
						{
							var buf = myStream.Read(4);
							if (buf == null)
								return pump();

							currentAudioFrame.size = ReadInt32(buf, { offset: 0 });
							if (currentAudioFrame.size > 2000000)
								return protocolError("Audio frame size of " + currentAudioFrame.size + " was rejected.");

							state = 4;
						}
						else if (blockType == 2) // Status
						{
							var buf = myStream.Read(1);
							if (buf == null)
								return pump();

							statusBlockSize = buf[0];

							if (statusBlockSize < 6)
								return protocolError("Status block size was invalid (" + statusBlockSize + ")!");

							state = 4;
						}
						else if (blockType == 4)
						{
							stopStreaming_Internal();
							CallStreamEnded("natural end of stream", true);
							return;
						}
						else
							return protocolError("Unknown block type " + blockType + " at state " + state);
					}
					else if (state == 4) // Read AV frame data
					{
						if (blockType == 0) // Video
						{
							var buf = myStream.Read(currentVideoFrame.size);
							if (buf == null)
								return pump();

							bitRateCalc_Video.AddDataPoint(currentVideoFrame.size);

							CallFrameCallback(new BIVideoFrame(buf, currentVideoFrame), availableStreams);

							state = 2;
						}
						else if (blockType == 1) // Audio
						{
							var buf = myStream.Read(currentAudioFrame.size);
							if (buf == null)
								return pump();

							bitRateCalc_Audio.AddDataPoint(currentAudioFrame.size);

							CallFrameCallback(new BIAudioFrame(buf, audioHeader), availableStreams);

							state = 2;
						}
						else if (blockType == 2) // Status
						{
							var buf = myStream.Read(statusBlockSize - 6); // We already read the first 6 bytes ['B', 'L', 'U', 'E', 2, statusBlockSize]
							if (buf == null)
								return pump();

							var statusBlock = new StatusBlock(buf);

							try
							{
								statusBlockCallback(statusBlock);
							}
							catch (e)
							{
								toaster.Error(e);
							}

							state = 2;
						}
						else
							return protocolError("Unknown block type " + blockType + " at state " + state);
					}
				}
			}
			catch (e)
			{
				toaster.Error(e);
			}
		}
		)["catch"](function (e)
		{
			try
			{
				stopStreaming_Internal();
				CallStreamEnded(e);
			}
			catch (e)
			{
				toaster.Error(e);
			}
		});
	}

	try
	{
		Start();
	}
	catch (e)
	{
		toaster.Error(e);
	}
}
function StatusBlock(buf)
{
	var offsetWrapper = { offset: 0 };
	this.bRec = ReadByte(buf, offsetWrapper);
	this.bMotion = ReadByte(buf, offsetWrapper);
	this.bCheckFPS = ReadByte(buf, offsetWrapper);
	this.bTriggered = ReadByte(buf, offsetWrapper);
	this.bSignalLost = ReadByte(buf, offsetWrapper);

	this.bPushError = ReadByte(buf, offsetWrapper);
	this.bFlashError = ReadByte(buf, offsetWrapper);
	this.bForceMovie = ReadByte(buf, offsetWrapper);

	this.bOther0 = ReadByte(buf, offsetWrapper);
	this.bOther1 = ReadByte(buf, offsetWrapper);

	this.fps = ReadInt32(buf, offsetWrapper); // in 100ths
	this.apeak = ReadInt32(buf, offsetWrapper); // out of 32767
	this.tpause = ReadInt32(buf, offsetWrapper);
}
function BITMAPINFOHEADER(buf)
{
	var offsetWrapper = { offset: 0 };
	this.raw = buf;
	this.biSize = ReadUInt32LE(buf, offsetWrapper);
	this.biWidth = ReadInt32LE(buf, offsetWrapper); // Width in pixels
	this.biHeight = ReadInt32LE(buf, offsetWrapper); // Height in pixels
	this.biPlanes = ReadUInt16LE(buf, offsetWrapper); // Number of planes (always 1)
	this.biBitCount = ReadUInt16LE(buf, offsetWrapper); // Bits Per Pixel
	this.biCompression = ReadASCII(buf, offsetWrapper, 4); // "JPEG" or "MJPG" or "H264" (this can be ignored)
	this.biSizeImage = ReadUInt32LE(buf, offsetWrapper); // Image size in bytes
	this.biXPelsPerMeter = ReadInt32LE(buf, offsetWrapper);
	this.biYPelsPerMeter = ReadInt32LE(buf, offsetWrapper);
	this.biClrUsed = ReadUInt32LE(buf, offsetWrapper);
	this.biClrImportant = ReadUInt32LE(buf, offsetWrapper);
}
/** This is only loosely based on the WAVEFORMATEX structure. */
function WAVEFORMATEX(buf)
{
	this.raw = buf;
	var offsetWrapper = { offset: 0 };
	if (buf.length >= 14)
	{
		this.valid = true;
		this.wFormatTag = ReadUInt16LE(buf, offsetWrapper);
		this.nChannels = ReadUInt16LE(buf, offsetWrapper);
		this.nSamplesPerSec = ReadUInt32LE(buf, offsetWrapper);
		this.nAvgBytesPerSec = ReadUInt32LE(buf, offsetWrapper);
		this.nBlockAlign = ReadUInt16LE(buf, offsetWrapper);
		this.wBitsPerSample = 0;
		this.cbSize = 0;
		if (buf.length >= 18)
		{
			this.wBitsPerSample = ReadUInt16LE(buf, offsetWrapper);
			this.cbSize = ReadUInt16LE(buf, offsetWrapper);
		}
	}
	else
		this.valid = false;
}
function BIVideoFrame(buf, metadata)
{
	var self = this;
	this.meta = $.extend({}, metadata);
	this.isVideo = true;
	this.frameData = buf;
	/** The percentage position of this frame in the clip, represented as an integer between 0 and 10000. */
	this.pos = metadata.pos;
	/** Millisecond timestamp since the start of the video stream. */
	this.time = metadata.time;
	/** Timestamp in milliseconds since the unix epoch (UTC). */
	this.utc = metadata.utc;
	/** Size in bytes of the frame data. */
	this.size = metadata.size;
	var cachedIsKeyframe = 0;
	this.isKeyframe = function ()
	{
		if (cachedIsKeyframe === 1)
			return true;
		else if (cachedIsKeyframe === -1)
			return false;
		if (self.frameData && self.frameData.length > 0)
		{
			// The NALU type is the last 5 bits of the first byte after a start code.
			// This method will look in the first 1000 bytes to find a "VCL NALU" (types 1-5) and assume the 
			// first found indicates the frame type.
			var end = Math.min(self.frameData.length, 1001) - 1;
			var zeroBytes = 0;
			for (var i = 0; i < end; i++)
			{
				if (self.frameData[i] === 0)
					zeroBytes++;
				else
				{
					if (zeroBytes >= 2 && self.frameData[i] === 1)
					{
						// Identified a start code.  Check the NALU type.
						var NALU_Type = self.frameData[i + 1] & 31; // 31 is 0b00011111
						if (NALU_Type == 5) // This is a slice of a keyframe.
						{
							cachedIsKeyframe = 1;
							return true;
						}
						else if (0 < NALU_Type && NALU_Type < 5) // This is another frame type
						{
							cachedIsKeyframe = -1;
							return false;
						}
					}
					zeroBytes = 0;
				}
			}
		}
		return false;
	}
	/** True if this is a keyframe */
	this.keyframe = this.meta.keyframe = self.isKeyframe();
}
function BIAudioFrame(buf, formatHeader)
{
	var self = this;
	this.isAudio = true;
	this.frameData = buf;
	this.format = formatHeader;
	this.isKeyframe = function ()
	{
		return self.format.wFormatTag === 7;
	}
}
///////////////////////////////////////////////////////////////
// GhettoStream ///////////////////////////////////////////////
///////////////////////////////////////////////////////////////
/** A class which consumes Uint8Array objects and produces Uint8Array objects of whatever size you want by concatenating the inputs as needed. */
function GhettoStream()
{
	var self = this;
	var dataQueue = new Queue();
	var totalCachedBytes = 0;
	this.Count = function ()
	{
		return totalCachedBytes;
	};
	/** Writes the specified Uint8Array to the stream so it can be read later. */
	this.Write = function (newArray)
	{
		dataQueue.enqueue(newArray);
		totalCachedBytes += newArray.length;
	};
	/** Reads the specified number of bytes from the stream, returning null if not enough bytes are available yet. */
	this.Read = function (byteCount)
	{
		if (byteCount > totalCachedBytes)
			return null;

		var readBuf = new Uint8Array(byteCount);
		var alreadyRead = 0;
		var remainingToRead = byteCount - alreadyRead;

		while (remainingToRead > 0)
		{
			var chunk = dataQueue.peek();
			if (chunk.length > remainingToRead)
			{
				// This chunk will have left-overs.
				readBuf.set(chunk.subarray(0, remainingToRead), alreadyRead);
				dataQueue.replaceFront(chunk.subarray(remainingToRead));
				alreadyRead += remainingToRead;
			}
			else
			{
				// This entire chunk goes into the output buffer.
				readBuf.set(chunk, alreadyRead);
				dataQueue.dequeue();
				alreadyRead += chunk.length;
			}
			remainingToRead = byteCount - alreadyRead;
		}
		totalCachedBytes -= readBuf.length;
		return readBuf;
	};
}
///////////////////////////////////////////////////////////////
// Binary Reading /////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function ReadByte(buf, offsetWrapper)
{
	return buf[offsetWrapper.offset++];
}
function ReadUInt16(buf, offsetWrapper)
{
	var v = new DataView(buf.buffer, offsetWrapper.offset, 2).getUint16(0, false);
	offsetWrapper.offset += 2;
	return v;
}
function ReadUInt16LE(buf, offsetWrapper)
{
	var v = new DataView(buf.buffer, offsetWrapper.offset, 2).getUint16(0, true);
	offsetWrapper.offset += 2;
	return v;
}
function ReadInt16(buf, offsetWrapper)
{
	var v = new DataView(buf.buffer, offsetWrapper.offset, 2).getInt16(0, false);
	offsetWrapper.offset += 2;
	return v;
}
function ReadInt16LE(buf, offsetWrapper)
{
	var v = new DataView(buf.buffer, offsetWrapper.offset, 2).getInt16(0, true);
	offsetWrapper.offset += 2;
	return v;
}
function ReadUInt32(buf, offsetWrapper)
{
	var v = new DataView(buf.buffer, offsetWrapper.offset, 4).getUint32(0, false);
	offsetWrapper.offset += 4;
	return v;
}
function ReadUInt32LE(buf, offsetWrapper)
{
	var v = new DataView(buf.buffer, offsetWrapper.offset, 4).getUint32(0, true);
	offsetWrapper.offset += 4;
	return v;
}
function ReadInt32(buf, offsetWrapper)
{
	var v = new DataView(buf.buffer, offsetWrapper.offset, 4).getInt32(0, false);
	offsetWrapper.offset += 4;
	return v;
}
function ReadInt32LE(buf, offsetWrapper)
{
	var v = new DataView(buf.buffer, offsetWrapper.offset, 4).getInt32(0, true);
	offsetWrapper.offset += 4;
	return v;
}
function ReadUInt64(buf, offsetWrapper)
{
	// This is a hack because JavaScript only has 64 bit doubles with 53 bit int precision.
	// If a number were to be higher than 2 ^ 53, this method would return the wrong value.
	var mostSignificant = (ReadUInt32(buf, offsetWrapper) & 0x001FFFFF) * 4294967296;
	var leastSignificant = ReadUInt32(buf, offsetWrapper);
	return mostSignificant + leastSignificant;
}
function ReadUInt64LE(buf, offsetWrapper)
{
	// This is a hack because JavaScript only has 64 bit doubles with 53 bit int precision.
	// If a number were to be higher than 2 ^ 53, this method would return the wrong value.
	var leastSignificant = ReadUInt32LE(buf, offsetWrapper);
	var mostSignificant = (ReadUInt32LE(buf, offsetWrapper) & 0x001FFFFF) * 4294967296;
	return mostSignificant + leastSignificant;
}
function ReadASCII(buf, offsetWrapper, byteLength)
{
	var v = ASCIIArrayToStr(new Uint8Array(buf.buffer, offsetWrapper.offset, byteLength));
	offsetWrapper.offset += byteLength;
	return v;
}
function ASCIIArrayToStr(arr)
{
	var str = [];
	for (var i = 0; i < arr.length; i++)
	{
		str.push(String.fromCharCode(arr[i]));
	}
	return str.join('');
}
function ReadSubArray(buf, offsetWrapper, byteLength)
{
	var readBuf = new Uint8Array(byteLength);
	readBuf.set(buf.subarray(offsetWrapper.offset, offsetWrapper.offset += byteLength));
	return readBuf;
}
///////////////////////////////////////////////////////////////
// Stats For Nerds ////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function UI3NerdStats()
{
	var self = this;
	var objSizes = { panel: 0, statsRow: 0, statsName: 0, statsValue: 0, statsGraphValue: 0 };
	var dialog = null;
	var $root;
	var didRepositionAfterFirstDraw = false;
	var openedAt = 0;
	var isInitialized = false;
	var isUpdating = false;
	var hideOnEndUpdate = {};
	var statsRows = [];
	this.orderedStatNames =
		[
			"Viewport"
			, "Stream Resolution"
			, "Requested Res"
			, "Seek Position"
			, "Frame Time"
			, "Stream Timestamp"
			, "Video Player"
			, "Renderer"
			, "Codecs"
			, "Video Bit Rate"
			, "Audio Bit Rate"
			, "Audio Buffer"
			, "Frames since key"
			, "Frame Size"
			, "Inter-Frame Time"
			, "Frame Timing Error"
			, "Frame Rate"
			, "Src/Network Delay"
			, "Player Delay"
			, "Delayed Frames"
			, "Jpeg Bit Rate"
			, "Jpeg Frame Size"
			, "Jpeg Loading Time"
			, "Jpeg Frame Rate"
		];
	this.statClickEvents = [
		{ name: "Audio Bit Rate", handler: CreateAudioVisualizer },
		{ name: "Audio Buffer", handler: CreateAudioVisualizer }
	];
	this.Open = function ()
	{
		if (dialog)
			dialog.close();
		var windowWidth = window.innerWidth;
		objSizes.panel = 328 + Clamp(windowWidth - 700, 0, 68); // This allows the panel to expand by up to 68px if the window is wider than 700px.
		objSizes.statsRow = objSizes.panel - 8;
		objSizes.statsName = 105;
		objSizes.statsValue = objSizes.statsRow - objSizes.statsName - 15;
		objSizes.statsGraphValue = objSizes.statsValue - 68;
		didRepositionAfterFirstDraw = false;
		openedAt = performance.now();
		isInitialized = false;
		$root = $('<div class="statsForNerds" style="width: ' + objSizes.panel + 'px;">Video playback must start before stats are available.</div>');
		dialog = $root.dialog(
			{
				title: "Stats for nerds"
				, onClosing: function ()
				{
					dialog = null;
					statsRows = [];
				}
			});
	}
	var Initialize = function ()
	{
		if (isInitialized || !dialog)
			return;
		isInitialized = true;

		$root.empty();
		for (var i = 0; i < self.orderedStatNames.length; i++)
			CreateStat(self.orderedStatNames[i]);

		for (var i = 0; i < self.statClickEvents.length; i++)
		{
			var e = self.statClickEvents[i];
			if (e && typeof e.name === "string" && typeof e.handler === "function")
			{
				var row = statsRows[e.name];
				if (row)
				{
					row.GetRoot().on('click', e.handler);
					row.GetRoot().css('cursor', 'pointer');
				}
			}
		}
	}
	this.IsOpen = function ()
	{
		return dialog != null;
	}
	/**
	 * Creates a row for the specified statistic if it does not already exist.
	 * @param {String} name Row Name
	 */
	var CreateStat = function (name)
	{
		if (!dialog)
			return;
		var row = statsRows[name];
		if (!row)
		{
			row = statsRows[name] = new StatsRow(name, objSizes);
			$root.append(row.GetEleRef());
			dialog.contentChanged(false, true);
		}
	}
	/** Marks all rows to be hidden during [EndUpdate] unless their values are set during the update. */
	this.BeginUpdate = function ()
	{
		if (isUpdating)
			return;
		Initialize();
		isUpdating = true;
		hideOnEndUpdate = {};
		for (var i = 0; i < self.orderedStatNames.length; i++)
			hideOnEndUpdate[self.orderedStatNames[i]] = true;
	}
	/** Hides all rows that were not updated since [BeginUpdate] was called. */
	this.EndUpdate = function ()
	{
		if (!isUpdating)
			return;
		Initialize();
		isUpdating = false;
		var hidSome = false;
		for (var i = 0; i < self.orderedStatNames.length; i++)
			if (hideOnEndUpdate[self.orderedStatNames[i]])
			{
				if (statsRows[self.orderedStatNames[i]].Hide())
					hidSome = true;
			}
		if (hidSome)
			dialog.contentChanged(false, true);
		if (!didRepositionAfterFirstDraw && performance.now() - openedAt < 500)
		{
			dialog.contentChanged(true, true);
			didRepositionAfterFirstDraw = true;
		}
	}
	/**
	 * Adds or updates the value with the specified name.
	 * @param {String} name Row Name
	 * @param {any} value Raw value
	 * @param {any} htmlValue HTML-formatted value
	 * @param {Boolean} onGraph If true, graph the raw value.
	 * @param {String} graphColor This data point on the graph gets colored in this color.  If falsy, the default graph color is used.
	 */
	this.UpdateStat = function (name, value, htmlValue, onGraph, graphColor)
	{
		if (!dialog)
			return;
		Initialize();
		var row = statsRows[name];
		if (!row)
		{
			self.orderedStatNames.push(name);
			CreateStat(name);
			row = statsRows[name];
		}
		if (isUpdating)
			hideOnEndUpdate[name] = false;
		row.SetValue(value, htmlValue, onGraph, graphColor);
	}
	/**
	 * Immediately hides the specified row.  Designed to be called outside of an organized update.
	 * @param {String} name Row Name
	 */
	this.HideStat = function (name)
	{
		if (!dialog)
			return;
		Initialize();
		var row = statsRows[name];
		if (row)
			row.Hide();
	}
}
function StatsRow(name, objSizes)
{
	var self = this;
	var $root = $('<div class="statsRow" style="width: ' + objSizes.statsRow + 'px"></div>');
	var $name = $('<div class="statsName" style="width: ' + objSizes.statsName + 'px">' + name + '</div>');
	var $value = $('<div class="statsValue" style="width: ' + objSizes.statsValue + 'px"></div>');
	var $graphValue = $('<div class="statsGraphValue" style="width: ' + objSizes.statsGraphValue + 'px"></div>');
	var $htmlValue = $('<div class="statsHtmlValue"></div>');
	$value.append($graphValue).append($htmlValue);
	$root.append($name);
	$root.append($value);
	$root.hide();
	var currentValue = null;
	var hidden = true;
	var graph = null;

	this.SetValue = function (value, htmlValue, addToGraph, graphColor)
	{
		if (hidden)
		{
			hidden = false;
			$root.show();
		}
		currentValue = value;
		if (addToGraph && isNaN(value))
			return;
		if (typeof htmlValue == "undefined")
			htmlValue = htmlEncode(value);
		if (addToGraph)
		{
			CreateGraph();
			graph.AddValue(value, true, graphColor);
		}
		else
			DestroyGraph();
		if ($htmlValue.html() !== htmlValue)
			$htmlValue.html(htmlValue);
	}
	this.GetValue = function ()
	{
		return currentValue;
	}
	this.GetEleRef = function ()
	{
		return $root;
	}
	this.Hide = function ()
	{
		if (hidden)
			return false;
		hidden = true;
		$root.hide();
		return true;
	}
	this.Hidden = function ()
	{
		return hidden;
	}
	this.GetRoot = function ()
	{
		return $root;
	}
	var CreateGraph = function ()
	{
		if (graph)
			return;
		graph = new SimpleGraph();
		$graphValue.append(graph.Get$Canvas());
		$graphValue.css("display", "inline-block");
	}
	var DestroyGraph = function ()
	{
		if (!graph)
			return;
		$graphValue.empty();
		$graphValue.hide();
		graph = null;
	}
}
///////////////////////////////////////////////////////////////
// Simple Graph ///////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function SimpleGraph()
{
	var self = this;
	var $canvas = $('<canvas class="simpleGraph"></canvas>');
	var canvas = $canvas.get(0);
	var dpiScale = 2;//BI_GetDevicePixelRatio();
	var dataIndex = 0;
	var buffer = null;
	var previousMaximum;

	this.Get$Canvas = function ()
	{
		return $canvas;
	}
	this.AddValue = function (value, drawNow, graphColor)
	{
		if (!buffer)
			Refresh();
		if (dataIndex >= buffer.length)
			dataIndex = 0;
		buffer[dataIndex] = { value: value, graphColor: graphColor };
		dataIndex++;
		if (drawNow)
			Draw();
	}
	var Refresh = function ()
	{
		//dpiScale = BI_GetDevicePixelRatio(); // Rendering pixel-perfect on high DPI devices makes the graph harder to read because one pixel horizontally is one frame.
		var h = Math.ceil($canvas.height() * dpiScale);
		if (canvas.height != h)
			canvas.height = h;
		var w = Math.ceil($canvas.width() * dpiScale);
		if (canvas.width != w || !buffer)
		{
			canvas.width = w;
			var ctx = canvas.getContext("2d");
			ctx.translate(0.5, 0);
			ctx.imageSmoothingEnabled = false;
			var newBuffer = new Array(canvas.width);
			// CONSIDER: Handle buffer resizes, preserving as much recent data as possible.
			//if (buffer)
			//{
			//	for (var i = 0, l = Math.min(buffer.length, newBuffer.length); i < l; i++)
			//		newBuffer[i] = buffer[i];
			//}
			dataIndex = 0;
			buffer = newBuffer;
		}
		Draw();
	};
	var Draw = function ()
	{
		var w = canvas.width;
		if (buffer.length != w)
		{
			setTimeout(Refresh, 1);
			return;
		}
		var h = canvas.height;
		var ctx = canvas.getContext("2d");

		ctx.fillStyle = "#222222";
		ctx.fillRect(0, 0, w, h);
		ctx.lineWidth = 1;
		//var min = 9007199254740991;
		var max = 0;
		for (var i = 0; i < w; i++)
		{
			var item = buffer[i];
			if (item && item.value > max)
				max = item.value;
		}
		ctx.strokeStyle = "#aaaaaa";
		ctx.beginPath();
		var colored = new FasterObjectMap();
		for (var i = 0; i < w; i++)
		{
			var item = buffer[i];
			if (!item)
				continue;
			var v = item.value;
			if (v <= 0)
				continue;
			if (item.graphColor)
			{
				if (!colored[item.graphColor])
					colored[item.graphColor] = [];
				colored[item.graphColor].push(i);
			}
			var percentH = 1 - (v / max);
			var scaledH = percentH * h;
			ctx.moveTo(i, h);
			ctx.lineTo(i, scaledH);
		}
		for (var color in colored)
		{
			ctx.stroke();
			ctx.strokeStyle = color;
			ctx.beginPath();
			var itemIndices = colored[color];
			for (var n = 0; n < itemIndices.length; n++)
			{
				var i = itemIndices[n];
				var v = buffer[i].value;
				var percentH = 1 - (v / max);
				var scaledH = percentH * h;
				ctx.moveTo(i, h);
				ctx.lineTo(i, scaledH);
			}
		}
		ctx.stroke();
		ctx.strokeStyle = "#0097F0";
		ctx.lineWidth = dpiScale;
		ctx.beginPath();
		ctx.moveTo(dataIndex, 0);
		ctx.lineTo(dataIndex, h);
		ctx.stroke();
	}
}
///////////////////////////////////////////////////////////////
// Audio Visualizer ///////////////////////////////////////////
///////////////////////////////////////////////////////////////
var ui3AudioVisualizer = null;
function CreateAudioVisualizer()
{
	if (ui3AudioVisualizer)
		return;
	ui3AudioVisualizer = new UI3AudioVisualizer(function ()
	{
		ui3AudioVisualizer = null;
	});
}
function UI3AudioVisualizer(onDialogClosing)
{
	var self = this;
	var $dlg;
	var dialog;

	var graphs = [];

	var Initialize = function ()
	{
		$dlg = $('<div id="ui3AudioVisualizerPanel"></div>');
		dialog = $dlg.dialog({
			title: 'Audio Waveform Visualizer'
			, onClosing: function ()
			{
				for (var i = 0; i < graphs.length; i++)
					graphs[i].Stop();
				onDialogClosing();
			}
		});
	}
	/**
	 * Accepts audio buffers.
	 * @param {array} channels Array of audio channels, where each value is a Float32Array of raw audio data (range -1.0 to 1.0)
	 * @param {Number} sampleRate Sample rate (hz)
	 * @param {Number} currentTime Current playback clock time in seconds
	 * @param {Number} sampleTime Timestamp of the sample in seconds
	 * @param {Number} duration Sample duration in seconds
	 */
	this.AcceptBuffer = function (channels, sampleRate, currentTime, sampleTime, duration)
	{
		for (var n = 0; n < channels.length; n++)
		{
			var graph = graphs[n];
			if (!graph)
			{
				graphs[n] = graph = new AudioGraph();
				$dlg.append(graph.Get$Canvas());
			}
			graph.AddValues(channels[n], sampleRate, currentTime, sampleTime, duration);
		}
	}
	this.Reset = function ()
	{
		for (var i = 0; i < graphs.length; i++)
			graphs[i].Stop();
		graphs = [];
		$dlg.empty();
	}
	Initialize();
}
///////////////////////////////////////////////////////////////
// Audio Graph ////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var ui3AudioVisualizerSeconds = 2;
function AudioGraph()
{
	var self = this;
	var $canvas = $('<canvas class="audioGraph"></canvas>');
	var canvas = $canvas.get(0);
	var dpiScale = BI_GetDevicePixelRatio();
	var buffer = new Array();
	var timeLastFrame = 0;

	this.Get$Canvas = function ()
	{
		return $canvas;
	}
	this.Stop = function ()
	{
		$canvas = canvas = buffer = null;
	}
	this.AddValues = function (audio32, sampleRate, currentTime, sampleTime, duration)
	{
		if (!canvas)
			return;
		dpiScale = BI_GetDevicePixelRatio();

		var h = 256 * dpiScale;
		var w = Math.ceil(1024 * dpiScale);
		if (canvas.height != h)
			canvas.height = h;

		if (canvas.width != w)
		{
			canvas.width = w;

			var ctx = canvas.getContext("2d");
			ctx.translate(0.5, 0.5);
			ctx.imageSmoothingEnabled = false;
		}

		for (var i = 0; i < audio32.length; i++)
			buffer.push({ t: sampleTime + (duration * (i / audio32.length)), v: audio32[i] });
	}
	var Draw = function ()
	{
		if (!canvas)
			return;

		dpiScale = BI_GetDevicePixelRatio();

		var currentTime = pcmPlayer.GetCurrentTime();

		var renderAheadTime = 0;
		if (timeLastFrame > 0)
			renderAheadTime = (performance.now() - timeLastFrame) / 1000;
		timeLastFrame = performance.now();
		currentTime += renderAheadTime;

		// Y increases as we go down the screen
		var w = canvas.width;
		var h = canvas.height;
		var halfW = w / 2;
		var halfH = h / 2;
		var currentTimeDrawOffset = 2 / 3;

		var ctx = canvas.getContext("2d");

		ctx.fillStyle = "#000000";
		ctx.fillRect(0, 0, w, h);

		ctx.lineWidth = 2 * dpiScale;
		ctx.strokeStyle = "#0097F0";
		ctx.beginPath();
		ctx.moveTo(w * currentTimeDrawOffset, 0);
		ctx.lineTo(w * currentTimeDrawOffset, h);
		ctx.moveTo(0, halfH);
		ctx.lineTo(w, halfH);
		ctx.stroke();

		if (buffer)
		{
			var graphStartTime = currentTime - (ui3AudioVisualizerSeconds * currentTimeDrawOffset);
			var graphEndTime = graphStartTime + ui3AudioVisualizerSeconds;

			// Remove expired samples
			for (var i = 0; i < buffer.length; i++)
			{
				if (buffer[i].t >= graphStartTime)
				{
					if (i > 0)
						buffer.splice(0, i);
					break;
				}
			}

			var pixelsPerSecond = w / ui3AudioVisualizerSeconds;
			ctx.lineWidth = 1;
			ctx.strokeStyle = "#33aa33";
			ctx.beginPath();
			for (var i = 0; i < buffer.length; i++)
			{
				var sample = buffer[i];
				var timeOffset = sample.t - graphStartTime;
				var x = timeOffset * pixelsPerSecond;
				if (x > w)
					break;

				var y = halfH + (sample.v * -1 * h);
				if (i === 0)
					ctx.moveTo(x, y);
				ctx.lineTo(x, y);
			}
			ctx.stroke();
		}
		requestAnimationFrame(function () { requestAnimationFrame(Draw); });
	}
	requestAnimationFrame(Draw);
}
///////////////////////////////////////////////////////////////
// Drag and Drop //////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function DragAndDropHelper($list, onItemMoved)
{
	var self = this;
	var $items = $();
	var x = 0;
	var y = 0;
	var offsetX = 0;
	var offsetY = 0;
	var down = false;
	var drag = false;
	var moved = false;
	var $lastTouched = null;
	var $drag = null;
	var $blank = null;
	var $ghost = null;
	var startDragTimeout = null;
	var startDragHoldTimeMs = 500;

	this.Rebind = function ()
	{
		$items = $list.children();
		$items.each(RebindItem);
	}
	var RebindItem = function (idx, ele)
	{
		var $ele = $(ele);
		$ele.off('touchstart.ddh mousedown.ddh contextmenu.ddh');
		$ele.on('touchstart.ddh mousedown.ddh', function (e)
		{
			OnStart(e, $ele);
			return false;
		});
		$ele.on('contextmenu.ddh', function (e)
		{
			return false;
		});
	}
	var ClearDragTimeout = function ()
	{
		if (startDragTimeout)
		{
			clearTimeout(startDragTimeout);
		}
	}
	var OnStart = function (e, $ele)
	{
		mouseCoordFixer.fix(e);
		if (touchEvents.Gate(e) || e.which === 3)
			return;
		down = true;
		x = e.mouseX;
		y = e.mouseY;
		var ofst = $ele.offset();
		offsetX = x - ofst.left;
		offsetY = y - ofst.top;
		ClearDragTimeout();
		$lastTouched = $ele;
		if (touchEvents.isTouchEvent(e))
			startDragTimeout = setTimeout(function ()
			{
				DragStart($ele);
			}, startDragHoldTimeMs);
		else
			DragStart($ele);
	}
	var DragStart = function ($ele)
	{
		if (vibrate_supported)
			navigator.vibrate(25);
		drag = true;
		$drag = $ele;
		$ghost = $ele.clone();
		$blank = $ele.clone().css('opacity', 0);
		$ghost.addClass('ghost');
		$ghost.css('left', mouseCoordFixer.last.x - offsetX).css('top', mouseCoordFixer.last.y - offsetY);
		$ghost.css('width', $ele.width() + 'px').css('height', $ele.height() + 'px');
		$('body').append($ghost);
		$drag.hide();
		$drag.after($blank);
	}

	var OnMove = function (e)
	{
		mouseCoordFixer.fix(e);
		if (touchEvents.Gate(e) || !down)
			return;
		var distance = Math.max(Math.abs(e.mouseX - x), Math.abs(e.mouseY - y));
		if (!moved && distance > 5)
		{
			moved = true;
			ClearDragTimeout();
		}
		if ($lastTouched && distance > 50)
			$lastTouched = null;
		if (drag)
		{
			$ghost.css('left', e.mouseX - offsetX).css('top', e.mouseY - offsetY);
			if (pointInsideElementBorder($drag.parent(), e.mouseX, e.mouseY))
			{
				$ghost.css("cursor", "move");
				for (var i = 0; i < $items.length; i++)
				{
					var $item = $items.eq(i);
					if (pointInsideElementBorder($item, e.mouseX, e.mouseY))
					{
						moved = true;
						if ($blank.position().top > $item.position().top)
							$item.before($blank);
						else
							$item.after($blank);
					}
				}
			}
			else
			{
				$ghost.css("cursor", "no-drop");
				$drag.after($blank);
			}
		}
	}
	var OnEnd = function (e)
	{
		mouseCoordFixer.fix(e);
		touchEvents.Gate(e);
		if (down)
			DragFinished(e, drag && pointInsideElementBorder($drag.parent(), e.mouseX, e.mouseY));
	}
	var DragFinished = function (e, success)
	{
		ClearDragTimeout();
		if (drag)
		{
			if (success && moved)
			{
				$blank.after($drag);
				onItemMoved($drag);
			}
			$drag.show();
			$blank.remove();
			$ghost.remove();
			if (!moved)
				TimedClick($drag);
			$drag = $blank = $ghost = null;
		}
		else
		{
			if ($lastTouched && $lastTouched.length > 0 && pointInsideElement($lastTouched, e.mouseX, e.mouseY))
			{
				TimedClick($lastTouched);
				$lastTouched = null;
			}
		}
		down = drag = moved = false;
	}
	var OnCancel = function (e)
	{
		mouseCoordFixer.fix(e);
		touchEvents.Gate(e);
		DragFinished(e, false);
	}
	var TimedClick = function ($ele)
	{
		setTimeout(function ()
		{
			$ele.trigger('click');
		}, 0);
	}
	this.Destroy = function ()
	{
		// Only one DragAndDropHelper can be active at a time; calling Destroy deactivates previous helpers.
		$(document).off('touchmove.ddh mousemove.ddh touchend.ddh mouseup.ddh touchcancel.ddh');
	}
	$(document).on('touchmove.ddh mousemove.ddh', OnMove);
	$(document).on('touchend.ddh mouseup.ddh', OnEnd);
	$(document).on('touchcancel.ddh', OnCancel);
}
///////////////////////////////////////////////////////////////
// Mouse Event Helper / Double Click Helper ///////////////////
///////////////////////////////////////////////////////////////
/**
 * Handles double-click events in a consistent way between touch and non-touch devices.
 * @param {Object} $ele jQuery object containing elements to listen for clicks on.
 * @param {Object} $excludeRecordings jQuery object containing elements to ignore clicks on while viewing a recording (maybe these are nested inside [$ele]). May be null.
 * @param {Object} $excludeLive jQuery object containing elements to ignore clicks on while viewing live video (maybe these are nested inside [$ele]). Also, cbOnDragStart will not be called when the drag starts in one of these elements regardless of playback mode.  May be null.
 * @param {Function} excludeFunc Called by all mouse/touch down/up events; if this returns true, the event is excluded from consideration for clicks and drag starts.
 * @param {Function} cbOnSingleClick Callback function that is called when a single click occurs.  The first argument is the event object, and the second argument is a boolean indicating whether the single click is confirmed (If false, it may be part of a future double-click.  If true, it is to be treated as a standalone single-click.).
 * @param {Function} cbOnDoubleClick Callback function that is called when a double click occurs.  The first argument is the event object.
 * @param {Function} cbDragStart Called when dragging begins, which happens after a non-excluded mouse/touch down event followed by cursor movement exceeding mouseMoveTolerance.
 * @param {Function} cbDragMove Called when the cursor moves while a button is down.
 * @param {Function} cbDragEnd Called when dragging ends, which is on any mouse or touch up event whether the drag start callback was called or not.
 * @param {Number} doubleClickTimeMS (Optional; default: 300) Maximum milliseconds between clicks to consider two clicks a double-click.
 * @param {Number} mouseMoveTolerance (Optional; default: 5) Maximum number of pixels the mouse can move before it is considered a drag instead of a click.
 */
function MouseEventHelper($ele, $excludeRecordings, $excludeLive, excludeFunc, cbOnSingleClick, cbOnDoubleClick, cbDragStart, cbDragMove, cbDragEnd, doubleClickTimeMS, mouseMoveTolerance)
{
	var self = this;
	if (!$ele || $ele.length < 1)
		return;

	if (typeof excludeFunc != "function")
		excludeFunc = function () { };
	if (typeof cbOnSingleClick != "function")
		cbOnSingleClick = function () { };
	if (typeof cbOnDoubleClick != "function")
		cbOnDoubleClick = function () { };
	if (typeof cbDragStart != "function")
		cbDragStart = function () { };
	if (typeof cbDragMove != "function")
		cbDragMove = function () { };
	if (typeof cbDragEnd != "function")
		cbDragEnd = function () { };
	var callCBTimeout = null;
	var callCB = function (cb, delay, e, confirmed)
	{
		var saveArgs = new Array(arguments.length - 2);
		for (var i = 2; i < arguments.length; i++)
			saveArgs[i - 2] = arguments[i];
		var execute = function ()
		{
			callCBTimeout = null;
			if (!lastMouseUp1.Excluded)
				cb.apply(self, saveArgs);
		};
		if (callCBTimeout)
		{
			clearTimeout(callCBTimeout);
			callCBTimeout = null;
		}
		if (delay)
			callCBTimeout = setTimeout(execute, 0);
		else
			execute();
	}
	if (!doubleClickTimeMS || doubleClickTimeMS < 0)
		doubleClickTimeMS = 300;

	if (!mouseMoveTolerance || mouseMoveTolerance < 0)
		mouseMoveTolerance = 5;

	var lastMouseDown1 = { X: -1000, Y: -1000, Time: performance.now() - 600000, Excluded: false, screenX: 0, screenY: 0 };
	var lastMouseDown2 = $.extend({}, lastMouseDown1);
	var lastMouseUp1 = $.extend({}, lastMouseDown1);
	var lastMouseUp2 = $.extend({}, lastMouseDown1);

	var lastEvent = 0; // Workaround for problem in Chrome where some mouse events are missed a moment after fullscreen change.

	var singleClickTimeout = null;
	var singleClickFunction = null;

	var excludeNextEvent = false;
	var exclude = false;
	var excludeDragStart = false;
	var clearExclusion = function ()
	{
		exclude = false;
		excludeDragStart = false;
	}

	if ($excludeRecordings)
	{
		BindEventsPassive($excludeRecordings.get(0), "mousedown touchstart mouseup touchend touchcancel", function (e)
		{
			if (touchEvents.isMultiTouch(e))
				return;
			if (videoPlayer.Loading().image.isLive)
				return;
			exclude = true;
			setTimeout(clearExclusion, 0);
		});
	}
	if ($excludeLive)
	{
		BindEventsPassive($excludeLive.get(0), "mousedown touchstart mouseup touchend touchcancel", function (e)
		{
			if (touchEvents.isMultiTouch(e))
				return;
			if (videoPlayer.Loading().image.isLive)
				exclude = true;
			excludeDragStart = true;
			setTimeout(clearExclusion, 0);
		});
	}

	BindEventsPassive($ele.get(0), "mousedown touchstart", function (e)
	{
		if (touchEvents.isMultiTouch(e))
			return self.Invalidate();
		mouseCoordFixer.fix(e);
		if (touchEvents.Gate(e))
			return;
		if (e.which !== 0 && e.which !== 1 && e.which !== 2) // Mustn't allow 4 and 5 (back and forward)
			return;
		handleExcludeFunc(e);
		if (lastEvent === 1)
			RecordMouseEvent(2, e); // Inject mouse up event that the browser likely missed.
		RecordMouseEvent(1, e);
		if (!excludeDragStart)
			cbDragStart(e);
	});
	BindEventsPassive($ele.get(0), "mouseup touchend touchcancel", function (e)
	{
		if (touchEvents.isMultiTouch(e))
			return self.Invalidate();
		mouseCoordFixer.fix(e);
		if (touchEvents.Gate(e))
			return;
		if (e.which !== 0 && e.which !== 1 && e.which !== 2)
			return;
		handleExcludeFunc(e);
		var fakeMouseDown = lastEvent == 2;
		if (fakeMouseDown)
			RecordMouseEvent(1, e); // Inject mouse down event that the browser likely missed.
		RecordMouseEvent(2, e);
		if (!positionsAreWithinTolerance(lastMouseUp1, lastMouseDown1))
			return; // It doesn't count as a click if the mouse moved too far between down and up.
		if (lastMouseDown1.Excluded || lastMouseUp1.Excluded)
			return;
		// A single click has occurred.
		if (!fakeMouseDown)
			callCB(cbOnSingleClick, touchEvents.isTouchEvent(e), e, false);
		if (lastMouseUp1.Time - lastMouseUp2.Time < doubleClickTimeMS
			&& lastMouseUp1.Time - lastMouseDown2.Time < doubleClickTimeMS
			&& lastMouseUp2.Time - lastMouseDown2.Time < doubleClickTimeMS
			&& positionsAreWithinTolerance(lastMouseUp2, lastMouseDown2)
			&& positionsAreWithinTolerance(lastMouseDown1, lastMouseDown2)
			&& !lastMouseDown2.Excluded
			&& !lastMouseUp2.Excluded
			&& singleClickTimeout)
		{
			clearTimeout(singleClickTimeout);
			singleClickTimeout = null;
			callCB(cbOnDoubleClick, false, e);
		}
		else if (!fakeMouseDown)
		{
			if (singleClickTimeout)
			{
				// If we get here, a second single click has occurred while another is still unconfirmed.
				// In this case, the previously unconfirmed click gets confirmed early.
				// A typical way this could happen is if the mouse moved between clicks.
				clearTimeout(singleClickTimeout);
				singleClickTimeout = null;
				if (singleClickFunction)
					singleClickFunction();
			}
			singleClickFunction = function ()
			{
				singleClickTimeout = null;
				singleClickFunction = null;
				cbOnSingleClick(e, true);
			};
			singleClickTimeout = setTimeout(singleClickFunction, doubleClickTimeMS);
		}
	});
	BindEventsPassive(document, "mousemove touchmove", function (e)
	{
		if (touchEvents.isMultiTouch(e))
			return self.Invalidate();
		mouseCoordFixer.fix(e);
		// Determine if this move event starts a drag.
		// When a drag starts, the MouseDown event becomes excluded from further consideration by this helper.
		if (lastMouseDown1.Time > lastMouseUp1.Time)
		{
			// The mouse button is down.
			if (!lastMouseDown1.Excluded)
			{
				// Has the curser moved far enough to start drag?
				if (!positionsAreWithinTolerance(lastMouseDown1, { X: e.mouseX, Y: e.mouseY })
					|| !positionWithinTouchScreenTolerance(lastMouseDown1, e))
				{
					lastMouseDown1.Excluded = true; // Cursor has moved far enough to start a drag.
				}
			}
			cbDragMove(e, true, lastMouseDown1.Excluded);
		}
		else
		{
			cbDragMove(e, false, lastMouseDown1.Excluded);
		}
	});
	BindEventsPassive(document, "mouseup mouseleave touchend touchcancel", function (e)
	{
		if (touchEvents.isMultiTouch(e))
			return self.Invalidate();
		mouseCoordFixer.fix(e);
		cbDragEnd(e);
	});
	var RecordMouseEvent = function (eventType, e)
	{
		var src, dst;
		if (eventType === 1)
		{
			src = lastMouseDown1;
			dst = lastMouseDown2;
		}
		else if (eventType === 2)
		{
			src = lastMouseUp1;
			dst = lastMouseUp2;
		}
		else
			return;
		dst.X = src.X;
		dst.Y = src.Y;
		dst.screenX = src.screenX;
		dst.screenY = src.screenY;
		dst.Time = src.Time;
		dst.Excluded = src.Excluded;
		src.X = e.mouseX;
		src.Y = e.mouseY;
		src.screenX = e.screenX;
		src.screenY = e.screenY;
		src.Time = performance.now();
		src.Excluded = exclude || excludeNextEvent;
		lastEvent = eventType;
		excludeNextEvent = false;
	}
	var positionsAreWithinTolerance = function (positionA, positionB)
	{
		return Math.abs(positionA.X - positionB.X) <= mouseMoveTolerance && Math.abs(positionA.Y - positionB.Y) <= mouseMoveTolerance;
	}
	var positionWithinTouchScreenTolerance = function (positionA, e)
	{
		if (e.touches && e.touches.length)
		{
			var positionB = e.touches[0];
			return Math.abs(positionA.screenX - positionB.screenX) <= mouseMoveTolerance && Math.abs(positionA.screenY - positionB.screenY) <= mouseMoveTolerance;
		}
		return true;
	}
	var handleExcludeFunc = function (e)
	{
		if (excludeFunc(e))
		{
			exclude = true;
			excludeDragStart = true;
			setTimeout(clearExclusion, 0);
		}
	}
	/** Sets the Excluded flag on all logged mouse events, causing them to not count toward clicks or double clicks. */
	this.Invalidate = function (invalidateNextEvent)
	{
		lastMouseUp1.Excluded = lastMouseUp2.Excluded = lastMouseDown1.Excluded = lastMouseDown2.Excluded = true;
		excludeNextEvent = invalidateNextEvent;
		clearTimeout(singleClickTimeout);
		singleClickTimeout = null;
	}
	this.getDoubleClickTime = function ()
	{
		return doubleClickTimeMS;
	}
}
function DumpTouchInfo(e, label)
{
	if (!touchEvents.isTouchEvent(e))
		return;
	var str = e.type + " (" + e.mouseX + "," + e.mouseY + "): ";
	var arr = [];
	if (e.changedTouches)
		for (var i = 0; i < e.changedTouches.length; i++)
		{
			arr.push(e.changedTouches[i].identifier);
		}
	str += '[' + arr.join(',') + ']';
	if (label)
		str = label + " " + str;
	toaster.Info(str, 1000);
}
///////////////////////////////////////////////////////////////
// Clipboard Helper ///////////////////////////////////////////
///////////////////////////////////////////////////////////////
function ClipboardHelper()
{
	var self = this;
	var textToCopy = "";

	var $ele = $('<div class="clipboardHelper" style="display:none;"></div>');
	$('body').append($ele);

	var clipboard = new Clipboard($ele.get(0), { text: function (trigger) { return textToCopy; } });

	self.CopyText = function (text)
	{
		if (text == null)
			textToCopy = "";
		else
			textToCopy = text;
		$ele.click();
	}
}
///////////////////////////////////////////////////////////////
// UI Settings ////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function UISettingsPanel()
{
	var self = this;
	var initialized = false;
	var modal_dialog = null;
	var $dlg = $();
	var $content = $();
	var filterText = "";
	var sections = [];
	var $expandCollapse = $();

	var Initialize = function ()
	{
		if (initialized)
			return;
		initialized = true;

		for (var i = 0; i < defaultSettings.length; i++)
		{
			var s = defaultSettings[i];
			if (s.label && (typeof s.IncludeInOptionsWindow == "undefined" || s.IncludeInOptionsWindow))
			{
				if (typeof s.category == "undefined")
					s.category = "Uncategorized";
				if (settingsCategoryList.indexOf(s.category) == -1)
				{
					toaster.Warning("Category " + s.category + " did not exist in the category list!");
					settingsCategoryList.push(s.category);
				}
			}
		}
	}

	this.open = function (initialFilterText)
	{
		Initialize();
		CloseDialog();
		if (isNullOrWhitespace(initialFilterText))
			initialFilterText = "";
		filterText = initialFilterText;
		$dlg = $('<div id="uiSettingsPanel" class="dialogOptionPanel"></div>');
		$dlg.append(MakeButtonBar());
		$dlg.find("#uiSettingsFilterInput").val(filterText);
		$content = $('<div id="uiSettingsPanelContent"></div>');
		$dlg.append($content);
		modal_dialog = $dlg.dialog({
			title: "UI Settings"
			, overlayOpacity: 0.3
			, closeOnOverlayClick: true
			, onClosing: function () { modal_dialog = null; BI_CustomEvent.Invoke("UI_Settings_Closing"); }
		});

		BI_CustomEvent.Invoke("UI_Settings_Opening");
		self.Refresh();
	}
	this.Refresh = function ()
	{
		if (!modal_dialog)
			return;

		BI_CustomEvent.Invoke("UI_Settings_Refreshing");
		$content.empty();
		sections = [];
		var loadedAny = false;
		for (var i = 0; i < settingsCategoryList.length; i++)
			if (LoadCategory(settingsCategoryList[i]))
				loadedAny = true;
		if (!loadedAny)
			$content.append('<div class="filterTextNoMatch">Your filter text did not match anything.</div>');

		modal_dialog.contentChanged(true);
		BI_CustomEvent.Invoke("UI_Settings_Refreshed");
	}
	var LoadCategory = function (category)
	{
		var cat = new CollapsibleSection("uiSettings_category_" + category, category, modal_dialog, filterActive(), updateExpandCollapseAllButtonState);
		sections.push(cat);
		var rowIdx = 0;
		if (category === "General Settings")
		{
			if (settings.bi_rememberMe === "1" && processFilter({ label: "Forget Saved Credentials" }))
				rowIdx = Add_ForgetSavedCredentialsButton(cat, rowIdx);
			if (processFilter({ label: "Reset All Settings" }))
				rowIdx = Add_ResetAllSettingsButton(cat, rowIdx);
		}
		var allCreated = [];
		for (var i = 0; i < defaultSettings.length; i++)
		{
			var s = defaultSettings[i];
			var isDisplayable = (s.label || (s.comment && s.inputType === "comment")) && s.category === category && (typeof s.IncludeInOptionsWindow == "undefined" || s.IncludeInOptionsWindow);
			if (isDisplayable && (typeof s.preconditionFunc !== "function" || s.preconditionFunc()) && processFilter(s))
			{
				var $row = $('<div class="uiSettingsRow withDefaultBtn"></div>');
				$row.attr("data-settings-key", s.key);
				if (s.hint && s.hint.length > 0)
					$row.attr('title', s.hint);
				if (rowIdx++ % 2 === 1)
					$row.addClass('everyOther');
				var formFields = {
					inputType: s.inputType
					, value: settings.getItem(s.key)
					, label: s.label
					, tag: s
					, defaultValue: s.value
					, class: s.class
				};
				if (s.hotkey)
				{
					formFields.inputType = "hotkey";
					formFields.onChange = HandleHotkeyChange;
					if (!fullscreen_supported && s.key === 'ui3_hotkey_togglefullscreen')
						formFields.label += '<br>(Unavailable)';
					$row.append(UIFormField(formFields));
				}
				else if (s.gamepad_binding)
				{
					formFields.inputType = "gamepad_binding";
					formFields.onChange = TextChanged;
					$row.append(UIFormField(formFields));
				}
				else if (s.inputType === "checkbox")
				{
					formFields.onChange = CheckboxChanged;
					$row.append(UIFormField(formFields));
				}
				else if (s.inputType === "select")
				{
					if ((s.options.length === 0 || s.alwaysRefreshOptions) && typeof s.getOptions === "function")
						s.options = s.getOptions();
					formFields.options = s.options;
					formFields.onChange = SelectChanged;
					$row.append(UIFormField(formFields));
				}
				else if (s.inputType === "number" || s.inputType === "range")
				{
					formFields.minValue = s.minValue;
					formFields.maxValue = s.maxValue;
					formFields.step = s.step;
					formFields.onChange = NumberChanged;
					if (s.inputType === "range")
					{
						if (s.changeOnStep)
							formFields.onInput = NumberChanged;
						formFields.unitLabel = s.unitLabel;
					}
					$row.append(UIFormField(formFields));
				}
				else if (s.inputType === "threeState")
				{
					formFields.onChange = ThreeStateChanged;
					$row.append(UIFormField(formFields));
				}
				else if (s.inputType === "comment")
				{
					var comment = typeof s.comment === "function" ? s.comment() : s.comment;
					$row.append(GetDialogOptionLabel(comment));
				}
				else if (s.inputType === "text" || s.inputType === "color" || s.inputType === "password")
				{
					if (s.inputType === "password")
					{
						formFields.onChange = PasswordChanged;
						formFields.value = Base64.decode(formFields.value);
					}
					else
						formFields.onChange = TextChanged;
					formFields.maxValue = s.maxValue;
					$row.append(UIFormField(formFields));
				}
				cat.$section.append($row);
				allCreated.push(s);
			}
		}
		if (category === "Extra")
		{
			if (processFilter({ label: "Export All Settings" }))
				rowIdx = Add_ExportAllSettingsButton(cat, rowIdx);
			if (processFilter({ label: "Import All Settings" }))
				rowIdx = Add_ImportAllSettingsButton(cat, rowIdx);
			if (sessionManager.IsAdministratorSession())
			{
				if (processFilter({ label: "Create Script: \"ui3-local-overrides.js\" (learn more) Download" }))
					rowIdx = Add_CreateLocalOverridesJsButton(cat, rowIdx);
			}
		}
		if (!filterActive() || rowIdx > 0)
		{
			$content.append(cat.$heading);
			$content.append(cat.$section);
			for (var i = 0; i < allCreated.length; i++)
			{
				var s = allCreated[i];
				if (typeof s.onCreate === "function")
				{
					try
					{
						s.onCreate();
					}
					catch (ex)
					{
						toaster.Error(ex);
					}
				}
			}
			return true;
		}
		return false;
	}
	var Add_CreateLocalOverridesJsButton = function (cat, rowIdx)
	{
		var $row = $('<div id="createLocalOverridesScript" class="uiSettingsRow dialogOption_item dialogOption_item_info"></div>');
		var $input = $('<a class="input" href="javascript:void(0)" download="ui3-local-overrides.js">Download</a>');
		$input.on('click', function ()
		{
			var text = BuildLocalOverridesTemplate();

			if (!text)
				return false;

			$input.attr('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
			setTimeout(function () { $input.attr('href', 'javascript:void(0)'); }, 0);
			return true;
		});
		$row.append($input);
		$row.append(GetDialogOptionLabel('Create Script: "ui3-local-overrides.js"<br><a href="javascript:UIHelp.LearnMore(\'ui3-local-overrides\')">(learn more)</a>'));
		if (rowIdx++ % 2 == 1)
			$row.addClass('everyOther');
		cat.$section.append($row);
		return rowIdx;
	}
	var Add_ExportAllSettingsButton = function (cat, rowIdx)
	{
		var date = GetPaddedDateStr(new Date(), false);

		var $row = $('<div id="exportAllSettingsBtn" class="uiSettingsRow dialogOption_item dialogOption_item_info"></div>');
		var $input = $('<a class="input" href="javascript:void(0)" download="ui3-settings-export-' + date + '.json">Export</a>');
		$input.on('click', function ()
		{
			var text = self.ExportAllSettingsToJson();
			if (text)
			{
				clipboardHelper.CopyText(text);
				toaster.Success("Copied all settings to clipboard. Please import into a different UI3 instance.");
			}
			else
			{
				toaster.Error("Failed to export settings");
				return false;
			}

			$input.attr('download', 'ui3-settings-export-' + date + '.json');
			$input.attr('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
			setTimeout(function () { $input.attr('href', 'javascript:void(0)'); }, 0);
			return true;
		});
		$row.append($input);
		$row.append(GetDialogOptionLabel('Export All Settings'));
		if (rowIdx++ % 2 == 1)
			$row.addClass('everyOther');
		cat.$section.append($row);
		return rowIdx;
	}
	var Add_ImportAllSettingsButton = function (cat, rowIdx)
	{
		var $row = $('<div id="importAllSettingsBtn" class="uiSettingsRow dialogOption_item dialogOption_item_info"></div>');
		var $input = $('<a class="input" href="ui3/storageinfo.htm">ui3/storageinfo.htm</a>');
		//$input.on('click', function ()
		//{
		//	SimpleDialog.InputText("Import All Settings", "Paste settings that were previously exported.<br>If import is successful, UI3 will be reloaded.", function (inputText)
		//	{
		//		if (self.ImportSettingsJson(inputText))
		//			ReloadInterface();
		//	});
		//});
		$row.append($input);
		$row.append(GetDialogOptionLabel('Import All Settings<div class="settingDesc">(via <a href="ui3/storageinfo.htm">ui3/storageinfo.htm</a>)</div>'));
		if (rowIdx++ % 2 == 1)
			$row.addClass('everyOther');
		cat.$section.append($row);
		return rowIdx;
	}
	var BuildLocalOverridesTemplate = function ($input)
	{
		try
		{
			var sb = new StringBuilder("\r\n");
			sb.AppendLine('/*');
			sb.AppendLine('\tTHIS IS FOR ADVANCED USE ONLY');
			sb.AppendLine('\t');
			sb.AppendLine('\tIf you want to modify UI3\'s default behavior, ');
			sb.AppendLine('\tyou must rename this file (if necessary) to "ui3-local-overrides.js"');
			sb.AppendLine('\tand place it in the "ui3" subdirectory where "ui3.js" is located.');
			sb.AppendLine('\t');
			sb.AppendLine('\t"ui3-local-overrides.js" is not included with Blue Iris and should');
			sb.AppendLine('\tnot be overwritten by updates.');
			sb.AppendLine('*/');
			sb.AppendLine();
			sb.AppendLine();
			for (var i = 0; i < settingsCategoryList.length; i++)
				BuildLocalOverridesTemplate_Category(sb, settingsCategoryList[i]);
			BuildLocalOverridesTemplate_Category(sb, null);
			BuildLocalOverridesTemplate_Category(sb, "Streaming Profiles"); // This category isn't shown in UI Settings
			return sb.ToString();
		}
		catch (ex)
		{
			toaster.Error(ex);
			return false;
		}
	}
	this.ExportAllSettingsToJson = function ()
	{
		try
		{
			if (isLocalStorageEnabled())
				return JSON.stringify(localStorage);
			else
			{
				toaster.Error("Local Storage is not enabled in this browser, so you have no persistent settings.");
				return false;
			}
		}
		catch (ex)
		{
			toaster.Error(ex);
			return false;
		}
	}
	this.ImportSettingsJson = function (s)
	{
		try
		{
			if (isLocalStorageEnabled())
			{
				if (typeof s === "string")
					s = JSON.parse(s);
				for (var key in s)
					if (Object.prototype.hasOwnProperty.call(s, key))
						localStorage.setItem(key, s[key]);
				return true;
			}
			else
			{
				toaster.Error("Local Storage is not enabled in this browser, so you have no persistent settings.");
				return false;
			}
		}
		catch (ex)
		{
			toaster.Error(ex);
			return false;
		}
	}
	var BuildLocalOverridesTemplate_Category = function (sb, category)
	{
		// Output Category heading
		sb.AppendLine('// Category "' + (category ? category : "Uncategorized") + '"');

		// Output parameter legend, which requires measuring key and value max lengths beforehand
		//                       Settings Key   Value   Options Window   Always Reload   Generation
		//OverrideDefaultSetting(key,           value,  true,            false,          0);
		var max_key = 14;
		var max_value = 7;
		for (var i = 0; i < defaultSettings.length; i++)
		{
			var s = defaultSettings[i];
			if (s.category != category || !s.key)
				continue;
			var value = settings.getItem(s.key);
			if (typeof value == "string")
				value = JavaScriptStringEncode(value, true);
			else
				value = value.toString();
			max_key = Math.max(max_key, JavaScriptStringEncode(s.key, true).length + 1);
			max_value = Math.max(max_value, value.length + 1);
		}
		sb.Append('//                     ');
		sb.Append('Settings Key'.padRight(max_key + 1, ' '));
		sb.Append('Value'.padRight(max_value + 1, ' '))
		sb.AppendLine('Options Window   Always Reload   Generation');
		// Output override lines
		for (var i = 0; i < defaultSettings.length; i++)
		{
			var s = defaultSettings[i];
			if (s.category != category)
				continue;
			var key = s.key;
			if (!key || key === "bi_rememberMe" || key === "bi_username" || key === "bi_password" || key === "bi_lastunload" || key === "bi_override_disable_auto_login_once")
				continue; // Don't write these to the file!
			var value = settings.getItem(key);
			sb.Append('OverrideDefaultSetting(');
			sb.Append((JavaScriptStringEncode(key, true) + ",").padRight(max_key, ' '));
			sb.Append(' ')
			if (typeof value == "string")
				sb.Append((JavaScriptStringEncode(value, true) + ",").padRight(max_value, ' '));
			else
				sb.Append((value.toString() + ",").padRight(max_value, ' '));
			if (typeof s.IncludeInOptionsWindow == "undefined")
				s.IncludeInOptionsWindow = true;
			if (typeof s.AlwaysReload == "undefined")
				s.AlwaysReload = false;
			sb.Append(' ').Append((!!s.IncludeInOptionsWindow + ",").padRight(16, ' '));
			sb.Append(' ').Append((!!s.AlwaysReload + ",").padRight(15, ' '));
			sb.Append(' ');

			// Increment generation.
			sb.Append(GetNextGenerationForLocalOverrides(s).toString());
			sb.AppendLine(");");
		}
		sb.AppendLine();
	}
	var GetNextGenerationForLocalOverrides = function (s)
	{
		if (typeof s.gen == "undefined" || s.gen == null)
			return 1;
		else
			return parseInt(s.gen) + 1;
	}
	var Add_ForgetSavedCredentialsButton = function (cat, rowIdx)
	{
		var $row = $('<div id="forgetSavedCredentialsRow" class="uiSettingsRow dialogOption_item dialogOption_item_info"></div>');
		var $input = $('<input type="button" value="Forget Now" />');
		$input.on('click', function ()
		{
			$("#forgetSavedCredentialsRow").remove();
			settings.bi_rememberMe = "0";
			settings.bi_username = "";
			settings.bi_password = "";
			toaster.Info("Saved credentials have been forgotten.", 5000);
		});
		$row.append($input);
		$row.append(GetDialogOptionLabel("Forget Saved Credentials"));
		if (rowIdx++ % 2 == 1)
			$row.addClass('everyOther');
		cat.$section.append($row);
		return rowIdx;
	}
	var Add_ResetAllSettingsButton = function (cat, rowIdx)
	{
		var $row = $('<div id="resetAllSettingsRow" class="uiSettingsRow dialogOption_item dialogOption_item_info"></div>');
		var $input = $('<input type="button" value="Reset" />');
		$input.on('click', function ()
		{
			AskYesNo('All UI settings will revert to their default values and the page will reload.<br><br><center>Continue?</center>', function ()
			{
				RevertSettingsToDefault();
				ReloadInterface();
			});
		});
		$row.append($input);
		$row.append(GetDialogOptionLabel("Reset All Settings"));
		if (rowIdx++ % 2 == 1)
			$row.addClass('everyOther');
		cat.$section.append($row);
		return rowIdx;
	}
	var CheckboxChanged = function (s, checked)
	{
		settings.setItem(s.key, checked ? "1" : "0");
		CallOnChangeCallback(s);
	}
	var SelectChanged = function (e, s, $select)
	{
		var selectedValue = $select.val();
		if (s.options.indexOf(selectedValue) != -1)
			settings.setItem(s.key, selectedValue);
		CallOnChangeCallback(s);
	}
	var NumberChanged = function (e, s, $input)
	{
		settings.setItem(s.key, parseFloat($input.val()));
		CallOnChangeCallback(s);
	}
	var TextChanged = function (e, s, $input)
	{
		settings.setItem(s.key, $input.val());
		CallOnChangeCallback(s);
	}
	var PasswordChanged = function (e, s, $input)
	{
		settings.setItem(s.key, Base64.encode($input.val()));
		CallOnChangeCallback(s);
	}
	var ThreeStateChanged = function (s, value, $input)
	{
		settings.setItem(s.key, value.toString());
		CallOnChangeCallback(s);
	}
	var HandleHotkeyChange = function (e, s, $input, textValue, hotkeyValue)
	{
		settings.setItem(s.key, hotkeyValue);
		return false;
	}
	var CallOnChangeCallback = function (s)
	{
		if (s && typeof s.onChange == "function")
		{
			try
			{
				s.onChange(settings.getItem(s.key));
			}
			catch (ex)
			{
				toaster.Error(ex);
			}
		}
	}
	var CloseDialog = function ()
	{
		if (modal_dialog != null)
		{
			modal_dialog.close();
			modal_dialog = null;
		}
	}
	var filterActive = function ()
	{
		return !isNullOrWhitespace(filterText);
	}
	var processFilter = function (s)
	{
		if (!filterActive())
			return true;
		var query = new RegExp(escapeRegExp(filterText), "i");
		if (filterFind(s.label, query))
			return true;
		if (filterFind(s.hint, query))
			return true;
		if (s.inputType === "comment" && filterFind(s.comment, query))
			return true;
		if (filterFind(s.keywords, query))
			return true;
		return false;
	}
	var filterFind = function (field, query)
	{
		if (!field)
			return false;
		var text = field;
		if (typeof text === "function")
			text = text();
		else if (typeof text !== "string")
			text = text.toString();
		return text.match(query);
	}
	var MakeButtonBar = function ()
	{
		var $buttonBar = $('<div class="uiSettingsButtonBar"></div>');
		var $filterInput = $('<input type="search" value="" placeholder="Type to filter..." id="uiSettingsFilterInput" />');
		$filterInput.on('input', function (e)
		{
			filterText = $filterInput.val();
			self.Refresh();
		});
		$buttonBar.append($filterInput);
		$expandCollapse = $('<input type="button" value="Toggle All" myaction="c" />');
		$expandCollapse.on('click', function (e)
		{
			if ($expandCollapse.attr("myaction") == "c")
			{
				for (var i = 0; i < sections.length; i++)
					sections[i].Collapse();
			}
			else
			{
				for (var i = 0; i < sections.length; i++)
					sections[i].Expand();
			}
		});
		setTimeout(updateExpandCollapseAllButtonState, 0);
		$buttonBar.append($expandCollapse);
		return $buttonBar;
	}
	var updateExpandCollapseAllButtonState = function ()
	{
		for (var i = 0; i < sections.length; i++)
		{
			if (sections[i].IsExpanded())
			{
				$expandCollapse.attr("myaction", "c");
				$expandCollapse.val("Collapse All");
				return;
			}
		}
		$expandCollapse.attr("myaction", "e");
		$expandCollapse.val("Expand All");
	}
	this.isOpen = function ()
	{
		return !!modal_dialog;
	}
}
function GenerateLocalSnapshotsComment()
{
	if (!any_h264_playback_supported || currentH264Player === H264PlayerOptions.HTML5)
		return "";
	return "<b>-- Your current H.264 player is not capable of local snapshots. --</b>";
}
function GenerateEventTriggeredSoundsComment()
{
	return "Sounds are loaded from Blue Iris's \"www/sounds\" directory. Supported extensions: " + sessionManager.supportedHTML5AudioFormats.join(", ");
}
function GenerateEventTriggeredIconsComment()
{
	return GenerateH264RequirementString() + "<br/>Icons are shown in the upper-right corner of the video player.";
}
function GenerateH264RequirementString()
{
	return '-- Requires an H.264 stream. --' + (any_h264_playback_supported ? '' : '<br/><span class="settingsCommentError">-- H.264 streams are not supported by this browser --</span>');
}
function GenerateCurrentH264PlayerComment()
{
	return '<div class="currentH264PlayerComment">Current H.264 player: ' + currentH264Player + '</div>';
}
function OnChange_ui3_audio_codec()
{
	if (videoPlayer.CurrentPlayerModuleName() === "h264")
		videoPlayer.ReopenStreamAtCurrentSeekPosition();
}
function OnChange_ui3_preferred_ui_scale(newValue)
{
	uiSizeHelper.SetUISizeByName(newValue);
}
function OnChange_ui3_portrait_layout()
{
	resized();
}
function OnChange_ui3_color_theme()
{
	SetColorTheme(settings.ui3_color_theme);
}
function OnChange_ui3_sideBarPosition()
{
	if (settings.ui3_sideBarPosition === "Right")
		$('body').addClass("sideBarRight");
	else
		$('body').removeClass("sideBarRight");
	resized();
}
function OnChange_ui3_show_cameras_in_group_dropdowns()
{
	var lastResponse = cameraListLoader.GetLastResponse();
	if (lastResponse)
		dropdownBoxes.listDefs["currentGroup"].rebuildItems(lastResponse.data);
}
function OnChange_ui3_bypass_single_camera_groups()
{
	cameraListLoader.LoadCameraList();
}
function OnChange_ui3_maxDynamicGroupImageMegapixels()
{
	videoPlayer.ReopenStreamAtCurrentSeekPosition();
}
var ui3_reload_to_take_effect_toast = null;
function ReloadToTakeEffectToast(extraMessage)
{
	DestroyReloadToTakeEffectToast();
	if (extraMessage)
		extraMessage = "<br><br>" + extraMessage;
	else
		extraMessage = "";
	ui3_reload_to_take_effect_toast = toaster.Info("This setting will take effect when you reload the page." + extraMessage + "<br><br>Clicking this message will reload the page.", 60000, false
		, function ()
		{
			ReloadInterface();
		});
}
function DestroyReloadToTakeEffectToast()
{
	if (ui3_reload_to_take_effect_toast)
	{
		ui3_reload_to_take_effect_toast.remove();
		ui3_reload_to_take_effect_toast = null;
	}
}
function OnChange_ui3_contextMenus_trigger(newValue)
{
	ReloadToTakeEffectToast("Context menus will open on " + settings.ui3_contextMenus_trigger + ".");
}
function OnChange_ui3_ptzPresetShowCount(newValue)
{
	ReloadToTakeEffectToast(settings.ui3_ptzPresetShowCount + " PTZ presets will be shown.");
}
function GetPreferredContextMenuTrigger()
{
	if (settings.ui3_contextMenus_trigger === "Long-Press")
		return "longpress";
	else if (settings.ui3_contextMenus_trigger === "Double-Click")
		return "double";
	else
	{
		if (BrowserIsIOS())
			return "longpress";
		else
			return "right";
	}
}
function OnChange_ui3_time24hour()
{
	use24HourTime = settings.ui3_time24hour == "1";
}
function OnChange_ui3_topbar_save_snapshot_btn_show()
{
	if (settings.ui3_topbar_save_snapshot_btn_show === "1")
		$("#save_snapshot_btn").show();
	else
		$("#save_snapshot_btn").hide();
}
function OnChange_ui3_topbar_allclips_shortcut_show()
{
	if (sessionManager.HasPermission_Clips() && settings.ui3_topbar_allclips_shortcut_show === "1")
		$("#open_all_clips_btn").show();
	else
		$("#open_all_clips_btn").hide();
}
function OnChange_ui3_topbar_alerts_shortcut_show()
{
	if (sessionManager.HasPermission_Clips() && settings.ui3_topbar_alerts_shortcut_show === "1")
		$("#open_alerts_btn").show();
	else
		$("#open_alerts_btn").hide();
}
function OnChange_ui3_topbar_alerts_canceled_shortcut_show()
{
	if (sessionManager.HasPermission_Clips() && settings.ui3_topbar_alerts_canceled_shortcut_show === "1")
		$("#open_alerts_canceled_btn").show();
	else
		$("#open_alerts_canceled_btn").hide();
}
function OnChange_ui3_topbar_alerts_confirmed_shortcut_show()
{
	if (sessionManager.HasPermission_Clips() && settings.ui3_topbar_alerts_confirmed_shortcut_show === "1")
		$("#open_alerts_confirmed_btn").show();
	else
		$("#open_alerts_confirmed_btn").hide();
}
function OnChange_ui3_topbar_alerts_shortcut_counter()
{
	statusLoader.LoadStatus();
}
function OnChange_ui3_topbar_warnings_counter()
{
	statusLoader.LoadStatus();
}
function OnChange_ui3_show_update_available_notice()
{
	sessionManager.ProcessVersionAvailability();
}
function OnChange_ui3_h264_choice()
{
	ReloadToTakeEffectToast();
	uiSettingsPanel.Refresh();
}
function Precondition_ui3_h264_choice()
{
	return any_h264_playback_supported;
}
function Precondition_ui3_h264_choice_requires_restart()
{
	return Precondition_ui3_h264_choice() && ui3_reload_to_take_effect_toast;
}
function Precondition_ui3_edge_fetch_bug_h264_enable()
{
	return fetch_streams_cant_close_bug;
}
function OnChange_ui3_edge_fetch_bug_h264_enable()
{
	ReloadToTakeEffectToast();
}
function OnChange_ui3_streamingProfileBitRateMax()
{
	videoPlayer.RefreshVideoStream();
}
function Precondition_ui3_streamingProfileBitRateMax()
{
	return any_h264_playback_supported;
}
function Precondition_ui3_html5_delay_compensation()
{
	return (mse_mp4_h264_supported && currentH264Player === H264PlayerOptions.HTML5);
}
function Precondition_ui3_h264_net_delay_threshold()
{
	return any_h264_playback_supported;
}
function Precondition_ui3_h264_html5_delay_threshold()
{
	return (mse_mp4_h264_supported && currentH264Player === H264PlayerOptions.HTML5);
}
function Precondition_ui3_h264_delay_threshold()
{
	return (any_h264_playback_supported && currentH264Player !== H264PlayerOptions.HTML5);
}
function Precondition_ui3_download_snapshot_server()
{
	return settings.ui3_download_snapshot_method === "Server";
}
function Precondition_ui3_download_snapshot_local()
{
	return settings.ui3_download_snapshot_method.startsWith("Local ");
}
function OnChange_ui3_icons_extraVisibility()
{
	cornerStatusIcons.ReInitialize();
	cameraNameLabels.show();
}
function OnChange_ui3_status_area()
{
	statusAreaApi.loadUserSettings();
}
function OnChange_ui3_fullscreen_videoonly()
{
	if (fullScreenModeController.isFullScreen())
	{
		if (settings.ui3_fullscreen_videoonly == "1")
			maximizedModeController.EnableMaximizedMode();
		else
			maximizedModeController.DisableMaximizedMode();
	}
}
function OnChange_ui3_show_maximize_button()
{
	maximizedModeController.updateMaximizeButtonState();
}
function OnChange_ui3_skipAmount()
{
	$('#lblSkipBack,#lblSkipAhead').text(GetSkipAmount().dropDecimalsStr() + "s");
}
function OnChange_ui3_download_snapshot_method()
{
	uiSettingsPanel.Refresh();
}
function OnChange_ui3_pc_next_prev_buttons()
{
	if (settings.ui3_pc_next_prev_buttons == "1")
		$('#pcPrevClip,#pcNextClip').removeClass("hidden");
	else
		$('#pcPrevClip,#pcNextClip').addClass("hidden");
}
function OnChange_ui3_pc_seek_buttons()
{
	if (settings.ui3_pc_seek_buttons == "1")
		$('#pcSkipBack,#pcSkipAhead').removeClass("hidden");
	else
		$('#pcSkipBack,#pcSkipAhead').addClass("hidden");
}
function OnChange_ui3_pc_seek_1frame_buttons()
{
	if (settings.ui3_pc_seek_1frame_buttons == "1")
		$('#pcSkipBack1Frame,#pcSkipAhead1Frame').removeClass("hidden");
	else
		$('#pcSkipBack1Frame,#pcSkipAhead1Frame').addClass("hidden");
}
function OnChange_ui3_pc_delete_button()
{
	if (settings.ui3_pc_delete_button === "1" && settings.ui3_allow_clip_deletion !== "0")
		$('#clipDeleteButton').removeClass("hidden");
	else
		$('#clipDeleteButton').addClass("hidden");
}
function OnChange_ui3_allow_clip_deletion()
{
	OnChange_ui3_pc_delete_button();
}
function OnChange_ui3_reverse_speed_substream_threshold()
{
	$("#playback_speed_mainStreamComment").text(playbackControls ? playbackControls.GetMainStreamSpeedRangeComment() : "[playback controls not loaded!]");
}
function OnChange_ui3_forward_speed_substream_threshold()
{
	OnChange_ui3_reverse_speed_substream_threshold();
}
function OnChange_ui3_extra_playback_controls_padding()
{
	if (settings.ui3_extra_playback_controls_padding == "1")
		$('#pcButtonContainer').addClass("extraPadding");
	else
		$('#pcButtonContainer').removeClass("extraPadding");
}
function OnChange_ui3_showClipListFilterSearch()
{
	clipFilterSearch.updateVisibility();
}
function OnChange_ui3_ir_brightness_contrast()
{
	if (settings.ui3_ir_brightness_contrast == "1")
		$('#ptzIrBrightnessContrast').show();
	else
		$('#ptzIrBrightnessContrast').hide();
}
function OnChange_ui3_ptzHome()
{
	if (settings.ui3_ptzHome == "1")
		$('#ptzHomeContainer').show();
	else
		$('#ptzHomeContainer').hide();
}
function OnChange_ui3_prioritizeTriggered()
{
	videoPlayer.PrioritizeTriggeredWasToggled();
}
function OnChange_ui3_playback_skipDeadAir()
{
	videoPlayer.RefreshVideoStream();
}
function OnChange_ui3_browserZoomEnabled()
{
	SetBrowserZoom(settings.ui3_browserZoomEnabled === "1");
	imageRenderer.onToggleBrowserZoom();
}
function SetBrowserZoom(enable)
{
	if (enable)
		$('meta[name="viewport"]').attr('content', 'width=device-width, initial-scale=1');
	else
		$('meta[name="viewport"]').attr('content', 'width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no');
}
function OnChange_ui3_swap_ptz_focus_buttons()
{
	ReloadToTakeEffectToast();
}
function OnChange_ui3_gamepad_ptz_enabled()
{
	uiSettingsPanel.Refresh();
}
function Precondition_ui3_gamepad_ptz_enabled()
{
	return settings.ui3_gamepad_ptz_enabled === "1"
}
function OnChange_ui3_video_loading_overlay()
{
	if (settings.ui3_video_loading_overlay === "1")
	{
		$('#camimg_loading').removeClass('disabledBySetting');
		$('#camimg_false_loading').removeClass('disabledBySetting');
	}
	else
	{
		$('#camimg_loading').addClass('disabledBySetting');
		$('#camimg_false_loading').addClass('disabledBySetting');
	}
}
function OnChange_ui3_video_loading_animation()
{
	if (settings.ui3_video_loading_animation === "1")
	{
		$('#camimg_loading_anim').removeClass('disabledBySetting');
		$('#camimg_false_loading_anim').removeClass('disabledBySetting');
	}
	else
	{
		$('#camimg_loading_anim').addClass('disabledBySetting');
		$('#camimg_false_loading_anim').addClass('disabledBySetting');
	}
}
///////////////////////////////////////////////////////////////
// Form Field Helpers /////////////////////////////////////////
///////////////////////////////////////////////////////////////
function UIFormField(args)
{
	var o = $.extend({
		inputType: "unset" // required
		, value: null // required
		, label: ""
		, tag: null // Object passed through to event handlers
		, onChange: null // Called when the input's value is changed
		, onInput: null // Some inputs emit this rapidly while the user types or drags
		, options: null // array of option strings for "select" inputs
		, minValue: undefined // number / range types
		, maxValue: undefined // number / range types
		, disabled: false
		, compact: false
		, defaultValue: undefined // default value.  If defined, this will cause a "reset to default" button to exist.
		, class: undefined
	}, args);

	var ff = UIFormFieldInternal(o);
	if (o.class)
		ff.addClass(o.class);
	if (typeof o.defaultValue !== "undefined")
	{
		var $defaultButton = $('<div class="uiFormFieldDefaultBtn" title="Reset value to default"><svg class="icon"><use xlink:href="#svg_x5F_Restart"></use></svg></div>');
		$defaultButton.on('click', function ()
		{
			var $input = ff.find('input,select');
			if (o.inputType === "checkbox")
				$input.prop('checked', o.defaultValue === "1");
			else if (o.inputType === "hotkey")
			{
				var textValue = getHotkeyTextValueFromHotkeyValue(o.defaultValue);
				$input.val(textValue);
				o.onChange(null, o.tag, $input, textValue, o.defaultValue);
			}
			else if (o.inputType === "gamepad_binding")
			{
				$input.val(o.defaultValue);
				o.onChange(null, o.tag, $input);
			}
			else
			{
				if (typeof o.defaultValue === "function")
					$input.val(o.defaultValue());
				else
					$input.val(o.defaultValue);
			}
			$input.trigger('change');
		});
		ff = $defaultButton.add(ff);
	}
	return ff;
}
function UIFormFieldInternal(o)
{
	var disabledClass = (o.disabled ? ' disabled' : '');
	var compactClass = (o.compact ? ' compact' : '');

	if (o.inputType === "checkbox")
	{
		var checked = o.value === true || o.value === "1";
		if (o.compact)
		{
			var $input = $('<input type="' + o.inputType + '"' + (checked ? ' checked="checked"' : '') + ' />');
			if (o.disabled)
				$input.attr("disabled", "disabled");
			else
				$input.on('change', function (e) { return o.onChange(o.tag, $input.is(":checked")); });

			var $label = $('<label> ' + o.label + '</label>');
			$label.prepend($input);

			var $row = $('<div class="dialogOption_item dialogOption_item_cb' + disabledClass + '"></div>');
			$row.append($label);
			return $row;
		}
		else
			return GetCustomCheckbox(o.tag, o.label, checked, o.onChange, o.disabled);
	}
	else if (o.inputType === "select")
	{
		var sb = new StringBuilder();

		sb.Append('<select>');
		for (var i = 0; i < o.options.length; i++)
			sb.Append(GetHtmlOptionElementMarkup(o.options[i], o.options[i], o.value));
		sb.Append('</select>');
		var $input = $(sb.ToString());
		if (o.disabled)
			$input.attr("disabled", "disabled");
		else
			$input.on('change', function (e) { return o.onChange(e, o.tag, $input); });
		var $el = $('<div class="dialogOption_item dialogOption_item_ddl' + disabledClass + compactClass + '"></div>');
		if (o.compact)
			$el.append(GetDialogOptionLabel(o.label)).append($input);
		else
			$el.append($input).append(GetDialogOptionLabel(o.label));
		return $el;
	}
	else if (o.inputType === "number" || o.inputType === "range")
	{
		var $input = $('<input type="' + o.inputType + '" />');
		if (typeof o.minValue !== "undefined") $input.attr('min', o.minValue);
		if (typeof o.maxValue !== "undefined") $input.attr('max', o.maxValue);
		if (typeof o.step !== "undefined") $input.attr('step', o.step);
		$input.val(o.value);
		if (o.disabled)
			$input.attr("disabled", "disabled");
		else
			$input.on('change', function (e) { return o.onChange(e, o.tag, $input); });
		var $label = $(GetDialogOptionLabel(o.label));
		var classes = "dialogOption_item dialogOption_item_info" + disabledClass + compactClass;
		if (o.inputType === "range")
		{
			if (typeof o.onInput === "function")
				$input.on('input', function (e) { return o.onInput(e, o.tag, $input); });
			// Set up numeric output for range control
			$label.append('<span>: </span>');
			var $numericValue = $('<span></span>');
			$numericValue.text(o.value);
			$label.append($numericValue);
			if (o.unitLabel)
				$label.append($('<span></span>').text(o.unitLabel));
			$input.on('input change', function ()
			{
				$numericValue.text($input.val());
			});
			return $('<div class="' + classes + ' dialogOption_item_range"></div>').append($label).append($input);
		}
		else
			return $('<div class="' + classes + '"></div>').append($input).append($label);
	}
	else if (o.inputType === "text" || o.inputType === "color" || o.inputType === "password")
	{
		var $inputWrapper = $('<div class="textBasedInput"></div>');
		var $input = $('<input type="' + o.inputType + '" data-lpignore="true" autocomplete="off" />');
		if (o.maxValue)
			$input.attr('maxlength', o.maxValue);
		$input.val(o.value);
		if (o.disabled)
			$input.attr("disabled", "disabled");
		else
			$input.on('change', function (e) { return o.onChange(e, o.tag, $input); });
		$inputWrapper.append($input);
		if (o.inputType === "password")
		{
			$input.addClass('passwordInput');
			var $showPasswordBtn = $('<a role="button" class="showPasswordButton" title="Show Password">&#x1F441;&#xFE0F;</a>');
			$showPasswordBtn.on('click', function ()
			{
				if ($input.attr('type') === "password")
				{
					$input.attr('type', 'text');
					$showPasswordBtn.attr('title', 'Hide Password');
					$showPasswordBtn.addClass('showingPassword');
				}
				else
				{
					$input.attr('type', 'password');
					$showPasswordBtn.attr('title', 'Show Password');
					$showPasswordBtn.removeClass('showingPassword');
				}
			});
			$inputWrapper.append($showPasswordBtn);
		}
		var $label = $(GetDialogOptionLabel(o.label));
		return $('<div class="dialogOption_item dialogOption_item_info' + disabledClass + compactClass + '"></div>').append($inputWrapper).append($label);
	}
	else if (o.inputType === "button" || o.inputType === "threeState")
	{
		var $input = $('<input type="button" />');

		if (o.disabled)
			$input.attr("disabled", "disabled");

		if (o.inputType === "threeState")
		{
			$input.attr("threeState", o.value);
			$input.val(ThreeStateOptions[o.value]);
			$input.addClass(ThreeStateButtonClasses[o.value]);
			$input.on('click', function (e)
			{
				if ($input.attr("disabled") !== "disabled")
				{
					var v = parseInt($input.attr("threeState"));
					$input.removeClass(ThreeStateButtonClasses[v]);
					v = (v + 1) % ThreeStateOptions.length;
					$input.attr("threeState", v);
					$input.val(ThreeStateOptions[v]);
					$input.addClass(ThreeStateButtonClasses[v]);
					return o.onChange(o.tag, v, $input);
				}
			});
		}
		else
		{
			$input.val(o.value);
			$input.on('click', function (e) { if ($input.attr("disabled") !== "disabled") { return o.onChange(o.tag, $input); } });
		}

		var $row = $('<div class="dialogOption_item dialogOption_item_btn' + disabledClass + '"></div>');
		if (o.label)
		{
			var $label = $('<label class="dialogOption_label">' + o.label + ' </label>');
			$row.append($label);
		}
		$row.append($input);
		return $row;
	}
	else if (o.inputType === "hotkey")
	{
		var $inputWrapper = $('<div class="textBasedInput"></div>');
		var $input = $('<input type="text" />');
		$input.val(getHotkeyTextValueFromHotkeyValue(o.value));
		$input.on('keydown', function (e)
		{
			var charCode = e.which;
			var keyName = hotkeys.getKeyName(charCode);
			var hotkeyValue = (e.ctrlKey ? "1" : "0") + "|" + (e.altKey ? "1" : "0") + "|" + (e.shiftKey ? "1" : "0") + "|" + charCode + "|" + keyName;
			var textValue = getHotkeyTextValueFromHotkeyValue(hotkeyValue);
			$input.val(textValue);
			return o.onChange(e, o.tag, $input, textValue, hotkeyValue);
		});

		$inputWrapper.append($input);
		var $row = $('<div class="dialogOption_item dialogOption_item_info"></div>')
		$row.append($inputWrapper);
		$row.append(GetDialogOptionLabel(o.label));
		return $row;
	}
	else if (o.inputType === "gamepad_binding")
	{
		var $input = $('<input type="button" />');
		$input.val(o.value ? o.value : "unbound");

		$input.on('click', function (e)
		{
			var gamepadBindingDialog = null;
			var LearnGamepadBinding = function (gamepad_action)
			{
				$input.val(gamepad_action.key);
				o.onChange(e, o.tag, $input);
				if (gamepadBindingDialog)
				{
					gamepadBindingDialog.close();
					gamepadBindingDialog = null;
				}
			}

			BI_CustomEvent.AddListener("GamepadAction", LearnGamepadBinding);

			var $dlg = $('<div style="white-space: pre-wrap; padding: 10px;">'
				+ '<div style="text-align: center; margin-bottom: 2em;">Binding "' + o.label + '"</div>'
				+ '<div><img src="ui3/ajax-loader-big.gif" role="presentation" alt="" /></div>'
				+ '<div style="text-align: center; margin-bottom: 2em;">(listening for a gamepad action)</div>'
				+ '</div>');
			var $unbindBtn = $('<div style="text-align: center;"><input type="button" value="unbind" /></div>');
			$unbindBtn.find('input').on('click', function ()
			{
				$input.val("unbound");
				o.onChange(e, o.tag, $input);
				if (gamepadBindingDialog)
				{
					gamepadBindingDialog.close();
					gamepadBindingDialog = null;
				}
			});
			$dlg.append($unbindBtn);
			$dlg.append('<div style="text-align: center; margin-top: 1em;">(close this dialog to cancel)</div>');
			gamepadBindingDialog = $dlg.modalDialog({
				onClosing: function ()
				{
					BI_CustomEvent.RemoveListener("GamepadAction", LearnGamepadBinding);
				}
			});
		});

		var $row = $('<div class="dialogOption_item dialogOption_item_info"></div>')
		$row.append($input);
		$row.append(GetDialogOptionLabel(o.label));
		return $row;
	}
	else if (o.inputType === "errorCommentText")
	{
		return $('<div class="dialogOption_item dialogOption_item_info dialogOption_item_comment settingsCommentError"></div>').text(o.label);
	}
	else if (o.inputType === "errorCommentHtml")
	{
		return $('<div class="dialogOption_item dialogOption_item_info dialogOption_item_comment settingsCommentError"></div>').html(o.label);
	}
	else if (o.inputType === "commentText")
	{
		return $('<div class="dialogOption_item dialogOption_item_info dialogOption_item_comment"></div>').text(o.label);
	}
	else if (o.inputType === "commentHtml")
	{
		return $('<div class="dialogOption_item dialogOption_item_info dialogOption_item_comment"></div>').html(o.label);
	}
	else if (o.inputType === "noteText")
	{
		return $('<div class="dialogOption_item dialogOption_item_info"></div>').text(o.label);
	}
	else if (o.inputType === "noteHtml")
	{
		return $('<div class="dialogOption_item dialogOption_item_info"></div>').html(o.label);
	}
	else
	{
		console.error("Invalid arguments sent to UIFormField", args);
		return $('<div class="dialogOption_item dialogOption_item_info">Invalid arguments sent to UIFormField.</div>');
	}
}
var ThreeStateOptions = ["No preference", "Force OFF", "Force ON"];
var ThreeStateButtonClasses = ["triBtn0", "triBtn1", "triBtn2"];
function MakeAddEditorFieldFn(title, $content, obj, o)
{
	o = $.extend({
		compact: false
	}, o);
	var rowIdx = 0;
	var AddEditorField = function (label, key, options)
	{
		if (!options)
			options = {};
		var $row = $('<div class="profileEditorRow"></div>');
		if (rowIdx++ % 2 === 1)
			$row.addClass('everyOther');

		if (options.hint)
			$row.attr('title', options.hint);

		var value = obj[key];
		var valueType = typeof value;
		var type = options.type;
		if (!type)
			type = valueType;

		if (valueType === "number")
		{
			if (value < 0)
			{
				obj[key] = -1;
				value = "";
			}
			else if (typeof options.min === "number" && value < options.min)
			{
				obj[key] = options.min;
				value = options.min;
			}
			else if (typeof options.max === "number" && value > options.max)
			{
				obj[key] = options.max;
				value = options.max;
			}
		}

		var fieldArgs = {
			value: value
			, label: label
			, tag: key
			, disabled: !!options.disabled
			, compact: o.compact
		};
		if (type === "boolean")
		{
			fieldArgs.inputType = "checkbox";
			fieldArgs.onChange = CheckboxChanged;
		}
		else if (type === "string")
		{
			fieldArgs.inputType = "text";
			fieldArgs.onChange = TextChanged;
			fieldArgs.maxValue = options.max;
		}
		else if (type === "color")
		{
			fieldArgs.inputType = "color";
			fieldArgs.onChange = TextChanged;
			fieldArgs.maxValue = 7;
			if (fieldArgs.value.length === 6)
				fieldArgs.value = "#" + fieldArgs.value;
		}
		else if (type === "number")
		{
			fieldArgs.inputType = "number";
			fieldArgs.onChange = NumberChanged;
			fieldArgs.minValue = options.min;
			fieldArgs.maxValue = options.max;
		}
		else if (type === "select")
		{
			fieldArgs.inputType = "select";
			fieldArgs.onChange = SelectChanged
			fieldArgs.options = options.options;
			if (valueType === "number")
			{
				if (valueType < 0 || valueType >= options.options.length)
					toaster.Error(title + " Error: invalid value for " + label + ": " + value, 30000);
				else
					fieldArgs.value = options.options[value];
			}
		}
		else if (type === "comment")
		{
			fieldArgs.inputType = "commentText";
		}
		else if (type === "errorCommentText")
		{
			fieldArgs.inputType = "errorCommentText";
		}
		else if (type === "errorCommentHtml")
		{
			fieldArgs.inputType = "errorCommentHtml";
		}
		else
		{
			fieldArgs.inputType = "noteText";
			fieldArgs.label = "Unknown object type: '" + type + "' with value '" + value + "' and label '" + label + "'";
		}
		if (typeof options.onChange === "function")
		{
			// An extra onChange method was provided. Create a wrapper to see both applied.
			var oldOnChange = fieldArgs.onChange;
			fieldArgs.onChange = function ()
			{
				if (typeof oldOnChange === "function")
					oldOnChange.apply(this, arguments);
				options.onChange.apply(this, arguments);
			}
		}
		$row.append(UIFormField(fieldArgs));

		$content.append($row);
	};
	var CheckboxChanged = function (key, checked)
	{
		obj[key] = checked;
	};
	var TextChanged = function (e, key, $input)
	{
		obj[key] = $input.val();
	};
	var SelectChanged = function (e, key, $select)
	{
		var type = typeof obj[key];
		if (type === "number")
			$select.children('option').each(function (idx, ele)
			{
				if ($(ele).is(':selected'))
				{
					obj[key] = idx;
					return;
				}
			});
		else
			obj[key] = $select.val();
	};
	var NumberChanged = function (e, key, $input)
	{
		var value = parseFloat($input.val());
		if (isNaN(value))
			obj[key] = -1;
		else
		{
			var min = parseFloat($input.attr('min'));
			var max = parseFloat($input.attr('max'));
			if (min > max)
			{
				var tmp = min;
				min = max;
				max = tmp;
			}
			if (!isNaN(min) && value < min)
				$input.val(value = min);
			else if (!isNaN(max) && value > max)
				$input.val(value = max);
			obj[key] = value;
		}
	};
	return AddEditorField;
}
///////////////////////////////////////////////////////////////
// UI Help ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
var UIHelp = new UIHelpTool();
function UIHelpTool()
{
	var self = this;
	this.LearnMore = function (topic)
	{
		switch (topic)
		{
			case 'Double-Click to Fullscreen':
				Double_Click_to_Fullscreen();
				break;
			case 'Context Menu Trigger':
				Context_Menu_Trigger();
				break;
			case 'Camera Group Webcasting':
				Camera_Group_Webcasting();
				break;
			case "IR Brightness Contrast":
				IR_Brightness_Contrast();
				break;
			case "ui3-local-overrides":
				UI3_Local_Overrides_Help();
				break;
			case "Export Types":
				UI3_Export_Types_Help();
				break;
			case "H.264 Player Options":
				UI3_H264_Player_Options_Help();
				break;
			case "HTML5 Video Delay Compensation":
				UI3_HTML5_Delay_Compensation_Help();
				break;
			case "Edge Fetch Bug":
				UI3_Edge_Fetch_Bug_Help();
				break;
			case "Local Snapshots":
				UI3_Local_Snapshots_Help();
				break;
			case "Dynamic Group Layout":
				UI3_Dynamic_Group_Layout();
				break;
			case "UI Status Sounds":
				UI3_UI_Status_Sounds();
				break;
			case "Video Player Error":
				UI3_Video_Player_Error();
				break;
			case "Camera List Totals":
				UI3_Camera_List_Totals();
				break;
		}
	}
	var Context_Menu_Trigger = function ()
	{
		$('<div class="UIHelp" style="max-width:500px;">'
			+ 'Many useful functions in this interface are accessed by context menus (a.k.a. "Right-click menus").<br><br>'
			+ 'Context menus are normally opened by right clicking.  On most touchscreen devices, instead you must press and hold.<br><br>'
			+ 'However on some devices it is impossible to open context menus the normal way.  If this applies to you,'
			+ ' try different values for the "Context Menu Trigger" option.<br><br>* The "Long-Press" method causes context menus to open'
			+ ' when the left mouse button is held down for a moment.<br><br>* For devices which cannot perform a "Long-Press" due to technical limitations, the "Double-Click" method causes context menus to open'
			+ ' when the left mouse button is pressed twice in rapid succession. In some cases, each click also performs other actions such as selecting a camera, so this method is best used only as a last-resort.'
			+ '</div>')
			.modalDialog({ title: "Context Menu Trigger", closeOnOverlayClick: true });
	}
	var Double_Click_to_Fullscreen = function ()
	{
		$('<div class="UIHelp" style="max-width:500px;">'
			+ 'This setting controls whether or not double-clicking the video area triggers fullscreen mode.<br><br>'
			+ 'When double-clicking is enabled, single-click actions on the same area will be delayed by ' + videoPlayer.getDoubleClickTime()
			+ ' milliseconds.  This is to allow the browser time to determine if you intended a single-click or a double-click.<br><br>'
			+ 'In live view, single-clicking a camera selects the camera.'
			+ (settings.ui3_doubleClick_behavior == "Both" || settings.ui3_doubleClick_behavior == "Live View"
				? '<br><span style="color:#ff4700;font-weight:bold;margin-left:15px;">The current setting will delay this behavior by ' + videoPlayer.getDoubleClickTime() + ' milliseconds.</span>'
				: '<br><span style="color:#26cb26;font-weight:bold;margin-left:15px;">The current setting will not delay this behavior.</span>')
			+ '<br><br>'
			+ 'When a recording is open, single-clicking the video invokes Play/Pause.'
			+ (settings.ui3_doubleClick_behavior == "Both" || settings.ui3_doubleClick_behavior == "Recordings"
				? '<br><span style="color:#ff4700;font-weight:bold;margin-left:15px;">The current setting will delay this behavior by ' + videoPlayer.getDoubleClickTime() + ' milliseconds.</span>'
				: '<br><span style="color:#26cb26;font-weight:bold;margin-left:15px;">The current setting will not delay this behavior.</span>')
			+ '</div>')
			.modalDialog({ title: "Double-Click to Fullscreen", closeOnOverlayClick: true });
	}
	var Camera_Group_Webcasting = function ()
	{
		var $root = $('<div class="UIHelp">'
			+ 'One or more of the cameras you have access to was not found in any group streams.  UI3 has added these cameras individually to the Current Group dropdown list so that you may access them for live viewing and alert/clip filtering.  This may happen if any cameras are flagged as "hidden" or if some of your groups do not have webcasting enabled.  UI3 is easier to use when all your camera groups have webcasting enabled.<br><br>'
			+ 'Enable webcasting for your groups using the group settings panel.  This panel is found near the top of the Blue Iris console:<br><br>'
			+ '</div>');
		var $img = $('<img src="ui3/help/img/GroupProperties.png' + currentServer.GetLocalSessionArg("?") + '" style="width:380px; height:255px;" />');
		$root.append($img);
		$img.lightbox();
		$root.modalDialog({ title: 'Camera Group Webcasting', closeOnOverlayClick: true });
	}
	var IR_Brightness_Contrast = function ()
	{
		var $root = $('<div class="UIHelp">'
			+ 'Infrared, Brightness, and Contrast controls do not work well with many cameras, so they are disabled by default to save space.<br><br>'
			+ 'When enabled, these controls appear in the PTZ section below the presets, and only work when you have maximized a camera that has PTZ enabled in Blue Iris.'
			+ '</div>');
		$root.modalDialog({ title: 'IR, Brightness, and Contrast', closeOnOverlayClick: true });
	}
	var UI3_Local_Overrides_Help = function ()
	{
		$('<div class="UIHelp">'
			+ 'Click "Download" to download a ui3-local-overrides.js file which is pre-configured to change the defaults for all of UI3\'s settings to match your current configuration.<br><br>'
			+ 'The ui3-local-overrides system allows you to override default UI3 behavior for all your users.<br><br>'
			+ '<a href="ui3/help/help.html' + currentServer.GetLocalSessionArg("?") + '#extensions" target="_blank">Click here to learn more about ui3-local-overrides.</a>'
			+ '</div>').modalDialog({ title: 'ui3-local-overrides', closeOnOverlayClick: true });
	}
	var UI3_Export_Types_Help = function ()
	{
		$('<div class="UIHelp">'
			+ 'UI3 will export in "Native" mode or "Slow Transcode" mode depending on the format of the source recording.<br><br>'
			+ '"Native" mode is used when the source recording has H.264 video in a .bvr container.  This mode is fast (depending on network speed) and results in excellent video quality.<br><br>'
			+ '"Slow Transcode" mode is used when "Native" mode is not possible.  This mode transcodes the source video to H.264 in real-time using your Streaming 0 profile.  The export will take about as many seconds as the size of the exported section.'
			+ '</div>').modalDialog({ title: 'Export Types', closeOnOverlayClick: true });
	}
	var UI3_H264_Player_Options_Help = function ()
	{
		$('<div class="UIHelp">'
			+ 'UI3 has several H.264 player options. Not all options are available in all browsers.'
			+ '<br><br><b>Automatic</b> <span style="color:#66FF66;">(Preferred)</span><br><br>'
			+ '&nbsp; &nbsp; When "Automatic" is selected, UI3 will choose which player to load.  It is recommended to stay on "Automatic" unless it causes problems.'
			+ '<br><br><b>WebCodecs</b> - ' + (webcodecs_h264_player_supported ? '<span style="color:#66FF66;">Available</span>' : '<span style="color:#FF3333;">Not Available</span>') + '<br><br>'
			+ '&nbsp; &nbsp; The WebCodecs player directly accesses the browser\'s built-in video codecs to efficiently decode video with the lowest possible latency.  WebCodecs is available in Chromium-based browsers since late 2021, and is only avalable on pages loaded via HTTPS.'
			+ '<br><br><b>JavaScript</b> - ' + (h264_js_player_supported ? '<span style="color:#66FF66;">Available</span>' : '<span style="color:#FF3333;">Not Available</span>') + '<br><br>'
			+ '&nbsp; &nbsp; The JavaScript player is the most robust and compatible player option, but also the slowest.'
			+ '<br><br><b>HTML5</b> - ' + (mse_mp4_h264_supported ? '<span style="color:#66FF66;">Available</span>' : '<span style="color:#FF3333;">Not Available</span>') + '<br><br>'
			+ '&nbsp; &nbsp; The HTML5 player works by converting each frame into a fragmented MP4 which is played using Media Source Extensions.  This is usually the fastest option, but has compatibility problems with some browsers.'
			+ '<br><br><b>NaCl</b> - ' + (pnacl_player_supported ? '<span style="color:#66FF66;">Available</span>' : '<span style="color:#FF3333;">Not Available</span>') + '<br><br>'
			+ '&nbsp; &nbsp; The NaCl player is faster than the JavaScript player. It is not quite as fast as the HTML5 player, and takes longer to load when you open UI3, but may be more stable. This player is only available in ChromeOS and in the Chrome browser on a desktop OS (such as Windows or Mac).  It uses Google\'s "NaCl" or "Native Client" technology, which was expected to be removed from Chrome in 2018 but remained available by entering <b>chrome://flags</b> in the address bar and enabling <b>Native Client</b>.'
			+ (pnacl_player_supported ? ('<br><br>The NaCl player has 3 modes available, each with different behavior regarding Hardware Accelerated Video Decoding.<br>'
				+ '<ul>'
				+ '<li><b>' + H264PlayerOptions.NaCl_HWVA_Auto + '</b><br>The player will try to use hardware decoding, but will fall back to software decoding if hardware decoding is unavailable. The fallback process may increase loading times.</li>'
				+ '<li><b>' + H264PlayerOptions.NaCl_HWVA_No + '</b><br>The player will use software decoding only.</li>'
				+ '<li><b>' + H264PlayerOptions.NaCl_HWVA_Yes + '</b><br>The player will use hardware decoding only, and may fail if hardware acceleration is unavailable.</li>'
				+ '</ul>'
			) : '')
			+ '</div>').modalDialog({ title: 'H.264 Player Options', closeOnOverlayClick: true });
	}
	var UI3_HTML5_Delay_Compensation_Help = function ()
	{
		$('<div class="UIHelp">'
			+ 'HTML5 video was not designed for low-latency playback, so brief stream interruptions build up to a noticeable delay. UI3 is built with an experimental delay compensator which can speed up or slow down the video player to keep video delay at a consistent level. This delay compensator is configurable via the HTML5 Video Delay Compensation option.'
			+ '</div>').modalDialog({ title: 'HTML5 Video Delay Compensation', closeOnOverlayClick: true });
	}
	var UI3_Edge_Fetch_Bug_Help = function ()
	{
		$('<div class="UIHelp">'
			+ "Beginning with EdgeHTML 17.x and continuing through 18.x (newest at the time of this writing), Microsoft Edge fails to close the network connections used to stream H.264 video (and audio) in UI3.  Instability and poor performance may result as multiple unused video streams remain open until the browser tab is closed.  For this reason, it is recommended to disable the H.264 player and only use Jpeg streaming methods in this browser."
			+ '</div>').modalDialog({ title: 'Edge Fetch Bug', closeOnOverlayClick: true });
	}
	var UI3_Local_Snapshots_Help = function ()
	{
		$('<div class="UIHelp">'
			+ "<p>UI3 has the ability to save snapshots to disk using the camera button in the upper right and also via context menu (right-click on the video player). There are three methods of capture:</p>"
			+ "<p><b>Server</b> (default)</p>"
			+ "<ul>"
			+ "<li>Downloaded snapshots come from the server.</li>"
			+ "<li>May not capture the exact frame you see in the video player while streaming H.264.</li>"
			+ "<li>Configurable quality.</li>"
			+ "</ul>"
			+ "<p><b>Local (JPEG)</b></p>"
			+ "<ul>"
			+ "<li>Downloaded snapshots are captured from the local video player.</li>"
			+ "<li>Always captures the frame you expect.</li>"
			+ "<li>Quality typically worse than server-sourced snapshots.</li>"
			+ "<li>Works well with poor internet connections.</li>"
			+ "<li>Only works with HTML5 and Jpeg video players.</li>"
			+ "</ul>"
			+ "<p><b>Local (PNG)</b></p>"
			+ "<ul>"
			+ "<li>Same as Local (JPEG) except snapshots are saved in PNG format.  Slightly better quality, much larger file size.  Still typically worse than server-sourced snapshots.</li>"
			+ "</ul>"
			+ '</div>').modalDialog({ title: 'Server Snapshots vs Local Snapshots', closeOnOverlayClick: true });
	}
	var UI3_Dynamic_Group_Layout = function ()
	{
		$('<div class="UIHelp">'
			+ "<p>If \"Dynamic Group Layout\" is enabled, the layout of your camera groups will be optimized to best-fit your current browser window.  This only works for groups that are configured in Blue Iris to have an \"Auto\" aspect ratio.</p>"
			+ "<p>Requires Blue Iris 5.5.x or newer.</p>"
			+ '</div>').modalDialog({ title: 'Dynamic Group Layout', closeOnOverlayClick: true });
	}
	var UI3_UI_Status_Sounds = function ()
	{
		function MakeSoundListItem(html, playSoundFn)
		{
			var $li = $('<li></li>');
			var $link = $('<a href="javascript:void(0)">' + html + '</a>');
			$link.on('click', function ()
			{
				playSoundFn();
			});
			$li.append($link);
			return $li;
		}
		var $ele = $('<div class="UIHelp">'
			+ "<p>By enabling \"UI Status Sounds\", sounds will be played:</p>"
			+ '</div>');
		var $ul = $('<ul class="extraSpacing"></ul>');
		$ul.append(MakeSoundListItem("When video streaming is disconnected.", function () { programmaticSoundPlayer.PlayDisconnectSound(true, true); }));
		$ul.append(MakeSoundListItem("When video streaming is reconnected.", function () { programmaticSoundPlayer.PlayConnectSound(true, true); }));
		$ul.append(MakeSoundListItem("Periodic tone while video is disconnected.", function () { programmaticSoundPlayer.PlayPeriodicDisconnectedSound(true, true); }));
		$ul.append(MakeSoundListItem("When the UI is about to reload (to recover from an error).", function () { programmaticSoundPlayer.PlayReloadingSound(true, true); }));
		$ele.append($ul);
		$ele.modalDialog({ title: 'UI Status Sounds', closeOnOverlayClick: true });
	}
	var UI3_Video_Player_Error = function ()
	{
		var $ele = $('<div class="UIHelp">'
			+ "<p>It looks like there was an error with the <b>" + currentH264Player + "</b> video player.</p>"
			+ "<p>UI3 offers a choice of video player modules to help you work around compatibility problems.</p>"
			+ "<p>Consider trying a different video player module via:</p>"
			+ "<p> &nbsp; <a role=\"button\" class=\"h264PlayerSettingsLink\">UI Settings &gt; Video Player &gt; H.264 Player</a></p>"
			+ '</div>');
		var dlg = null;
		$ele.find('.h264PlayerSettingsLink').on('click', function ()
		{
			uiSettingsPanel.open("H.264 Player");
			//if (dlg)
			//	dlg.close();
		});
		dlg = $ele.modalDialog({ title: 'Troubleshooting Video Player Errors', closeOnOverlayClick: true });
	}
	var UI3_Camera_List_Totals = function ()
	{
		$('<div class="UIHelp">'
			+ "The \"Bit Rate\" and \"Megapixels Per Second\" totals shown in UI3 are computed from camera metadata provided by Blue Iris.  UI3's totals may not exactly match Blue Iris's totals for several reasons:"
			+ "<ul>"
			+ "<li>Cloned cameras will be counted redundantly, because UI3 doesn't know which cameras are clones (if any).</li>"
			+ "<li>Sub stream resolutions are often slightly upscaled by Blue Iris to match the aspect ratio of the main stream; UI3 only knows the upscaled size, therefore may slightly overestimate the Megapixels Per Second.</li>"
			+ "</ul>"
			+ '</div>').modalDialog({ title: 'Camera List Totals', closeOnOverlayClick: true });
	}
}
///////////////////////////////////////////////////////////////
// Collapsible Section for Dialogs ////////////////////////////
///////////////////////////////////////////////////////////////
function CollapsibleSection(id, htmlTitle, dialogToNotify, permanentOpen, onToggle)
{
	var self = this;
	var settingsKey = "ui3_cps_" + id.replace(/\W/g, '_') + "_visible";
	var visibleSetting = settings.getItem(settingsKey);
	if (visibleSetting !== "0" && visibleSetting !== "1")
	{
		// The setting should have been added to defaultSettings.
		console.error("SETTING DOES NOT EXIST", settingsKey);
		visibleSetting = "1";
		settings.setItem(settingsKey, visibleSetting);
	}

	var GetSectionHeading = function ()
	{
		var $heading = $('<div class="collapsible_section_heading">' + htmlTitle + '</div>');
		if (!permanentOpen)
			$heading.on('click', SectionHeadingClick);
		if (permanentOpen || settings.getItem(settingsKey) == "1")
			$heading.addClass("expanded");
		if (permanentOpen)
			$heading.addClass("permanentOpen");
		return $heading;
	}
	var GetSection = function ()
	{
		var $section = $('<div class="collapsible_section"></div>');
		if (!permanentOpen && settings.getItem(settingsKey) == "0")
			$section.hide();
		return $section;
	}
	var SectionHeadingClick = function ()
	{
		self.$section.slideToggle(
			{
				duration: 150
				, always: function ()
				{
					if (dialogToNotify != null)
						dialogToNotify.contentChanged(false, true);
					var expanded = self.$section.is(":visible");
					settings.setItem(settingsKey, expanded ? "1" : "0");
					if (expanded)
						self.$heading.addClass("expanded");
					else
						self.$heading.removeClass("expanded");
					if (typeof onToggle === "function")
						onToggle(expanded);
				}
			});
	}
	this.Expand = function ()
	{
		if (!self.$section.is(":visible"))
			SectionHeadingClick();
	}
	this.Collapse = function ()
	{
		if (self.$section.is(":visible"))
			SectionHeadingClick();
	}
	this.IsExpanded = function ()
	{
		return self.$section.is(":visible");
	}
	this.$heading = GetSectionHeading();
	this.$section = GetSection();
}
///////////////////////////////////////////////////////////////
// Binary Constants ///////////////////////////////////////////
///////////////////////////////////////////////////////////////
var b0000_0001 = 1;
var b0000_0010 = 1 << 1; // 2
var b0000_0100 = 1 << 2; // 4
var b0000_1000 = 1 << 3; // 8
var b0001_0000 = 1 << 4; // 16
var b0010_0000 = 1 << 5; // 32
var b0100_0000 = 1 << 6; // 64
var b1000_0000 = 1 << 7; // 128
// JavaScript can't conveniently left shift beyond 30.  Add more flags as needed to this object:
var HIGHFLAGS = {
	F31: 2147483648,
	F32: 4294967296,
	F33: 8589934592,
	F34: 17179869184
}
var BIDBFLAG = {
	AUDIO: 1,
	FLAGGED: 1 << 1,
	PROTECTED: 1 << 2,
	CORRUPT: 1 << 3,
	DELETE: 1 << 4,
	DELETED: 1 << 5,
	ARCHIVE: 1 << 6,
	ARCHIVED: 1 << 7,
	RECORDING: 1 << 8,
	EXPORT: 1 << 9,
	EXPORTED: 1 << 10,
	SPECIALOBJ: 1 << 11,

	AI_CONFIRMED_X: 1 << 14,
	AI_OCCUPIED_X: 1 << 15,

	ALERT_OFFSETTIME: 1 << 16,
	ALERT_MOTION: 1 << 17,
	ALERT_ONVIF: 1 << 18,
	ALERT_AUDIO: 1 << 19,
	ALERT_EXTERNAL: 1 << 20,
	ALERT_DIO: 1 << 21,
	ALERT_GROUP: 1 << 22,
	ALERT_CANCELLED: 1 << 23,
	ALERT_NOSIGNAL: 1 << 24,
	ALERT_HIDDEN: 1 << 24,

	AI_PERSON: 1 << 26,
	AI_VEHICLE: 1 << 27,
	AI_CONFIRMED: 1 << 28,
	AI_OCCUPIED: 1 << 29,
	ALERT_AI: 1 << 30,
	AI_WILDLIFE: HIGHFLAGS.F31
};

BIDBFLAG.ALERT_TRIGGERBITS = (BIDBFLAG.ALERT_MOTION
	| BIDBFLAG.ALERT_NOSIGNAL
	| BIDBFLAG.ALERT_AUDIO
	| BIDBFLAG.ALERT_EXTERNAL
	| BIDBFLAG.ALERT_ONVIF
	| BIDBFLAG.ALERT_DIO
	| BIDBFLAG.ALERT_GROUP
	| BIDBFLAG.ALERT_CANCELLED);

var NO_SHOW_ON_TIMELINE = UI3_BINARY_OR(BIDBFLAG.DELETED, BIDBFLAG.ALERT_HIDDEN);

var TRIGGER_SOURCE_MOTION = (1 << 1);
var TRIGGER_SOURCE_ONVIF = (1 << 2);
var TRIGGER_SOURCE_AUDIO = (1 << 3);
var TRIGGER_SOURCE_EXTERNAL = (1 << 4);
var TRIGGER_SOURCE_DIO = (1 << 5);
var TRIGGER_SOURCE_GROUP = (1 << 6);
var TRIGGER_SOURCE_CANCELLED = (1 << 7);
var TRIGGER_SOURCE_NOSIGNAL = (1 << 8);

/**
 * Returns true if all the binary bits set in the second number are also set in the first number.
 * JavaScript can't do bitwise operations across its full range of supported integer numbers.
 * @param {Number} number The number containing 0 or more flags.
 * @param {Number} flags The flag or flags that you wish to determine if they exist in the first number.
 */
function NumberHasFlags(number, flags)
{
	if (number % 1 !== 0)
		return false; // number is not an integer. treat it like 0
	if (flags % 1 !== 0 || flags === 0)
		return false;
	if (number >= 0 && number < 2147483648 && flags >= 0 && flags < 2147483648)
		return (number & flags) === flags;
	var numberAsStr = number.toString(2);
	var flagsAsStr = flags.toString(2);
	var diff = numberAsStr.length - flagsAsStr.length;
	if (diff > 0)
		numberAsStr = numberAsStr.substring(diff); // If `number` produces a longer string, trim it so we compare the correct number of digits.
	else if (diff < 0)
		return false; // if `flags` produces a longer string, it must have a flag set that is not set in `number`.
	for (var i = 0; i < flagsAsStr.length; i++)
	{
		if (flagsAsStr[i] === '1' && numberAsStr[i] !== '1')
			return false;
	}
	return true;
}
function UI3_BINARY_AND(a, b)
{
	if (a >= 0 && a < 2147483648 && b >= 0 && b < 2147483648)
		return a & b;
	a = a.toString(2);
	b = b.toString(2);
	if (a.length > b.length)
		b = b.padLeft(a.length, "0");
	else if (b.length > a.length)
		a = a.padLeft(b.length, "0");
	var resultArr = [];
	for (var i = 0; i < a.length; i++)
		resultArr.push(a[i] === "1" && b[i] === "1" ? "1" : "0");
	return parseInt(resultArr.join(""), 2);
}
function UI3_BINARY_OR(a, b)
{
	if (a >= 0 && a < 2147483648 && b >= 0 && b < 2147483648)
		return a | b;
	a = a.toString(2);
	b = b.toString(2);
	if (a.length > b.length)
		b = b.padLeft(a.length, "0");
	else if (b.length > a.length)
		a = a.padLeft(b.length, "0");
	var resultArr = [];
	for (var i = 0; i < a.length; i++)
		resultArr.push(a[i] === "1" || b[i] === "1" ? "1" : "0");
	return parseInt(resultArr.join(""), 2);
}
function UI3_BINARY_XOR(a, b)
{
	if (a >= 0 && a < 2147483648 && b >= 0 && b < 2147483648)
		return a ^ b;
	a = a.toString(2);
	b = b.toString(2);
	if (a.length > b.length)
		b = b.padLeft(a.length, "0");
	else if (b.length > a.length)
		a = a.padLeft(b.length, "0");
	var resultArr = [];
	for (var i = 0; i < a.length; i++)
		resultArr.push((a[i] === "1" || b[i] === "1") && a[i] !== b[i] ? "1" : "0");
	return parseInt(resultArr.join(""), 2);
}
function UI3_BINARY_INVERT(a)
{
	a = a.toString(2).padLeft(53, '0');
	var resultArr = [];
	for (var i = 0; i < a.length; i++)
		resultArr.push(a[i] === "1" ? "0" : "1");
	return parseInt(resultArr.join(""), 2);
}
function UI3_BINARY_FLAG(idx)
{
	if (idx > 53)
		throw new Error("JavaScript cannot safely represent flag index " + idx + " without using BigInt");
	var resultArr = [];
	resultArr.push("1");
	for (var i = 0; i < idx; i++)
		resultArr.push("0");
	return parseInt(resultArr.join(""), 2);
}

function NumberToBinaryBooleans(number)
{
	var result = [];
	var binStr = number.toString(2);
	for (var i = binStr.length - 1; i >= 0; i--)
		result.push(binStr[i] === "1");
	return result;
}
function DecodeClipFlags(flags)
{
	var names = [];
	for (var property in BIDBFLAG)
	{
		if (BIDBFLAG.hasOwnProperty(property) && NumberHasFlags(flags, BIDBFLAG[property]))
			names.push(property);
	}
	return names.join(", ");
}
///////////////////////////////////////////////////////////////
// Clip Icons Helper //////////////////////////////////////////
///////////////////////////////////////////////////////////////
var clipIcons = new (function ()
{
	var self = this;
	this.icons = new FasterObjectMap();
	/**
	 * Declares (creates or updates) the icon with the given iconId.
	 * @param {String} iconId unique identifier string for the icon
	 * @param {String} svgId id attribute of the svg graphic
	 * @param {Boolean} noflip true if the "noflip" css class needs to be applied to the svg
	 * @param {String} descriptionText Description text to use in tooltips and Clip/Alert properties panel
	 * @param {Number} flags Flags which must be found in the clip data for this icon to appear.  If 0, no flags are required.
	 * @param {String} clipListDisplaySetting UI3 settings key which must have value "1" in order for this icon to appear. May be null or empty.
	 * @param {Function} conditionFn Condition function accepting clipData argument which must return true in order for this icon to appear. May be null.
	 */
	this.setIcon = function (iconId, svgId, noflip, descriptionText, flags, clipListDisplaySetting, conditionFn)
	{
		this.icons[iconId] = { iconId: iconId, svgId: svgId, noflip: noflip, descriptionText: descriptionText, flags: flags, clipListDisplaySetting: clipListDisplaySetting, conditionFn: conditionFn };
	}
	this.setIcon("trigger_ai_confirmed", "#svg_mio_cbChecked", true, "AI-confirmed (or manually confirmed) alert", BIDBFLAG.AI_CONFIRMED, "ui3_clipicon_trigger_sentry");
	this.setIcon("trigger_ai_occupied", "#sentry_human", true, "", BIDBFLAG.AI_OCCUPIED, "ui3_clipicon_trigger_sentry_occupied");
	this.setIcon("ai_person", "#svg_mio_man", true, "AI detected a person", BIDBFLAG.AI_PERSON, "ui3_clipicon_ai_person");
	this.setIcon("ai_vehicle", "#svg_mio_directions_car", true, "AI detected a vehicle", BIDBFLAG.AI_VEHICLE, "ui3_clipicon_ai_vehicle");
	this.setIcon("ai_wildlife", "#wildlife", true, "AI detected wildlife", BIDBFLAG.AI_WILDLIFE, "ui3_clipicon_ai_wildlife");
	this.setIcon("alert_cancelled", "#svg_x5F_HoldProfile", false, "Alert was cancelled", BIDBFLAG.ALERT_CANCELLED, "ui3_clipicon_alert_cancelled");
	this.setIcon("trigger_motion", "#svg_mio_run", true, "Triggered by motion detection", BIDBFLAG.ALERT_MOTION, "ui3_clipicon_trigger_motion");
	this.setIcon("trigger_audio", "#svg_mio_volumeUp", true, "Triggered by audio", BIDBFLAG.ALERT_AUDIO, "ui3_clipicon_trigger_audio");
	this.setIcon("trigger_external", "#svg_x5F_Alert1", false, "Triggered by external source such as DIO or manual trigger", BIDBFLAG.ALERT_EXTERNAL, "ui3_clipicon_trigger_external");
	this.setIcon("trigger_group", "#svg_mio_quilt", true, "The group was triggered", BIDBFLAG.ALERT_GROUP, "ui3_clipicon_trigger_group");
	this.setIcon("clip_audio", "#svg_mio_volumeUp", true, "Clip has audio", BIDBFLAG.AUDIO, "ui3_clipicon_clip_audio");
	this.setIcon("clip_backingup", "#svg_mio_cloudUploading", true, "Clip is currently being backed up", BIDBFLAG.ARCHIVE, "ui3_clipicon_clip_backingup");
	this.setIcon("clip_backedup", "#svg_mio_cloudUploaded", true, "Clip has been backed up", BIDBFLAG.ARCHIVED, "ui3_clipicon_clip_backup");
	this.setIcon("protect", "#svg_mio_lock", true, "Item is protected", BIDBFLAG.PROTECTED, "ui3_clipicon_protect");
	this.setIcon("flag", "#svg_x5F_Flag", false, "Item is flagged", BIDBFLAG.FLAGGED, "ui3_clipicon_flag");
	this.setIcon("is_recording", "#svg_x5F_Stoplight", false, "Clip is still recording", BIDBFLAG.RECORDING, "ui3_clipicon_is_recording");
	this.setIcon("nosignal", "#svg_x5F_Error", false, "Camera had no signal", BIDBFLAG.ALERT_NOSIGNAL, "ui3_clipicon_nosignal");
	this.setIcon("is_new", "#svg_x5F_Stoplight", true, "Alert is newer than you have seen before", 0, "ui3_clipicon_is_new", function (clipData) { return clipData.isNew; });

	this.getIconsAffectingClip = function (clipData, checkUserSettings)
	{
		var arr = [];
		for (var iconId in self.icons)
		{
			var icon = self.icons[iconId];
			if (icon.flags && !NumberHasFlags(clipData.flags, icon.flags))
				continue;
			if (checkUserSettings && icon.clipListDisplaySetting && settings[icon.clipListDisplaySetting] !== "1")
				continue;
			if (typeof icon.conditionFn === "function")
			{
				try
				{
					if (!icon.conditionFn(clipData))
						continue;
				}
				catch (ex)
				{
					toaster.Error(ex);
					continue;
				}
			}
			arr.push(icon);
		}
		return arr;
	}
	this.getIconHtmlForClipTile = function (clipData)
	{
		var iconObjects = self.getIconsAffectingClip(clipData, true);
		var html = [];
		for (var i = 0; i < iconObjects.length; i++)
			html.push(self.GetClipIconHtml(iconObjects[i]));
		return html.join("");
	}
	this.getIconHtmlForClipProperties = function (clipData)
	{
		var iconObjects = self.getIconsAffectingClip(clipData, false);
		var html = [];
		for (var i = 0; i < iconObjects.length; i++)
		{
			html.push('<div class="dialogOption_item clipprop_item_info">');
			html.push(self.GetClipIconHtml(iconObjects[i]));
			html.push(iconObjects[i].descriptionText);
			html.push('</div>');
		}
		return html.join("");
	}
	this.getIconIds = function ()
	{
		var ids = [];
		for (var property in self.icons)
			ids.push(property);
		return ids;
	}
	this.GetClipIconHtml = function (icon)
	{
		return '<div class="clipicon icon-' + htmlAttributeEncode(icon.iconId) + '"'
			+ (icon.descriptionText ? (' title="' + htmlAttributeEncode(icon.descriptionText) + '"') : '')
			+ '><svg class="icon' + (icon.noflip ? ' noflip' : '') + '"><use xlink:href="' + htmlAttributeEncode(icon.svgId) + '"></use></svg></div>'
	}
})();
///////////////////////////////////////////////////////////////
// Zones Bitmask //////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function AlertZonesMask(zonesVal)
{
	this.A = (zonesVal & b0000_0001) > 0;
	this.B = (zonesVal & b0000_0010) > 0;
	this.C = (zonesVal & b0000_0100) > 0;
	this.D = (zonesVal & b0000_1000) > 0;
	this.E = (zonesVal & b0001_0000) > 0;
	this.F = (zonesVal & b0010_0000) > 0;
	this.G = (zonesVal & b0100_0000) > 0;
	this.Hotspot = (zonesVal & b1000_0000) > 0;
	this.toString = function ()
	{
		var arr = [];
		if (this.A) arr.push("A");
		if (this.B) arr.push("B");
		if (this.C) arr.push("C");
		if (this.D) arr.push("D");
		if (this.E) arr.push("E");
		if (this.F) arr.push("F");
		if (this.G) arr.push("G");
		if (this.Hotspot) arr.push("Hotspot");
		if (arr.length > 0)
			return arr.join(", ");
		else
			return "none";
	}
}
///////////////////////////////////////////////////////////////
// StringBuilder //////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function StringBuilder(lineBreakStr)
{
	var self = this;
	var strings = [];
	if (!lineBreakStr)
		lineBreakStr = "\r\n";
	this.Append = function (value)
	{
		if (typeof value !== "undefined")
			strings.push(value);
		return this;
	}
	this.AppendLine = function (value)
	{
		if (typeof value !== "undefined")
			strings.push(value);
		strings.push(lineBreakStr);
		return this;
	}
	this.Clear = function ()
	{
		strings = [];
		return this;
	}
	this.ToString = function ()
	{
		return strings.join("");
	}
	this.Length = function ()
	{
		var size = 0;
		for (var i = 0; i < strings.length; i++)
			size += strings[i].length;
		return size;
	}
}
///////////////////////////////////////////////////////////////
// Uint8Array to Data URI /////////////////////////////////////
///////////////////////////////////////////////////////////////
/**
 * The dataUri returned from this method should be sent to window.URL.revokeObjectURL() when it is done being used!
 * @param {Uint8Array} someUint8Array Uint8Array to convert into a data URI (actually, it will become a "blob:" url)
 */
function Uint8ArrayToDataURI(someUint8Array)
{
	var blob = new Blob([someUint8Array]);
	return window.URL.createObjectURL(blob);
}
///////////////////////////////////////////////////////////////
// Programmatic Sound Player //////////////////////////////////
///////////////////////////////////////////////////////////////
function ProgrammaticSoundPlayer()
{
	var self = this;

	var audioContext = null;
	var voice = null;
	var fail = false;

	var Initialize = function ()
	{
		self.setVoice(settings.ui3_speechVoice);
	}

	this.setVoice = function (voiceName)
	{
		if (!speech_synthesis_supported)
			return;
		try
		{
			var voices = speechSynthesis.getVoices();
			for (var i = 0; i < voices.length; i++)
			{
				if (voices[i].name === voiceName)
				{
					voice = voices[i];
					return;
				}
			}
			voice = voices.length ? voices[0] : null;
		}
		catch (ex)
		{
		}
	}

	var PrepareAudioContext = function ()
	{
		if (!web_audio_supported)
		{
			console.log("Web audio is not supported.");
			return false;
		}
		if (!audioContext && !fail)
		{
			try
			{
				//console.log("Preparing Audio Context");
				var AudioContext = window.AudioContext || window.webkitAudioContext;
				audioContext = new AudioContext(); // browsers limit the number of concurrent audio contexts
			}
			catch (ex)
			{
				fail = true;
				toaster.Error("Unable to create audioContext for sound player: " + ex.stack);
			}
		}
		return !!audioContext;
	}

	/**
	 * Plays a simple tone defined by the specified parameters.
	 * @param {Number} volume Volume from 0 to 1.
	 * @param {Number} frequency Frequency in Hz.
	 * @param {Number} durationSeconds Tone duration in seconds
	 * @returns {Number} Returns the audio context time when the sound will stop. This can be used to schedule future notes to play in sequence.
	 */
	this.PlayNote = function (volume, frequency, durationSeconds, playAt)
	{
		if (!PrepareAudioContext())
			return 0;

		//console.log("Playing note ", arguments);
		var edgeSofteningTime = Math.min(durationSeconds / 3, 0.02);

		var oscillator = audioContext.createOscillator();
		var gainNode = audioContext.createGain();
		oscillator.connect(gainNode);
		oscillator.frequency.value = frequency;
		oscillator.type = "triangle";
		gainNode.connect(audioContext.destination);
		gainNode.gain.value = volume;

		var startAt = playAt ? playAt : audioContext.currentTime;
		gainNode.gain.setValueAtTime(gainNode.gain.value, startAt);
		oscillator.start(startAt);
		gainNode.gain.exponentialRampToValueAtTime(gainNode.gain.value, startAt + edgeSofteningTime);

		var stopAt = startAt + durationSeconds;
		oscillator.stop(stopAt);
		gainNode.gain.setValueAtTime(gainNode.gain.value, stopAt - edgeSofteningTime);
		gainNode.gain.exponentialRampToValueAtTime(0.0001, stopAt);

		return stopAt;
	}
	/**
	 * Plays an array of notes in sequence.
	 * @param {Array} notes An array of notes taking the form { volume: Number, frequency: Number, durationSeconds: Number, offset: Number }. The offset of the first note is ignored.
	 */
	this.PlayNotes = function (notes)
	{
		if (!PrepareAudioContext())
			return;
		var nextStartTime = null;
		for (var i = 0; i < notes.length; i++)
		{
			if (nextStartTime !== null)
				nextStartTime += notes[i].offset;
			nextStartTime = self.PlayNote(notes[i].volume, notes[i].frequency, notes[i].durationSeconds, nextStartTime);
		}
	}

	this.PlaySoundAsConfigured = function (fn)
	{
		if (typeof fn === "function")
			fn(settings.ui3_uiStatusSounds === "1", settings.ui3_uiStatusSpeech === "1");
	}
	this.PlayDisconnectSound = function (sound, speech)
	{
		if (sound)
			self.PlayNotes([
				{ volume: 0.2, frequency: 171, durationSeconds: 0.15, offset: 0 },
				{ volume: 0.2, frequency: 114, durationSeconds: 0.15, offset: 0 },
				{ volume: 0.2, frequency: 86, durationSeconds: 0.15, offset: 0 },
			]);
		if (speech)
			setTimeout(function ()
			{
				self.Speak("disconnected", true);
			}, sound ? 150 : 0);
	}
	this.PlayConnectSound = function (sound, speech)
	{
		if (sound)
			self.PlayNotes([
				{ volume: 0.2, frequency: 86, durationSeconds: 0.15, offset: 0 },
				{ volume: 0.2, frequency: 114, durationSeconds: 0.15, offset: 0 },
				{ volume: 0.2, frequency: 171, durationSeconds: 0.15, offset: 0 },
			]);
		if (speech)
			setTimeout(function ()
			{
				self.Speak("reconnected", true);
			}, sound ? 150 : 0);
	}
	this.PlayPeriodicDisconnectedSound = function (sound)
	{
		if (sound)
			self.PlayNotes([{ volume: 0.2, frequency: 86, durationSeconds: 0.15, offset: 0 }]);
	}
	this.PlayReloadingSound = function (sound, speech)
	{
		if (sound)
			self.PlayNotes([
				{ volume: 0.2, frequency: 1600, durationSeconds: 0.1, offset: 0 },
				{ volume: 0.2, frequency: 1600, durationSeconds: 0.1, offset: 0 },
				{ volume: 0.2, frequency: 1600, durationSeconds: 0.1, offset: 0 },
			]);
		if (speech)
			self.Speak("reloading", true);
	}
	this.Speak = function (str, immediate)
	{
		if (!speech_synthesis_supported)
			return;
		try
		{
			if (immediate)
				self.CancelSpeech();
			var utterance = new SpeechSynthesisUtterance(str);
			if (voice == null)
				self.setVoice(settings.ui3_speechVoice);
			utterance.voice = voice;
			speechSynthesis.speak(utterance);
		}
		catch (ex) { }
	}
	this.CancelSpeech = function ()
	{
		if (!speech_synthesis_supported)
			return;
		try
		{
			speechSynthesis.cancel();
		}
		catch (ex) { }
	}
	var disconnectTimeout = null;
	var isDisconnected = false;
	var didEmitDisconnectedSound = false;
	/**
	 * Call when video stream connection is lost.
	 */
	this.NotifyDisconnected = function ()
	{
		if (!isDisconnected)
		{
			isDisconnected = true;
			didEmitDisconnectedSound = false;
			clearTimeout(disconnectTimeout);
			disconnectTimeout = setTimeout(function ()
			{
				didEmitDisconnectedSound = true;
				self.PlaySoundAsConfigured(self.PlayDisconnectSound);
				RecursiveDisconnectedStatusBeeps();
			}, 1000);
		}
	}
	var RecursiveDisconnectedStatusBeeps = function ()
	{
		disconnectTimeout = setTimeout(function ()
		{
			self.PlaySoundAsConfigured(self.PlayPeriodicDisconnectedSound);
			RecursiveDisconnectedStatusBeeps();
		}, 2000);
	}
	/**
	 * Call when video stream connection is re-established after it is lost.
	 */
	this.NotifyReconnected = function ()
	{
		if (disconnectTimeout)
			clearTimeout(disconnectTimeout);
		if (isDisconnected)
		{
			isDisconnected = false;
			if (didEmitDisconnectedSound)
				self.PlaySoundAsConfigured(self.PlayConnectSound);
		}
	}
	this.NotifyReloadingUI = function ()
	{
		self.PlaySoundAsConfigured(self.PlayReloadingSound);
	}

	Initialize();
}
function OnChange_ui3_timeline_minZoomScaler()
{
	if (currentPrimaryTab !== "timeline")
		$("#topbar_tab_timeline").click();
	clipTimeline.setZoomScaler(parseFloat(settings.ui3_timeline_minZoomScaler));
}
function OnChange_ui3_timeline_alertThumbnailsAppearAtZoomLevel()
{
	if (currentPrimaryTab !== "timeline")
		$("#topbar_tab_timeline").click();
	clipTimeline.setZoomScaler(parseFloat(settings.ui3_timeline_alertThumbnailsAppearAtZoomLevel));
}
function OnChange_ui3_timeline_alertThumbnailsAppearForGroups()
{
	clipTimeline.redrawCanvas();
}
function OnChange_ui3_uiStatusSounds()
{
	var spk = settings.ui3_uiStatusSpeech === "1";
	if (settings.ui3_uiStatusSounds === "1")
		programmaticSoundPlayer.PlayConnectSound(true, spk);
	else
		programmaticSoundPlayer.PlayDisconnectSound(true, spk);
}
function OnChange_ui3_uiStatusSpeech()
{
	if (settings.ui3_uiStatusSpeech === "1")
		programmaticSoundPlayer.Speak("Speech enabled", true);
	else
		programmaticSoundPlayer.Speak("Speech disabled", true);
}
function OnChange_ui3_speechVoice()
{
	programmaticSoundPlayer.setVoice(settings.ui3_speechVoice);
	programmaticSoundPlayer.Speak(settings.ui3_speechVoice, true);
}
function Precondition_ui3_speechAvailable()
{
	return speech_synthesis_supported;
}
function TestSpeech()
{
	var speeches = [
		"you eye three is great, and so are you!",
		"are we there yet?",
		"I want a cookie"
	];
	programmaticSoundPlayer.Speak(speeches[getRandomInt(speeches.length)], true);
}
///////////////////////////////////////////////////////////////
// MQTT Client ////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// UI3 uses paho-mqtt instead of the better-maintained mqtt.js, because the latter is about 6x larger filesize.
function OnChange_ui3_mqttClientEnabled()
{
	if (settings.ui3_mqttClientEnabled === "1")
	{
		mqttClient.disconnect();
		mqttClient = new MqttClient();
	}
	else
		mqttClient.disconnect();
}
function GetRandomMqttInstanceId()
{
	return getRandomAlphanumericStr(12);
}
var mqttWindowId = getRandomAlphanumericStr(16); // Used by MQTT client to indicate that this unique browser window is connected to the broker.
/**
 Clientside cache of state values from the MQTT broker so we can track when things actually change versus when we just get notified of the same value again.
 */
var mqttTopicState = new MqttTopicState();
function MqttClient()
{
	var self = this;
	/**
	 * If a video ID is received from MQTT before loading has completed, it will be stored in this property.
	 */
	this.preLoadVideoSpecified = null;

	var hasDisconnected = false;

	var client;
	var isConnected = false;

	var clientId = "ui3" + getRandomBase36String(17); // Used by MQTT broker to indentify reconnecting clients after a lost connection. Must be unique across all active connections. Not persisted outside of memory so it doesn't get shared with other browser windows.

	var brokerUrl = settings.ui3_mqttBrokerUrl;
	if (!brokerUrl.endsWith("/"))
		brokerUrl = brokerUrl + "/";
	var user = settings.ui3_mqttUser;
	var pass = Base64.decode(settings.ui3_mqttPass);
	var instance_id = settings.ui3_mqttInstanceId; // This UI3 instance only cares about topics with this instance ID in them.
	var subscribeEnabled = settings.ui3_mqttSubscribeEnabled === "1";
	var subscribeQos = Clamp(parseInt(settings.ui3_mqttSubscribeQOS), 0, 2);
	var publishEnabled = settings.ui3_mqttPublishEnabled === "1";
	var publishQos = Clamp(parseInt(settings.ui3_mqttPublishQOS), 0, 2);
	var publishRetain = settings.ui3_mqttPublishRetain === "1";
	var clientEnabled = settings.ui3_mqttClientEnabled === "1";

	var publishQueue = new FasterObjectMap();
	var eventRemovalFunctions = [];

	function connect()
	{
		try
		{
			if (!clientEnabled)
				return;
			if (!subscribeEnabled && !publishEnabled)
			{
				toaster.Warning("MQTT Client was enabled, but publishing and subscribing were disabled. MQTT client has nothing to do.", 10000);
				return;
			}
			if (!instance_id)
				instance_id = settings.ui3_mqttInstanceId = GetRandomMqttInstanceId();
			if (instance_id.length > 12)
				instance_id = settings.ui3_mqttInstanceId = instance_id.substr(0, 12);

			hasDisconnected = false;

			client = new Paho.Client(brokerUrl, clientId);

			client.onConnectionLost = onConnectionLost;
			client.onMessageArrived = onMessageArrived;

			var willMessage = new Paho.Message("");
			willMessage.destinationName = "ui3/" + instance_id + "/online/" + mqttWindowId;
			willMessage.retained = true;
			willMessage.qos = 1;
			var connectArgs = {
				userName: user
				, password: pass
				, mqttVersion: 4
				, reconnect: true
				, cleanSession: (subscribeQos === 0 && publishQos === 0)
				, onSuccess: onConnect
				, onFailure: onConnectFailure
				, invocationContext: self
				, willMessage: willMessage
			};
			client.connect(connectArgs);
		}
		catch (ex)
		{
			toaster.Error("MqttClient connect exception: " + ex, 10000);
		}
	}

	this.disconnect = function ()
	{
		try
		{
			if (!hasDisconnected)
				internalDisconnect();
		}
		catch (ex)
		{
			console.log("MqttClient disconnect exception: ", ex);
		}
	}
	function internalDisconnect()
	{
		hasDisconnected = true;
		if (client && isConnected)
		{
			internalPublish("ui3/" + instance_id + "/online/" + mqttWindowId, "", 1, true, true);
			client.disconnect();
		}
		for (var i = 0; i < eventRemovalFunctions.length; i++)
			eventRemovalFunctions[i]();
		eventRemovalFunctions = [];
	}

	function onConnect(arg)
	{
		if (arg.invocationContext !== self)
			return;
		try
		{
			isConnected = true;
			if (settings.ui3_mqttStatusToasts === "1")
				toaster.Success("Connected to MQTT broker.", 3000);
			if (hasDisconnected)
			{
				console.log("MqttClient just finished connecting, but disconnect() has already been called. Disconnecting now.");
				internalDisconnect();
				return;
			}

			if (subscribeEnabled)
				startSubscription();
			if (publishEnabled)
				startPublishing();

			var syncMode = "pub/sub";
			if (!subscribeEnabled)
				syncMode = "pub only";
			else if (!publishEnabled)
				syncMode = "sub only";
			internalPublish("ui3/" + instance_id + "/online/" + mqttWindowId, syncMode, 1, true);
		}
		catch (ex)
		{
			toaster.Error("MqttClient onConnect exception: " + ex, 10000);
		}
	}

	function onConnectFailure(arg)
	{
		if (arg.invocationContext !== self)
			return;
		try
		{
			isConnected = false;
			toaster.Warning("MQTT Connect Failed: " + arg.errorCode + " " + arg.errorMessage, 10000);
		}
		catch (ex)
		{
			toaster.Error("MqttClient onConnectFailure exception: " + ex);
		}
	}

	function onConnectionLost(arg)
	{
		try
		{
			isConnected = false;
			if (arg.errorCode === 0)
			{
				if (settings.ui3_mqttStatusToasts === "1")
					toaster.Info("MQTT Disconnected", 3000);
			}
			else
				toaster.Warning("MQTT Disconnected: " + arg.errorCode + " " + arg.errorMessage, 10000);
		}
		catch (ex)
		{
			toaster.Error("MqttClient onConnectionLost exception: " + ex, 10000);
		}
	}

	function startSubscription()
	{
		var subscribeOptions = {
			qos: subscribeQos
			, invocationContext: self
			, onSuccess: function (arg)
			{
				if (arg.invocationContext !== self)
					return;
				try
				{
					//if (settings.ui3_mqttStatusToasts === "1")
					//	toaster.Success("UI3 is ready to be remotely controlled.", 3000);
				}
				catch (ex)
				{
					toaster.Error("MqttClient subscription success handler exception: " + ex, 10000);
				}
			}
			, onFailure: function (arg)
			{
				if (context !== self)
					return;
				try
				{
					toaster.Error("MqttClient Subscription Failed: " + arg.errorCode + " " + arg.errorMessage, 10000);
				}
				catch (ex)
				{
					toaster.Error("MqttClient subscription fail handler exception: " + ex, 10000);
				}
			}
		};
		client.subscribe("ui3/" + instance_id + "/#", subscribeOptions);
		client.subscribe("ui3/global/#", subscribeOptions);
	}

	function onMessageArrived(message)
	{
		try
		{
			console.log('MQTT Received: "' + message.topic + '" -> "' + message.payloadString + '"');
			if (!subscribeEnabled)
			{
				console.log("Rejecting MQTT message because subscription was not enabled in settings.");
				return;
			}
			// EXAMPLE TOPIC: "ui3/instance_id/state/vid"
			var parts = message.topic.split('/');
			if (parts.length === 4)
			{
				if (parts[0] === "ui3" && parts[1] === instance_id && parts[2] === "state")
				{
					var key = parts[3];
					var value = message.payloadString;
					mqttTopicState.set(key, value);
					if (key === "vid")
					{
						if (!cameraListLoader.GetLastResponse())
							self.preLoadVideoSpecified = value;
						else
						{
							var camData = cameraListLoader.GetCameraWithId(value);
							if (camData && iEquals(videoPlayer.Loading().image.id, camData.optionValue))
								videoPlayer.LoadLiveCamera(camData);
						}
					}
					else if (key === "maximize")
					{
						if (value === "1")
							maximizedModeController.EnableMaximizedMode();
						else
							maximizedModeController.DisableMaximizedMode();
					}
					else if (key === "volume")
					{
						var newVolume = Clamp(parseFloat(value), 0, 100) / 100.0;
						settings.ui3_audioMute = newVolume === 0 ? "1" : "0";
						settings.ui3_audioVolume = newVolume;
						volumeSlider.setPosition(newVolume);
					}
				}
				else if (parts[0] === "ui3" && (parts[1] === instance_id || parts[1] === "global") && parts[2] === "playaudio")
				{
					handlePlayAudio(parts[3], message.payloadString);
				}
				else if (parts[0] === "ui3" && (parts[1] === instance_id || parts[1] === "global") && parts[2] === "toast")
				{
					MqttShowToast(parts[3], message.payloadString);
				}
			}
			else if (parts.length === 3)
			{
				if (parts[0] === "ui3" && (parts[1] === instance_id || parts[1] === "global"))
				{
					if (parts[2] === "playtts")
						handlePlayTTS(message.payloadString);
					else if (parts[2] === "playaudio")
						handlePlayAudio(null, message.payloadString);
					else if (parts[2] === "toast")
						MqttShowToast(null, message.payloadString);
				}
			}
		}
		catch (ex)
		{
			toaster.Error("MqttClient onMessageArrived exception: " + ex, 10000);
		}
	}

	function startPublishing()
	{
		if (publishEnabled)
		{
			processPublishQueue();
			eventRemovalFunctions.push(BI_CustomEvent.AddListener("OpenVideo", function (loading)
			{
				if (loading.isLive)
				{
					self.publish("vid", loading.id);
				}
			}));
			eventRemovalFunctions.push(BI_CustomEvent.AddListener("MaximizeChanged", function (maximized)
			{
				self.publish("maximize", maximized ? "1" : "0");
			}));
		}
	}

	function processPublishQueue()
	{
		if (client && isConnected && publishQueue)
		{
			for (var k in publishQueue)
			{
				var v = publishQueue[k];
				self.publish(k, v);
			}
			publishQueue = null;
		}
	}

	var debounced_PublishVolume = debounce(function ()
	{
		var volume = Math.floor(parseFloat(settings.ui3_audioVolume) * 100.0);
		if (settings.ui3_audioMute === "1")
			volume = 0;
		self.publish("volume", volume);
	}, 400);

	this.volumeChanged = function ()
	{
		debounced_PublishVolume();
	}

	this.publish = function (key, value)
	{
		if (!publishEnabled)
			return;
		value = value.toString();
		if (!client || !isConnected)
		{
			if (publishQueue)
				publishQueue[key] = value;
		}
		else
		{
			if (mqttTopicState.set(key, value))
			{
				internalPublish("ui3/" + instance_id + "/state/" + key, value, publishQos, publishRetain);
			}
		}
	}
	var internalPublish = function (topic, message, qos, retain, suppressExceptions)
	{
		try
		{
			var message = new Paho.Message(message);
			message.destinationName = topic;
			if (typeof qos !== "undefined")
				message.qos = qos;
			if (typeof retain !== "undefined")
				message.retained = retain;
			client.publish(message);
			console.log('MQTT Publish: "' + topic + '" -> "' + message + '"');
		}
		catch (ex)
		{
			if (!suppressExceptions)
				toaster.Error("MqttClient publish exception: " + ex, 10000);
		}
	}

	function handlePlayAudio(audioPlayerId, audioFileName)
	{
		if (settings.ui3_mqttAudioEvents !== "1")
		{
			console.log("MQTT Audio Events are not enabled. Ignoring request:", audioFileName);
			return;
		}
		if (audioFileName.indexOf('..') > -1 || audioFileName.indexOf(':') > -1)
		{
			console.log("Rejected audio file name:", audioFileName);
			return;
		}
		biSoundPlayer.PlaySoundFile(audioPlayerId, audioFileName);
	}

	function handlePlayTTS(message)
	{
		programmaticSoundPlayer.Speak(message, true);
	}

	connect();
}
function MqttTopicState()
{
	var map = new FasterObjectMap();
	/**
	 * Sets the value, returning true if the value has changed as a result of calling this method.
	 * @param {String} key
	 * @param {any} value
	 */
	this.set = function (key, value)
	{
		var oldValue = map[key];
		if (oldValue !== value)
		{
			map[key] = value;
			return true;
		}
		else
			return false;
	}
	this.get = function (key)
	{
		return map[key];
	}
}
var MqttToastMap = new FasterObjectMap();
function MqttShowToast(toastId, jsonArg)
{
	if (settings.ui3_mqttToastEvents !== "1")
	{
		console.log("MQTT Toast Events are not enabled. Ignoring request:", jsonArg);
		return;
	}
	var args;
	if (jsonArg)
	{
		try
		{
			args = JSON.parse(jsonArg);
			if (typeof args === "string")
				args = { msg: args };
		}
		catch (ex) { args = { msg: jsonArg }; }
	}
	if (!args)
	{
		console.log("MQTT Toast Event rejected:", jsonArg);
		return;
	}

	// Argument "timeout"
	if (typeof args.timeout !== "number")
		args.timeout = -1;

	// Argument "type"
	if (typeof args.type !== "string")
		args.type = "info";
	args.type = args.type.toLowerCase();
	if (args.type !== "success" && args.type !== "info" && args.type !== "warning" && args.type !== "error")
		args.type = "info";

	// Argument "click"
	if (typeof args.click !== "string")
		args.click = "";
	var onClick = null;
	if (args.click.length > 0)
	{
		if (args.click == "alerts")
			onClick = function ()
			{
				if (currentPrimaryTab !== "clips" || settings.ui3_current_dbView !== "alerts")
					clipLoader.LoadView("alerts");
			};
		else if (args.click == "clips")
			onClick = function ()
			{
				if (currentPrimaryTab !== "clips" || settings.ui3_current_dbView !== "all")
					clipLoader.LoadView("all");
			};
		else if (args.click.startsWith("alerts:") || args.click.startsWith("clips:"))
			onClick = function () { PlayRecordingIdFromToast(args.click); };
		else if (args.click == "timeline")
			onClick = function ()
			{
				if (currentPrimaryTab !== "timeline")
					$("#topbar_tab_timeline").click();
			};
		else if (args.click.startsWith("timeline:"))
			onClick = function ()
			{
				if (currentPrimaryTab !== "timeline")
					$("#topbar_tab_timeline").click();
				var timelineStartStr = args.click.substr("timeline:".length);
				var timelineStart = ParseTimelineStartStr(timelineStartStr);
				if (!isNaN(timelineStart))
					clipTimeline.seekTo(timelineStart);
				else
					toaster.Error("Unable to understand timeline date: " + htmlEncode(timelineStartStr));
			};
		else if (args.click == "live")
			onClick = function () { $("#topbar_tab_live").click(); };
		else
			toaster.Error("Unrecognized MQTT toast click action: " + htmlEncode(args.click), 30000);
	}
	if (typeof args.cam !== "string")
		args.cam = "";
	if (args.cam)
	{
		var originalOnClick = onClick;
		onClick = function ()
		{
			var cam = cameraListLoader.GetCameraWithId(args.cam);
			if (cam)
				videoPlayer.LoadLiveCamera(cam);
			else
				toaster.Error("Unable to load camera: " + htmlEncode(args.cam));
			if (originalOnClick)
				originalOnClick();
		};
	}

	// Toast ID
	try
	{
		toastId = toastId.toString();
	}
	catch (ex) { }
	if (typeof toastId !== "string" || !toastId)
		toastId = "multi";
	if (toastId !== "multi")
	{
		if (MqttToastMap[toastId])
			MqttToastMap[toastId].remove();
	}

	MqttToastMap[toastId] = toaster.Show(args.type, htmlEncode(args.msg), args.timeout, !args.noCloseButton, onClick, args.timeout);

}
function PlayRecordingIdFromToast(str)
{
	if (sessionManager.HasPermission_Clips())
	{
		if (str.startsWith("alerts:"))
		{
			var recId = str.substr("alerts:".length);
			if (recId.length > 0)
			{
				if (currentPrimaryTab !== "clips" || settings.ui3_current_dbView !== "alerts")
					clipLoader.LoadView("alerts");
				PlayRecordingId(recId);
			}
		}
		else if (str.startsWith("clips:"))
		{
			var recId = str.substr("clips:".length);
			if (recId.length > 0)
			{
				if (currentPrimaryTab !== "clips")
					$("#topbar_tab_clips").click();
				PlayRecordingId(recId);
			}
		}
	}
	else
	{
		toaster.Error("This session does not have permission to view clips.");
	}
}
function PlayRecordingId(recId)
{
	recId = ltrim(recId, "@");
	if (!recId.startsWith("@"))
		recId = "@" + recId;
	var offset = 0;
	var idxHyphen = recId.lastIndexOf('-');
	if (idxHyphen > 0)
	{
		offset = parseInt(recId.substr(idxHyphen + 1));
		if (isNaN(offset))
			offset = 0;
		recId = recId.substr(0, idxHyphen);
	}
	clipStatsLoader.LoadClipStats(recId, null, false, function (stats)
	{
		if (!stats)
			toaster.Warning("The recording with ID " + htmlEncode(recId) + " could not be opened.");
		else
		{
			if (offset && offset > 0)
			{
				if (offset > stats.msec || stats.msec - offset < 100)
					offset = 0;
				stats.offset = offset;
			}
		}

		if (!loadingHelper.DidLoadingFinish())
		{
			BI_CustomEvent.AddListener("FinishedLoading", function ()
			{
				OpenClipFromStats(stats);
			});
		}
		else
			OpenClipFromStats(stats);
	});
}
///////////////////////////////////////////////////////////////
// Stopwatch //////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
/** Creates a new Stopwatch which begins in the running state. A Stopwatch instance operates only while it is being interacted with, and as such does not leak resources if left running. */
function UI3Stopwatch()
{
	var self = this;
	var startTime = performance.now();
	var accumulatedTime = 0;
	var isRunning = true;
	/** Starts, or resumes, measuring elapsed time. Returns a reference to this Stopwatch. */
	this.Start = function ()
	{
		if (!isRunning)
		{
			startTime = performance.now();
			isRunning = true;
		}
		return self;
	}
	/** Stops measuring elapsed time. Returns a reference to this Stopwatch. */
	this.Stop = function ()
	{
		if (isRunning)
		{
			accumulatedTime += performance.now() - startTime;
			isRunning = false;
		}
		return self;
	}
	/** Stops time measurement and resets the elapsed time to zero. Returns a reference to this Stopwatch. */
	this.Reset = function ()
	{
		self.Stop();
		accumulatedTime = 0;
		return self;
	}
	/** Stops time measurement, resets the elapsed time to zero, and starts measuring elapsed time. Returns a reference to this Stopwatch. */
	this.Restart = function ()
	{
		self.Reset();
		self.Start();
		return self;
	}
	/** Returns true if this Stopwatch is currently running and measuring time. */
	this.IsRunning = function ()
	{
		return isRunning;
	}
	/** Returns the total elapsed time measured by the current instance in milliseconds with sub-millisecond precison.  Time is only counted while the Stopwatch is running. */
	this.Elapsed = function ()
	{
		var time = accumulatedTime;
		if (isRunning)
			time += performance.now() - startTime;
		return time;
	}
	/**
	 * Sets the elapsed time to the specified value in milliseconds.
	 * @param {Number} timeMs The time in milliseconds to set the elapsed time to.
	 */
	this.Set = function (timeMs)
	{
		if (isRunning)
		{
			accumulatedTime = 0;
			startTime = performance.now() - timeMs;
		}
		else
			accumulatedTime = timeMs;
	}
}
///////////////////////////////////////////////////////////////
// Misc ///////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
function SysNameToAppName(sysName)
{
	sysName = sysName ? sysName.trim() : "";
	if (sysName == "")
		return "Blue Iris UI3";
	if (sysName.match(/\b(Blue Iris|BlueIris|BI|UI3)\b/i))
		return sysName;
	if (sysName.length <= 13)
		return sysName + " UI3";
	return sysName;
}
function IsStandaloneApp()
{
	return navigator.standalone || (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches == true);
}
(function ()
{
	// Date.now() and performance.now() polyfills
	window.Date.now = (Date.now || function () { return new Date().getTime(); });
	if ("performance" in window == false)
		window.performance = {};
	if ("now" in window.performance == false)
	{
		var start = Date.now();
		window.performance.now = function () { return Date.now() - start; }
	}
})();
function isCanvasSupported()
{
	var elem = document.createElement('canvas');
	return !!(elem.getContext && elem.getContext('2d'));
}
function logout()
{
	currentServer.isLoggingOut = true;
	var fallbackLogoutUrl = currentServer.remoteBaseURL + 'logout.htm' + currentServer.GetAPISessionArg("?");
	if (currentServer.isUsingRemoteServer)
	{
		ExecJSON({ cmd: "logout" }, function (response)
		{
			if (response && response.result == "success")
			{
				// If implementing remote server connections:  Here, we would do SendToServerListOnStartup();
				location.href = fallbackLogoutUrl;
			}
			else
				location.href = fallbackLogoutUrl;
		}, function ()
		{
			location.href = fallbackLogoutUrl;
		});
	}
	else
	{
		ExecJSON({ cmd: "logout" }, function (response)
		{
			if (response && response.result == "success")
				location.href = currentServer.remoteBaseURL + "login.htm?autologin=0&page=" + encodeURIComponent(location.pathname);
			else
				location.href = fallbackLogoutUrl;
		}, function ()
		{
			location.href = fallbackLogoutUrl;
		});
	}
}
function logoutOldSession(oldSession)
{
	// When running multiple instances of the UI in the same browser, this causes instances to log out the session belonging to another instance.
	// As long as cookies are sharing sessions between multiple browser tabs, this code should not be enabled.
	// With the user name in the session data, we avoid creating most unnecessary new sessions in the first place, but it does not make this feature safe to turn on.
	// NOTE: Blue Iris fails to log out the session anyway if it is currently in use by an active connection.
	//if (oldSession != null && oldSession != sessionManager.GetAPISession())
	//	ExecJSON({ cmd: "logout", session: oldSession });
}
function GetDialogOptionLabel(html)
{
	return '<div class="dialogOption_label">' + html + '</div>';
}
function GetHtmlOptionElementMarkup(value, name, selectedValue)
{
	return '<option value="' + value + '"' + (selectedValue == value ? ' selected="selected"' : '') + '>' + name + '</option>';
}
function FitRectangleIntoCanvas(rect, canvas)
{
	var w = canvas.width;
	var h = canvas.height;
	if (w < 1 || h < 1)
		return;
	rect[0] = Clamp(rect[0], 0, w - 1);
	rect[1] = Clamp(rect[1], 0, h - 1);
	rect[2] = Clamp(rect[2], rect[0] + 1, w);
	rect[3] = Clamp(rect[3], rect[1] + 1, h);
}
function Clamp(i, min, max)
{
	if (i < min)
		return min;
	if (i > max)
		return max;
	if (isNaN(i))
		return min;
	return i;
}
function getDistanceBetweenPointAndElementCenter(x, y, $ele)
{
	var offset = $ele.offset();
	var eX = offset.left + ($ele.outerWidth(true) / 2);
	var eY = offset.top + ($ele.outerHeight(true) / 2);
	var dX = Math.abs(x - eX);
	var dY = Math.abs(y - eY);
	return Math.sqrt((dX * dX) + (dY * dY));
}
function AskYesNo(question, onYes, onNo, onError, yesText, noText, title)
{
	SimpleDialog.ConfirmHtml(question, onYes, onNo,
		{
			title: title
			, onError: onError
			, yesText: yesText
			, noText: noText
		});
}
function isNullOrWhitespace(input)
{
	return !input || !input.trim();
}
String.prototype.padLeft = function (len, c)
{
	var pads = len - this.length;
	if (pads > 0)
	{
		var sb = [];
		var pad = c || "&nbsp;";
		for (var i = 0; i < pads; i++)
			sb.push(pad);
		sb.push(this);
		return sb.join("");
	}
	return this;
};
String.prototype.padRight = function (len, c)
{
	var pads = len - this.length;
	if (pads > 0)
	{
		var sb = [];
		sb.push(this);
		var pad = c || "&nbsp;";
		for (var i = 0; i < pads; i++)
			sb.push(pad);
		return sb.join("");
	}
	return this;
};
Number.prototype.padLeft = function (len, c)
{
	return this.toString().padLeft(len, c);
};
Number.prototype.padRight = function (len, c)
{
	return this.toString().padRight(len, c);
};
function NumToHex4(num)
{
	return num.toString(16).toUpperCase().padLeft(4, '0');
}
function NumToHexUpper(num)
{
	return num.toString(16).toUpperCase();
}
function makeUnselectable($target)
{
	$target
		.addClass('unselectable') // All these attributes are inheritable
		.attr('unselectable', 'on') // For IE9 - This property is not inherited, needs to be placed onto everything
		.attr('draggable', 'false') // For moz and webkit, although Firefox 16 ignores this when -moz-user-select: none; is set, it's like these properties are mutually exclusive, seems to be a bug.
		.on('dragstart', function () { return false; });  // Needed since Firefox 16 seems to ingore the 'draggable' attribute we just applied above when '-moz-user-select: none' is applied to the CSS

	$target // Apply non-inheritable properties to the child elements
		.find('*:not(.selectable)')
		.attr('draggable', 'false')
		.attr('unselectable', 'on');
}
function pointInsideElement($ele, pX, pY)
{
	if ($ele.length == 0)
		return false;
	var ele = $ele.get(0);
	var o, w, h;
	if (ele.savedBounds)
	{
		o = { left: ele.savedBounds.x, top: ele.savedBounds.y };
		w = ele.savedBounds.w;
		h = ele.savedBounds.h;
	}
	else
	{
		o = $ele.offset();
		w = $ele.outerWidth(true);
		h = $ele.outerHeight(true);
	}
	return pX >= o.left && pX < o.left + w && pY >= o.top && pY < o.top + h;
}
function pointToElementRelative($ele, pX, pY)
{
	if ($ele.length == 0)
		return false;
	var ele = $ele.get(0);
	var o, w, h;
	if (ele.savedBounds)
	{
		o = { left: ele.savedBounds.x, top: ele.savedBounds.y };
		w = ele.savedBounds.w;
		h = ele.savedBounds.h;
	}
	else
	{
		o = $ele.offset();
		w = $ele.outerWidth(true);
		h = $ele.outerHeight(true);
	}
	return { x: pX - o.left, y: pY - o.top };
}
function pointInsideElementBorder($ele, pX, pY)
{
	if ($ele.length == 0)
		return false;
	var o = $ele.offset();
	var w = $ele.outerWidth();
	var h = $ele.outerHeight();
	return pX >= o.left && pX < o.left + w && pY >= o.top && pY < o.top + h;
}
function BlueIrisColorToCssColor(biColor)
{
	var colorHex = biColor.toString(16).padLeft(8, '0').substr(2);
	return colorHex.substr(4, 2) + colorHex.substr(2, 2) + colorHex.substr(0, 2);
}
function BlueIrisColorToHsl(biColor)
{
	var o = HexColorToRgbObj(BlueIrisColorToCssColor(biColor));
	return rgbToHsl(o.r, o.g, o.b);
}
function HexColorToRgbObj(c)
{
	if (c.startsWith('#'))
		c = c.substr(1);
	return { r: parseInt(c.substr(0, 2), 16), g: parseInt(c.substr(2, 2), 16), b: parseInt(c.substr(4, 2), 16) };
}
function HexColorToRgbaColor(c, alpha)
{
	c = HexColorToRgbObj(c);
	return "rgba(" + c.r + "," + c.g + "," + c.b + "," + alpha + ")";
}
/**
 * Returns a hex color not including "#", such as "222222" or "DDDDDD".
 * @param {String} c Hex color of the background.  The idea is that the returned hex color will be high contrast against this background.
 * @param {String} dark Your preferred color for dark text (defaults to "222222")
 * @param {String} light Your preferred color for light text (defaults to "DDDDDD")
 */
function GetReadableTextColorHexForBackgroundColorHex(c, dark, light)
{
	c = HexColorToRgbObj(c);
	var o = Math.round(((c.r * 299) + (c.g * 587) + (c.b * 114)) / 1000);
	if (o > 125)
	{
		if (dark)
			return dark;
		else
			return "222222";
	}
	else
	{
		if (light)
			return light;
		else
			return "DDDDDD";
	}
}
function hslToRgb(h, s, l) { if (0 == s) l = s = h = l; else { var f = function (l, s, c) { 0 > c && (c += 1); 1 < c && --c; return c < 1 / 6 ? l + 6 * (s - l) * c : .5 > c ? s : c < 2 / 3 ? l + (s - l) * (2 / 3 - c) * 6 : l }, e = .5 > l ? l * (1 + s) : l + s - l * s, g = 2 * l - e; l = f(g, e, h + 1 / 3); s = f(g, e, h); h = f(g, e, h - 1 / 3) } return { r: Math.round(255 * l), g: Math.round(255 * s), b: Math.round(255 * h) } }
function rgbToHsl(r, g, b) { r /= 255; g /= 255; b /= 255; var e = Math.max(r, g, b), a = Math.min(r, g, b), h = (e + a) / 2; if (e == a) var f = a = 0; else { var z = e - a; a = .5 < h ? z / (2 - e - a) : z / (e + a); switch (e) { case r: f = (g - b) / z + (g < b ? 6 : 0); break; case g: f = (b - r) / z + 2; break; case b: f = (r - g) / z + 4 }f /= 6 } return { h: f, s: a, l: h } };
function CompareBlueIrisColors(a, b)
{
	return CompareHSLColors(BlueIrisColorToHsl(a), BlueIrisColorToHsl(b));
}
function CompareHSLColors(a, b)
{
	var diff = a.h - b.h;
	if (diff === 0)
		diff = a.s - b.s;
	if (diff === 0)
		diff = a.l - b.l;
	return diff;
}
/**
 * Returns the first argument if it is a valid 3-digit or 6-digit hex color preceded by a '#', otherwise returns the second argument.
 * @param {String} color Color that is possibly invalid.
 * @param {String} fallbackColor Color that is guaranteed to be valid. Will be returned if the first argument is not a valid hex color.
 */
function ValidateHexColor(color, fallbackColor)
{
	if (color && (color.match(/^#[0-9a-f]{6}$/i) || color.match(/^#[0-9a-f]{3}$/i)))
		return color;
	return fallbackColor;
}
function PercentTo01Float(s, defaultValue)
{
	s = parseFloat(s) / 100;
	if (typeof s === 'undefined' || isNaN(s))
		s = defaultValue;
	return Clamp(s, 0, 1);
}
function stopDefault(e)
{
	if (e && e.preventDefault)
	{
		e.preventDefault();
	}
	else if (window.event)
	{
		window.event.returnValue = false;
	}
	return false;
}
/**
 * Encodes a string so it can safely be written to a string literal in a JavaScript file.  Characters such as tab, carriage return, line feed, single and double quotes are escaped.
 * @param {String} str String to encode.
 * @param {Boolean} wrapInQuotes If true, the return value will be wrapped in "quotation marks".
 * @returns {String} Encoded value.
 */
function JavaScriptStringEncode(str, wrapInQuotes)
{
	var sb = [];
	if (wrapInQuotes)
		sb.push('"');
	for (var i = 0; i < str.length; i++)
	{
		var c = str.charCodeAt(i);
		if ((c >= 0 && c <= 7) || c == 11 || (c >= 14 && c <= 31) || c == 39 || c == 60 || c == 62)
			sb.push("\\u" + NumToHex4(c));
		else if (c == 8)
			sb.push("\\b");
		else if (c == 9)
			sb.push("\\t");
		else if (c == 10)
			sb.push("\\n");
		else if (c == 12)
			sb.push("\\f");
		else if (c == 13)
			sb.push("\\r");
		else if (c == 34)
			sb.push("\\\"");
		else if (c == 39)
			sb.push("\\'");
		else if (c == 92)
			sb.push("\\\\");
		else
			sb.push(str.charAt(i));
	}
	if (wrapInQuotes)
		sb.push('"');
	return sb.join("");
}
function CleanUpGroupName(groupName)
{
	while (groupName.indexOf("+") == 0)
		groupName = groupName.substr(1);
	return groupName;
}
function GetClipLengthFromFileSize(fileSize)
{
	var indexLeftParen = fileSize.indexOf("(");
	if (indexLeftParen > 1)
		fileSize = fileSize.substring(0, indexLeftParen - 1);
	return fileSize;
}
function DoesFileSizeStringHaveOnlyDuration(fileSize)
{
	var indexLeftParen = fileSize.indexOf("(");
	return indexLeftParen < 0;
}
function GetClipLengthMs(str)
{
	var time = GetTimeFromBIStr(str);
	return (time.hours * 3600000) + (time.minutes * 60000) + (time.seconds * 1000);
}
function GetClipDurStrFromMs(str)
{
	if (str == "Snapshot")
		return "S";
	var time = GetTimeFromBIStr(str);
	var hours;
	var minutes;
	if (time.hours == 0)
	{
		hours = "";
		minutes = time.minutes.toString();
	}
	else
	{
		hours = time.hours.toString() + ":";
		minutes = time.minutes.toString().padLeft(2, '0');
	}
	return hours + minutes + ":" + time.seconds.toString().padLeft(2, '0');
}
function GetTimeFromBIStr(str)
{
	var hours = 0;
	var minutes = 0;
	var seconds = 0;

	var match = new RegExp("(\\d+) ?h").exec(str);
	if (match)
		hours = parseInt(match[1]);

	match = new RegExp("(\\d+) ?m").exec(str);
	if (match)
		minutes = parseInt(match[1]);

	match = new RegExp("(\\d+) ?s").exec(str);
	if (match)
		seconds = parseInt(match[1]);

	if (hours == 0 && minutes == 0 && seconds == 0)
		seconds = 10;

	return { hours: hours, minutes: minutes, seconds: seconds };
}
function MsToDHMS(ms, includeMilliseconds, includeSpaces)
{
	var negative = "";
	if (ms < 0)
	{
		negative = "-";
		ms *= -1;
	}
	var space = includeSpaces ? " " : "";
	var days = Math.floor(ms / 86400000);
	ms = ms % 86400000;
	var hours = Math.floor(ms / 3600000);
	ms = ms % 3600000;
	var minutes = Math.floor(ms / 60000);
	ms = ms % 60000;
	var seconds = Math.floor(ms / 1000);
	ms = ms % 1000;

	var str = "";
	if (days > 0)
		str += days + "d" + space;
	if (str.length > 0 || hours > 0)
		str += hours + "h" + space;
	if (str.length > 0 || minutes > 0)
		str += minutes + "m" + space;
	str += seconds + (includeMilliseconds && ms > 0 ? "." + ms.toString().padLeft(3, "0") : "") + "s";
	return negative + str;
}
function GetClipFileSize(fileSize)
{
	var parentheticals = fileSize.match(/\(.*?\)$/);
	if (parentheticals && parentheticals.length > 0)
		return parentheticals[0].substr(1, parentheticals[0].length - 2);
	return "";
}
function GetRecIdFromPath(path)
{
	return path.replace(/@/g, "").replace(/\..*/g, "");
}
function ltrim(str, chars)
{
	for (var i = 0; i < str.length; i++)
	{
		var matched = false;
		for (var n = 0; n < chars.length; n++)
		{
			if (str[i] === chars[n])
			{
				matched = true;
				break;
			}
		}
		if (!matched)
		{
			if (i === 0)
				return str;
			else
				return str.substr(i);
		}
	}
	return "";
}
function rtrim(str, chars)
{
	for (var i = str.length - 1; i >= 0; i--)
	{
		var matched = false;
		for (var n = 0; n < chars.length; n++)
		{
			if (str[i] === chars[n])
			{
				matched = true;
				break;
			}
		}
		if (!matched)
		{
			if (i === str.length - 1)
				return str;
			else
				return str.substr(0, i + 1);
		}
	}
	return "";
}

String.prototype.startsWith = function (prefix)
{
	return this.lastIndexOf(prefix, 0) === 0;
}
String.prototype.startsWithCaseInsensitive = function (prefix)
{
	if (this.length < prefix.length)
		return false;
	return this.toLowerCase().startsWith(prefix.toLowerCase());
}
String.prototype.endsWith = function (suffix)
{
	if (this.length < suffix.length)
		return false;
	return this.substr(this.length - suffix.length) === suffix;
};
String.prototype.endsWithCaseInsensitive = function (suffix)
{
	if (this.length < suffix.length)
		return false;
	return this.substr(this.length - suffix.length).toLowerCase() === suffix.toLowerCase();
};
/**
 * Returns true if the given strings are equal with a case-insensitive comparison.
 * @param {String} s1 First string.
 * @param {String} s2 Second string.
 * @returns True if the given strings are equal with a case-insensitive comparison.
 */
function iEquals(s1, s2)
{
	if (typeof s1 !== "string" || typeof s2 !== "string")
		return false;
	return s1.toLowerCase() == s2.toLowerCase();
}
String.prototype.toFloat = function (digits)
{
	return parseFloat(this.toFixed(digits));
};
Number.prototype.toFloat = function (digits)
{
	return parseFloat(this.toFixed(digits));
};
Number.prototype.toFixedNoE = function (digits)
{
	var str = this.toFixed(digits);
	if (str.indexOf('e+') < 0)
		return str;

	// if number is in scientific notation, pick (b)ase and (p)ower
	return str.replace('.', '').split('e+').reduce(function (p, b)
	{
		return p + Array(b - p.length + 2).join(0);
	}) + (digits > 0 ? ('.' + Array(digits + 1).join(0)) : '');
};
Number.prototype.dropDecimals = function ()
{
	return Number(this.dropDecimalsStr());
};
Number.prototype.dropDecimalsStr = function ()
{
	var str = this.toFixedNoE(20);
	var idxDot = str.indexOf('.');
	if (idxDot > -1)
		str = str.substr(0, idxDot);
	return str;
};
function msToTime(totalMs, includeMs)
{
	var ms = totalMs % 1000;
	var totalS = totalMs / 1000;
	var totalM = totalS / 60;
	var totalH = totalM / 60;
	var s = Math.floor(totalS) % 60;
	var m = Math.floor(totalM) % 60;
	var h = Math.floor(totalH);

	var retVal;
	if (h != 0)
		retVal = h + ":" + m.toString().padLeft(2, "0");
	else
		retVal = m;

	retVal += ":" + s.toString().padLeft(2, "0");

	if (includeMs)
		retVal += '<span style="opacity:0.6;">.' + ms.toString().padLeft(3, "0") + "</span>";

	return retVal;
}
function localeUses24HourTime()
{
	return new Date(2000, 0, 1, 13).toLocaleString().indexOf("13") > -1;
}
var use24HourTime = false;
function GetTimeStr(date, includeMilliseconds)
{
	var ampm = "";
	var hour = date.getHours();
	if (!use24HourTime)
	{
		if (hour == 0)
		{
			hour = 12;
			ampm = " AM";
		}
		else if (hour == 12)
		{
			ampm = " PM";
		}
		else if (hour > 12)
		{
			hour -= 12;
			ampm = " PM";
		}
		else
		{
			ampm = " AM";
		}
	}
	var ms = includeMilliseconds ? ("." + date.getMilliseconds()) : "";

	var str = hour.toString().padLeft(2, '0') + ":" + date.getMinutes().toString().padLeft(2, '0') + ":" + date.getSeconds().toString().padLeft(2, '0') + ms + ampm;
	return str;
}
function GetDateStr(date, includeMilliseconds)
{
	var str = date.getFullYear() + "/" + (date.getMonth() + 1) + "/" + date.getDate() + " " + GetTimeStr(date, includeMilliseconds);
	return str;
}
function GetDateDisplayStr(date, includeWeekday)
{
	var sameDay = isSameDay(date, GetServerDate(new Date(GetUtcNow())));
	return (sameDay ? "Today, " : "") + date.getMonthName() + " " + date.getDate() + (sameDay ? "" : ", " + date.getFullYear()) + (includeWeekday ? ' <span class="dayNameShort">(' + date.getDayNameShort() + ')</span><span class="dayNameFull">(' + date.getDayName() + ')</span>' : '');
}
function GetDateDisplayStrShort(date, includeDayNameShort)
{
	var sameDay = isSameDay(date, GetServerDate(new Date(GetUtcNow())));
	return (sameDay ? "Today, " : "") + date.getMonthNameShort() + " " + date.getDate() + (sameDay ? "" : (", " + date.getFullYear())) + (includeDayNameShort ? ' (' + (date.getDayNameShort() + ')') : '');
}
function GetShortDateOrToday(date)
{
	var sameDay = isSameDay(date, GetServerDate(new Date(GetUtcNow())));
	if (sameDay)
		return "Today";
	else
		return date.getFullYear() + "/" + (date.getMonth() + 1) + "/" + date.getDate();
}
function GetWeekDisplayStr(date)
{
	return "Week of " + date.getMonthNameShort() + " " + date.getDate() + ", " + date.getFullYear();
}
function GetMonthDisplayStr(date, longMonthName)
{
	return (longMonthName ? date.getMonthName() : date.getMonthNameShort()) + " " + date.getFullYear();
}
function GetPaddedDateStr(date, includeMilliseconds)
{
	var str = date.getFullYear() + "/" + (date.getMonth() + 1).toString().padLeft(2, '0') + "/" + date.getDate().toString().padLeft(2, '0') + " " + GetTimeStr(date, includeMilliseconds);
	return str;
}
function GetHourStr(date, includeMinutes)
{
	var ampm = "";
	var hour = date.getHours();
	if (!use24HourTime)
	{
		if (hour == 0)
		{
			hour = 12;
			ampm = " AM";
		}
		else if (hour == 12)
		{
			ampm = " PM";
		}
		else if (hour > 12)
		{
			hour -= 12;
			ampm = " PM";
		}
		else
		{
			ampm = " AM";
		}
	}

	var str = hour.toString() + (includeMinutes ? (":" + date.getMinutes().toString().padLeft(2, '0')) : "") + ampm;
	return str;
}
Date.prototype.getMonthName = function ()
{
	try
	{
		if (toLocaleDateStringSupportsLocales())
			return this.toLocaleString(getPreferredLanguageCode(), { month: 'long' });
	}
	catch (ex) { }
	return fallbackDateLocale.en.month_names[this.getMonth()];
};

Date.prototype.getMonthNameShort = function ()
{
	try
	{
		if (toLocaleDateStringSupportsLocales())
			return this.toLocaleString(getPreferredLanguageCode(), { month: 'short' });
	}
	catch (ex) { }
	return fallbackDateLocale.en.month_names_short[this.getMonth()];
};

Date.prototype.getDayName = function ()
{
	try
	{
		if (toLocaleDateStringSupportsLocales())
			return this.toLocaleString(getPreferredLanguageCode(), { weekday: 'long' });
	}
	catch (ex) { }
	return fallbackDateLocale.en.day_names[this.getDay()];
};

Date.prototype.getDayNameShort = function ()
{
	try
	{
		if (toLocaleDateStringSupportsLocales())
			return this.toLocaleString(getPreferredLanguageCode(), { weekday: 'short' });
	}
	catch (ex) { }
	return fallbackDateLocale.en.day_names_short[this.getDay()];
};
function getPreferredLanguageCode()
{
	try
	{
		return navigator.userLanguage || (navigator.languages && navigator.languages.length && navigator.languages[0]) || navigator.language || navigator.browserLanguage || navigator.systemLanguage || 'en';
	}
	catch (ex)
	{
		return 'en';
	}
}
var cached_toLocaleDateStringSupportsLocales = 0;
function toLocaleDateStringSupportsLocales()
{
	if (cached_toLocaleDateStringSupportsLocales === 0)
		return false;
	else if (cached_toLocaleDateStringSupportsLocales === 1)
		return true;
	try
	{
		new Date().toLocaleDateString('i');
	}
	catch (e)
	{
		if (e.name === 'RangeError')
		{
			cached_toLocaleDateStringSupportsLocales = 1;
			return true;
		}
	}
	cached_toLocaleDateStringSupportsLocales = 0;
	return false;
}
var fallbackDateLocale = {
	en: {
		month_names: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
		month_names_short: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		day_names: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		day_names_short: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
	}
};
// Performs a deep clone of the specified element, removing all id attributes, data, and event handlers.
function CloneAndStripIdAttributes($ele)
{
	var $clone = $ele.clone(false);
	StripIdAttributesRecursive($clone);
	return $clone;
}
function StripIdAttributesRecursive($ele)
{
	$ele.removeAttr("id");
	$ele.children().each(function (idx, child)
	{
		StripIdAttributesRecursive($(child));
	});
}
var UrlParameters =
{
	loaded: false,
	parsed_url_params: {},
	Get: function ()
	{
		if (!this.loaded)
		{
			var params = this.parsed_url_params;
			window.location.search.replace(/[?&]+([^=&]+)=([^&]*)/gi, function (str, key, value)
			{
				params[key.toLowerCase()] = decodeURIComponent(value);
			})
			this.loaded = true;
		}
		for (var i = 0; i < arguments.length; i++)
		{
			if (typeof this.parsed_url_params[arguments[i].toLowerCase()] != 'undefined')
				return this.parsed_url_params[arguments[i].toLowerCase()];
		}
		return "";
	}
};
var UrlHashParameters =
{
	Get: function (key)
	{
		var params = {};
		window.location.hash.replace(/[?#&]+([^=&]+)=([^&]*)/gi, function (str, key, value)
		{
			params[key.toLowerCase()] = decodeURIComponent(value);
		})
		if (typeof params[key.toLowerCase()] != 'undefined')
			return params[key.toLowerCase()];
		return "";
	}
};
function htmlEncode(value)
{
	return $('<div/>').text(value).html();
}
function htmlDecode(value)
{
	return $('<div/>').html(value).text();
}
/**
 * Encodes a string to be safely inserted into an attribute of an HTML element when writing literal HTML markup.
 * @param {String} value String to encode.
 * @returns {String} Encoded value.
 */
function htmlAttributeEncode(value)
{
	if (typeof value !== "string" && typeof value !== "undefined" && typeof value.toString === "function")
		value = value.toString();
	var sb = new StringBuilder();
	for (var i = 0; i < value.length; i++)
	{
		var c = value.charAt(i);
		switch (c)
		{
			case '"':
				sb.Append("&quot;");
				break;
			case "'":
				sb.Append("&#39;");
				break;
			case "&":
				sb.Append("&amp;");
				break;
			case "<":
				sb.Append("&lt;");
				break;
			case ">":
				sb.Append("&gt;");
				break;
			default:
				sb.Append(c);
				break;
		}
	}
	return sb.ToString();
}
jQuery.cachedScript = function (url, options)
{
	options = $.extend(options || {}, { dataType: "script", cache: true, url: url });
	return jQuery.ajax(options);
};
function isSameDay(date1, date2)
{
	if (date1.getDate() != date2.getDate())
		return false;
	if (date1.getMonth() != date2.getMonth())
		return false;
	if (date1.getFullYear() != date2.getFullYear())
		return false;
	return true;
}
/**
 * Performs binary search and returns the index of a matching element.
 * If there is no match, the returned index will be negative and you can negate it 
 * and subtract 1 ((-idx - 1)) to get the index where the item should be inserted.
 * @param {Array} ar Array
 * @param {any} el Value to find
 * @param {Function} compare_fn A function that compares two values of the appropriate type.  Should return a positive number if the first argument is greater, negative number if the first argument is lesser.
 */
function binarySearch(ar, el, compare_fn)
{
	var m = 0;
	var n = ar.length - 1;
	while (m <= n)
	{
		var k = (n + m) >> 1;
		var cmp = compare_fn(el, ar[k]);
		if (cmp > 0)
			m = k + 1;
		else if (cmp < 0)
			n = k - 1;
		else
			return k;
	}
	return -m - 1;
}
function NumberCompare(a, b)
{
	return a - b;
}
function getBytesFromBISizeStr(str)
{
	if (str.endsWith("B")) // 2025-05-20: BI changed at an unknown time to begin using units like "GB" instead of just "G".  E.g. In the 'memphys' field of a status response.
		str = str.substr(0, str.length - 1);
	if (str.endsWith("K"))
		return parseInt(parseFloat(str) * 1024);
	else if (str.endsWith("M"))
		return parseInt(parseFloat(str) * 1024 * 1024);
	else if (str.endsWith("G"))
		return parseInt(parseFloat(str) * 1024 * 1024 * 1024);
	else if (str.endsWith("T"))
		return parseInt(parseFloat(str) * 1024 * 1024 * 1024 * 1024);
	else
		return parseInt(parseFloat(str));
}
function getBytesFrom_MiB(MiB)
{
	return MiB * 1048576;
}
/**
 * Formats the given number of bytes as a string with a suffix ('B', 'K', 'M', etc.) using multiples of 1024.
 * @param {Number} bytes Number of bytes.
 * @param {Number} decimals Number of decimal places to include in the string.
 */
function formatBytes(bytes, decimals)
{
	if (bytes == 0) return '0B';
	var negative = bytes < 0;
	if (negative)
		bytes = -bytes;
	var k = 1024,
		dm = typeof decimals != "undefined" ? decimals : 2,
		sizes = ['B', 'K', 'M', 'G', 'T', 'PB', 'EB', 'ZB', 'YB'],
		i = Math.floor(Math.log(bytes) / Math.log(k));
	return (negative ? '-' : '') + (bytes / Math.pow(k, i)).toFloat(dm) + sizes[i];
}
/**
 * Formats the given number of bytes as a string with a suffix ('B', 'KiB', 'MiB', etc.) using multiples of 1024.
 * @param {Number} bytes Number of bytes.
 * @param {Number} decimals Number of decimal places to include in the string.
 */
function formatBytes2(bytes, decimals)
{
	if (bytes == 0) return '0 B';
	var negative = bytes < 0;
	if (negative)
		bytes = -bytes;
	var k = 1024,
		dm = typeof decimals != "undefined" ? decimals : 2,
		sizes = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'],
		i = Math.floor(Math.log(bytes) / Math.log(k));
	return (negative ? '-' : '') + (bytes / Math.pow(k, i)).toFloat(dm) + ' ' + sizes[i];
}
/**
* Formats the given number of bytes as a string with a suffix ('B', 'KB', 'MB', etc.) using multiples of 1000.
 * @param {Number} bytes Number of bytes.
 * @param {Number} decimals Number of decimal places to include in the string.
 */
function formatBytesF10(bytes, decimals)
{
	if (bytes == 0) return '0 B';
	var negative = bytes < 0;
	if (negative)
		bytes = -bytes;
	var k = 1000,
		dm = typeof decimals != "undefined" ? decimals : 2,
		sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
		i = Math.floor(Math.log(bytes) / Math.log(k));
	return (negative ? '-' : '') + (bytes / Math.pow(k, i)).toFloat(dm) + ' ' + sizes[i];
}
/**
* Formats the given number of bits as a string with a suffix ('bps', 'Kbps', 'Mbps', etc.) using multiples of 1000.
 * @param {Number} bits Number of bits.
 */
function formatBitsPerSecond(bits)
{
	if (bits == 0) return '0 bps';
	var negative = bits < 0;
	if (negative)
		bits = -bits;
	var k = 1000,
		dm = typeof decimals != "undefined" ? decimals : 2,
		sizes = ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps', 'Pbps', 'Ebps', 'Zbps', 'Ybps'],
		decimals = [0, 0, 1, 2, 2, 2, 2, 2, 2],
		i = Math.floor(Math.log(bits) / Math.log(k));
	return (negative ? '-' : '') + (bits / Math.pow(k, i)).toFloat(decimals[i]) + ' ' + sizes[i];
}
var mouseCoordFixer =
{
	last: {
		x: 0, y: 0
	}
	, fix: function (e)
	{
		if (e.alreadyMouseCoordFixed)
			return;
		e.alreadyMouseCoordFixed = true;
		if (e.type.startsWith("touch") || typeof e.pageX === "undefined")
		{
			//if (e.changedTouches && e.changedTouches.length > 0)
			//{
			//	var t = null;
			//	for (var i = 0; i < e.changedTouches.length; i++)
			//	{
			//		if (e.changedTouches[i].identifier === 0)
			//		{
			//			t = e.changedTouches[i];
			//			break;
			//		}
			//	}
			//	if (!t)
			//		t = e.changedTouches[0];
			//	mouseCoordFixer.last.x = e.mouseX = t.pageX + $(window).scrollLeft();
			//	mouseCoordFixer.last.y = e.mouseY = t.pageY + $(window).scrollTop();

			//}
			//else
			if (e.originalEvent && e.originalEvent.touches && e.originalEvent.touches.length > 0)
			{
				mouseCoordFixer.last.x = e.mouseX = e.originalEvent.touches[0].pageX + $(window).scrollLeft();
				mouseCoordFixer.last.y = e.mouseY = e.originalEvent.touches[0].pageY + $(window).scrollTop();
			}
			else if (e.touches && e.touches.length > 0)
			{
				mouseCoordFixer.last.x = e.mouseX = e.touches[0].pageX + $(window).scrollLeft();
				mouseCoordFixer.last.y = e.mouseY = e.touches[0].pageY + $(window).scrollTop();
			}
			else
			{
				e.mouseX = mouseCoordFixer.last.x;
				e.mouseY = mouseCoordFixer.last.y;
			}
		}
		else
		{
			mouseCoordFixer.last.x = e.mouseX = e.pageX + $(window).scrollLeft();
			mouseCoordFixer.last.y = e.mouseY = e.pageY + $(window).scrollTop();
		}
	}
};
function IE_GetDevicePixelRatio()
{
	return Math.sqrt(screen.deviceXDPI * screen.deviceYDPI) / 96;
}

function BI_GetDevicePixelRatio()
{
	var returnValue = window.devicePixelRatio || IE_GetDevicePixelRatio() || 1;
	if (returnValue <= 0)
		returnValue = 1;
	return returnValue;
}
function GetDevicePixelRatioTag()
{
	var dpr = BI_GetDevicePixelRatio();
	return dpr === 1 ? "" : ('<span class="dprTag">*' + dpr.toFloat(2) + '</span>');
}
/**
 * @returns {Boolean} Returns true if the user agent suggests this browser is Chrome.  Browsers may pretend to be chrome (MS Edge).
 */
function BrowserIsChrome()
{
	return navigator.appVersion.indexOf(" Chrome/") > -1;
}
function BrowserIsIOS()
{
	if (window.MSStream)
		return false;
	if (navigator.userAgent.match(/iPad|iPhone|iPod/))
		return true;
	else
	{
		if (navigator.platform)
		{
			if (/iPad|iPhone|iPod/.test(navigator.platform) ||
				(navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1))
				return true;
		}
		return false;
	}
}
function BrowserIsIOSSafari()
{
	return BrowserIsIOS() && !!navigator.userAgent.match(/ Safari\//) && !navigator.userAgent.match(/ CriOS\//);
}
function BrowserIsIOSChrome()
{
	return BrowserIsIOS() && !!navigator.userAgent.match(/ Safari\//) && !!navigator.userAgent.match(/ CriOS\//);
}
/**
 * Returns an array of 3 integers indicating the iOS version (e.g. [16, 4, 1] or [0, 0, 0] if not positively identified as iOS).
 */
function GetIOSVersion()
{
	if (BrowserIsIOS())
	{
		try
		{
			var v = navigator.userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/);
			if (!v && navigator.appVersion)
				v = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
			if (v)
				return [parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)];
		}
		catch (ex)
		{
			console.error("GetIOSVersion() failed to identify iOS version. Method will return [0,0,0].", ex);
		}
	}
	return [0, 0, 0];
}
function BrowserIsAndroid()
{
	return !!navigator.userAgent.match(/ Android /) || !!navigator.userAgent.match(/\(Android \d+;/);
}
function getHiddenProp()
{
	var prefixes = ['webkit', 'moz', 'ms', 'o'];

	// if 'hidden' is natively supported just return it
	if ('hidden' in document) return 'hidden';

	// otherwise loop over all the known prefixes until we find one
	for (var i = 0; i < prefixes.length; i++)
	{
		if ((prefixes[i] + 'Hidden') in document)
			return prefixes[i] + 'Hidden';
	}

	// otherwise it's not supported
	return null;
}
function documentIsHidden()
{
	if (settings.ui3_pause_when_hidden !== "1")
		return false;

	var prop = getHiddenProp();
	if (!prop) return false;

	if (pictureInPictureController.isPictureInPictureEnabled())
		return false;

	return document[prop];
}
/**
 * Given a date in local time, returns a new date with the time adjusted so that it reads as if the browser shared a time zone with the server. Does not correct clock sync.
 * @param {Date} date Date in local time zone.
 */
function GetServerDate(date)
{
	return new Date(date.getTime() + GetServerTimeOffset());
}
/**
 * For use when GetServerDate() caused the date to be offset in the wrong direction for the desired effect. Does not correct clock sync.
 * Due to complex time zone handling, sometimes you need to subtract the time zone offset instead of add it.  This method does that.
 * @param {Date} date Date in server time zone (but local time zone is desired).
 */
function GetReverseServerDate(date)
{
	return new Date(date.getTime() - GetServerTimeOffset());
}
/**
 * Returns the difference in milliseconds between this browser's time zone and the server's time zone.
 * 
 * Timekeeping inaccuracy between the server and client is NOT accounted for by this method.  This is only for display purposes, to make the date appear as it would if the client was in the server's time zone.
 * 
 * The following code would print the date and time as if this machine was running in the server's time zone.
 *
 *	var utcMs = new Date().getTime();
 *	var serverTime = new Date(utcMs + GetServerTimeOffset());
 *	console.log(serverTime.toString());
 */
function GetServerTimeOffset()
{
	var localOffsetMs = new Date().getTimezoneOffset() * 60000;
	var serverOffsetMs = serverTimeZoneOffsetMs;
	return localOffsetMs - serverOffsetMs;
}
/**
 * Returns the binary representation of a number.
 * @param {Number} dec A number to print in binary as a string.
 */
function dec2bin(dec)
{
	return (dec >>> 0).toString(2);
}
function InsertSpacesInBinary(binaryString, maxLength)
{
	if (binaryString.length < maxLength)
		binaryString = binaryString.padLeft(maxLength, '0');
	var output = [];
	for (var i = 0; i < binaryString.length; i++)
	{
		if (i != 0 && i % 8 == 0)
			output.push(" ");
		else if (i != 0 && i % 4 == 0)
			output.push("_");
		output.push(binaryString[i]);
	}
	return output.join("");
}
function GetMediaErrorMessage(code)
{
	if (MediaError)
	{
		if (code === MediaError.MEDIA_ERR_ABORTED)
			return "MEDIA_ERR_ABORTED";
		else if (code === MediaError.MEDIA_ERR_NETWORK)
			return "MEDIA_ERR_NETWORK";
		else if (code === MediaError.MEDIA_ERR_DECODE)
			return "MEDIA_ERR_DECODE";
		else if (code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED)
			return "MEDIA_ERR_SRC_NOT_SUPPORTED";
	}
	return "unknown error code (" + code + ")";
}

/**
 * Changes the current URL by removing the specified query string parameter(s) from it.
 * @returns {String} Returns null if successful, otherwise returns the new URL if changing the history state failed.
 */
function NavRemoveUrlParams()
{
	var url = RemoveUrlParams.apply(this, arguments);
	try { history.replaceState(history.state, "", url); return null; } catch (ex) { return url; }
}
function RemoveUrlParams()
{
	var s = location.search;
	for (var i = 0; i < arguments.length; i++)
	{
		var param = arguments[i];
		var rx = new RegExp('[&?]' + param + '=[^&?#]*', 'gi');
		s = s.replace(rx, "");
		while (s.indexOf("&") === 0)
		{
			if (s.length > 1)
				s = s.substr(1);
			else
				s = "";
		}
		if (s.length > 0 && s.indexOf("?") === -1)
			s = "?" + s;
	}
	return location.origin + location.pathname + s + location.hash;
}
function FormatFileName(str)
{
	return str.replace(/\//g, '-').replace(/:/g, '.');
}
function GetCssVar(varName, fallback)
{
	return getComputedStyle(document.body).getPropertyValue(varName) || fallback;
}
function InjectStyleBlock(cssText)
{
	var styleBlock = $('<style type="text/css"></style>');
	styleBlock.text(cssText);
	$("body").append(styleBlock);
	return function (newCssText) { styleBlock.text(newCssText); };
}
function BindEvents(ele, events, handler, options)
{
	var eventArray = events.split(' ');
	for (var i = 0; i < eventArray.length; i++)
		ele.addEventListener(eventArray[i], handler, options);
}
function BindEventsPassive(ele, events, handler)
{
	BindEvents(ele, events, handler, { passive: true });
}
function GetAppPath()
{
	var appPath = "/" + appPath_raw.replace(/^\/+|\/+$/g, '');
	if (appPath[appPath.length - 1] !== '/')
		appPath = appPath + "/";
	return appPath;
}
function GetFilenameFromPath(path)
{
	if (!path)
		return "";
	var i = path.lastIndexOf("\\");
	if (i > -1)
		path = path.substr(i + 1);
	i = path.lastIndexOf("/");
	if (i > -1)
		path = path.substr(i + 1);
	return path;
}
function escapeRegExp(string)
{
	return string.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}
function ShowErrorDialog(messageText)
{
	var dialogContent = $('<div style="white-space: pre-wrap; padding: 10px;"></div>');

	var copyButtonContainer = $('<div style="margin-bottom: 10px;"></div>');
	var copyButton = $('<input type="button" value="Copy to clipboard" />');
	copyButton.on('click', function ()
	{
		clipboardHelper.CopyText(messageText);
		var copiedLabel = $('<span style="font-weight: bold; margin-left: 7px;">copied!</span>');
		copyButton.after(copiedLabel);
		setTimeout(function ()
		{
			copiedLabel.fadeOut(1000, function ()
			{
				copiedLabel.remove();
			});
		}, 300);
	});
	copyButtonContainer.append(copyButton);

	var messageBox = $('<div></div>').text(messageText);

	dialogContent.append(copyButtonContainer);
	dialogContent.append(messageBox);

	dialogContent.modalDialog({ title: "Error" });
}
function debounce(fn, delay)
{
	var timeout = null;
	return function ()
	{
		clearTimeout(timeout);
		timeout = setTimeout(fn, delay);
	};
}
function throttle(fn, delay)
{
	var interval;
	var queued;
	return function ()
	{
		if (!interval)
		{
			fn.apply(this, arguments);
			interval = setInterval(function ()
			{
				if (queued)
				{
					fn.apply(this, queued.args);
					queued = null;
				}
				else
				{
					clearInterval(interval);
					interval = null;
				}
			}, delay);
		}
		else
			queued = { args: arguments };
	};
}
function getRandomInt(maxPlusOne)
{
	return Clamp(Math.floor(Math.random() * maxPlusOne), 0, maxPlusOne - 1);
}
function getRandomAlphanumericStr(length)
{
	var chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
	if (!length)
		length = 8;
	var result = '';
	for (var i = length; i > 0; --i)
		result += chars[Math.floor(Math.random() * chars.length)];
	return result;
}
function getRandomBase36String(length)
{
	if (!length)
		length = 8;
	return Math.round((Math.pow(36, length + 1) - Math.random() * Math.pow(36, length))).toString(36).slice(1);
}
function PreviewSpeedToDelayMs(speed)
{
	if (!speed)
		speed = 5;
	speed = Clamp(speed, 1, 60);
	var scaled = 1000 / speed;
	return scaled;
	// exponential scaling
	//var sqrt = Math.sqrt(scaled);
	//return 1000 - Clamp(sqrt * 984, 0, 1000);
}

/**
 * FasterObjectMap can be used in lieu of regular empty objects as a slightly faster key/value map which does not require the use of hasOwnProperty when iterating over keys.
 * In fact it doesn't have a hasOwnProperty function. 
 */
function FasterObjectMap() { }
FasterObjectMap.prototype = Object.create(null);

function WrapperMap(vueReactive)
{
	var map;
	if (vueReactive)
	{
		if (typeof Map === "function")
		{
			this.r = 1;
			map = new Map();
			this.get = function (key)
			{
				if (this.r)
					return map.get(key);
			};
			this.set = function (key, value)
			{
				this.r = this.r === 2 ? 1 : 2;
				map.set(key, value);
			};
		}
		else
		{
			map = new FasterObjectMap();
			this.get = function (key)
			{
				if (this.r)
					return map[key];
			};
			this.set = function (key, value)
			{
				this.r = this.r === 2 ? 1 : 2;
				map[key] = value;
			};
		}
	}
	else
	{
		if (typeof Map === "function")
		{
			map = new Map();
			this.get = function (key)
			{
				return map.get(key);
			};
			this.set = function (key, value)
			{
				map.set(key, value);
			};
		}
		else
		{
			map = new FasterObjectMap();
			this.get = function (key)
			{
				return map[key];
			};
			this.set = function (key, value)
			{
				map[key] = value;
			};
		}
	}
	this.internalMap = map;
}

function normalizeWheelEvent(e)
{
	var sX = 0, sY = 0, pX = 0, pY = 0;

	if ('detail' in e) sY = e.detail;
	if ('wheelDelta' in e) sY = -e.wheelDelta / 120;
	if ('wheelDeltaY' in e) sY = -e.wheelDeltaY / 120;
	if ('wheelDeltaX' in e) sX = -e.wheelDeltaX / 120;

	pX = sX * 10;
	pY = sY * 10;

	if ('deltaY' in e) pY = e.deltaY;
	if ('deltaX' in e) pX = e.deltaX;

	if ((pX || pY) && e.deltaMode)
	{
		if (e.deltaMode === 1)
		{
			pX *= 40;
			pY *= 40;
		}
		else if (e.deltaMode === 2)
		{
			pX *= 800;
			pY *= 800;
		}
	}
	if (pX && !sX) sX = (pX < 1) ? -1 : 1;
	if (pY && !sY) sY = (pY < 1) ? -1 : 1;

	// Galaxy Tabpro S touchpad pinch zoom in Win10/Chrome causes a spew of spinY @ 1.5 magnitude despite relatively small pixelY values.
	// The zoom direction is also reversed, but I'm afraid that swapping it here might break it on more devices.
	if (Math.abs(sX) > 1 && pX < 30) sX = pX * 0.02;
	if (Math.abs(sY) > 1 && pY < 30) sY = pY * 0.02;

	return {
		spinX: sX, // Normalized to 1 for a wheel detent
		spinY: sY, // Normalized to 1 for a wheel detent
		pixelX: pX, // Arbitrary browser/os dependent number of pixels.
		pixelY: pY // Arbitrary browser/os dependent number of pixels.
	};
}
function ui3Modulus(n, m)
{
	return ((n % m) + m) % m;
}
/**
 * Constructor for ui3Rect. Contains a width and height and provides scaling functions.
 * @param {Number} w Rectangle width
 * @param {Number} h Rectangle height
 */
function ui3Rect(w, h)
{
	if (typeof w !== "number" || typeof h !== "number")
		throw Error("ui3Rect was constructed with an invalid or missing argument.");
	var self = this;
	/** Width of the rectangle (float) */
	this.w = w;
	/** Height of the rectangle (float) */
	this.h = h;
	/**
	 * Downscales this rectangle if necessary, but does not upscale, to fit within the given rectangle.  Preserve's this rectangle's aspect ratio.  Returns self.
	 * @param {ui3Rect} otherRect Another ui3Rect to fit this rect within.
	 */
	this.ApplyBoundingBox = function (otherRect)
	{
		var myAspect = self.AspectRatio();
		if (self.w > otherRect.w)
		{
			self.w = otherRect.w;
			self.h = self.w / myAspect;
		}
		if (self.h > otherRect.h)
		{
			self.h = otherRect.h;
			self.w = self.h * myAspect;
		}
		return self;
	}
	/**
	 * Scales this rectangle to be able to fit the given rectangle fully within it, preserving my aspect ratio.  Returns self.
	 * @param {ui3Rect} otherRect Another ui3Rect to fit this rect around.
	 */
	this.ExpandAround = function (otherRect)
	{
		var myAspect = self.AspectRatio();
		if (self.w < otherRect.w)
		{
			self.w = otherRect.w;
			self.h = self.w / myAspect;
		}
		if (self.h < otherRect.h)
		{
			self.h = otherRect.h;
			self.w = self.h * myAspect;
		}
		return self;
	}
	/** Returns this rectangle's aspect ratio (w/h). */
	this.AspectRatio = function ()
	{
		return self.w / self.h;
	}
	/** Returns true if this rectangle's width and height match a given rectangle's width and height.
	 * @param { ui3Rect } otherRect Another ui3Rect that defines the minimum size.
	 */
	this.Equals = function (otherRect)
	{
		if (!otherRect)
			return false;
		return self.w === otherRect.w && self.h === otherRect.h;
	}
	/** Multplies the dimensions of this rectangle by a given scaler. Returns self. */
	this.MultiplyBy = function (scaler)
	{
		self.w *= scaler;
		self.h *= scaler;
		return self;
	}
	/** Swaps w and h fields. Returns self. */
	this.Rotate = function ()
	{
		var tmp = self.w;
		self.w = self.h;
		self.h = tmp;
		return self;
	}
	/** Rounds the dimensions of this rectangle to the nearest integer. Returns self. */
	this.Round = function ()
	{
		self.w = Math.round(self.w);
		self.h = Math.round(self.h);
		return self;
	}
	/** Makes the dimensions of this rectangle divisible by 8. Returns self. */
	this.MakeDivisibleBy8 = function ()
	{
		self.w = MakeDivisibleBy8(self.w);
		self.h = MakeDivisibleBy8(self.h);
		return self;
	}
	/** Shrinks the box if necessary so that the area (w*h) is less than or equal to the given number.  Preserves aspect ratio. */
	this.EnforceMaxArea = function (max)
	{
		if (self.w * self.h > max)
		{
			var myAspect = self.AspectRatio();
			self.h = Math.sqrt(max / myAspect);
			self.w = self.h * myAspect;
		}
		return self;
	}
	/** Returns a copy of this rectangle. */
	this.Copy = function ()
	{
		return new ui3Rect(self.w, self.h);
	}
	this.toString = function ()
	{
		return self.w + "x" + self.h;
	}
}
function MakeDivisibleBy8(num)
{
	var rem = num % 8;
	if (!rem)
		return num;
	if (num < 3840)
		return num + (8 - num % 8);
	else
		return num - num % 8;
}
function getHotkeyTextValueFromHotkeyValue(val)
{
	if (!val)
		val = "";
	var parts = val.split("|");
	if (parts.length < 4)
		return "unset";
	else
		return (parts[0] === "1" ? "CTRL + " : "")
			+ (parts[1] === "1" ? "ALT + " : "")
			+ (parts[2] === "1" ? "SHIFT + " : "")
			+ hotkeys.getKeyName(parts[3]);
}
// Disable middle-click scrolling. In most non-scrollable parts of UI3 in Chrome, middle click causes the cursor to get stuck in the scrolling state.
setTimeout(function ()
{
	BindEvents(document, 'mousedown', function (e)
	{
		if (e.which === 2)
		{
			e.preventDefault();
			e.stopPropagation();
			return false;
		}
	});
}, 0);
/**
 * Compares two version numbers using semantic versioning rules. Returns 1 if the first version is greater than the second version, -1 if it is less, 0 if the versions are the same.
 * @param {String} version1 First version to compare.
 * @param {String} version2 Second version to compare.
 */
function compareVersions(version1, version2)
{
	var v1 = version1.split('.');
	var v2 = version2.split('.');
	for (var i = 0; i < Math.max(v1.length, v2.length); i++)
	{
		var num1 = parseInt(v1[i] || 0);
		var num2 = parseInt(v2[i] || 0);
		if (num1 > num2) return 1;
		if (num2 > num1) return -1;
	}
	return 0;
}
function getDateFromDateArgument(dateArgument)
{
	if (!dateArgument)
		return null;

	// JavaScript date parsing is a bit stupid, e.g. Chrome parses "2022-12-9" and "2022-12-10" as different time zones, so we are rolling our own simple parser here.
	var date = null;
	var parts = dateArgument.split(/[-/]/);
	if (parts.length === 2 || parts.length === 3)
	{
		var year = parseInt(parts[0]);
		var month = parseInt(parts[1]);
		var day = parts.length === 3 ? parseInt(parts[2]) : 1;
		if (year && month && day)
			date = new Date(year, month - 1, day);
	}
	if (!date)
	{
		// Assume it is a linux epoch timestamp in milliseconds
		date = parseInt(dateArgument);
		if (date && date < 253402326000) // <-- Assume this date actually has precision in seconds.
			date *= 1000;
	}
	if (!date)
		return null;
	return new Date(date);
}
function dateSecondsToYMD(seconds)
{
	var date = new Date(seconds * 1000);
	return date.getFullYear() + "-" + (date.getMonth() + 1) + "-" + date.getDate();
}
function getSvgIconToEmbed(svgId, newId, classes)
{
	if (typeof classes === "undefined")
	{
		if (svgId.indexOf('svg_mio') === 0)
			classes = "icon noflip";
		else
			classes = "icon";
	}

	var str = document.getElementById(svgId).outerHTML;
	str = str.replace('<symbol ', '<svg ');
	str = str.replace('</symbol>', '</svg>');
	if (classes)
		str = str.replace('<svg ', '<svg class="' + classes + '" ');
	if (str.indexOf('xmlns=') < 0)
		str = str.replace('<svg ', '<svg xmlns="http://www.w3.org/2000/svg" ');
	if (newId)
		str = str.replace(' id="' + svgId + '"', ' id="' + newId + '"');
	else
		str = str.replace(' id="' + svgId + '"', '');
	return str;
}
function firstNonFalsy()
{
	if (arguments.length)
	{
		for (var i = 0; i < arguments.length; i++)
			if (arguments[i])
				return arguments[i];
		return arguments[arguments.length - 1];
	}
	return undefined;
}
function ParseFileName(fileName)
{
	var fileNameNoExt = fileName;
	var extension = "";
	var type = "";
	var extensionIdx = fileName.lastIndexOf(".");
	if (extensionIdx > -1)
	{
		fileNameNoExt = fileName.substr(0, extensionIdx);
		extension = fileName.substr(extensionIdx);
		if (fileName.length > extensionIdx)
			type = fileName.substr(extensionIdx + 1);
	}
	return { name: fileNameNoExt, extension: extension, type: type };
}